{
    "main_text": "Interpretation as a Process || Programming Statements and their Execution\n1.3 Programming Statements and their Execution\n\nIt is instructive to compare the actions of update semantics to\nprogramming statements and their execution. Such a comparison provides\na first glimpse into how quantification works within a dynamic\nsetting. Programming statements of imperative languages are\ninterpreted (or \u201cexecuted\u201d) in the context of a machine\nstate, where machine states can be viewed as allocations of values to\nregisters. Assume the registers are named by variables \\(x, y, z\\),\nand that the contents of the registers are natural numbers. Then the\nfollowing is a machine state: \n\n\\[\n\\begin{array}{|c|c|}\\hline\nx & 12 \\\\\\hline\ny & 117 \\\\\\hline\nz & 3 \\\\\\hline\n\\end{array}\n\\]\n\n\nIf the statement \\(z := x\\) is executed, i.e.,\n\u201cinterpreted\u201d, in this state (in C syntax, this statement\nwould have the simpler form \\(z = x)\\), the result is a new machine\nstate: \n\n\\[\n\\begin{array}{|c|c|}\\hline\nx & 12 \\\\\\hline\ny & 117 \\\\\\hline\nz & 12 \\\\\\hline\n\\end{array}\n\\]\n\n\nIf the sequence of statements \\(x := y\\); \\(y := z\\) is executed in\nthis state, the result is: \n\n\\[\n\\begin{array}{|c|c|}\\hline\nx & 117 \\\\\\hline\ny & 12 \\\\\\hline\nz & 12 \\\\\\hline\n\\end{array}\n\\]\n\n\nThis illustrates that the result of the sequence \\(z := x\\); \\(x :=\ny\\); \\(y := z\\) is that the values of \\(x\\) and \\(y\\) are\nswapped, with the side effect that the old value of \\(z\\) gets\nlost. In other words, the meaning of the program \\(z := x\\); \\(x :=\ny\\); \\(y := z\\) can be viewed as a mapping from an input machine state\n\\(s\\) to an output machine state \\(s'\\) that differs from \\(s\\)\nin several respects: \\(s'(x) = s(y)\\) and \\(s'(y) = s(x)\\) (that is,\nthe input values of \\(x\\) and \\(y\\) are swapped in the\noutput state), and \\(s'(z) = s'(y)\\).\n\nNow consider the existential quantifier \u201cthere exists an\n\\(x\\) such that \\(A\\)\u201d. Suppose we add this quantifier to\nan imperative programming language. What would be its meaning? It\nwould be an instruction to replace the old value of \\(x\\) by a new\nvalue, where the new value has property \\(A\\). We can decompose\nthis into a part \u201cthere exists \\(x\\)\u201d and a test\n\u201c\\(A\\)\u201d. A formula/instruction is a test if\nthe update contributed by it takes the states in the input context one\nat a time and tests that they satisfy a particular condition. If they\ndo, they are included in the output context; if they don\u2019t, they\nare discarded. That is, a test is an update that takes an input\ncontext and outputs a context that is a subset of the input context.\nAll the formulas of propositional logic in the\n Propositional logic as an update logic\n section above are tests.\n\nThe two parts \u201cthere exists \\(x\\)\u201d and the test\n\u201c\\(A\\)\u201d are glued together by sequential composition:\n\u201c\\(\\exists x\\); \\(A\\)\u201d. Focusing on the part\n\u201c\\(\\exists x\\)\u201d, what would be its natural meaning? An\ninstruction to replace the old value of \\(x\\) by some arbitrary new\nvalue. This is again a relation between input states and output\nstates, but the difference with definite assignments like \\(x := y\\)\nis that now the relation is not a function. In fact, this relational\nmeaning of quantifiers shows up in the well known Tarski-style truth\ndefinition for first order logic (compare the entry on\n Tarski\u2019s truth definitions):\n\n\n\\(\\exists x\\phi\\) is true in a model \\(M\\) relative to a variable\nassignment \\(\\alpha\\) iff (if and only if) there is some variable\nassignment \\(\\beta\\) such that \\(\\beta\\) differs from \\(\\alpha\\) at\nmost with respect to the value it assigns to \\(x\\) and such that\n\\(\\phi\\) is true in \\(M\\) relative to assignment \\(\\beta\\). \n\n\nImplicit in the Tarskian definition is a relation that holds between\nassignment \\(\\alpha\\) and assignment \\(\\beta\\) iff for all variables\n\\(y\\) that are different from \\(x\\), it is the case that\n\\(\\alpha(y) = \\beta(y)\\). This relation is often called a random\nreset of x and is written as [\\(x\\)]. For any variable\n\\(x\\), the binary relation between total assignments [\\(x\\)] is\nan equivalence relation between assignments, i.e., it is a reflexive,\nsymmetric and transitive binary relation. Below, we see how such\nrelations are put to work in a dynamicised version of first order\npredicate logic. \n\nAdopting [\\(x\\)] as the meaning of \u201c\\(\\exists x\\)\u201d,\nnote that its meaning is quite different in nature from that of a test\nin that it creates new values in the output context. In contrast, the\noutput context resulting from an update with a test is always a subset\nof the input context and can therefore never contain anything new\nrelative to the input context.\n",
    "section_title": "1.3 Programming Statements and their Execution",
    "entry_title": "Dynamic Semantics",
    "hierarchy_title": "Dynamic Semantics || Interpretation as a Process || Programming Statements and their Execution",
    "tokenized_text": [
        "interpretation",
        "process",
        "programming",
        "statement",
        "execution",
        "programming",
        "statement",
        "execution",
        "instructive",
        "compare",
        "action",
        "update",
        "semantics",
        "programming",
        "statement",
        "execution",
        "comparison",
        "provides",
        "first",
        "glimpse",
        "quantification",
        "work",
        "within",
        "dynamic",
        "setting",
        "programming",
        "statement",
        "imperative",
        "language",
        "interpreted",
        "executed",
        "context",
        "machine",
        "state",
        "machine",
        "state",
        "viewed",
        "allocation",
        "value",
        "register",
        "assume",
        "register",
        "named",
        "variable",
        "x",
        "z",
        "content",
        "register",
        "natural",
        "number",
        "following",
        "machine",
        "state",
        "begin",
        "array",
        "cc",
        "hline",
        "x",
        "hline",
        "hline",
        "z",
        "hline",
        "end",
        "array",
        "statement",
        "z",
        "x",
        "executed",
        "ie",
        "interpreted",
        "state",
        "c",
        "syntax",
        "statement",
        "would",
        "simpler",
        "form",
        "z",
        "x",
        "result",
        "new",
        "machine",
        "state",
        "begin",
        "array",
        "cc",
        "hline",
        "x",
        "hline",
        "hline",
        "z",
        "hline",
        "end",
        "array",
        "sequence",
        "statement",
        "x",
        "y",
        "z",
        "executed",
        "state",
        "result",
        "begin",
        "array",
        "cc",
        "hline",
        "x",
        "hline",
        "hline",
        "z",
        "hline",
        "end",
        "array",
        "illustrates",
        "result",
        "sequence",
        "z",
        "x",
        "x",
        "y",
        "z",
        "value",
        "x",
        "y",
        "swapped",
        "side",
        "effect",
        "old",
        "value",
        "z",
        "get",
        "lost",
        "word",
        "meaning",
        "program",
        "z",
        "x",
        "x",
        "y",
        "z",
        "viewed",
        "mapping",
        "input",
        "machine",
        "state",
        "s",
        "output",
        "machine",
        "state",
        "s",
        "differs",
        "s",
        "several",
        "respect",
        "x",
        "x",
        "input",
        "value",
        "x",
        "y",
        "swapped",
        "output",
        "state",
        "z",
        "consider",
        "existential",
        "quantifier",
        "exists",
        "x",
        "a",
        "suppose",
        "add",
        "quantifier",
        "imperative",
        "programming",
        "language",
        "would",
        "meaning",
        "would",
        "instruction",
        "replace",
        "old",
        "value",
        "x",
        "new",
        "value",
        "new",
        "value",
        "property",
        "a",
        "decompose",
        "part",
        "exists",
        "x",
        "test",
        "a",
        "formulainstruction",
        "test",
        "update",
        "contributed",
        "take",
        "state",
        "input",
        "context",
        "one",
        "time",
        "test",
        "satisfy",
        "particular",
        "condition",
        "included",
        "output",
        "context",
        "discarded",
        "test",
        "update",
        "take",
        "input",
        "context",
        "output",
        "context",
        "subset",
        "input",
        "context",
        "formula",
        "propositional",
        "logic",
        "propositional",
        "logic",
        "update",
        "logic",
        "section",
        "test",
        "two",
        "part",
        "exists",
        "x",
        "test",
        "a",
        "glued",
        "together",
        "sequential",
        "composition",
        "exists",
        "x",
        "a",
        "focusing",
        "part",
        "exists",
        "x",
        "would",
        "natural",
        "meaning",
        "instruction",
        "replace",
        "old",
        "value",
        "x",
        "arbitrary",
        "new",
        "value",
        "relation",
        "input",
        "state",
        "output",
        "state",
        "difference",
        "definite",
        "assignment",
        "like",
        "x",
        "y",
        "relation",
        "function",
        "fact",
        "relational",
        "meaning",
        "quantifier",
        "show",
        "well",
        "known",
        "tarskistyle",
        "truth",
        "definition",
        "first",
        "order",
        "logic",
        "compare",
        "entry",
        "tarski",
        "truth",
        "definition",
        "exists",
        "xphi",
        "true",
        "model",
        "m",
        "relative",
        "variable",
        "assignment",
        "alpha",
        "iff",
        "variable",
        "assignment",
        "beta",
        "beta",
        "differs",
        "alpha",
        "respect",
        "value",
        "assigns",
        "x",
        "phi",
        "true",
        "m",
        "relative",
        "assignment",
        "beta",
        "implicit",
        "tarskian",
        "definition",
        "relation",
        "hold",
        "assignment",
        "alpha",
        "assignment",
        "beta",
        "iff",
        "variable",
        "y",
        "different",
        "x",
        "case",
        "alpha",
        "beta",
        "relation",
        "often",
        "called",
        "random",
        "reset",
        "x",
        "written",
        "x",
        "variable",
        "x",
        "binary",
        "relation",
        "total",
        "assignment",
        "x",
        "equivalence",
        "relation",
        "assignment",
        "ie",
        "reflexive",
        "symmetric",
        "transitive",
        "binary",
        "relation",
        "see",
        "relation",
        "put",
        "work",
        "dynamicised",
        "version",
        "first",
        "order",
        "predicate",
        "logic",
        "adopting",
        "x",
        "meaning",
        "exists",
        "x",
        "note",
        "meaning",
        "quite",
        "different",
        "nature",
        "test",
        "creates",
        "new",
        "value",
        "output",
        "context",
        "contrast",
        "output",
        "context",
        "resulting",
        "update",
        "test",
        "always",
        "subset",
        "input",
        "context",
        "therefore",
        "never",
        "contain",
        "anything",
        "new",
        "relative",
        "input",
        "context"
    ]
}