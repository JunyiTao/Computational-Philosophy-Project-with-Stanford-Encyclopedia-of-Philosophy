{
    "main_text": "Structured programming and correctness of programs\n3. Structured programming and correctness of programs\n\nHistorically, logics of programs stem from the work in the late 1960s\nof computer scientists interested in assigning meaning to programming\nlanguages and finding a rigorous standard for proofs about the\nprograms. For example such proofs may be about the correctness of a\nprogram with respect to an expected behavior, or about the termination\nof a program. A seminal paper is Floyd [1967] which presents an\nanalysis of the properties of structured computer programs using\nflowcharts. Some early work such as Yanov [1959] or Engeler\n[1967] had advanced and studied formal languages in which the\nproperties of program connectives can be expressed. The formalism of\nHoare [1969] was a milestone in the advent of PDL. It was proposed as\na rigorous axiomatic interpretation of Floyd\u2019s flowcharts. We\noften talk about Hoare logic, or Floyd-Hoare logic, or Hoare calculus\nwhen referring to this formalism. Hoare calculus is concerned with the\ntruth of statements (\u201cHoare triples\u201d), such as\n\\(\\{A\\}\\alpha\\{B\\}\\) which establishes a connection between a\nprecondition \\(A\\), a program \\(\\alpha\\), and a post-condition \\(B\\).\nIt indicates that whenever \\(A\\) holds as a precondition of the\nexecution of \\(\\alpha\\), then \\(B\\) holds as a post-condition after\nthe successful execution of \\(\\alpha\\).\n\nIt was true some decades ago, and it is still the case: validating a\nprogram is more often than not done by testing it on a reasonable\nvariety of inputs. When an input does not yield the expected output,\nthe \u201cbug\u201d is fixed. If eventually for every tested input\nwe obtain the expected output, one has a reasonable belief that the\nprogram has no error. However, this is a time consuming method of\nvalidation, and it leaves place for untested inputs that could fail.\nFinding these errors after the program has been implemented and gone\ninto use is even more costly in resources. Reasoning about program\ncorrectness with formal methods is crucial for critical systems since\nit offers a way of proving exhaustively that a program has no\nerrors.\n",
    "section_title": "3. Structured programming and correctness of programs",
    "entry_title": "Propositional Dynamic Logic",
    "hierarchy_title": "Propositional Dynamic Logic || Structured programming and correctness of programs",
    "tokenized_text": [
        "structured",
        "programming",
        "correctness",
        "program",
        "structured",
        "programming",
        "correctness",
        "program",
        "historically",
        "logic",
        "program",
        "stem",
        "work",
        "late",
        "s",
        "computer",
        "scientist",
        "interested",
        "assigning",
        "meaning",
        "programming",
        "language",
        "finding",
        "rigorous",
        "standard",
        "proof",
        "program",
        "example",
        "proof",
        "may",
        "correctness",
        "program",
        "respect",
        "expected",
        "behavior",
        "termination",
        "program",
        "seminal",
        "paper",
        "floyd",
        "present",
        "analysis",
        "property",
        "structured",
        "computer",
        "program",
        "using",
        "flowchart",
        "early",
        "work",
        "yanov",
        "engeler",
        "advanced",
        "studied",
        "formal",
        "language",
        "property",
        "program",
        "connective",
        "expressed",
        "formalism",
        "hoare",
        "milestone",
        "advent",
        "pdl",
        "proposed",
        "rigorous",
        "axiomatic",
        "interpretation",
        "floyd",
        "flowchart",
        "often",
        "talk",
        "hoare",
        "logic",
        "floydhoare",
        "logic",
        "hoare",
        "calculus",
        "referring",
        "formalism",
        "hoare",
        "calculus",
        "concerned",
        "truth",
        "statement",
        "hoare",
        "triple",
        "a",
        "alpha",
        "b",
        "establishes",
        "connection",
        "precondition",
        "a",
        "program",
        "alpha",
        "postcondition",
        "b",
        "indicates",
        "whenever",
        "a",
        "hold",
        "precondition",
        "execution",
        "alpha",
        "b",
        "hold",
        "postcondition",
        "successful",
        "execution",
        "alpha",
        "true",
        "decade",
        "ago",
        "still",
        "case",
        "validating",
        "program",
        "often",
        "done",
        "testing",
        "reasonable",
        "variety",
        "input",
        "input",
        "yield",
        "expected",
        "output",
        "bug",
        "fixed",
        "eventually",
        "every",
        "tested",
        "input",
        "obtain",
        "expected",
        "output",
        "one",
        "reasonable",
        "belief",
        "program",
        "error",
        "however",
        "time",
        "consuming",
        "method",
        "validation",
        "leaf",
        "place",
        "untested",
        "input",
        "could",
        "fail",
        "finding",
        "error",
        "program",
        "implemented",
        "gone",
        "use",
        "even",
        "costly",
        "resource",
        "reasoning",
        "program",
        "correctness",
        "formal",
        "method",
        "crucial",
        "critical",
        "system",
        "since",
        "offer",
        "way",
        "proving",
        "exhaustively",
        "program",
        "error"
    ]
}