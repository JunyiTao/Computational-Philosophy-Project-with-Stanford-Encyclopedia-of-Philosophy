{
    "main_text": "The origins of complexity theory || The Cobham-Edmond\u2019s Thesis and feasible computability\n2.2 The Cobham-Edmond\u2019s Thesis and feasible computability\nChurch\u2019s Thesis is often cited as a paradigm example of a case in which mathematical methods have been successfully employed to provide a precise analysis of an informal concept \u2013 i.e. that of effective computability. It is also  natural to ask whether the concept of feasible computability described in Section 1 itself admits a mathematical analysis similar to Church\u2019s Thesis.  \n\nWe saw above that \\(\\sc{FACTORIZATION}\\) is an example of a problem of antecedent mathematical and practical interest for which more efficient algorithms have historically been sought.   The task of efficiently solving combinatorial problems of the sort exemplified by \\(\\sc{TSP}\\), \\(\\sc{INTEGER}\\ \\sc{PROGRAMMING}\\) and \\(\\sc{PERFECT} \\ \\sc{MATCHING}\\) grew in importance during the 1950s and 1960s due to their role in scientific, industrial, and clerical applications. At the same time, the availability of digital computers began to make many such problems mechanically solvable on a mass scale for the first time.\nThis era also saw several theoretical steps which heralded the attempt to develop a general theory of feasible computability. The basic definitions of time and space complexity for the Turing machine model were first systematically formulated by Hartmanis and Stearns (1965) in a paper called \u201cOn the Computational Complexity of Algorithms\u201d. This paper is also the origin of the so-called Hierarchy Theorems (see Section 3.2) \nwhich demonstrate that a sufficiently large increase in the time or space bound for a Turing machine computation allows more problems to be decided.\nA systematic exploration of the relationships between different models of computation was also undertaken during this period. This included variants of the traditional Turing machine model with additional heads, tapes, and auxiliary storage devices such as stacks. Another important model introduced at about this time was the random access (or RAM) machine \\(\\mathfrak{A}\\) (see, e.g, Cook and Reckhow 1973). This model provides a simplified representation of the so-called von Neumann architecture on which contemporary digital computers are based. In particular, a RAM machine \\(A\\) consists of a finite sequence of instructions (or program) \\(\\langle \\pi_1,\\ldots,\\pi_n \\rangle\\) expressing how numerical operations (typically addition and subtraction) are to be applied to a sequence of registers \\(r_1,r_2, \\dots\\) in which values may be stored and retrieved directly by their index.\nShowing that one of these models \\(\\mathfrak{M}_1\\) determines the same class of functions as some reference model \\(\\mathfrak{M}_2\\) (such as \\(\\mathfrak{T}\\)) requires showing that for all \\(M_1 \\in \\mathfrak{M}_1\\), there exists a machine \\(M_2 \\in \\mathfrak{M}_2\\) which computes the same function as \\(M_1\\) (and conversely). This is typically accomplished by constructing \\(M_2\\) such that each of the basic steps of \\(M_1\\) is simulated by one or more basic steps of \\(M_2\\). Demonstrating the coincidence of the classes of functions computed by the models \\(\\mathfrak{M}_1\\) and \\(\\mathfrak{M}_2\\) thus often yields additional information about their relative efficiencies. For instance, it is generally possible to extract from the definition of a simulation between \\(\\mathfrak{M}_1\\) and \\(\\mathfrak{M}_2\\) time and space overhead functions \\(o_t(x)\\) and \\(o_s(x)\\) such that if the value of a function \\(f(x)\\) can be computed in time \\(t(n)\\) and space \\(s(n)\\) by a machine \\(M_1 \\in \\mathfrak{M}_1\\), then it can also be computed in time \\(o_t(t(n))\\) and space \\(o_s(s(n))\\) by some machine \\(M_2 \\in \\mathfrak{M}_2\\).\nFor a wide class of  models, a significant discovery was that efficient simulations can be found. For instance, it might at first appear that the model \\(\\mathfrak{A}\\) allows for considerably more efficient implementations of familiar algorithms than does the model \\(\\mathfrak{T}\\) in virtue of the fact that a RAM machine can access any of its registers in a single step whereas a Turing machine may move its head only a single cell at a time. Nonetheless it can be shown that there exists a simulation of the RAM model by the Turing machine model with cubic time overhead and constant space overhead \u2013 i.e. \\(o_t(t(n)) \\in O(t(n)^3)\\) and \\(o_s(s(n)) \\in O(s(n))\\) (Slot and Emde Boas 1988). On the basis of this and related results, Emde Boas (1990) formulated the following proposal to characterize the relationship between reference models which might be used for defining time and space complexity:\nInvariance Thesis \u2018Reasonable\u2019 models of computation can simulate each other within a polynomially bounded overhead in time and a constant-factor overhead in space.\nThe 1960s also saw a number of advances in algorithmic methods applicable to problems in fields like graph theory and linear algebra. One example was a technique known as dynamic programming. This method can sometimes be used to find efficient solutions to  optimization problems which ask us to find an object which minimizes or maximizes a certain quantity from a range of possible solutions. An algorithm based on dynamic programming solves an instance of such a problem by recursively breaking it into subproblems, whose optimal values are then computed and stored in a manner which can then be efficiently reassembled to achieve an optimal overall solution. \n\n Bellman (1962) showed that the naive time complexity of \\(O(n!)\\) for \\(\\sc{TSP}\\) could be improved to \\(O(2^n n^2)\\) via the use of dynamic programming.  The question thus arose whether it was possible to improve upon such algorithms further, not only for \\(\\sc{TSP}\\), but also for other problem such as \\(\\sc{SAT}\\) for which efficient algorithms had been sought but were not known to exist.  In order to appreciate what is at stake with this question, observe that the naive algorithm for \\(\\sc{TSP}\\) works as follows: 1) enumerate the set \\(S_G\\) of all possible tours in \\(G\\) and compute their weights; 2) check if the cost of any of these tours is \\(\\leq b\\). Note, however, that if \\(G\\) has \\(n\\) nodes, then \\(S_G\\) may contain as many as \\(n!\\) tours.\nThis is an example of a so-called brute force algorithm -- i.e. one which solves a problem by exhaustively enumerating all possible solutions and then successively testing whether any of them are correct.  Somewhat more precisely, a problem \\(X\\) is said to admit a brute force solution if there exists a feasibly decidable relation \\(R_X\\) and a family of uniformly defined finite sets \\(S_x\\) such that \\(x \\in X\\) if and only if there exists a feasibly sized witness \\(y \\in S_x\\) such that \\(R_X(x,y)\\). Such a \\(y\\) is often called a certificate for \\(x\\)\u2019s membership in \\(X\\). The procedure of deciding \\(x \\in X\\) by exhaustively searching through all of the certificates \\(y_0, y_1, \\ldots \\in S_x\\) and checking if \\(R_X(x,y)\\) holds at each step is known as a brute force search. For instance, the membership of a propositional formula \\(\\phi\\) with atomic letters among \\(P_0,\\ldots, P_{n-1}\\) in the problem \\(\\sc{SAT}\\) can be established by searching through the set \\(S_{\\phi}\\) of possible valuation functions of type \\(v:\\{0,\\ldots,n-1\\} \\rightarrow \\{0,1\\}\\), to determine if there exists \\(v \\in S_{\\phi}\\) such that \\(\\llbracket \\phi \\rrbracket_v = 1\\). Note, however, that since there are \\(2^n\\) functions in \\(S_{\\phi}\\), this yields only an exponential time decision algorithm.\nMany other problems came to light in the 1960s and 1970s which, like \\(\\sc{SAT}\\) and  \\(\\sc{TSP}\\), can easily be seen to possess exponential time brute force algorithms but for which no polynomial time algorithm could be found. On this basis, it gradually came to be accepted that a sufficient condition for a decidable problem to be intractable is that the most efficient algorithm by which it can be solved has at best exponential time complexity. The corresponding positive hypothesis that possession of a polynomial time decision algorithm should be regarded as sufficient grounds for regarding a problem as feasibly decidable was first put forth by Cobham (1965) and Edmonds (1965a).\nCobham began by citing the evidence motivating the Invariance Thesis as suggesting that the question of whether a problem admits a polynomial time algorithm is independent of which model of computation is used to measure time complexity across a broad class of alternatives. He additionally presented a machine-independent characterization of the class \\(\\textbf{FP}\\) \u2013 i.e. functions \\(f:\\mathbb{N}^k \\rightarrow \\mathbb{N}\\) which are computable in polynomial time \u2013 in terms of a restricted form of primitive recursive definition known as bounded recursion on notation (see \n Section 4.5).\n Edmonds (1965a) first proposed that polynomial time complexity could be used as a positive criterion of feasibility \u2013 or, as he put it, possessing a \u201cgood algorithm\u201d \u2013 in a paper in which he showed that a problem which might a priori be thought to be solvable only by brute force search (a generalization of \\(\\sc{PERFECT}\\ \\sc{MATCHING}\\) from above) was decidable by a polynomial time algorithm.  Paralleling a similar study of brute force search in the Soviet Union, in a subsequent paper Edmonds (1965b) also provided an informal description of the complexity class \\(\\textbf{NP}\\).  In particular, he characterized this class as containing those problems \\(X\\) for which there exists a \u201cgood characterization\u201d \u2013 i.e. \\(X\\) is such that the membership of an instance \\(x\\) may be verified by using brute force search to find a certificate \\(y\\) of feasible size which certifies \\(x\\)\u2019s membership in \n \\(X\\).[9]\nThese observations provided the groundwork for has come to be known as the Cobham-Edmonds Thesis (see, e.g., Brookshear et al. 2006; Goldreich 2010; Homer and Selman 2011):\n\n(CET)\n\nA function \\(f:\\mathbb{N}^k \\rightarrow \\mathbb{N}\\) is feasibly computable if and only if \\(f(\\vec{x})\\) is computed by some machine \\(M\\) such that \\(t_M(n) \\in O(n^k)\\) where \\(k\\) is fixed and \\(M\\) is drawn from a reasonable model of computation \\(\\mathfrak{M}\\).\n\n\nCET provides a characterization of the notion of a feasibly computable function discussed in  Section 1 which is similar in form to Church\u2019s Thesis. The corresponding thesis for decision problems holds that a problem is feasibly decidable just in case it is in the class \\(\\textbf{P}\\). As just formulated, however, CET relies on the informal notion of a reasonable model of computation. A more precise formulation can be given by replacing this notion with a specific model such as \\(\\mathfrak{T}\\) or \\(\\mathfrak{A}\\) from the first machine class as discussed in \n Section 3.1 below.\nCET is now widely accepted within theoretical computer science for reasons which broadly parallel those which are traditionally given in favor of Church\u2019s Thesis.  For instance, not only is the definition of the class \\(\\textbf{FP}\\) stable across different machine-based models of computation in the manner highlighted by the Invariance Thesis, but there also exist several machine independent characterizations of this class which we will consider in Section 4.  Such results testify to the robustness of the definition of polynomial time computability.\n It is also possible to make a case for CET which parallels the quasi-inductive argument for CT. For in cases where we can compute the values of a function (or decide a problem) uniformly for the class of instances we are concerned with in practice, this is typically so precisely because we have discovered a polynomial time algorithm which can be implemented on current computing hardware (and hence also as a Turing machine).  And in instances where we are currently unable to uniformly compute the values of a function (or decide a problem) for all arguments in which we take interest, it is typically the case that we have not discovered a polynomial time algorithm (and in many cases may also possess circumstantial evidence that such an algorithm cannot exist).\nNonetheless, there are several features of CET which  suggest it should be regarded as less well established than CT.  Paramount amongst these is that we do not as yet know whether \\(\\textbf{P}\\) is properly contained in complexity classes such as \\(\\textbf{NP}\\) which appear to contain highly intractable problems.  The following additional caveats are also often issued with respect to the claim that the class of computational problems we can decide in practice neatly aligns with those decidable in polynomial time using a conventional deterministic Turing \n machine.[10]\n\n\nCET classifies as feasible those functions whose most efficient algorithms have time complexity \\(c \\cdot n^k\\) for arbitrarily large scalar factors \\(c\\) and exponents \\(k\\). This means that if a function is only computable by an algorithm with time complexity \\(2^{1000} \\cdot n\\) or \\(n^{1000}\\), it would still be classified as feasible. This is so despite the fact that we would be unable to compute its values in practice for most or all inputs.\n\nCET classifies as infeasible functions whose most efficient algorithms have time complexity which is of super-polynomial order of growth inclusive of, e.g., \\(2^{.000001n}\\) or \\(n^{\\log(\\log(\\log(n)))}\\). However, such algorithms would run more efficiently when applied to the sorts of inputs we are likely to be concerned with than an algorithm with time complexity of (say) \\(O(n^2)\\).\n\nThere exist problems for which the most efficient known decision algorithm has exponential time complexity in the worst case (and in fact are known to be \\(\\textbf{NP}\\)-hard in the general case \u2013 see Section 3.2)  but which operate in polynomial time either in the average case or for a large subclass of problem instances of practical interest. Commonly cited examples include \\(\\sc{SAT}\\) (e.g. Cook and Mitchell 1997), as well as some problems from graph theory (e.g. Scott and Sorkin 2006), and computational algebra (e.g. Kapovich et al. 2003).\n\nMany of the problems studied in complexity theory are decision variants of optimization problems.  In cases where these problems are  \\(\\textbf{NP}\\)-complete, it is a consequence of CET (together with \\(\\textbf{P} \\neq \\textbf{NP}\\) \u2013 see Section 4.1) that they do not admit feasible exact algorithms \u2013 i.e. algorithms which are guaranteed to always find a maximal or minimal solution.  Nonetheless, it is known that a significant subclass of \\(\\textbf{NP}\\)-complete problems possess polynomial time approximation algorithms -- i.e. algorithms which are guaranteed to find a solution which is within a certain constant factor of optimality.   For instance the optimization version of the problem \\(\\sc{VERTEX}\\ \\sc{COVER}\\) defined below possesses a simple polynomial time approximation algorithm which allows us to find a solution (i.e. a set of vertices including at least one from each edge of the input graph) which is no larger than twice the size of an optimal solution.\n\nThere are non-classical models of computation which are hypothesized to yield a different classification of problems with respect to the appropriate definition of \u2018polynomial time computability\u2019. A notable example is the existence of a procedure known as Shor\u2019s algorithm which solves the problem \\(\\sc{FACTORIZATION}\\) in polynomial time relative the a model of computation known as the Quantum Turing Machine (see \n Section 3.4.3).\n\n",
    "section_title": "2.2 The Cobham-Edmond\u2019s Thesis and feasible computability",
    "entry_title": "Computational Complexity Theory",
    "hierarchy_title": "Computational Complexity Theory || The origins of complexity theory || The Cobham-Edmond\u2019s Thesis and feasible computability",
    "tokenized_text": [
        "origin",
        "complexity",
        "theory",
        "cobhamedmond",
        "thesis",
        "feasible",
        "computability",
        "cobhamedmond",
        "thesis",
        "feasible",
        "computability",
        "church",
        "thesis",
        "often",
        "cited",
        "paradigm",
        "example",
        "case",
        "mathematical",
        "method",
        "successfully",
        "employed",
        "provide",
        "precise",
        "analysis",
        "informal",
        "concept",
        "ie",
        "effective",
        "computability",
        "also",
        "natural",
        "ask",
        "whether",
        "concept",
        "feasible",
        "computability",
        "described",
        "section",
        "admits",
        "mathematical",
        "analysis",
        "similar",
        "church",
        "thesis",
        "saw",
        "sc",
        "factorization",
        "example",
        "problem",
        "antecedent",
        "mathematical",
        "practical",
        "interest",
        "efficient",
        "algorithm",
        "historically",
        "sought",
        "task",
        "efficiently",
        "solving",
        "combinatorial",
        "problem",
        "sort",
        "exemplified",
        "sc",
        "tsp",
        "sc",
        "integer",
        "sc",
        "programming",
        "sc",
        "perfect",
        "sc",
        "matching",
        "grew",
        "importance",
        "s",
        "s",
        "due",
        "role",
        "scientific",
        "industrial",
        "clerical",
        "application",
        "time",
        "availability",
        "digital",
        "computer",
        "began",
        "make",
        "many",
        "problem",
        "mechanically",
        "solvable",
        "mass",
        "scale",
        "first",
        "time",
        "era",
        "also",
        "saw",
        "several",
        "theoretical",
        "step",
        "heralded",
        "attempt",
        "develop",
        "general",
        "theory",
        "feasible",
        "computability",
        "basic",
        "definition",
        "time",
        "space",
        "complexity",
        "turing",
        "machine",
        "model",
        "first",
        "systematically",
        "formulated",
        "hartmanis",
        "stearns",
        "paper",
        "called",
        "computational",
        "complexity",
        "algorithm",
        "paper",
        "also",
        "origin",
        "socalled",
        "hierarchy",
        "theorem",
        "see",
        "section",
        "demonstrate",
        "sufficiently",
        "large",
        "increase",
        "time",
        "space",
        "bound",
        "turing",
        "machine",
        "computation",
        "allows",
        "problem",
        "decided",
        "systematic",
        "exploration",
        "relationship",
        "different",
        "model",
        "computation",
        "also",
        "undertaken",
        "period",
        "included",
        "variant",
        "traditional",
        "turing",
        "machine",
        "model",
        "additional",
        "head",
        "tape",
        "auxiliary",
        "storage",
        "device",
        "stack",
        "another",
        "important",
        "model",
        "introduced",
        "time",
        "random",
        "access",
        "ram",
        "machine",
        "mathfrak",
        "see",
        "eg",
        "cook",
        "reckhow",
        "model",
        "provides",
        "simplified",
        "representation",
        "socalled",
        "von",
        "neumann",
        "architecture",
        "contemporary",
        "digital",
        "computer",
        "based",
        "particular",
        "ram",
        "machine",
        "a",
        "consists",
        "finite",
        "sequence",
        "instruction",
        "program",
        "langle",
        "pi_",
        "ldots",
        "pi_n",
        "rangle",
        "expressing",
        "numerical",
        "operation",
        "typically",
        "addition",
        "subtraction",
        "applied",
        "sequence",
        "register",
        "r_",
        "r_",
        "dots",
        "value",
        "may",
        "stored",
        "retrieved",
        "directly",
        "index",
        "showing",
        "one",
        "model",
        "mathfrak",
        "_",
        "determines",
        "class",
        "function",
        "reference",
        "model",
        "mathfrak",
        "_",
        "mathfrak",
        "requires",
        "showing",
        "m_",
        "in",
        "mathfrak",
        "_",
        "exists",
        "machine",
        "m_",
        "in",
        "mathfrak",
        "_",
        "computes",
        "function",
        "m_",
        "conversely",
        "typically",
        "accomplished",
        "constructing",
        "m_",
        "basic",
        "step",
        "m_",
        "simulated",
        "one",
        "basic",
        "step",
        "m_",
        "demonstrating",
        "coincidence",
        "class",
        "function",
        "computed",
        "model",
        "mathfrak",
        "_",
        "mathfrak",
        "_",
        "thus",
        "often",
        "yield",
        "additional",
        "information",
        "relative",
        "efficiency",
        "instance",
        "generally",
        "possible",
        "extract",
        "definition",
        "simulation",
        "mathfrak",
        "_",
        "mathfrak",
        "_",
        "time",
        "space",
        "overhead",
        "function",
        "o_t",
        "x",
        "o_s",
        "x",
        "value",
        "function",
        "f",
        "x",
        "computed",
        "time",
        "n",
        "space",
        "n",
        "machine",
        "m_",
        "in",
        "mathfrak",
        "_",
        "also",
        "computed",
        "time",
        "o_t",
        "n",
        "space",
        "o_s",
        "n",
        "machine",
        "m_",
        "in",
        "mathfrak",
        "_",
        "wide",
        "class",
        "model",
        "significant",
        "discovery",
        "efficient",
        "simulation",
        "found",
        "instance",
        "might",
        "first",
        "appear",
        "model",
        "mathfrak",
        "allows",
        "considerably",
        "efficient",
        "implementation",
        "familiar",
        "algorithm",
        "model",
        "mathfrak",
        "virtue",
        "fact",
        "ram",
        "machine",
        "access",
        "register",
        "single",
        "step",
        "whereas",
        "turing",
        "machine",
        "may",
        "move",
        "head",
        "single",
        "cell",
        "time",
        "nonetheless",
        "shown",
        "exists",
        "simulation",
        "ram",
        "model",
        "turing",
        "machine",
        "model",
        "cubic",
        "time",
        "overhead",
        "constant",
        "space",
        "overhead",
        "ie",
        "o_t",
        "n",
        "in",
        "n",
        "o_s",
        "n",
        "in",
        "n",
        "slot",
        "emde",
        "boa",
        "basis",
        "related",
        "result",
        "emde",
        "boa",
        "formulated",
        "following",
        "proposal",
        "characterize",
        "relationship",
        "reference",
        "model",
        "might",
        "used",
        "defining",
        "time",
        "space",
        "complexity",
        "invariance",
        "thesis",
        "reasonable",
        "model",
        "computation",
        "simulate",
        "within",
        "polynomially",
        "bounded",
        "overhead",
        "time",
        "constantfactor",
        "overhead",
        "space",
        "s",
        "also",
        "saw",
        "number",
        "advance",
        "algorithmic",
        "method",
        "applicable",
        "problem",
        "field",
        "like",
        "graph",
        "theory",
        "linear",
        "algebra",
        "one",
        "example",
        "technique",
        "known",
        "dynamic",
        "programming",
        "method",
        "sometimes",
        "used",
        "find",
        "efficient",
        "solution",
        "optimization",
        "problem",
        "ask",
        "u",
        "find",
        "object",
        "minimizes",
        "maximizes",
        "certain",
        "quantity",
        "range",
        "possible",
        "solution",
        "algorithm",
        "based",
        "dynamic",
        "programming",
        "solves",
        "instance",
        "problem",
        "recursively",
        "breaking",
        "subproblems",
        "whose",
        "optimal",
        "value",
        "computed",
        "stored",
        "manner",
        "efficiently",
        "reassembled",
        "achieve",
        "optimal",
        "overall",
        "solution",
        "bellman",
        "showed",
        "naive",
        "time",
        "complexity",
        "n",
        "sc",
        "tsp",
        "could",
        "improved",
        "n",
        "n",
        "via",
        "use",
        "dynamic",
        "programming",
        "question",
        "thus",
        "arose",
        "whether",
        "possible",
        "improve",
        "upon",
        "algorithm",
        "sc",
        "tsp",
        "also",
        "problem",
        "sc",
        "sat",
        "efficient",
        "algorithm",
        "sought",
        "known",
        "exist",
        "order",
        "appreciate",
        "stake",
        "question",
        "observe",
        "naive",
        "algorithm",
        "sc",
        "tsp",
        "work",
        "follows",
        "enumerate",
        "set",
        "s_g",
        "possible",
        "tour",
        "g",
        "compute",
        "weight",
        "check",
        "cost",
        "tour",
        "leq",
        "b",
        "note",
        "however",
        "g",
        "n",
        "node",
        "s_g",
        "may",
        "contain",
        "many",
        "n",
        "tour",
        "example",
        "socalled",
        "brute",
        "force",
        "algorithm",
        "ie",
        "one",
        "solves",
        "problem",
        "exhaustively",
        "enumerating",
        "possible",
        "solution",
        "successively",
        "testing",
        "whether",
        "correct",
        "somewhat",
        "precisely",
        "problem",
        "x",
        "said",
        "admit",
        "brute",
        "force",
        "solution",
        "exists",
        "feasibly",
        "decidable",
        "relation",
        "r_x",
        "family",
        "uniformly",
        "defined",
        "finite",
        "set",
        "s_x",
        "x",
        "in",
        "x",
        "exists",
        "feasibly",
        "sized",
        "witness",
        "in",
        "s_x",
        "r_x",
        "x",
        "y",
        "often",
        "called",
        "certificate",
        "x",
        "membership",
        "x",
        "procedure",
        "deciding",
        "x",
        "in",
        "x",
        "exhaustively",
        "searching",
        "certificate",
        "y_",
        "y_",
        "ldots",
        "in",
        "s_x",
        "checking",
        "r_x",
        "x",
        "hold",
        "step",
        "known",
        "brute",
        "force",
        "search",
        "instance",
        "membership",
        "propositional",
        "formula",
        "phi",
        "atomic",
        "letter",
        "among",
        "p_",
        "ldots",
        "p_",
        "n",
        "problem",
        "sc",
        "sat",
        "established",
        "searching",
        "set",
        "s_",
        "phi",
        "possible",
        "valuation",
        "function",
        "type",
        "v",
        "ldots",
        "n",
        "rightarrow",
        "determine",
        "exists",
        "v",
        "in",
        "s_",
        "phi",
        "llbracket",
        "phi",
        "rrbracket_v",
        "note",
        "however",
        "since",
        "n",
        "function",
        "s_",
        "phi",
        "yield",
        "exponential",
        "time",
        "decision",
        "algorithm",
        "many",
        "problem",
        "came",
        "light",
        "s",
        "s",
        "like",
        "sc",
        "sat",
        "sc",
        "tsp",
        "easily",
        "seen",
        "posse",
        "exponential",
        "time",
        "brute",
        "force",
        "algorithm",
        "polynomial",
        "time",
        "algorithm",
        "could",
        "found",
        "basis",
        "gradually",
        "came",
        "accepted",
        "sufficient",
        "condition",
        "decidable",
        "problem",
        "intractable",
        "efficient",
        "algorithm",
        "solved",
        "best",
        "exponential",
        "time",
        "complexity",
        "corresponding",
        "positive",
        "hypothesis",
        "possession",
        "polynomial",
        "time",
        "decision",
        "algorithm",
        "regarded",
        "sufficient",
        "ground",
        "regarding",
        "problem",
        "feasibly",
        "decidable",
        "first",
        "put",
        "forth",
        "cobham",
        "edmonds",
        "a",
        "cobham",
        "began",
        "citing",
        "evidence",
        "motivating",
        "invariance",
        "thesis",
        "suggesting",
        "question",
        "whether",
        "problem",
        "admits",
        "polynomial",
        "time",
        "algorithm",
        "independent",
        "model",
        "computation",
        "used",
        "measure",
        "time",
        "complexity",
        "across",
        "broad",
        "class",
        "alternative",
        "additionally",
        "presented",
        "machineindependent",
        "characterization",
        "class",
        "textbf",
        "fp",
        "ie",
        "function",
        "f",
        "mathbb",
        "n",
        "k",
        "rightarrow",
        "mathbb",
        "n",
        "computable",
        "polynomial",
        "time",
        "term",
        "restricted",
        "form",
        "primitive",
        "recursive",
        "definition",
        "known",
        "bounded",
        "recursion",
        "notation",
        "see",
        "section",
        "edmonds",
        "a",
        "first",
        "proposed",
        "polynomial",
        "time",
        "complexity",
        "could",
        "used",
        "positive",
        "criterion",
        "feasibility",
        "put",
        "possessing",
        "good",
        "algorithm",
        "paper",
        "showed",
        "problem",
        "might",
        "priori",
        "thought",
        "solvable",
        "brute",
        "force",
        "search",
        "generalization",
        "sc",
        "perfect",
        "sc",
        "matching",
        "decidable",
        "polynomial",
        "time",
        "algorithm",
        "paralleling",
        "similar",
        "study",
        "brute",
        "force",
        "search",
        "soviet",
        "union",
        "subsequent",
        "paper",
        "edmonds",
        "b",
        "also",
        "provided",
        "informal",
        "description",
        "complexity",
        "class",
        "textbf",
        "np",
        "particular",
        "characterized",
        "class",
        "containing",
        "problem",
        "x",
        "exists",
        "good",
        "characterization",
        "ie",
        "x",
        "membership",
        "instance",
        "x",
        "may",
        "verified",
        "using",
        "brute",
        "force",
        "search",
        "find",
        "certificate",
        "y",
        "feasible",
        "size",
        "certifies",
        "x",
        "membership",
        "x",
        "observation",
        "provided",
        "groundwork",
        "come",
        "known",
        "cobhamedmonds",
        "thesis",
        "see",
        "eg",
        "brookshear",
        "et",
        "al",
        "goldreich",
        "homer",
        "selman",
        "cet",
        "function",
        "f",
        "mathbb",
        "n",
        "k",
        "rightarrow",
        "mathbb",
        "n",
        "feasibly",
        "computable",
        "f",
        "vec",
        "x",
        "computed",
        "machine",
        "m",
        "t_m",
        "n",
        "in",
        "nk",
        "k",
        "fixed",
        "m",
        "drawn",
        "reasonable",
        "model",
        "computation",
        "mathfrak",
        "cet",
        "provides",
        "characterization",
        "notion",
        "feasibly",
        "computable",
        "function",
        "discussed",
        "section",
        "similar",
        "form",
        "church",
        "thesis",
        "corresponding",
        "thesis",
        "decision",
        "problem",
        "hold",
        "problem",
        "feasibly",
        "decidable",
        "case",
        "class",
        "textbf",
        "p",
        "formulated",
        "however",
        "cet",
        "relies",
        "informal",
        "notion",
        "reasonable",
        "model",
        "computation",
        "precise",
        "formulation",
        "given",
        "replacing",
        "notion",
        "specific",
        "model",
        "mathfrak",
        "mathfrak",
        "first",
        "machine",
        "class",
        "discussed",
        "section",
        "cet",
        "widely",
        "accepted",
        "within",
        "theoretical",
        "computer",
        "science",
        "reason",
        "broadly",
        "parallel",
        "traditionally",
        "given",
        "favor",
        "church",
        "thesis",
        "instance",
        "definition",
        "class",
        "textbf",
        "fp",
        "stable",
        "across",
        "different",
        "machinebased",
        "model",
        "computation",
        "manner",
        "highlighted",
        "invariance",
        "thesis",
        "also",
        "exist",
        "several",
        "machine",
        "independent",
        "characterization",
        "class",
        "consider",
        "section",
        "result",
        "testify",
        "robustness",
        "definition",
        "polynomial",
        "time",
        "computability",
        "also",
        "possible",
        "make",
        "case",
        "cet",
        "parallel",
        "quasiinductive",
        "argument",
        "ct",
        "case",
        "compute",
        "value",
        "function",
        "decide",
        "problem",
        "uniformly",
        "class",
        "instance",
        "concerned",
        "practice",
        "typically",
        "precisely",
        "discovered",
        "polynomial",
        "time",
        "algorithm",
        "implemented",
        "current",
        "computing",
        "hardware",
        "hence",
        "also",
        "turing",
        "machine",
        "instance",
        "currently",
        "unable",
        "uniformly",
        "compute",
        "value",
        "function",
        "decide",
        "problem",
        "argument",
        "take",
        "interest",
        "typically",
        "case",
        "discovered",
        "polynomial",
        "time",
        "algorithm",
        "many",
        "case",
        "may",
        "also",
        "posse",
        "circumstantial",
        "evidence",
        "algorithm",
        "exist",
        "nonetheless",
        "several",
        "feature",
        "cet",
        "suggest",
        "regarded",
        "le",
        "well",
        "established",
        "ct",
        "paramount",
        "amongst",
        "yet",
        "know",
        "whether",
        "textbf",
        "p",
        "properly",
        "contained",
        "complexity",
        "class",
        "textbf",
        "np",
        "appear",
        "contain",
        "highly",
        "intractable",
        "problem",
        "following",
        "additional",
        "caveat",
        "also",
        "often",
        "issued",
        "respect",
        "claim",
        "class",
        "computational",
        "problem",
        "decide",
        "practice",
        "neatly",
        "aligns",
        "decidable",
        "polynomial",
        "time",
        "using",
        "conventional",
        "deterministic",
        "turing",
        "machine",
        "cet",
        "classifies",
        "feasible",
        "function",
        "whose",
        "efficient",
        "algorithm",
        "time",
        "complexity",
        "c",
        "cdot",
        "nk",
        "arbitrarily",
        "large",
        "scalar",
        "factor",
        "c",
        "exponent",
        "k",
        "mean",
        "function",
        "computable",
        "algorithm",
        "time",
        "complexity",
        "cdot",
        "n",
        "n",
        "would",
        "still",
        "classified",
        "feasible",
        "despite",
        "fact",
        "would",
        "unable",
        "compute",
        "value",
        "practice",
        "input",
        "cet",
        "classifies",
        "infeasible",
        "function",
        "whose",
        "efficient",
        "algorithm",
        "time",
        "complexity",
        "superpolynomial",
        "order",
        "growth",
        "inclusive",
        "eg",
        "n",
        "n",
        "log",
        "log",
        "log",
        "n",
        "however",
        "algorithm",
        "would",
        "run",
        "efficiently",
        "applied",
        "sort",
        "input",
        "likely",
        "concerned",
        "algorithm",
        "time",
        "complexity",
        "say",
        "n",
        "exist",
        "problem",
        "efficient",
        "known",
        "decision",
        "algorithm",
        "exponential",
        "time",
        "complexity",
        "worst",
        "case",
        "fact",
        "known",
        "textbf",
        "np",
        "hard",
        "general",
        "case",
        "see",
        "section",
        "operate",
        "polynomial",
        "time",
        "either",
        "average",
        "case",
        "large",
        "subclass",
        "problem",
        "instance",
        "practical",
        "interest",
        "commonly",
        "cited",
        "example",
        "include",
        "sc",
        "sat",
        "eg",
        "cook",
        "mitchell",
        "well",
        "problem",
        "graph",
        "theory",
        "eg",
        "scott",
        "sorkin",
        "computational",
        "algebra",
        "eg",
        "kapovich",
        "et",
        "al",
        "many",
        "problem",
        "studied",
        "complexity",
        "theory",
        "decision",
        "variant",
        "optimization",
        "problem",
        "case",
        "problem",
        "textbf",
        "np",
        "complete",
        "consequence",
        "cet",
        "together",
        "textbf",
        "p",
        "neq",
        "textbf",
        "np",
        "see",
        "section",
        "admit",
        "feasible",
        "exact",
        "algorithm",
        "ie",
        "algorithm",
        "guaranteed",
        "always",
        "find",
        "maximal",
        "minimal",
        "solution",
        "nonetheless",
        "known",
        "significant",
        "subclass",
        "textbf",
        "np",
        "complete",
        "problem",
        "posse",
        "polynomial",
        "time",
        "approximation",
        "algorithm",
        "ie",
        "algorithm",
        "guaranteed",
        "find",
        "solution",
        "within",
        "certain",
        "constant",
        "factor",
        "optimality",
        "instance",
        "optimization",
        "version",
        "problem",
        "sc",
        "vertex",
        "sc",
        "cover",
        "defined",
        "posse",
        "simple",
        "polynomial",
        "time",
        "approximation",
        "algorithm",
        "allows",
        "u",
        "find",
        "solution",
        "ie",
        "set",
        "vertex",
        "including",
        "least",
        "one",
        "edge",
        "input",
        "graph",
        "larger",
        "twice",
        "size",
        "optimal",
        "solution",
        "nonclassical",
        "model",
        "computation",
        "hypothesized",
        "yield",
        "different",
        "classification",
        "problem",
        "respect",
        "appropriate",
        "definition",
        "polynomial",
        "time",
        "computability",
        "notable",
        "example",
        "existence",
        "procedure",
        "known",
        "shor",
        "algorithm",
        "solves",
        "problem",
        "sc",
        "factorization",
        "polynomial",
        "time",
        "relative",
        "model",
        "computation",
        "known",
        "quantum",
        "turing",
        "machine",
        "see",
        "section"
    ]
}