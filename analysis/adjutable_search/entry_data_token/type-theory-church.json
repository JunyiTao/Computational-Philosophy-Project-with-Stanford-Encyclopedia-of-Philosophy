{"url": "type-theory-church", "title": "Church\u2019s Type Theory", "authorship": {"year": "Copyright \u00a9 2019", "author_text": "Christoph Benzm\u00fcller\n<christoph.benzmueller@uni-bamberg.de>\nPeter Andrews", "author_links": [{"https://www.uni-bamberg.de/en/aise/team/benzmueller/": "Christoph Benzm\u00fcller"}, {"mailto:christoph%2ebenzmueller%40uni-bamberg%2ede": "christoph.benzmueller@uni-bamberg.de"}], "raw_html": "<div id=\"article-copyright\">\n<p>\n<a href=\"../../info.html#c\">Copyright \u00a9 2019</a> by\n\n<br/>\n<a href=\"https://www.uni-bamberg.de/en/aise/team/benzmueller/\" target=\"other\">Christoph Benzm\u00fcller</a>\n&lt;<a href=\"mailto:christoph%2ebenzmueller%40uni-bamberg%2ede\"><em>christoph<abbr title=\" dot \">.</abbr>benzmueller<abbr title=\" at \">@</abbr>uni-bamberg<abbr title=\" dot \">.</abbr>de</em></a>&gt;<br/>\nPeter Andrews\n\n    </p>\n</div>"}, "pubinfo": ["First published Fri Aug 25, 2006", "substantive revision Tue May 21, 2019"], "preamble": "\n\nChurch\u2019s type theory, aka simple type theory, is a formal\nlogical language which includes classical first-order and\npropositional logic, but is more expressive in a practical sense. It\nis used, with some modifications and enhancements, in most modern\napplications of type theory. It is particularly well suited to the\nformalization of mathematics and other disciplines and to specifying\nand verifying hardware and software. It also plays an important role\nin the study of the formal semantics of natural language. When\nutilizing it as a meta-logic to semantically embed expressive\n(quantified) non-classical logics further topical applications are\nenabled in artificial intelligence and philosophy.\n\nA great wealth of technical knowledge can be expressed very naturally\nin it. With possible enhancements, Church\u2019s type theory\nconstitutes an excellent formal language for representing the\nknowledge in automated information systems, sophisticated automated\nreasoning systems, systems for verifying the correctness of\nmathematical proofs, and a range of projects involving logic and\nartificial intelligence. Some examples and further references are\ngiven in Sections\n 1.2.2\n and\n 5\n below. \n\nType theories are also called higher-order logics, since they allow\nquantification not only over individual variables (as in first-order\nlogic), but also over function, predicate, and even higher order\nvariables. Type theories characteristically assign types to entities,\ndistinguishing, for example, between numbers, sets of numbers,\nfunctions from numbers to sets of numbers, and sets of such functions.\nAs illustrated in\n Section 1.2.2\n below, these distinctions allow one to discuss the conceptually rich\nworld of sets and functions without encountering the paradoxes of\nnaive set theory.\n\nChurch\u2019s type theory is a formulation of type theory that was\nintroduced by Alonzo Church in Church 1940. In certain respects, it is\nsimpler and more general than the type theory introduced by Bertrand\nRussell in Russell 1908 and Whitehead & Russell 1927a. Since\nproperties and relations can be regarded as functions from entities to\ntruth values, the concept of a function is taken as primitive in\nChurch\u2019s type theory, and the \u03bb-notation which Church\nintroduced in Church 1932 and Church 1941 is incorporated into the\nformal language. Moreover, quantifiers and description operators are\nintroduced in a way so that additional binding mechanisms can be\navoided, \u03bb-notation is reused instead. \u03bb-notation is\nthus the only binding mechanism employed in Church\u2019s type\ntheory.\n", "toc": [{"#Synt": "1. Syntax"}, {"#FundIdea": "1.1 Fundamental Ideas"}, {"#Form": "1.2 Formulas"}, {"#Defi": "1.2.1 Definitions"}, {"#Exam": "1.2.2 Examples"}, {"#AxioRuleInfe": "1.3 Axioms and Rules of Inference"}, {"#RuleInfe": "1.3.1 Rules of Inference"}, {"#ElemTypeTheo": "1.3.2 Elementary Type Theory"}, {"#AxioExte": "1.3.3 Axioms of Extensionality"}, {"#Desc": "1.3.4 Descriptions"}, {"#AxioChoi": "1.3.5 Axiom of Choice"}, {"#AxioInfi": "1.3.6 Axioms of Infinity"}, {"#FormBaseEqua": "1.4 A Formulation Based on Equality"}, {"#Defi_1": "1.4.1 Definitions"}, {"#AxioRuleInfe_1": "1.4.2 Axioms and Rules of Inference"}, {"#Sema": "2. Semantics"}, {"#Meta": "3. Metatheory"}, {"#LambConv": "3.1 Lambda-Conversion"}, {"#HighOrdeUnif": "3.2 Higher-Order Unification"}, {"#UnifPrin": "3.3 A Unifying Principle"}, {"#ElemTypeTheo_1": "3.3.1 Elementary Type Theory"}, {"#ExteTypeTheo": "3.3.2 Extensional Type Theory"}, {"#CutElimCutSimu": "3.4 Cut-Elimination and Cut-Simulation"}, {"#ExpaProo": "3.5 Expansion Proofs"}, {"#DeciProb": "3.6 The Decision Problem"}, {"#Auto": "4. Automation"}, {"#MachOrieProoCalc": "4.1 Machine-Oriented Proof Calculi"}, {"#EarlProoAssi": "4.2 Early Proof Assistants"}, {"#AutoTheoProv": "4.3 Automated Theorem Provers"}, {"#CounModeFind": "4.4 (Counter-)Model Finding"}, {"#Appl": "5. Applications"}, {"#SemaNatuLang": "5.1 Semantics of Natural Language"}, {"#MathCompScie": "5.2 Mathematics and Computer Science"}, {"#CompMetaArtiInte": "5.3 Computational Metaphysics and Artificial Intelligence"}, {"#Bib": "Bibliography"}, {"#Aca": "Academic Tools"}, {"#Oth": "Other Internet Resources"}, {"#Rel": "Related Entries"}], "main_text": "\n1. Syntax\n1.1 Fundamental Ideas\n\nWe start with an informal description of the fundamental ideas\nunderlying the syntax of Church\u2019s formulation of type\ntheory.\n\nAll entities have types, and if \u03b1 and \u03b2 are types, the type\nof functions from elements of type \u03b2 to elements of type \u03b1\nis written as \\((\\alpha \\beta)\\). (This notation was introduced by\nChurch, but some authors write \\((\\beta \\rightarrow \\alpha)\\) instead\nof \\((\\alpha \\beta)\\). See, for example, Section 2 of the entry on\n type theory.)\n\nAs noted by Sch\u00f6nfinkel (1924), functions of more than one\nargument can be represented in terms of functions of one argument when\nthe values of these functions can themselves be functions. For\nexample, if f is a function of two arguments, for each element\nx of the left domain of f there is a function g\n(depending on x) such that \\(gy = fxy\\) for each element\ny of the right domain of f. We may now write \\(g = fx\\),\nand regard f as a function of a single argument, whose value\nfor any argument x in its domain is a function \\(fx\\), whose\nvalue for any argument y in its domain is fxy.\n\nFor a more explicit example, consider the function + which carries any\npair of natural numbers to their sum. We may denote this function by\n\\(+_{((\\sigma \\sigma)\\sigma)}\\), where \\(\\sigma\\) is the type of\nnatural numbers. Given any number x, \\([+_{((\\sigma\n\\sigma)\\sigma)}x]\\) is the function which, when applied to any number\ny, gives the value \\([[+_{((\\sigma \\sigma)\\sigma)}x]y]\\), which\nis ordinarily abbreviated as \\(x + y\\). Thus \\([+_{((\\sigma\n\\sigma)\\sigma)}x]\\) is the function of one argument which adds\nx to any number. When we think of \\(+_{((\\sigma\n\\sigma)\\sigma)}\\) as a function of one argument, we see that it maps\nany number x to the function \\([+_{((\\sigma\n\\sigma)\\sigma)}x]\\).\n\nMore generally, if f is a function which maps n-tuples\n\\(\\langle w_{\\beta},x_{\\gamma},\\ldots ,y_{\\delta},z_{\\tau}\\rangle\\) of\nelements of types \\(\\beta\\), \\(\\gamma\\),\u2026, \\(\\delta\\)\n,\\(\\tau\\), respectively, to elements of type \u03b1, we may assign to\nf the type \\(((\\ldots((\\alpha \\tau)\\delta)\\ldots\n\\gamma)\\beta)\\). It is customary to use the convention of association\nto the left to omit parentheses, and write this type symbol simply as\n\\((\\alpha \\tau \\delta \\ldots \\gamma \\beta)\\).\n\nA set or property can be represented by a function (often called\ncharacteristic function) which maps elements to truth values,\nso that an element is in the set, or has the property, in question iff\nthe function representing the set or property maps that element to\ntruth. When a statement is asserted, the speaker means that it is\ntrue, so that \\(s x\\) means that \\(s x\\) is true, which also expresses\nthe assertions that s maps x to truth and that \\(x \\in\ns\\). In other words, \\(x \\in s\\) iff \\(s x\\). We take \\({o}\\) as the\ntype symbol denoting the type of truth values, so we may speak of any\nfunction of type \\(({o}\\alpha)\\) as a set of elements of type\n\u03b1. A function of type \\((({o}\\alpha)\\beta)\\) is a binary\nrelation between elements of type \u03b2 and elements of type \u03b1.\nFor example, if \\(\\sigma\\) is the type of the natural numbers, and\n\\(<\\) is the order relation between natural numbers, \\(<\\) has\ntype \\(({o}\\sigma \\sigma)\\), and for all natural numbers x and\n\\(y, {<}x y\\) (which we ordinarily write as \\(x < y)\\) has the\nvalue truth iff x is less than y. Of course, \\(<\\)\ncan also be regarded as the function which maps each natural number\nx to the set \\(<x\\) of all natural numbers y such\nthat x is less than y. Thus sets, properties, and\nrelations may be regarded as particular kinds of functions.\nChurch\u2019s type type theory is thus a logic of functions, and, in\nthis sense, it is in the tradition of the work of Frege\u2019s\nBegriffsschrift. The opposite approach would be to reduce\nfunctions to relations, which was the approach taken by Whitehead and\nRussell (1927a) in the Principia Mathematica.\n\nExpressions which denote elements of type \u03b1 are called wffs\nof type \u03b1. Thus, statements of type theory are wffs of type\n\\({o}\\).\n\nIf \\(\\bA_{\\alpha}\\) is a wff of type \u03b1 in which \\(\\bu_{\\alpha\n\\beta}\\) is not free, the function (associated with) \\(\\bu_{\\alpha\n\\beta}\\) such that \\(\\forall \\bv_{\\beta}[\\bu_{\\alpha \\beta}\\bv_{\\beta}\n= \\bA_{\\alpha}]\\) is denoted by \\([\\lambda \\bv_{\\beta}\\bA_{\\alpha}]\\).\nThus \\(\\lambda \\bv_{\\beta}\\) is a variable-binder, like \\(\\forall\n\\bv_{\\beta}\\) or \\(\\exists \\bv_{\\beta}\\) (but with a quite different\nmeaning, of course); \u03bb is known as an abstraction\noperator. \\([\\lambda \\bv_{\\beta}\\bA_{\\alpha}]\\) denotes the\nfunction whose value on any argument \\(\\bv_{\\beta}\\) is\n\\(\\bA_{\\alpha}\\), where \\(\\bv_{\\beta}\\) may occur free in\n\\(\\bA_{\\alpha}\\). For example, \\([\\lambda n_{\\sigma}[4\\cdot\nn_{\\sigma}+3]]\\) denotes the function whose value on any natural\nnumber n is \\(4\\cdot n+3\\). Hence, when we apply this function\nto the number 5 we obtain \\([\\lambda n_{\\sigma}[4\\cdot n_{\\sigma}+3]]5\n= 4\\cdot 5+3 = 23\\).\n\nWe use \\(\\textsf{Sub}(\\bB,\\bv,\\bA)\\) as a notation for the result of\nsubstituting \\(\\bB\\) for \\(\\bv\\) in \\(\\bA\\), and\n\\(\\textsf{SubFree}(\\bB,\\bv,\\bA)\\) as a notation for the result of\nsubstituting \\(\\bB\\) for all free occurrences of \\(\\bv\\) in \\(\\bA\\).\nThe process of replacing \\([\\lambda\n\\bv_{\\beta}\\bA_{\\alpha}]\\bB_{\\beta}\\) by\n\\(\\textsf{SubFree}(\\bB_{\\beta},\\bv_{\\beta},\\bA_{\\alpha})\\) (or\nvice-versa) is known as \u03b2-conversion, which is one form\nof \u03bb-conversion. Of course, when \\(\\bA_{{o}}\\) is a\nwff of type \\({o}\\), \\([\\lambda \\bv_{\\beta}\\bA_{{o}}]\\) denotes the\nset of all elements \\(\\bv_{\\beta}\\) (of type \\(\\beta)\\) of which\n\\(\\bA_{{o}}\\) is true; this set may also be denoted by\n\\(\\{\\bv_{\\beta}|\\bA_{{o}}\\}\\). For example, \\([\\lambda x\\ x<y]\\)\ndenotes the set of x such that x is less than y\n(as well as that property which a number x has if it is less\nthan y). In familiar set-theoretic notation,  \n\n\\[[\\lambda \\bv_{\\beta} \\bA_{{o}}]\\bB_{\\beta} = \\textsf{SubFree}(\\bB_{\\beta},\\bv_{\\beta},\\bA_{{o}})\\]\n\n\nwould be written \n\n\\[\\bB_{\\beta} \\in \\{\\bv_{\\beta}|\\bA_{{o}}\\} \\equiv \\textsf{SubFree}(\\bB_{\\beta},\\bv_{\\beta},\\bA_{{o}}).\\]\n\n\n(By the Axiom of Extensionality for truth values, when \\(\\bC_{{o}}\\)\nand \\(\\bD_{{o}}\\) are of type \\({o}, \\bC_{{o}} \\equiv \\bD_{{o}}\\) is\nequivalent to \\(\\bC_{{o}} = \\bD_{{o}}\\).)\n\nPropositional connectives and quantifiers can be assigned types and\ncan be denoted by constants of these types. The negation function maps\ntruth values to truth values, so it has type \\(({o}{o})\\). Similarly,\ndisjunction and conjunction (etc.) are binary functions from truth\nvalues to truth values, so they have type \\(({o}{o}{o})\\).\n\nThe statement \\(\\forall \\bx_{\\alpha}\\bA_{{o}}\\) is true iff the set\n\\([\\lambda \\bx_{\\alpha}\\bA_{{o}}]\\) contains all elements of type\n\u03b1. A constant \\(\\Pi_{{o}({o}\\alpha)}\\) can be introduced (for\neach type symbol \\(\\alpha)\\) to denote a property of sets: a set\n\\(s_{{o}\\alpha}\\) has the property \\(\\Pi_{{o}({o}\\alpha)}\\) iff\n\\(s_{{o}\\alpha}\\) contains all elements of type \u03b1. With this\ninterpretation  \n\n\\[\n  \\forall s_{{o}\\alpha}\\left[\\Pi_{{o}({o}\\alpha)}s_{{o}\\alpha} \\equiv \\forall x_{\\alpha}\\left[s_{{o}\\alpha}x_{\\alpha}\\right]\\right]\n\\]\n\n\nshould be true, as well as  \n\n\\[\n  \\Pi_{{o}({o}\\alpha)}[\\lambda \\bx_{\\alpha}\\bA_{{o}}] \\equiv \\forall \\bx_{\\alpha}[[\\lambda \\bx_{\\alpha}\\bA_{{o}}]\\bx_{\\alpha}] \\label{eqPi}\n\\]\n\n\nfor any wff \\(\\bA_{{o}}\\) and variable \\(\\bx_{\\alpha}\\). Since by\n\u03bb-conversion we have  \n\n\\[\n  [\\lambda\n  \\bx_{\\alpha}\\bA_{{o}}]\\bx_{\\alpha} \\equiv\n\\bA_{{o}}\n\\]\n\n\nequation can be written more simply as  \n\n\\[\n  \\Pi_{{o}({o}\\alpha)}[\\lambda\n  \\bx_{\\alpha}\\bA_{{o}}] \\equiv \\forall\n  \\bx_{\\alpha}\\bA_{{o}}\n\\]\n\n\nThus, \\(\\forall \\bx_{\\alpha}\\) can be defined in terms of\n\\(\\Pi_{{o}({o}\\alpha)}\\), and \u03bb is the only variable-binder\nthat is needed.\n1.2 Formulas\n\nBefore we state the definition of a \u201cformula\u201d, a word of\ncaution is in order. The reader may be accustomed to thinking of a\nformula as an expression which plays the role of an assertion in a\nformal language, and of a term as an expression which designates an\nobject. Church\u2019s terminology is somewhat different, and provides\na uniform way of discussing expressions of many different types. What\nwe call well-formed formula of type \u03b1\n(\\(\\textrm{wff}_{\\alpha}\\)) below would in more standard terminology\nbe called term of type \u03b1, and then only certain terms,\nnamely those with type \\({o}\\), would be called formulas. Anyhow, in\nthis entry we have decided to stay with Church\u2019s original\nterminology. Another remark concerns the use of some specific\nmathematical notation. In what follows, the entry distinguishes\nbetween the symbols \\(\\imath\\), \\(\\iota_{(\\alpha({o}\\alpha))}\\), and \\(\\atoi\\). The first is\nthe symbol used for the type of individuals; the second is the symbol\nused for a logical constant (see\n Section 1.2.1\n below); the third is the symbol used as a variable-binding operator\nthat represents the definite description \u201cthe\u201d (see\n Section 1.3.4).\n The reader should not confuse them and check to see that the browser\nis displaying these symbols correctly.\n1.2.1 Definitions\n\nType symbols are defined inductively as follows:\n\n\\(\\imath\\) is a type symbol (denoting the type of individuals).\nThere may also be additional primitive type symbols which are used in\nformalizing disciplines where it is natural to have several sorts of\nindividuals.\n\\({o}\\) is a type symbol (denoting the type of truth values).\nIf \u03b1 and \u03b2 are type symbols, then \\((\\alpha \\beta)\\) is\na type symbol (denoting the type of functions from elements of type\n\u03b2 to elements of type \u03b1).\n\n\nThe primitive symbols are the following:\n\nImproper symbols: [, ], \\(\\lambda\\)\nFor each type symbol \u03b1, a denumerable list of\nvariables of type \\(\\alpha : a_{\\alpha}, b_{\\alpha},\nc_{\\alpha}\\ldots\\)\nLogical constants: \\(\\nsim_{({o}{o})}\\), \\(\\lor_{(({o}{o}){o})}\\),\n\\(\\Pi_{({o}({o}\\alpha))}\\) and \\(\\iota_{(\\alpha({o}\\alpha))}\\) (for\neach type symbol \u03b1). The types of these constants are indicated\nby their subscripts. The symbol \\(\\nsim_{({o}{o})}\\) denotes negation,\n\\(\\lor_{(({o}{o}){o})}\\) denotes disjunction, and\n\\(\\Pi_{({o}({o}\\alpha))}\\) is used in defining the universal\nquantifier as discussed above. \\(\\iota_{(\\alpha({o}\\alpha))}\\) serves\neither as a description or selection operator as discussed in\n Section 1.3.4\n and\n Section 1.3.5\n below.\nIn addition, there may be other constants of various types, which\nwill be called nonlogical constants or parameters.\nEach choice of parameters determines a particular formulation of the\nsystem of type theory. Parameters are typically used as names for\nparticular entities in the discipline being formalized.\n\n\nA formula is a finite sequence of primitive symbols. Certain\nformulas are called well-formed formulas (wffs). We\nwrite \\(\\textrm{wff}_{\\alpha}\\) as an abbreviation for wff of\ntype \u03b1, and define this concept inductively as follows:\n\nA primitive variable or constant of type \u03b1 is a\nwff\\(_{\\alpha}\\).\nIf \\(\\bA_{\\alpha \\beta}\\) and \\(\\bB_{\\beta}\\) are wffs of the\nindicated types, then \\([\\bA_{\\alpha \\beta}\\bB_{\\beta}]\\) is a\nwff\\(_{\\alpha}\\).\nIf \\(\\bx_{\\beta}\\) is a variable of type \u03b2 and\n\\(\\bA_{\\alpha}\\) is a wff, then \\([\\lambda \\bx_{\\beta}\\bA_{\\alpha}]\\)\nis a wff\\(_{(\\alpha \\beta)}\\).\n\n\nNote, for example, that by (a) \\(\\nsim_{({o}{o})}\\) is a\nwff\\(_{({o}{o})}\\), so by (b) if \\(\\bA_{{o}}\\) is a wff\\(_{{o}}\\),\nthen \\([\\nsim_{({o}{o})}\\bA_{{o}}]\\) is a wff\\(_{{o}}\\). Usually, the\nlatter wff will simply be written as \\(\\nsim \\bA\\). It is often\nconvenient to avoid parentheses, brackets and type symbols, and use\nconventions for omitting them. For formulas we use the convention of\nassociation to the right, and we may write \\(\\lor_{((oo)o)}\\bA_{{o}}\n\\bB_{{o}}\\) instead of \\([[\\lor_{((oo)o)}\\bA_{{o}}] \\bB_{{o}}]\\). For\ntypes the corresponding convention is association to the left, and we\nmay write \\(ooo\\) instead of \\(((oo)o)\\).\nAbbreviations:\n\n\\(\\bA_{{o}} \\lor \\bB_{{o}}\\) stands for \\(\\lor_{ooo}\\bA_{{o}}\n\\bB_{{o}}\\).\n\\(\\bA_{{o}} \\supset \\bB_{{o}}\\) stands for\n\\([\\nsim_{{o}{o}}\\bA_{{o}}] \\lor \\bB_{{o}}\\).\n\\(\\forall \\bx_{\\alpha}\\bA_{{o}}\\) stands for\n\\(\\Pi_{{o}({o}\\alpha)} [\\lambda \\bx_{\\alpha}\\bA_{{o}}]\\).\nOther propositional connectives, and the existential quantifier,\nare defined in familiar ways. In particular, \n\n\\[\n    {\\bA_{{o}} \\equiv \\bB_{{o}} \\quad \n    \\text{stands for}  \\quad\n    [\\bA_{{o}} \\supset \\bB_{{o}}] \\land\n    [\\bB_{{o}} \\supset \\bA_{{o}}]}\n  \\]\n\n \n\\(\\sfQ_{{o}\\alpha \\alpha}\\) stands for \\(\\lambda\n\\)x\\(_{\\alpha}\\lambda \\)y\\(_{\\alpha}\\forall\nf_{{o}\\alpha}{[}f_{{o}\\alpha} x_{\\alpha} \\supset\nf_{{o}\\alpha}y_{\\alpha}{]}\\).\n\\(\\bA_{\\alpha} = \\bB_{\\alpha}\\) stands for \\(\\sfQ_{{o}\\alpha\n\\alpha}\\bA_{\\alpha}\\bB_{\\alpha}\\).\n\n\nThe last definition is known as the Leibnizian definition of equality.\nIt asserts that x and y are the same if y has\nevery property that x has. Actually, Leibniz called his\ndefinition \u201cthe identity of indiscernibles\u201d and gave it in\nthe form of a biconditional: x and y are the same if\nx and y have exactly the same properties. It is not\ndifficult to show that these two forms of the definition are logically\nequivalent.\n1.2.2 Examples\n\nWe now provide a few examples to illustrate how various assertions and\nconcepts can be expressed in Church\u2019s type theory.\n\n Example 1 To express the assertion that\n\u201cNapoleon is charismatic\u201d we introduce constants\n\\(\\const{Charismatic}_{{o}\\imath}\\) and \\(\\const{Napoleon}_{\\imath}\\),\nwith the types indicated by their subscripts and the obvious meanings,\nand assert the wff  \n\n\\[\\const{Charismatic}_{{o}\\imath} \\const{Napoleon}_{\\imath}\\]\n\n\nIf we wish to express the assertion that\n\u201cNapoleon has all the properties of a great\ngeneral\u201d, we might consider interpreting this to mean that\n\u201cNapoleon has all the properties of some great\ngeneral\u201d, but it seems more appropriate to interpret this\nstatement as meaning that \u201cNapoleon has all the properties\nwhich all great generals have\u201d. If the constant\n\\(\\const{GreatGeneral}_{{o}\\imath}\\) is added to the formal language,\nthis can be expressed by the wff  \n\n\\[\\forall p_{{o}\\imath}[\\forall\n  g_{\\imath}{[}\\const{GreatGeneral}_{{o}\\imath}g_{\\imath} \\supset\n  p_{{o}\\imath}g_{\\imath}] \\supset p_{{o}\\imath}\n  \\const{Napoleon}_{\\imath}]\\]\n\n\nAs an example of such a property, we note that the sentence\n\u201cNapoleon\u2019s soldiers admire him\u201d can be\nexpressed in a similar way by the wff \n\n\\[\\forall\n x_{\\imath}{[}\\const{Soldier}_{{o}\\imath}x_{\\imath} \\land\n \\const{CommanderOf}_{\\imath\\imath}x_{\\imath} =\n \\const{Napoleon}_{\\imath} \\supset \\const{Admires}_{{o}\\imath\\imath}x_{\\imath}\\const{Napoleon}_{\\imath}]\\]\n\n\nBy \u03bb-conversion, this is equivalent to \n\n\\[[\\lambda n_{\\imath}\\forall\n x_{\\imath}{[}\\const{Soldier}_{{o}\\imath}x_{\\imath} \\land\n \\const{CommanderOf}_{\\imath\\imath}x_{\\imath} = n_{\\imath} \\supset\n \\const{Admires}_{{o}\\imath\\imath}x_{\\imath}n_{\\imath}]]\\, \n \\const{Napoleon}_{\\imath}\\]\n\n\nThis statement asserts that one of the properties which Napoleon has\nis that of being admired by his soldiers. The property itself is\nexpressed by the wff  \n\n\\[\\lambda n_{\\imath}\\forall\nx_{\\imath}{[}\\const{Soldier}_{{o}\\imath}x_{\\imath} \\land\n\\const{CommanderOf}_{\\imath\\imath}x_{\\imath} = n_{\\imath} \\supset\n\\const{Admires}_{{o}\\imath\\imath}x_{\\imath}n_{\\imath}]\\]\n\n\nExample 2 We illustrate some potential applications\nof type theory with the following fable.\n\n\nA rich and somewhat eccentric lady named Sheila has an ostrich and a\ncheetah as pets, and she wishes to take them from her hotel to her\nremote and almost inaccessible farm. Various portions of the trip may\ninvolve using elevators, boxcars, airplanes, trucks, very small boats,\ndonkey carts, suspension bridges, etc., and she and the pets will not\nalways be together. She knows that she must not permit the ostrich and\nthe cheetah to be together when she is not with them.\n\n\nWe consider how certain aspects of this problem can be formalized so\nthat Sheila can use an automated reasoning system to help analyze the\npossibilities.\n\nThere will be a set Moments of instants or intervals of time\nduring the trip. She will start the trip at the location\n\\(\\const{Hotel}\\) and moment \\(\\const{Start}\\), and end it at the\nlocation \\(\\const{Farm}\\) and moment \\(\\const{Finish}\\). Moments will\nhave type \\(\\tau\\), and locations will have type \\(\\varrho\\). A\nstate will have type \\(\\sigma\\) and will specify the location\nof Sheila, the ostrich, and the cheetah at a given moment. A\nplan will specify where the entities will be at each moment\naccording to this plan. It will be a function from moments to states,\nand will have type \\((\\sigma \\tau)\\). The exact representation of\nstates need not concern us, but there will be functions from states to\nlocations called \\(\\const{LocationOfSheila}\\),\n\\(\\const{LocationOfOstrich}\\), and \\(\\const{LocationOfCheetah}\\) which\nprovide the indicated information. Thus,\n\\(\\const{LocationOfSheila}_{\\varrho \\sigma}[p_{\\sigma \\tau}t_{\\tau}]\\)\nwill be the location of Sheila according to plan \\(p_{\\sigma \\tau}\\)\nat moment \\(t_{\\tau}\\). The set \\(\\const{Proposals}_{{o}(\\sigma\n\\tau)}\\) is the set of plans Sheila is considering.\n\nWe define a plan p to be acceptable if, according to that plan,\nthe group starts at the hotel, finishes at the farm, and whenever the\nostrich and the cheetah are together, Sheila is there too. Formally,\nwe define \\(\\const{Acceptable}_{{o}(\\sigma \\tau)}\\) as \n\n\\[\\begin{multline}\n    \\lambda p_{\\sigma \\tau} \n\\left[\n\\begin{aligned}\n& \\const{LocationOfSheila}_{\\varrho \\sigma} [p_{\\sigma \\tau}\\const{Start}_{\\tau}] = \\const{Hotel}_{\\varrho}    \\,\\land\\\\ \n&  \\const{LocationOfOstrich}_{\\varrho \\sigma}[p_{\\sigma \\tau} \\const{Start}_{\\tau}] = \\const{Hotel}_{\\varrho}  \\,\\land\\\\ \n&  \\const{LocationOfCheetah}_{\\varrho \\sigma}[p_{\\sigma \\tau} \\const{Start}_{\\tau}] =  \\const{Hotel}_{\\varrho} \\,\\land\\\\\n&  \\const{LocationOfSheila}_{\\varrho \\sigma}[p_{\\sigma \\tau} \\const{Finish}_{\\tau}] = \\const{Farm}_{\\varrho}   \\,\\land\\\\\n&  \\const{LocationOfOstrich}_{\\varrho \\sigma}[p_{\\sigma \\tau} \\const{Finish}_{\\tau}] = \\const{Farm}_{\\varrho}  \\,\\land\\\\\n&  \\const{LocationOfCheetah}_{\\varrho \\sigma}[p_{\\sigma \\tau} \\const{Finish}_{\\tau}] = \\const{Farm}_{\\varrho}  \\,\\land\\\\\n&  \\forall t_{\\tau}  \n  \\left [\n\\begin{split}\n& \\const{Moments}_{{o}\\tau}t_{\\tau} \\\\\n& \\supset\n       \\left [\n    \\begin{split}\n&             \\left[\n\\begin{split}\n& \\const{LocationOfOstrich}_{\\varrho \\sigma}[p_{\\sigma \\tau}t_{\\tau}] \\\\\n& = \\const{LocationOfCheetah}_{\\varrho \\sigma}[p_{\\sigma \\tau}t_{\\tau}]\n\\end{split}\n\\right] \\\\ \n& \\supset \n                 \\left[\n\\begin{split}\n& \\const{LocationOfSheila}_{\\varrho \\sigma}[p_{\\sigma \\tau}t_{\\tau}] \\\\\n&  = \\const{LocationOfCheetah}_{\\varrho\\sigma}[p_{\\sigma\\tau}t_{\\tau}]\n\\end{split}\n      \\right] \n\\end{split}\n    \\right]\n\\end{split}\n  \\right]\n\\end{aligned}\n\\right]\n\\end{multline}\\]\n\n\nWe can express the assertion that Sheila has a way to accomplish her\nobjective with the formula \n\n\\[\\exists p_{\\sigma\n    \\tau}[\\const{Proposals}_{{o}(\\sigma \\tau)}p_{\\sigma \\tau}\n  \\land \\const{Acceptable}_{{o}(\\sigma \\tau)}p_{\\sigma \\tau}]\\]\n\n\nExample 3 We now provide a mathematical example.\nMathematical ideas can be expressed in type theory without introducing\nany new constants. An iterate of a function f from a\nset to itself is a function which applies f one or more times.\nFor example, if \\(g(x) = f(f(f(x)))\\), then g is an iterate of\nf.\n\\([\\text{ITERATE+}_{{o}(\\imath\\imath)(\\imath\\imath)}f_{\\imath\\imath}g_{\\imath\\imath}]\\)\nmeans that \\(g_{\\imath\\imath}\\) is an iterate of \\(f_{\\imath\\imath}\\).\n\\(\\text{ITERATE+}_{{o}(\\imath\\imath)(\\imath\\imath)}\\) is defined\n(inductively) as  \n\n\\[\n\\lambda f_{\\imath\\imath}\\lambda g_{\\imath\\imath}\\forall\n  p_{{o}(\\imath\\imath)}\n\\left [p_{{o}(\\imath\\imath)}f_{\\imath\\imath}   \\land \\forall j_{\\imath\\imath}\n\\left [p_{{o}(\\imath\\imath)}j_{\\imath\\imath} \\supset   p_{{o}(\\imath\\imath)}\n\\left [\\lambda  x_{\\imath}f_{\\imath\\imath}\n\\left [j_{\\imath\\imath}x_{\\imath}\n\\right]\n\\right]\n\\right] \\supset  p_{{o}(\\imath\\imath)}g_{\\imath\\imath}\n\\right]\n\\]\n\n\nThus, g is an iterate of f if g is in every set\np of functions which contains f and which contains the\nfunction \\(\\lambda\nx_{\\imath}f_{\\imath\\imath}[j_{\\imath\\imath}x_{\\imath}]\\) (i.e.,\nf composed with j) whenever it contains j.\n\nA fixed point of f is an element y such that\n\\(f(y) = y\\).\n\nIt can be proved that if some iterate of a function f has a\nunique fixed point, then f itself has a fixed point. This\ntheorem can be expressed by the wff  \n\n\\[\\begin{aligned}\n    \\forall f_{\\imath\\imath}  \n\\left [\n\\begin{split}\n\\exists g_{\\imath\\imath}                     \n& \\left [\n\\begin{split}\n&\\text{ITERATE+}_{{o}(\\imath\\imath)(\\imath\\imath)}   f_{\\imath\\imath} g_{\\imath\\imath} \\\\\n&{} \\land  \n                              \\exists x_{\\imath} \n\\left [\n\\begin{split}\n& g_{\\imath\\imath}x_{\\imath} = x_{\\imath} \\\\\n&{}  \\land \\forall z_{\\imath} \n\\left [g_{\\imath\\imath} z_{\\imath} =\n                               z_{\\imath}\n                               \\supset z_{\\imath} = x_{\\imath}\n\\right] \n\\end{split}\n\\right] \n\\end{split}\n\\right]\\\\\n& \\supset { }\n                             \\exists y_{\\imath}\n[f_{\\imath\\imath}y_{\\imath} = y_{\\imath}]\n\\end{split}\n\\right].\n  \\end{aligned}\\]\n\n\nSee Andrews et al. 1996, for a discussion of how this theorem, which\nis called THM15B, can be proved automatically.\n\nExample 4 An example from philosophy is\nG\u00f6del\u2019s variant of the ontological argument for the\nexistence of God. This example illustrates two interesting\naspects:\n\n\n\nChurch\u2019s type theory can be employed as a meta-logic to\nconcisely embed expressive other logics such as the higher-order modal\nlogic assumed by G\u00f6del. By exploiting the possible world\nsemantics of this target logic, its syntactic elements are defined in\nsuch a way that the infrastructure of the meta-logic are reused as\nmuch as possible. In this technique, called shallow semantical\nembedding, the modal operator \\(\\Box\\), for example, is simply\nidentified with (taken as syntactic sugar for) the \u03bb-formula\n \n\n\\[\\lambda \\varphi_{{o}\\imath} \\lambda w_{\\imath} \\forall v_{\\imath} [R_{{o}\\imath\\imath} w_{\\imath} v_{\\imath} \\supset \\varphi_{{o}\\imath} v_{\\imath}]\\]\n\n\nwhere \\(R_{{o}\\imath\\imath}\\) denotes the accessibility relation\nassociated with \\(\\Box\\) and type \\({\\imath}\\) is identified with\npossible worlds. Moreover, since \\(\\forall x_{\\alpha} [\\bA_{{o}\\alpha}\nx_{\\alpha}]\\) is shorthand in Church\u2019s type theory for\n\\(\\Pi_{{o}({o}\\alpha)} [\\lambda x_{\\alpha} [\\bA_{{o}\\alpha}\nx_{\\alpha}]]\\), the modal formula  \n\n\\[\\Box \\forall x \\bP x\\]\n\n\nis represented as  \n\n\\[\\Box \\Pi' [\\lambda x_{\\alpha} \\lambda w_{\\imath} [\\bP_{{o}\\imath\\alpha} x_{\\alpha} w_{\\imath}]]\\]\n\n\nwhere \\(\\Pi'\\) stands for the \u03bb-term  \n\n\\[\\lambda \\Phi_{{o}\\imath\\alpha} \\lambda w_{\\imath} \\forall x_{\\alpha} [\\Phi_{{o}\\imath\\alpha} x_{\\alpha} w_{\\imath}]\\]\n\n\nand the \\(\\Box\\) gets resolved as described above. The above choice of\n\\(\\Pi'\\) realizes a possibilist notion of quantification. By\nintroducing a binary \u201cexistence\u201d predicate in the\nmeta-logic and by utilizing this predicate as an additional guard in\nthe definition of \\(\\Pi'\\) an actualist notion of quantification\ncan be obtained. Expressing that an embedded modal formula\n\\(\\varphi_{{o}\\imath}\\) is globally valid is then captured by the\nformula \\(\\forall x_{\\imath} [\\varphi_{{o}\\imath} x_{\\imath}]\\). Local\nvalidity (and also actuality) can be modeled as \\(\\varphi_{{o}\\imath}\nn_{\\imath}\\), where \\(n_{\\imath}\\) is a nominal (constant symbol in\nthe meta-logic) denoting a particular possible world.\n\n\nThe above technique can be exploited for a natural encoding and\nautomated assessment of G\u00f6del\u2019s ontological argument in\nhigher-order modal logic, which unfolds into formulas in\nChurch\u2019s type theory such that higher-order theorem provers can\nbe applied. Further details are presented in Section 6 (Logic and\nPhilosophy) of the SEP entry on\n automated reasoning\n and also in\n Section 5.2;\n moreover, see Benzm\u00fcller & Woltzenlogel-Paleo 2014 and\nBenzm\u00fcller 2019.\n\n\nExample 5 Suppose we omit the use of type symbols in\nthe definitions of wffs. Then we can write the formula \\(\\lambda\nx\\nsim[xx]\\), which we shall call \\(\\textrm{R}\\). It can be regarded as\ndenoting the set of all sets x such that x is not in\nx. We may then consider the formula \\([\\textrm{R R}]\\), which\nexpresses the assertion that \\(\\textrm{R}\\) is in itself. We can clearly\nprove \\([\\textrm{R R}] \\equiv [[\\lambda x\\nsim [xx]] \\textrm{R}]\\), so by\n\u03bb-conversion we can derive \\([\\textrm{R R}] \\equiv\\,\n\\nsim[\\textrm{R R}]\\), which is a contradiction. This is\nRussell\u2019s paradox. Russell\u2019s discovery of this paradox\n(Russell 1903, 101-107) played a crucial role in the development of\ntype theory. Of course, when type symbols are present, \\(\\textrm{R}\\) is not\nwell-formed, and the contradiction cannot be derived.\n1.3 Axioms and Rules of Inference\n1.3.1 Rules of Inference\n\nAlphabetic Change of Bound Variables\n\\((\\alpha\\)-conversion). To replace any well-formed part\n\\(\\lambda \\bx_{\\beta}\\bA_{\\alpha}\\) of a wff by \\(\\lambda \\by_{\\beta}\n\\textsf{Sub}(\\by_{\\beta},\\bx_{\\beta},\\bA_{\\alpha})\\), provided that\n\\(\\by_{\\beta}\\) does not occur in \\(\\bA_{\\alpha}\\) and \\(\\bx_{\\beta}\\)\nis not bound in \\(\\bA_{\\alpha}\\).\n\u03b2-contraction. To replace any well-formed part\n\\([\\lambda \\bx_{\\alpha}\\bB_{\\beta}] \\bA_{\\alpha}\\) of a wff by\n\\(\\textsf{Sub}(\\bA_{\\alpha},\\bx_{\\alpha},\\bB_{\\beta})\\), provided that\nthe bound variables of \\(\\bB_{\\beta}\\) are distinct both from\n\\(\\bx_{\\alpha}\\) and from the free variables of \\(\\bA_{\\alpha}\\).\n\u03b2-expansion. To infer \\(\\bC\\) from \\(\\bD\\) if\n\\(\\bD\\) can be inferred from \\(\\bC\\) by a single application of\n\u03b2-contraction.\nSubstitution. From \\(\\bF_{({o}\\alpha)}\\bx_{\\alpha}\\), to\ninfer \\(\\bF_{({o}\\alpha)}\\bA_{\\alpha}\\), provided that\n\\(\\bx_{\\alpha}\\) is not a free variable of \\(\\bF_{({o}\\alpha)}\\).\nModus Ponens. From \\([\\bA_{{o}} \\supset \\bB_{{o}}]\\) and\n\\(\\bA_{{o}}\\), to infer \\(\\bB_{{o}}\\).\nGeneralization. From \\(\\bF_{({o}\\alpha)}\\bx_{\\alpha}\\) to\ninfer \\(\\Pi_{{o}({o}\\alpha)}\\bF_{({o}\\alpha)}\\), provided that\n\\(\\bx_{\\alpha}\\) is not a free variable of \\(\\bF_{({o}\\alpha)}\\).\n\n1.3.2 Elementary Type Theory\n\nWe start by listing the axioms for what we shall call elementary\ntype theory.  \n\n\\[\\begin{align}\n     [p_{{o}} \\lor p_{{o}}] & \\supset          p_{{o}} \\tag{1}\\\\\n      p_{{o}} & \\supset [p_{{o}} \\lor q_{{o}}] \\tag{2}\\\\\n      [p_{{o}} \\lor q_{{o}}] & \\supset [q_{{o}} \\lor p_{{o}}] \\tag{3}\\\\\n      [p_{{o}} \\supset q_{{o}}] & \\supset [[r_{{o}} \\lor p_{{o}}] \\supset [r_{{o}} \\lor q_{{o}}]] \\tag{4}\\\\\n    \\Pi_{{o}({o}\\alpha)}f_{({o}\\alpha)} & \\supset f_{({o}\\alpha)}x_{\\alpha} \\tag{\\(5^{\\alpha}\\)} \\\\\n    \\forall x_{\\alpha}[p_{{o}} \\lor f_{({o}\\alpha)}x_{\\alpha}] & \\supset \\left[p_{{o}} \\lor \\Pi_{{o}({o}\\alpha)}f_{({o}\\alpha)}\\right]  \\tag{\\(6^{\\alpha}\\)}\n\\end{align}\\]\n\n\nThe theorems of elementary type theory are those theorems which can be\nderived, using the rules of inference, from Axioms\n(1)\u2013\\((6^{\\alpha})\\) (for all type symbols \\(\\alpha)\\). We shall\nsometimes refer to elementary type theory as \\(\\cT\\). It embodies the\nlogic of propositional connectives, quantifiers, and\n\u03bb-conversion in the context of type theory.\n\nTo illustrate the rules and axioms introduced above, we give a short\nand trivial proof in \\(\\cT\\). Following each wff of the proof, we\nindicate how it was inferred. (The proof is actually quite\ninefficient, since line 3 is not used later, and line 7 can be derived\ndirectly from line 5 without using line 6. The additional proof lines\nhave been inserted to illustrate some relevant aspects. For the sake\nof readability, many brackets have been deleted from the formulas in\nthis proof. The diligent reader should be able to restore them.) \n\n\\[\\begin{alignat}{2}\n    \\forall x_{\\imath}\\left[p_{{o}} \\lor f_{{o}\\imath}x_{\\imath}\\right]  \\supset\\left[p_{{o}} \\lor \\Pi_{{o}({o}\\imath)} f_{{o}\\imath}\\right]\n    && \\text{Axiom \\(6^{\\imath}\\)}  \\tag{1}\\\\\n%\n      \\bigg[\\lambda f_{{o}\\imath}\\bigg[\\forall x_{\\imath}[p_{{o}} \\lor  f_{{o}\\imath}x_{\\imath}]\n  \\supset \\bigg[p_{{o}} \\lor \\Pi_{{o}({o}\\imath)}f_{{o}\\imath}\\bigg]\\bigg]\\bigg] f_{{o}\\imath} \n&& \\text{\u03b2-expansion: 1} \\tag{2}\\\\\n%\n   \\Pi_{{o}({o}({o}\\imath))}\\bigg[\\lambda f_{{o}\\imath}\\bigg[\\forall x_{\\imath}[p_{{o}} \\lor f_{{o}\\imath}x_{\\imath}]  \\supset \\bigg[p_{{o}} \\lor \\Pi_{{o}({o}\\imath)}f_{{o}\\imath}\\bigg]\\bigg]\\bigg]\n    && \\text{Generalization: 2} \\tag{3}\\\\\n%\n    \\bigg[\\lambda f_{{o}\\imath}\\bigg[\\forall x_{\\imath}[p_{{o}}\\lor f_{{o}\\imath}x_{\\imath}]  \\supset \\bigg[p_{{o}} \\lor \\Pi_{{o}({o}\\imath)}f_{{o}\\imath}\\bigg]\\bigg]\\bigg] [\\lambda x_{\\imath}r_{{o}\\imath}x_{\\imath}]\n    && \\text{Substitution: 2} \\tag{4}\\\\\n%\n    \\forall x_{\\imath}[p_{{o}} \\lor [\\lambda x_{\\imath}r_{{o}\\imath}x_{\\imath}]x_{\\imath}]  \\supset \\left[p_{{o}} \\lor \\Pi_{{o}({o}\\imath)}\\left[\\lambda x_{\\imath}r_{{o}\\imath}x_{\\imath}\\right]\\right]\n    && \\text{\u03b2-contraction: 4} \\tag{5}\\\\\n%\n   \\forall x_{\\imath}[p_{{o}} \\lor [\\lambda y_{\\imath} r_{{o}\\imath} y_{\\imath}] x_{\\imath}]  \\supset \\left[p_{{o}} \\lor \\Pi_{{o}({o}\\imath)}\\left[\\lambda x_{\\imath}r_{{o}\\imath}x_{\\imath}\\right]\\right]\n    && \\text{\u03b1-conversion: 5} \\tag{6}\\\\\n%\n   \\forall x_{\\imath}\\left[p_{{o}} \\lor r_{{o}\\imath}x_{\\imath}\\right]  \\supset \\left[p_{{o}} \\lor \\Pi_{{o}({o}\\imath)}\\left[\\lambda x_{\\imath}r_{{o}\\imath}x_{\\imath}\\right]\\right]\n    && \\text{\u03b2-contraction: 6} \\tag{7}\n  \\end{alignat}\\]\n\n\nNote that (3) can be written as  \n\n\\[\n       \\forall f_{{o}\\imath} [\\forall x_{\\imath} [p_{{o}}\n             \\lor f_{{o}\\imath}x_{\\imath}] \\supset [p_{{o}} \\lor\n             [\\forall x_{\\imath} f_{{o}\\imath} x_{\\imath}]\n                          ]] \n\\tag{\\(3'\\)}\n\\]\n\n\nand (7) can be written as  \n\n\\[\n     \\forall x_{\\imath}[p_{{o}} \\lor r_{{o}\\imath}x_{\\imath}] \\supset [p_{{o}} \\lor \\forall\n      x_{\\imath}r_{{o}\\imath}x_{\\imath}]  \\tag{\\(7'\\)}\n\\]\n\n\nWe have thus derived a well known law of quantification theory. We\nillustrate one possible interpretation of the wff \\((7')\\) (which\nis closely related to Axiom 6) by considering a situation in which a\nrancher puts some horses in a corral and leaves for the night. Later,\nhe cannot remember whether he closed the gate to the corral. While\nreflecting on the situation, he comes to a conclusion which can be\nexpressed by \\((7')\\) if we take the horses to be the elements of\ntype \\(\\imath\\), interpret \\(p_{{o}}\\) to mean \u201cthe gate was\nclosed\u201d, and interpret \\(r_{{o}\\imath}\\) so that\n\\(r_{{o}\\imath}x_{\\imath}\\) asserts \u201c\\(x_{\\imath}\\) left the\ncorral\u201d. With this interpretation, \\((7')\\) says \n\n\nIf it is true of every horse that the gate was closed or that the\nhorse left the corral, then the gate was closed or every horse left\nthe corral.\n\n\nTo the axioms listed above we add the axioms below to obtain\nChurch\u2019s type theory.\n1.3.3 Axioms of Extensionality\n\nThe axioms of boolean and functional extensionality are the following:\n \n\n\\[\\begin{align}\n                        [x_{{o}} \\equiv y_{{o}}] & \\supset                  x_{{o}} = y_{{o}}  \\tag{\\(7^{o}\\)} \\\\\n    \\forall x_{\\beta}[f_{\\alpha \\beta}x_{\\beta} = g_{\\alpha \\beta}x_{\\beta}] & \\supset f_{\\alpha \\beta} = g_{\\alpha \\beta}\\tag{\\(7^{\\alpha \\beta}\\)}\n\\end{align}\\]\n\n\nChurch did not include Axiom \\(7^{{o}}\\) in his list of axioms in\nChurch 1940, but he mentioned the possibility of including it. Henkin\ndid include it in Henkin 1950.\n1.3.4 Descriptions\n\nThe expression  \n\n\\[\\exists_1\\bx_{\\alpha}\\bA_{{o}}\\]\n\n\nstands for  \n\n\\[[\\lambda p_{{o}\\alpha}\\exists y_{\\alpha}[p_{{o}\\alpha}y_{\\alpha} \\land \\forall z_{\\alpha}[p_{{o}\\alpha}z_{\\alpha} \\supset z_{\\alpha} = y_{\\alpha}]]]\\, [\\lambda\n\\bx_{\\alpha}\\bA_{{o}}]\\]\n\n\nFor example,  \n\n\\[\\exists_1 x_{\\alpha}P_{{o}\\alpha}x_{\\alpha}\\]\n\n\nstands for  \n\n\\[[\\lambda p_{{o}\\alpha}\\exists y_{\\alpha}[p_{{o}\\alpha}y_{\\alpha} \\land \\forall z_{\\alpha}[p_{{o}\\alpha}z_{\\alpha} \\supset z_{\\alpha} = y_{\\alpha}]]]\\, [\\lambda\nx_{\\alpha}P_{{o}\\alpha}x_{\\alpha}]\\]\n\n\nBy \u03bb-conversion, this is equivalent to  \n\n\\[\\exists y_{\\alpha}[[\\lambda x_{\\alpha}P_{{o}\\alpha}x_{\\alpha}]y_{\\alpha} \\land \\forall z_{\\alpha}[[\\lambda\nx_{\\alpha}P_{{o}\\alpha}x_{\\alpha}] z_{\\alpha} \\supset z_{\\alpha}\n= y_{\\alpha}]]\\]\n\n\nwhich reduces by \u03bb-conversion to  \n\n\\[\\exists y_{\\alpha}[P_{{o}\\alpha}y_{\\alpha} \\land \\forall\nz_{\\alpha}[P_{{o}\\alpha}z_{\\alpha} \\supset z_{\\alpha} =\ny_{\\alpha}]]\\]\n\n\nThis asserts that there is a unique element which has the property\n\\(P_{{o}\\alpha}\\). From this example we can see that in general,\n\\(\\exists_1\\bx_{\\alpha}\\bA_{{o}}\\) expresses the assertion that\n\u201cthere is a unique \\(\\bx_{\\alpha}\\) such that\n\\(\\bA_{{o}}\\)\u201d.\n\nWhen there is a unique such element \\(\\bx_{\\alpha}\\), it is convenient\nto have the notation \\(\\atoi\\bx_{\\alpha}\\bA_{{o}}\\) to represent the\nexpression \u201cthe \\(\\bx_{\\alpha}\\) such that \\(\\bA_{{o}}\\)\u201d.\nRussell showed in Whitehead & Russell 1927b how to provide\ncontextual definitions for such notations in his formulation of type\ntheory. In Church\u2019s type theory \\(\\atoi\\bx_{\\alpha}\\bA_{{o}}\\)\nis defined as \\(\\iota_{\\alpha({o}\\alpha)}[\\lambda\n\\bx_{\\alpha}\\bA_{{o}}]\\). Thus, \\(\\atoi\\) behaves like a\nvariable-binding operator, but it is defined in terms of \u03bb with\nthe aid of the constant \\(\\iota_{\\alpha({o}\\alpha)}\\). Thus, \u03bb\nis still the only variable-binding operator that is needed.\n\nSince \\(\\bA_{{o}}\\) describes \\(\\bx_{\\alpha},\n\\iota_{\\alpha({o}\\alpha)}\\) is called a description operator.\nAssociated with this notation is the following:\nAxiom of Descriptions: \n\n\\[\n   \\exists_1 x_{\\alpha}[p_{{o}\\alpha}x_{\\alpha}]\n                   \\supset p_{{o}\\alpha} [\\iota_{\\alpha({o}\\alpha)}p_{{o}\\alpha}] \\tag{\\(8^{\\alpha}\\)}\n\n\\]\n\n\nThis says that when the set \\(p_{{o}\\alpha}\\) has a unique member,\nthen \\(\\iota_{\\alpha({o}\\alpha)}p_{{o}\\alpha}\\) is in\n\\(p_{{o}\\alpha}\\), and therefore is that unique member. Thus, this\naxiom asserts that \\(\\iota_{\\alpha({o}\\alpha)}\\) maps one-element sets\nto their unique members.\n\nIf from certain hypotheses one can prove  \n\n\\[\\exists_1\\bx_{\\alpha}\\bA_{{o}}\\]\n\n\nthen by using Axiom \\(8^{\\alpha}\\) one can derive  \n\n\\[[\\lambda\n  \\bx_{\\alpha}\\bA_{{o}}] [\\iota_{\\alpha({o}\\alpha)}[\\lambda \\bx_{\\alpha}\\bA_{{o}}]]\\]\n\n\nwhich can also be written as  \n\n\\[[\\lambda\n\\bx_{\\alpha}\\bA_{{o}}]\n{[\\atoi\\bx_{\\alpha}\\bA_{{o}}]}\\]\n\n\nWe illustrate the usefulness of the description operator with a small\nexample. Suppose we have formalized the theory of real numbers, and\nour theory has constants \\(1_{\\varrho}\\) and \\(\\times_{\\varrho \\varrho\n\\varrho}\\) to represent the number 1 and the multiplication function,\nrespectively. (Here \\(\\varrho\\) is the type of real numbers.) To\nrepresent the multiplicative inverse function, we can define the wff\n\\(\\textrm{INV}_{\\varrho \\varrho}\\) as  \n\n\\[{\\lambda z_{\\varrho} \\atoi x_{\\varrho} [\\times_{\\varrho \\varrho\n     \\varrho}z_{\\varrho}x_{\\varrho} = 1_{\\varrho}]}\\]\n\n\nOf course, in traditional mathematical notation we would not write the\ntype symbols, and we would write \\(\\times_{\\varrho \\varrho\n\\varrho}z_{\\varrho}x_{\\varrho}\\) as \\(z \\times x\\) and write\n\\(\\textrm{INV}_{\\varrho \\varrho}z\\) as \\(z^{-1}\\). Thus \\(z^{-1}\\) is\ndefined to be that x such that \\(z \\times x = 1\\). When\nZ is provably not 0, we will be able to prove \\(\\exists_1\nx_{\\varrho}[\\times_{\\varrho \\varrho \\varrho} \\textrm{Z x}_{\\varrho} =\n1_{\\varrho}]\\) and \\(Z \\times Z^{-1} = 1\\), but if we cannot establish\nthat Z is not 0, nothing significant about \\(Z^{-1}\\) will be\nprovable.\n1.3.5 Axiom of Choice\n\nThe Axiom of Choice can be expressed as follows in Church\u2019s type\ntheory:  \n\n\\[\n    \\exists x_{\\alpha}p_{{o}\\alpha}x_{\\alpha}\n                   \\supset p_{{o}\\alpha}[\\iota_{\\alpha({o}\\alpha)}p_{{o}\\alpha}] \\tag{\\(9^{\\alpha}\\)}\n\\]\n\n\n\\((9^{\\alpha})\\) says that the choice function\n\\(\\iota_{\\alpha({o}\\alpha)}\\) chooses from every nonempty set\n\\(p_{{o}\\alpha}\\) an element, designated as\n\\(\\iota_{\\alpha({o}\\alpha)}p_{{o}\\alpha}\\), of that set. When this\nform of the Axiom of Choice is included in the list of axioms,\n\\(\\iota_{\\alpha({o}\\alpha)}\\) is called a selection operator instead\nof a description operator, and \\(\\atoi\\bx_{\\alpha} \\bA_{{o}}\\) means\n\u201can \\(\\bx_{\\alpha}\\) such that \\(\\bA_{{o}}\\)\u201d when there\nis some such element \\(\\bx_{\\alpha}\\). These selection operators have\nthe same meaning as Hilbert\u2019s \\(\\epsilon\\)-operator (Hilbert\n1928). However, we here provide one such operator for each type\n\u03b1.\n\nIt is natural to call \\(\\atoi\\) a definite description operator in\ncontexts where \\(\\atoi\\bx_{\\alpha}\\bA_{{o}}\\) means \u201cthe\n\\(\\bx_{\\alpha}\\) such that \\(\\bA_{{o}}\\)\u201d, and to call it an\nindefinite description operator in contexts where\n\\(\\atoi\\bx_{\\alpha}\\bA_{{o}}\\) means \u201can \\(\\bx_{\\alpha}\\) such\nthat \\(\\bA_{{o}}\\)\u201d.\n\nClearly the Axiom of Choice implies the Axiom of Descriptions, but\nsometimes formulations of type theory are used which include the Axiom\nof Descriptions, but not the Axiom of Choice.\n\nAnother formulation of the Axiom of Choice simply asserts the\nexistence of a choice function without explicitly naming it: \n\n\\[\n     \\exists j_{\\alpha ({o}\\alpha)}\\forall\n                           p_{{o}\\alpha}[\\exists x_{\\alpha}p_{{o}\\alpha}x_{\\alpha} \\supset p_{{o}\\alpha}[j_{\\alpha({o}\\alpha)}p_{{o}\\alpha}]]\n\\tag{\\(\\text{AC}^{\\alpha}\\)}\n\\]\n\n\nNormally when one assumes the Axiom of Choice in type theory, one\nassumes it as an axiom schema, and asserts AC\\(^{\\alpha}\\) for each\ntype symbol \u03b1. A similar remark applies to the axioms for\nextensionality and description. However, modern proof systems for\nChurch\u2019s type theory, which are, e.g., based on resolution, do\nin fact avoid the addition of such axiom schemata for reasons as\nfurther explained in\n Sections 3.4\n and\n 4\n below. They work with more constrained, goal-directed proof rules\ninstead.\n\nBefore proceeding, we need to introduce some terminology. \\(\\cQ_0\\) is\nan alternative formulation of Church\u2019s type theory which will be\ndescribed in\n Section 1.4\n and is equivalent to the system described above using Axioms\n(1)\u2013(8). A type symbol is propositional if the only symbols\nwhich occur in it are \\({o}\\) and parentheses.\n\nYasuhara (1975) defined the relation \u201c\\(\\ge\\)\u201d between\ntypes as the reflexive transitive closure of the minimal relation such\nthat \\((\\alpha \\beta) \\ge \\alpha\\) and \\((\\alpha \\beta) \\ge \\beta\\).\nHe established that:\n\nIf \\(\\alpha \\ge \\beta\\), then \\(\\cQ_0 \\vdash\\) AC\\(^{\\alpha}\n\\supset\\) AC\\(^{\\beta}\\).\nGiven a set S of types, none of which is propositional,\nthere is a model of \\(\\cQ_0\\) in which AC\\(^{\\alpha}\\) fails if and\nonly if \\(\\alpha \\ge \\beta\\) for some \u03b2 in S.\n\n\nThe existence of a choice functions for \u201chigher\u201d types\nthus entails the existence of choice functions for \u201clower\u201d\ntypes, the opposite is generally not the case though.\n\nB\u00fcchi (1953) has shown that while the schemas expressing the\nAxiom of Choice and Zorn\u2019s Lemma can be derived from each other,\nthe relationships between the particular types involved are\ncomplex.\n1.3.6 Axioms of Infinity\n\nOne can define the natural numbers (and therefore other basic\nmathematical structures such as the real and complex numbers) in type\ntheory, but to prove that they have the required properties (such as\nPeano\u2019s Postulates), one needs an Axiom of Infinity. There are\nmany viable possibilities for such an axiom, such as those discussed\nin Church 1940, section 57 of Church 1956, and section 60 of Andrews\n2002.\n1.4 A Formulation Based on Equality\n\nIn\n Section 1.2.1,\n \\(\\nsim_{({o}{o})}, \\lor_{(({o}{o}){o})}\\), and the\n\\(\\Pi_{({o}({o}\\alpha))}\\)\u2019s were taken as primitive\nconstants, and the wffs \\(\\sfQ_{{o}\\alpha \\alpha}\\) which denote\nequality relations at type \u03b1 were defined in terms of these. We\nnow present an alternative formulation \\(\\cQ_0\\) of Church\u2019s\ntype theory in which there are primitive constants \\(\\sfQ_{{o}\\alpha\n\\alpha}\\) denoting equality, and \\(\\nsim_{({o}{o})},\n\\lor_{(({o}{o}){o})}\\), and the \\(\\Pi_{({o}({o}\\alpha))}\\)\u2019s\nare defined in terms of the \\(\\sfQ_{{o}\\alpha \\alpha}\\)\u2019s.\n\nTarski (1923) noted that in the context of higher-order logic, one can\ndefine propositional connectives in terms of logical equivalence and\nquantifiers. Quine (1956) showed how both quantifiers and connectives\ncan be defined in terms of equality and the abstraction operator\n\u03bb in the context of Church\u2019s type theory. Henkin (1963)\nrediscovered these definitions, and developed a formulation of\nChurch\u2019s type theory based on equality in which he restricted\nattention to propositional types. Andrews (1963) simplified the axioms\nfor this system.\n\n\\(\\cQ_0\\) is based on these ideas, and can be shown to be equivalent\nto a formulation of Church\u2019s type theory using Axioms\n(1)\u2013(8) of the preceding sections. This section thus provides an\nalternative to the material in the preceding Sections\n1.2.1\u20131.3.4. More details about \\(\\cQ_0\\) can be found in\nAndrews 2002.\n1.4.1 Definitions\n\nType symbols, improper symbols, and variables of \\(\\cQ_0\\) are\ndefined as in\n Section 1.2.1.\nThe logical constants of \\(\\cQ_0\\) are\n\\(\\sfQ_{(({o}\\alpha)\\alpha)}\\) and \\(\\iota_{(\\imath({o}\\imath))}\\)\n(for each type symbol \u03b1).\nWffs of \\(\\cQ_0\\) are defined as in\n Section 1.2.1.\n\nAbbreviations:\n\n\\(\\bA_{\\alpha} = \\bB_{\\alpha}\\) stands for \\(\\sfQ_{{o}\\alpha\n\\alpha}\\bA_{\\alpha}\\bB_{\\alpha}\\)\n\\(\\bA_{{o}} \\equiv \\bB_{{o}}\\) stands for\n\\(\\sfQ_{{o}{o}{o}}\\)A\\(_{{o}}\\)B\\(_{{o}}\\)\n\\(T_{{o}}\\) stands for \\(\\sfQ_{{o}{o}{o}} =\n\\sfQ_{{o}{o}{o}}\\)\n\\(F_{{o}}\\) stands for \\([\\lambda x_{{o}}T_{{o}}] = [\\lambda\nx_{{o}}x_{{o}}]\\)\n\\(\\Pi_{{o}({o}\\alpha)}\\) stands for\n\\(\\sfQ_{{o}({o}\\alpha)({o}\\alpha)}[\\lambda x_{\\alpha}T_{{o}}]\\)\n\\(\\forall \\bx_{\\alpha}\\bA\\) stands for\n\\(\\Pi_{{o}({o}\\alpha)}[\\lambda \\bx_{\\alpha}\\bA]\\)\n\\(\\land_{{o}{o}{o}}\\) stands for \\(\\lambda x_{{o}}\\lambda\ny_{{o}}[[\\lambda g_{{o}{o}{o}}[g_{{o}{o}{o}}T_{{o}}T_{{o}}]] =\n[\\lambda g_{{o}{o}{o}}[g_{{o}{o}{o}}x_{{o}}y_{{o}}]]]\\)\n\\(\\bA_{{o}} \\land \\bB_{{o}}\\) stands for \\(\\land_{{o}{o}{o}}\n\\bA_{{o}} \\bB_{{o}}\\)\n\\(\\nsim_{{o}{o}}\\) stands for \\(\\sfQ_{{o}{o}{o}}F_{{o}}\\)\n\n\n\\(T_{{o}}\\) denotes truth. The meaning of \\(\\Pi_{{o}({o}\\alpha)}\\)\nwas discussed in\n Section 1.1.\n To see that this definition of \\(\\Pi_{{o}({o}\\alpha)}\\) is\nappropriate, note that \\(\\lambda x_{\\alpha}T\\) denotes the set of all\nelements of type \u03b1, and that\n\\(\\Pi_{{o}({o}\\alpha)}s_{{o}\\alpha}\\) stands for\n\\(\\sfQ_{{o}({o}\\alpha)({o}\\alpha)}[\\lambda x_{\\alpha}T]\ns_{{o}\\alpha}\\), respectively for \\([\\lambda x_{\\alpha}T] =\ns_{{o}\\alpha}\\). Therefore \\(\\Pi_{{o}({o}\\alpha)}s_{{o}\\alpha}\\)\nasserts that \\(s_{{o}\\alpha}\\) is the set of all elements of type\n\u03b1, so \\(s_{{o}\\alpha}\\) contains all elements of type \u03b1.\nIt can be seen that \\(F_{{o}}\\) can also be written as \\(\\forall\nx_{{o}}x_{{o}}\\), which asserts that everything is true. This is\nfalse, so \\(F_{{o}}\\) denotes falsehood. The expression \\(\\lambda\ng_{{o}{o}{o}}[g_{{o}{o}{o}}x_{{o}}y_{{o}}]\\) can be used to represent\nthe ordered pair \\(\\langle x_{{o}},y_{{o}}\\rangle\\), and the\nconjunction \\(x_{{o}} \\land y_{{o}}\\) is true iff \\(x_{{o}}\\) and\n\\(y_{{o}}\\) are both true, i.e., iff \\(\\langle T_{{o}},T_{{o}}\\rangle\n= \\langle x_{{o}},y_{{o}}\\rangle\\). Hence \\(x_{{o}} \\land y_{{o}}\\)\ncan be expressed by the formula \\([\\lambda\ng_{{o}{o}{o}}[g_{{o}{o}{o}}T_{{o}}T_{{o}}]] = [\\lambda\ng_{{o}{o}{o}}[g_{{o}{o}{o}}x_{{o}}y_{{o}}]]\\).\n\nOther propositional connectives and the existential quantifier are\neasily defined. By using \\(\\iota_{(\\imath({o}\\imath))}\\), one can\ndefine description operators \\(\\iota_{\\alpha({o}\\alpha)}\\) for all\ntypes \u03b1.\n1.4.2 Axioms and Rules of Inference\n\n\\(\\cQ_0\\) has a single rule of inference.\n\nRule R: From \\(\\bC\\) and \\(\\bA_{\\alpha} =\n\\bB_{\\alpha}\\), to infer the result of replacing one occurrence of\n\\(\\bA_{\\alpha}\\) in \\(\\bC\\) by an occurrence of \\(\\bB_{\\alpha}\\),\nprovided that the occurrence of \\(\\bA_{\\alpha}\\) in \\(\\bC\\) is not (an\noccurrence of a variable) immediately preceded by \u03bb.\n\nThe axioms for \\(\\cQ_0\\) are the following: \n\n\\[\\begin{align}\n  [g_{{o}{o}}T_{{o}} \\land g_{{o}{o}}F_{{o}}] &= \\forall x_{{o}}[g_{{o}{o}}x_{{o}}] \\tag{1}\\\\\n  [x_{\\alpha} = y_{\\alpha}] & \\supset  [h_{{o}\\alpha}x_{\\alpha} = h_{{o}\\alpha}y_{\\alpha}] \\tag{\\(2^{\\alpha)}\\)}\\\\\n  [f_{\\alpha \\beta} = g_{\\alpha \\beta}] & = \\forall x_{\\beta}[f_{\\alpha \\beta}x_{\\beta} = g_{\\alpha  \\beta}x_{\\beta}] \\tag{\\(3^{\\alpha \\beta}\\)}\\\\\n%\n        [\\lambda \\bx_{\\alpha}\\bB_{\\beta}]\\bA_{\\alpha} & = \\textsf{SubFree}(\\bA_{\\alpha},\\bx_{\\alpha},\\bB_{\\beta}), \\tag{4}\\\\\n &\\quad \\text{ provided } \\bA_{\\alpha} \\text{ is free for } \\bx \\text{ in } \\bB_{\\beta}\\\\\n%\n        \\iota_{\\imath({o}\\imath)}[\\sfQ_{{o}\\imath\\imath}y_{\\imath}] &= y_{\\imath} \\tag{5}\n\\end{align}\\]\n\n2. Semantics\n\nIt is natural to compare the semantics of type theory with the\nsemantics of first-order logic, where the theorems are precisely the\nwffs which are valid in all interpretations. From an intuitive point\nof view, the natural interpretations of type theory are standard\nmodels, which are defined below. However, it is a consequence of\nG\u00f6del\u2019s Incompleteness Theorem (G\u00f6del 1931) that\naxioms (1)\u2013(9) do not suffice to derive all wffs which are valid in\nall standard models, and there is no consistent recursively\naxiomatized extension of these axioms which suffices for this purpose.\nNevertheless, experience shows that these axioms are sufficient for\nmost purposes, and Leon Henkin considered the problem of clarifying in\nwhat sense they are complete. The definitions and theorem below\nconstitute Henkin\u2019s (1950) solution to this problem, which is\noften referred to as general semantics or Henkin\nsemantics.\n\nA frame is a collection \\(\\{\\cD_{\\alpha}\\}_{\\alpha}\\) of\nnonempty domains (sets) \\(\\cD_{\\alpha}\\), one for each type symbol\n\u03b1, such that \\(\\cD_{{o}} = \\{\\sfT,\\sfF\\}\\) (where \\(\\sfT\\)\nrepresents truth and \\(\\sfF\\) represents falsehood), and \\(\\cD_{\\alpha\n\\beta}\\) is some collection of functions mapping \\(\\cD_{\\beta}\\) into\n\\(\\cD_{\\alpha}\\). The members of \\(\\cD_{\\imath}\\) are called\nindividuals.\n\nAn interpretation \\(\\langle \\{\\cD_{\\alpha}\\}_{\\alpha},\n\\frI\\rangle\\) consists of a frame and a function \\(\\frI\\) which maps\neach constant C of type \u03b1 to an appropriate element of\n\\(\\cD_{\\alpha}\\), which is called the denotation of C.\nThe logical constants are given their standard denotations.\n\nAn assignment of values in the frame\n\\(\\{\\cD_{\\alpha}\\}_{\\alpha}\\) to variables is a function \\(\\phi\\) such\nthat \\(\\phi \\bx_{\\alpha} \\in \\cD_{\\alpha}\\) for each variable\n\\(\\bx_{\\alpha}\\). (Notation: The assignment \\(\\phi[a/x]\\) maps\nvariable x to value a and it is identical with \\(\\phi\\)\nfor all other variable symbols different from x.)\n\nAn interpretation \\(\\cM = \\langle \\{\\cD_{\\alpha}\\}_{\\alpha},\n\\frI\\rangle\\) is a general model (aka Henkin model)\niff there is a binary function \\(\\cV\\) such that\n\\(\\cV_{\\phi}\\bA_{\\alpha} \\in \\cD_{\\alpha}\\) for each assignment\n\\(\\phi\\) and wff \\(\\bA_{\\alpha}\\), and the following conditions are\nsatisfied for all assignments and all wffs:\n\n\\(\\cV_{\\phi}\\bx_{\\alpha} = \\phi \\bx_{\\alpha}\\) for each variable\n\\(\\bx_{\\alpha}\\).\n\\(\\cV_{\\phi}A_{\\alpha} = \\frI A_{\\alpha}\\) if \\(A_{\\alpha}\\) is a\nprimitive constant.\n\\(\\cV_{\\phi}[\\bA_{\\alpha \\beta}\\bB_{\\beta}] =\n(\\cV_{\\phi}\\bA_{\\alpha \\beta})(\\cV_{\\phi}\\bB_{\\beta})\\) (the value of\na function \\(\\cV_{\\phi}\\bA_{\\alpha \\beta}\\) at the argument\n\\(\\cV_{\\phi}\\bB_{\\beta})\\).\n\\(\\cV_{\\phi}[\\lambda \\bx_{\\alpha}\\bB_{\\beta}] =\\) that function\nfrom \\(\\cD_{\\alpha}\\) into \\(\\cD_{\\beta}\\) whose value for each\nargument \\(z \\in \\cD_{\\alpha}\\) is \\(\\cV_{\\psi}\\bB_{\\beta}\\), where\n\\(\\psi\\) is that assignment such that \\(\\psi \\bx_{\\alpha} = z\\) and\n\\(\\psi \\by_{\\beta} = \\phi \\by_{\\beta}\\) if \\(\\by_{\\beta} \\ne\n\\bx_{\\alpha}\\).\n\n\nIf an interpretation \\(\\cM\\) is a general model, the function \\(\\cV\\)\nis uniquely determined. \\(\\cV_{\\phi}\\bA_{\\alpha}\\) is called the\nvalue of \\(\\bA_{\\alpha}\\) in \\(\\cM\\) with respect to\n\\(\\phi\\).\n\nOne can easily show that the following statements hold in all general\nmodels \\(\\cM\\) for all assignments \\(\\phi\\) and all wffs \\(\\bA\\) and\n\\(\\bB\\):\n\n\\(\\cV_{\\phi} T_{{o}} = \\sfT\\) and \\(\\cV_{\\phi} F_{{o}} =\n\\sfF\\)\n\\(\\cV_{\\phi} [\\nsim_{{o}{o}} \\bA_{{o}}] = \\sfT\\) iff \\(\\cV_{\\phi}\n\\bA_{{o}} = \\sfF\\)\n\\(\\cV_{\\phi} [ \\bA_{{o}} \\lor \\bB_{{o}} ] = \\sfT\\) iff\n\\(\\cV_{\\phi} \\bA_{{o}} = \\sfT\\) or \\(\\cV_{\\phi} \\bB_{{o}} =\n\\sfT\\)\n\\(\\cV_{\\phi} [ \\bA_{{o}} \\land \\bB_{{o}} ] = \\sfT\\) iff\n\\(\\cV_{\\phi} \\bA_{{o}} = \\sfT\\) and \\(\\cV_{\\phi} \\bB_{{o}} =\n\\sfT\\)\n\\(\\cV_{\\phi} [ \\bA_{{o}} \\supset \\bB_{{o}} ] = \\sfT\\) iff\n\\(\\cV_{\\phi} \\bA_{{o}} = \\sfF\\) or \\(\\cV_{\\phi} \\bB_{{o}} =\n\\sfT\\)\n\\(\\cV_{\\phi} [ \\bA_{{o}} \\equiv \\bB_{{o}} ] = \\sfT\\) iff\n\\(\\cV_{\\phi} \\bA_{{o}} = \\cV_{\\phi} \\bB_{{o}}\\)\n\\(\\cV_{\\phi} [\\forall \\bx_{\\alpha}\\bA] = \\sfT\\) iff\n\\(\\cV_{\\phi[a/x]} \\bA= \\sfT\\) for all \\(a \\in \\cD_{\\alpha}\\)\n\\(\\cV_{\\phi} [\\exists \\bx_{\\alpha}\\bA] = \\sfT\\) iff there exists\nan \\(a \\in \\cD_{\\alpha}\\) such that \\(\\cV_{\\phi[a/x]} \\bA= \\sfT\\)\n\n\nThe semantics of general models is thus as expected. However, there is\na subtlety to note regarding the following condition for arbitrary\ntypes \u03b1:\n\n[equality] \\(\\cV_{\\phi} [ \\bA_{\\alpha} = \\bB_{\\alpha} ] = \\sfT\\)\niff \\(\\cV_{\\phi} \\bA_{\\alpha} = \\cV_{\\phi} \\bB_{\\alpha}\\)\n\n\nWhen the definitions of\n Section 1.2.1\n are employed, where equality has been defined in terms of\nLeibniz\u2019 principle, then this statement is not implied for all\ntypes \u03b1. It only holds if we additionally require that the\ndomains \\(\\cD_{{o}\\alpha}\\) contain all the unit sets of objects of\ntype \u03b1, or, alternatively, that the domains\n\\(\\cD_{{o}\\alpha\\alpha}\\) contain the respective identity relations on\nobjects of type \u03b1 (which entails the former). The need for this\nadditional requirement, which is not included in the original work of\nHenkin (1950), has been demonstrated in Andrews 1972a.\n\nWhen instead the alternative definitions of\n Section 1.4\n are employed, then this requirement is obviously met due to the\npresence of the logical constants \\(\\sfQ_{{o}\\alpha \\alpha}\\) in the\nsignature, which by definition denote the respective identity\nrelations on the objects of type \u03b1 and therefore trivially\nensure their existence in each general model \\(\\cM\\). It is therefore\na natural option to always assume primitive equality constants (for\neach type \u03b1) in a concrete choice of base system for\nChurch\u2019s type theory, just as realized in Andrews\u2019 system\n\\(\\cQ_0\\).\n\nAn interpretation \\(\\langle \\{\\cD_{\\alpha}\\}_{\\alpha}, \\frI\\rangle\\)\nis a standard model iff for all \u03b1 and \\(\\beta ,\n\\cD_{\\alpha \\beta}\\) is the set of all functions from \\(\\cD_{\\beta}\\)\ninto \\(\\cD_{\\alpha}\\). Clearly a standard model is a general\nmodel.\n\nWe say that a wff \\(\\bA\\) is valid in a model \\(\\cM\\) iff\n\\(\\cV_{\\phi}\\bA = \\sfT\\) for every assignment \\(\\phi\\) into \\(\\cM\\). A\nmodel for a set \\(\\cH\\) of wffs is a model in which each wff of\n\\(\\cH\\) is valid.\n\nA wff \\(\\bA\\) is valid in the general [standard]\nsense iff \\(\\bA\\) is valid in every general [standard] model.\nClearly a wff which is valid in the general sense is valid in the\nstandard sense, but the converse of this statement is false.\n\nCompleteness and Soundness Theorem (Henkin 1950):\nA wff is a theorem if and only if it is valid in the general\nsense.\n\nNot all frames belong to interpretations, and not all interpretations\nare general models. In order to be a general model, an interpretation\nmust have a frame satisfying certain closure conditions which are\ndiscussed further in Andrews 1972b. Basically, in a general model\nevery wff must have a value with respect to each assignment.\n\nA model is said to be finite iff its domain of individuals is\nfinite. Every finite model for \\(\\cQ_0\\) is standard (Andrews 2002,\nTheorem 5404), but every set of sentences of \\(\\cQ_0\\) which has\ninfinite models also has nonstandard models (Andrews2002, Theorem\n5506).\n\nAn understanding of the distinction between standard and nonstandard\nmodels can clarify many phenomena. For example, it can be shown that\nthere is a model \\(\\cM = \\langle \\{\\cD_{\\alpha}\\}_{\\alpha},\n\\frI\\rangle\\) in which \\(\\cD_{\\imath}\\) is infinite, and all the\ndomains \\(\\cD_{\\alpha}\\) are countable. Thus \\(\\cD_{\\imath}\\) and\n\\(\\cD_{{o}\\imath}\\) are both countably infinite, so there must be a\nbijection h between them. However, Cantor\u2019s Theorem\n(which is provable in type theory and therefore valid in all models)\nsays that \\(\\cD_{\\imath}\\) has more subsets than members. This\nseemingly paradoxical situation is called Skolem\u2019s Paradox. It\ncan be resolved by looking carefully at Cantor\u2019s Theorem, i.e.,\n\\(\\nsim \\exists g_{{o}\\imath\\imath}\\forall f_{{o}\\imath}\\exists\nj_{\\imath}[g_{{o}\\imath\\imath}j_{\\imath} = f_{{o}\\imath}]\\), and\nconsidering what it means in a model. The theorem says that there is\nno function \\(g \\in \\cD_{{o}\\imath\\imath}\\) from \\(\\cD_{\\imath}\\) into\n\\(\\cD_{{o}\\imath}\\) which has every set \\(f_{{o}\\imath} \\in\n\\cD_{{o}\\imath}\\) in its range. The usual interpretation of the\nstatement is that \\(\\cD_{{o}\\imath}\\) is bigger (in cardinality) than\n\\(\\cD_{\\imath}\\). However, what it actually means in this model is\nthat h cannot be in \\(\\cD_{{o}\\imath\\imath}\\). Of course,\n\\(\\cM\\) must be nonstandard.\n\nWhile the Axiom of Choice is presumably true in all standard models,\nthere is a nonstandard model for \\(\\cQ_0\\) in which AC\\(^{\\imath}\\) is\nfalse (Andrews 1972b). Thus, AC\\(^{\\imath}\\) is not provable in\n\\(\\cQ_0\\).\n\nThus far, investigations of model theory for Church\u2019s type\ntheory have been far less extensive than for first-order logic.\nNevertheless, there has been some work on methods of constructing\nnonstandard models of type theory and models in which various forms of\nextensionality fail, models for theories with arbitrary (possibly\nincomplete) sets of logical constants, and on developing general\nmethods of establishing completeness of various systems of axioms with\nrespect to various classes of models. Relevant papers include Andrews\n1971, 1972a,b, and Henkin 1975. Further related work can be found in\nBenzm\u00fcller et al. 2004, Brown 2004, 2007, and Muskens 2007.\n3. Metatheory\n3.1 Lambda-Conversion\n\nThe first three rules of inference in\n Section 1.3.1\n are called rules of \u03bb-conversion. If \\(\\bD\\) and\n\\(\\bE\\) are wffs, we write \\(\\bD \\conv \\bE\\) to indicate that \\(\\bD\\)\ncan be converted to \\(\\bE\\) by applications of these rules. This is an\nequivalence relation between wffs. A wff \\(\\bD\\) is in\n\u03b2-normal form iff it has no well-formed parts of the\nform \\([[\\lambda \\bx_{\\alpha}\\bB_{\\beta}]\\bA_{\\alpha}]\\). Every wff is\nconvertible to one in \u03b2-normal form. Indeed, every sequence of\ncontractions (applications of rule 2, combined as necessary with\nalphabetic changes of bound variables) of a wff is finite; obviously,\nif such a sequence cannot be extended, it terminates with a wff in\n\u03b2-normal form. (This is called the strong normalization theorem.)\nBy the Church-Rosser Theorem, this wff in \u03b2-normal form is unique\nmodulo alphabetic changes of bound variables. For each wff \\(\\bA\\) we\ndenote by \\({\\downarrow}\\bA\\) the first wff (in some enumeration) in\n\u03b2-normal form such that \\(\\bA \\conv {\\downarrow} \\bA\\). Then \\(\\bD\n\\conv \\bE\\) if and only if \\({\\downarrow} \\bD = {\\downarrow} \\bE\\).\n\nBy using the Axiom of Extensionality one can obtain the following\nderived rule of inference:\n\n\n\\(\\eta\\)-Contraction. Replace a well-formed part \\([\\lambda\n\\by_{\\beta}[\\bB_{\\alpha \\beta}\\by_{\\beta}]]\\) of a wff by\n\\(\\bB_{\\alpha \\beta}\\), provided \\(\\by_{\\beta}\\) does not occur free\nin \\(\\bB_{\\alpha \\beta}\\).\n\n\nThis rule and its inverse (which is called\n\\(\\eta\\)-Expansion) are sometimes used as additional rules of\n\u03bb-conversion. See Church 1941, Stenlund 1972, Barendregt 1984,\nand Barendregt et al. 2013 for more information about\n\u03bb-conversion.\n\nIt is worth mentioning (again) that \u03bb-abstraction replaces the\nneed for comprehension axioms in Church\u2019s type theory.\n3.2 Higher-Order Unification\n\nThe challenges in higher-order unification are outlined very briefly.\nMore details on the topic are given in Dowek 2001; its utilization in\nhigher-order theorem provers is also discussed in Benzm\u00fcller\n& Miller 2014.\n\nDefinition. A higher-order unifier for a\npair \\(\\langle \\bA,\\bB\\rangle\\) of wffs is a substitution \\(\\theta\\)\nfor free occurrences of variables such that \\(\\theta \\bA\\) and\n\\(\\theta \\bB\\) have the same \u03b2-normal form. A higher-order\nunifier for a set of pairs of wffs is a unifier for each of the pairs\nin the set.\n\nHigher-order unification differs from first-order unification (Baader\n& Snyder 2001) in a number of important respects. In\nparticular:\n\nEven when a unifier for a pair of wffs exists, there may be no\nmost general unifier (Gould 1966).\nHigher-order unification is undecidable (Huet 1973b), even in the\n\u201csecond-order\u201d case (Goldfarb 1981).\n\n\nHowever, an algorithm has been devised (Huet 1975, Jensen &\nPietrzykowski 1976), called pre-unification, which will find\na unifier for a set of pairs of wffs if one exists. The pre-unifiers\ncomputed by Huet\u2019s procedure are substitutions that can reduce\nthe original unification problem to one involving only so called\nflex-flex unification pairs. Flex-flex pairs have variable\nhead symbols in both terms to be unified and they are known to always\nhave a solution. The concrete computation of these solutions can thus\nbe postponed or omitted. Pre-unification is utilized in all the\nresolution based theorem provers mentioned in\n Section 4.\n \n\nPattern unification refers a small subset of unification\nproblems, first studied by Miller 1991, whose identification has been\nimportant for the construction of practical systems. In a pattern\nunification problem every occurrence of an existentially quantified\nvariable is applied to a list of arguments that are all distinct\nvariables bound by either a \u03bb-binder or a universal quantifier\nin the scope of the existential quantifier. Thus, existentially\nquantified variables cannot be applied to general terms but a very\nrestricted set of bound variables. Pattern unification, like\nfirst-order unification, is decidable and most general unifiers exist\nfor solvable problems. This is why pattern unification is preferably\nemployed (when applicable) in some state-of-the-art theorem provers\nfor Church\u2019s type theory. \n3.3 A Unifying Principle\n\nThe Unifying Principle was introduced in Smullyan 1963 (see\nalso Smullyan 1995) as a tool for deriving a number of basic\nmetatheorems about first-order logic in a uniform way. The principle\nwas extended to elementary type theory by Andrews (1971) and to\nextensional type theory, that is, Henkin\u2019s general semantics\nwithout description or choice, by Benzm\u00fcller, Brown and Kohlhase\n(2004). We outline these extensions in some more detail below.\n3.3.1 Elementary Type Theory\n\nThe Unifying Principle was extended to elementary type theory (the\nsystem \\(\\cT\\) of\n Section 1.3.2)\n in Andrews 1971 by applying ideas in Takahashi 1967. This Unifying\nPrinciple for \\(\\cT\\) has been used to establish cut-elimination for\n\\(\\cT\\) in Andrews 1971 and completeness proofs for various systems of\ntype theory in Huet 1973a, Kohlhase 1995, and Miller 1983. We first\ngive a definition and then state the principle.\n\nDefinition. A property \\(\\Gamma\\) of finite sets of\nwffs\\(_{{o}}\\) is an abstract consistency property iff for\nall finite sets \\(\\cS\\) of wffs\\(_{{o}}\\), the following properties\nhold (for all wffs A, B):\n\nIf \\(\\Gamma(\\cS)\\), then there is no atom \\(\\bA\\) such that \\(\\bA\n\\in \\cS\\) and \\([\\nsim \\bA] \\in \\cS\\).\nIf \\(\\Gamma(\\cS \\cup \\{\\bA\\})\\), then \\(\\Gamma(\\cS \\cup {\\downarrow}\n\\bA\\})\\).\nIf \\(\\Gamma(\\cS \\cup \\{\\nsim \\nsim \\bA\\})\\), then \\(\\Gamma(\\cS\n\\cup \\{\\bA\\})\\).\nIf \\(\\Gamma(\\cS \\cup \\{\\bA \\lor \\bB\\})\\), then \\(\\Gamma(\\cS \\cup\n\\{\\bA\\})\\) or \\(\\Gamma(\\cS \\cup \\{\\bB\\})\\).\nIf \\(\\Gamma(\\cS \\cup \\{\\nsim[\\bA \\lor \\bB]\\})\\), then \\(\\Gamma(\\cS\n\\cup \\{\\nsim \\bA,\\nsim \\bB\\})\\).\nIf \\(\\Gamma(\\cS \\cup \\{\\Pi_{{o}({o}\\alpha)}\\bA_{{o}\\alpha}\\})\\),\nthen \\(\\Gamma(\\cS \\cup \\{\\Pi_{{o}({o}\\alpha)}\\bA_{{o}\\alpha},\n\\bA_{{o}\\alpha}\\bB_{\\alpha}\\})\\) for each wff \\(\\bB_{\\alpha}\\).\nIf \\(\\Gamma(\\cS \\cup \\{\\nsim\n\\Pi_{{o}({o}\\alpha)}\\bA_{{o}\\alpha}\\})\\), then \\(\\Gamma(\\cS \\cup\n\\{\\nsim \\bA_{{o}\\alpha}\\bc_{\\alpha}\\})\\), for any variable or\nparameter \\(\\bc_{\\alpha}\\) which does not occur free in\n\\(\\bA_{{o}\\alpha}\\) or any wff in \\(\\cS\\).\n\n\nNote that consistency is an abstract consistency\nproperty.\n\nUnifying Principle for \\(\\cT\\). If \\(\\Gamma\\) is an\nabstract consistency property and \\(\\Gamma(\\cS)\\), then \\(\\cS\\) is\nconsistent in \\(\\cT\\).\n\nHere is a typical application of the Unifying Principle. Suppose there\nis a procedure \\(\\cM\\) which can be used to refute sets of sentences,\nand we wish to show it is complete for \\(\\cT\\). For any set of\nsentences, let \\(\\Gamma(\\cS)\\) mean that \\(\\cS\\) is not refutable by\n\\(\\cM\\), and show that \\(\\Gamma\\) is an abstract consistency property.\nNow suppose that \\(\\bA\\) is a theorem of \\(\\cT\\). Then \\(\\{\\nsim\n\\bA\\}\\) is inconsistent in \\(\\cT\\), so by the Unifying Principle not\n\\(\\Gamma(\\{\\nsim \\bA\\})\\), so \\(\\{\\nsim \\bA\\}\\) is refutable by\n\\(\\cM\\).\n3.3.2 Extensional Type Theory\n\nExtensions of the above Unifying principle towards Church\u2019s type\ntheory with general semantics were studied since the mid nineties. A\nprimary motivation was to support (refutational) completeness\ninvestigations for the proof calculi underlying the emerging\nhigher-order automated theorem provers (see\n Section 4\n below). The initial interest was on a fragment of Church\u2019s type\ntheory, called extensional type theory, that includes the\nextensionality axioms, but excludes \\(\\iota_{(\\alpha({o}\\alpha))}\\)\nand the axioms for it (description and choice were largely neglected\nin the automated theorem provers at the time). Analogous to before, a\ndistinction has been made between extensional type theory with\ndefined equality (as in\n Section 1.2.1,\n where equality is defined via Leibniz\u2019 principle) and\nextensional type theory with primitive equality (e.g., system\n\\(\\cQ_0\\) as in\n Section 1.4,\n or, alternatively, a system based on logical constants\n\\(\\nsim_{({o}{o})}, \\lor_{(({o}{o}){o})}\\), and the\n\\(\\Pi_{({o}({o}\\alpha))}\\)\u2019s as in\n Section 1.2.1,\n but with additional primitive logical constants\n\\(=_{{o}\\alpha\\alpha}\\) added).\n\nA first attempt towards a Unifying Principle for extensional type\ntheory with primitive equality is presented in Kohlhase 1993. The\nconditions given there, which are still\n incomplete[1],\n were subsequently modified and complemented as follows:\n\n\n\nTo obtain a Unifying Principle for extensional type theory with\ndefined equality, Benzm\u00fcller & Kohlhase 1997 added the\nfollowing conditions for boolean extensionality, functional\nextensionality and saturation to the above conditions 1.-7. for\n\\(\\cT\\) (their presentation has been adapted here; for technical reasons,\nthey also employ a slightly stronger variant for condition 2. based on\n\u03b2-conversion rather than \u03b2-normalization):\n\nIf \\(\\Gamma(\\cS \\cup \\{ \\bA_{{o}} = \\bB_{{o}} \\})\\), then\n\\(\\Gamma(\\cS \\cup \\{ \\bA_{{o}}, \\bB_{{o}} \\})\\) or \\(\\Gamma(\\cS \\cup \\{ \\nsim \\bA_{{o}}, \\nsim \\bB_{{o}} \\})\\)\nIf \\(\\Gamma(\\cS \\cup \\{ \\bA_{\\alpha\\beta} = \\bB_{\\alpha\\beta}\n\\})\\), then \\(\\Gamma(\\cS \\cup \\{ \\bA_{\\alpha\\beta} \\bc_\\beta =\n\\bB_{\\alpha\\beta} \\bc_\\beta \\})\\) for any parameter \\(\\bc_{\\beta}\\)\nwhich does not occur free in \\(\\cS\\).\n\\(\\Gamma(\\cS \\cup \\{ \\bA_{{o}} \\})\\) or \\(\\Gamma(\\cS \\cup \\{ \\nsim\n\\bA_{{o}} \\})\\)\n\n\nThe saturation condition 10. was required to properly establish the\nprinciple. However, since this condition is related to the proof\ntheoretic notion of cut-elimination, it limits the utility of the\nprinciple in completeness proofs for machine-oriented calculi. The\nprinciple was nevertheless used in Benzm\u00fcller & Kohlhase\n1998a and Benzm\u00fcller 1999a,b to obtain a completeness proof for a\nsystem of extensional higher-order resolution. The principle was also\napplied in Kohlhase 1998 to study completeness for a related\nextensional higher-order tableau\n calculus,[2]\n in which the extensionality rules for Leibniz equality were adapted\nfrom Benzm\u00fcller & Kohlhase 1998a, respectively\nBenzm\u00fcller 1997.\n\n\nDifferent options for achieving a Unifying Principle for extensional\ntype theory with primitive equality are presented in Benzm\u00fcller\n1999a (in this work primitive logical constants\n\\(=_{{o}\\alpha\\alpha}\\) were used in addition to \\(\\nsim_{({o}{o})},\n\\lor_{(({o}{o}){o})}\\), and the \\(\\Pi_{({o}({o}\\alpha))}\\)\u2019s;\nsuch a redundant choice of logical constants is not rare in\nhigher-order theorem provers). One option is to introduce a\nreflexivity and substitutivity condition. An alternative is to combine\na reflexivity condition with a condition connecting primitive with\ndefined equality, so that the substitutivity condition follows. Note\nthat introducing a defined notion of equality based on the Leibniz\nprinciple is, of course, still possible in this context (defined\nequality is denoted in the remainder of this section by \\(\\doteq\\) to\nproperly distinguish it from primitive equality \\(=\\)):\n\nNot \\(\\Gamma(\\cS \\cup \\{ \\nsim [\\bA_{\\alpha} = \\bA_{\\alpha}]\n\\})\\)\nIf \\(\\Gamma(\\cS \\cup \\{ \\bA_{\\alpha} = \\bA_{\\alpha} \\})\\), then\n\\(\\Gamma(\\cS \\cup \\{ \\bA_{\\alpha} \\doteq \\bA_{\\alpha} \\})\\)\n\\(\\Gamma(\\cS \\cup \\{ \\bA_{{o}} \\})\\) or \\(\\Gamma(\\cS \\cup \\{ \\nsim\n\\bA_{{o}} \\})\\)\n\n\nThe saturation condition 10. still has to be added independent of\nwhich option is considered. The principle was applied in\nBenzm\u00fcller 1999a,b to\nprove completeness for the extensional higher-order\n RUE-resolution[3]\n calculus underlying the higher-order automated theorem prover LEO and\nits successor LEO-II.\n\n\nIn Benzm\u00fcller et al. 2004 the principle is presented in a very\ngeneral way which allows for various possibilities concerning the\ntreatment of extensionality and equality in the range between\nelementary type theory and extensional type theory. The principle is\napplied to obtain completeness proofs for an associated range of\nnatural deduction calculi. The saturation condition is still used in\nthis work.\n\n\nBased on insights from Brown\u2019s (2004, 2007) thesis, a solution\nfor replacing the undesirable saturation condition by two weaker\nconditions is presented in Benzm\u00fcller, Brown, and Kohlhase 2009;\nthis work also further studies the relation between saturation and\ncut-elimination. The two weaker conditions, termed mating and\ndecomposition, are easier to demonstrate than saturation in\ncompleteness proofs for machine-oriented calculi. They are (omitting\nsome type information in the second one and abusing notation):\n\nIf \\(\\Gamma(\\cS \\cup \\{ \\nsim \\bA_{{o}}, \\bB_{{o}} \\})\\) for atoms\n\\(\\bA_{{o}}\\) and \\(\\bB_{{o}}\\), then \\(\\Gamma(\\cS \\cup \\{ \\nsim [\\bA_{{o}} \\doteq \\bB_{{o}}] \\})\\)\nIf \\(\\Gamma(\\cS \\cup \\{ \\nsim [h \\overline{\\bA^n_{\\alpha^n}}\n\\doteq h \\overline{\\bB^n_{\\alpha^n}} ] \\})\\), where head symbol\n\\(h_{\\beta\\overline{\\alpha^n}}\\) is a parameter, then there is an \\(i\\\n(1 \\leq i \\leq n)\\) such that \\(\\Gamma(\\cS \\cup \\{ \\nsim [\\bA^i_{\\alpha^i} \\doteq \\bB^i_{\\alpha^i}]\n\\})\\).\n\n\nThe modified principle is applied in Benzm\u00fcller et al. 2009 to\nshow completeness for a sequent calculus for extensional type theory\nwith defined equality.\n\n\nA further extended Unifying Principle for extensional type theory with\nprimitive equality is presented and used in Backes & Brown 2011 to\nprove the completeness of a tableau calculus for type theory which\nincorporates the axiom of choice.\n\n\nA closely related and further simplified principle has also been\npresented and studied in Steen 2018, where it was applied for showing\ncompleteness of the paramodulation calculus (Steen 2018) that is\nunderlying the theorem prover Leo-III (Steen & Benzm\u00fcller\n2018).\n\n3.4 Cut-Elimination and Cut-Simulation\n\nCut-elimination proofs (see also the SEP entry on\n proof theory)\n for Church\u2019s type theory, which are often closely related to\nsuch proofs (Takahashi 1967, 1970; Prawitz 1968; Mints 1999) for other\nformulations of type theory, may be found in Andrews 1971, Dowek &\nWerner 2003, and Brown 2004. In Benzm\u00fcller et al. 2009 it is\nshown how certain wffs\\(_{{o}}\\), such as axioms of extensionality,\ndescriptions, choice (see\n Sections 1.3.3\n to\n 1.3.5),\n and induction, can be used to justify cuts in cut-free sequent\ncalculi for elementary type theory. Moreover, the notions of\ncut-simulation and cut-strong axioms are introduced\nin this work, and the need for omitting defined equality and for\neliminating cut-strong axioms such as extensionality,\ndescription, choice and induction in machine-oriented calculi (e.g.,\nby replacing them with more constrained, goal-directed rules) in order\nto reduce cut-simulation effects are discussed as a major\nchallenge for higher-order automated theorem proving. In other words,\nincluding cut-strong axioms in a machine-oriented proof calculus for\nChurch\u2019s type theory is essentially as bad as including a cut\nrule, since the cut rule can be mimicked by them.\n3.5 Expansion Proofs\n\nAn expansion proof is a generalization of the notion of a\nHerbrand expansion of a theorem of first-order logic; it provides a\nvery elegant, concise, and nonredundant representation of the\nrelationship between the theorem and a tautology which can be obtained\nfrom it by appropriate instantiations of quantifiers and which\nunderlies various proofs of the theorem. Miller (1987) proved that a\nwff \\(\\bA\\) is a theorem of elementary type theory if and only if\n\\(\\bA\\) has an expansion proof.\n\nIn Brown 2004 and 2007, this concept is generalized to that of an\nextensional expansion proof to obtain an analogous theorem\ninvolving type theory with extensionality.\n3.6 The Decision Problem\n\nSince type theory includes first-order logic, it is no surprise that\nmost systems of type theory are undecidable. However, one may look for\nsolvable special cases of the decision problem. For example, the\nsystem \\(\\cQ_{0}^1\\) obtained by adding to \\(\\cQ_0\\) the additional\naxiom \\(\\forall x_{\\imath}\\forall y_{\\imath}[x_{\\imath}=y_{\\imath}]\\)\nis decidable.\n\nAlthough the system \\(\\cT\\) of elementary type theory is analogous to\nfirst-order logic in certain respects, it is a considerably more\ncomplex language, and special cases of the decision problem for\nprovability in \\(\\cT\\) seem rather intractable for the most part.\nInformation about some very special cases of this decision problem may\nbe found in Andrews 1974, and we now summarize this.\n\nA wff of the form \\(\\exists \\bx^1 \\ldots \\exists \\bx^n [\\bA=\\bB]\\) is\na theorem of \\(\\cT\\) iff there is a substitution \\(\\theta\\) such that\n\\(\\theta \\bA \\conv \\theta \\bB\\). In particular, \\(\\vdash \\bA=\\bB\\) iff\n\\(\\bA \\conv \\bB\\), which solves the decision problem for wffs of the\nform \\([\\bA=\\bB]\\). Naturally, the circumstance that only trivial\nequality formulas are provable in \\(\\cT\\) changes drastically when\naxioms of extensionality are added to \\(\\cT\\). \\(\\vdash \\exists\n\\bx_{\\beta}[\\bA=\\bB]\\) iff there is a wff \\(\\bE_{\\beta}\\) such that\n\\(\\vdash[\\lambda \\bx_{\\beta}[\\bA=\\bB]]\\bE_{\\beta}\\), but the decision\nproblem for the class of wffs of the form \\(\\exists\n\\bx_{\\beta}[\\bA=\\bB]\\) is unsolvable.\n\nA wff of the form \\(\\forall \\bx^1 \\ldots \\forall \\bx^n\\bC\\), where\n\\(\\bC\\) is quantifier-free, is provable in \\(\\cT\\) iff \\({\\downarrow}\n\\bC\\) is tautologous. On the other hand, the decision problem for wffs\nof the form \\(\\exists \\bz\\bC\\), where \\(\\bC\\) is quantifier-free, is\nunsolvable. (By contrast, the corresponding decision problem in\nfirst-order logic with function symbols is known to be solvable\n(Maslov 1967).) Since irrelevant or vacuous quantifiers can always be\nintroduced, this shows that the only solvable classes of wffs of\n\\(\\cT\\) in prenex normal form defined solely by the structure of the\nprefix are those in which no existential quantifiers occur.\n4. Automation\n4.1 Machine-Oriented Proof Calculi\n\nThe development, respectively improvement, of machine-oriented proof\ncalculi for Church\u2019s type theory is still a challenge research\ntopic. Compared, e.g., to the theoretical and practical maturity\nachieved in first-order automated theorem proving, the area is still\nin its infancy. Obviously, the challenges are also much bigger than in\nfirst-order logic. The practically way more expressive nature of the\nterm-language of Church\u2019s type theory causes a larger, bushier\nand more difficult to traverse proof search space than in first-order\nlogic. Moreover, remember that unification, which constitutes a very\nimportant control and filter mechanism in first-order theorem proving,\nis undecidable (in general) in type theory; see\n Section 3.2.\n On the positive side, however, there is a chance to find\nsignificantly shorter proofs than in first-order logic. This is well\nillustrated with a small, concrete example in Boolos 1987. Clearly,\nmuch further progress is needed to further leverage the practical\nrelevance of existing calculi for Church\u2019s type theory and their\nimplementations (see\n Section 4.3).\n The challenges include\n\nan appropriate handling of the impredicative nature of\nChurch\u2019s type theory (some form of blind guessing cannot\ngenerally be avoided in a complete proof procedure, but must be\nintelligently guided),\nthe elimination/reduction of cut-simulation effects (see\n Section 3.4)\n caused by defined equality or cut-strong axioms (e.g.,\nextensionality, description, choice, induction) in the search\nspace,\nthe general undecidability of unification, rendering it a rather\nproblematic filter mechanism for controlling proof search,\nthe invention of suitable heuristics for traversing the search\nspace,\nthe provision of suitable term-orderings and their effective\nexploitation in term rewriting procedures,\nand the development of efficient data structures in combination\nwith strong technical support for essential operations such\n\u03bb-conversion, substitution and rewriting.\n\n\nIt is planned that future editions of this article further elaborate\non machine-oriented proof calculi for Church\u2019s type theory. For\nthe time being, however, we provide only a selection of historical and\nmore recent references for the interested reader (see also\n Section 5 below):\n\nSequent calculi: Sch\u00fctte 1960; Takahashi\n1970; Takeuti 1987; Mints 1999; Brown 2004, 2007; Benzm\u00fcller et\nal. 2009.\nMating method: Andrews 1981; Bibel 1981; Bishop\n1999.\nResolution calculi: Andrews 1971; Huet 1973a;\nJensen & Pietrzykowski 1976; Benzm\u00fcller 1997, 1999a;\nBenzm\u00fcller & Kohlhase 1998a. \nTableau method:\n Kohlhase[4]\n 1995, 1998; Brown & Smolka 2010; Backes & Brown 2011.\nParamodulation calculi: Benzm\u00fcller 1999a,b;\nSteen 2018.\n\n4.2 Early Proof Assistants\n\nEarly computer systems for proving theorems of Church\u2019s type\ntheory (or extensions of it) include HOL (Gordon 1988; Gordon &\nMelham 1993), TPS (Andrews et al. 1996; Andrews & Brown 2006),\nIsabelle (Paulson 1988, 1990), PVS (Owre et al. 1996; Shankar 2001),\nIMPS (Farmer et al. 1993), HOL\nLight (Harrison 1996), OMEGA (Siekmann et al. 2006), and \u03bbClam\n(Richardson et al. 1998). See\n Other Internet References\n section below for links to further info on these and other provers\nmentioned later. \n\nThe majority of the above systems focused (at least initially) on\ninteractive proof and provided rather limited support for additional\nproof automation. Full proof automation was pioneered, in particular,\nby the TPS project. Progress was made in the nineties, when other\nprojects started similar activities, respectively, enforced theirs.\nHowever, the resource investments and achievements were lacking much\nbehind those seen in first-order theorem proving. Significant progress\nwas fostered only later, in particular, through the development of a\ncommonly supported syntax for Church\u2019s type theory, called TPTP\nTHF (Sutcliffe & Benzm\u00fcller 2010), and the inclusion, from\n2009 onwards, of a TPTP THF division in the yearly CASC competitions\n(kind of world championships for automated theorem proving; see\nSutcliffe 2016 for further details).\n4.3 Automated Theorem Provers\n\nAn selection of theorem provers for Church\u2019s type theory is\npresented. The focus is on systems that have successfully participated\nin TPTP THF CASC competitions in the past. The latest editions of most\nmentioned systems can be accessed online via the SystemOnTPTP\ninfrastructure (Sutcliffe 2017). Nearly all mentioned systems produce\nverifiable proof certificates in the TPTP TSTP syntax. Further details\non the automation of Church\u2019s type theory are given in\nBenzm\u00fcller & Miller 2014.\n\nThe TPS prover (Andrews et al. 1996, Andrews & Brown 2006) can be\nused to prove theorems of elementary type theory or extensional type\ntheory automatically, interactively, or semi-automatically. When\nsearching for a proof automatically, TPS first searches for an\nexpansion proof (Miller 1987) or an extensional expansion proof (Brown\n2004, 2007) of the theorem. Part of this process involves searching\nfor acceptable matings (Andrews 1981, Bishop 1999). The behavior of\nTPS is controlled by sets of flags, also called modes. A simple\nscheduling mechanism is employed in the latest versions of TPS to\nsequentially run a about fifty modes for a limited amount of time. TPS\nwas the winner of the first THF CASC competition in 2009.\n\nThe LEO-II prover (Benzm\u00fcller et al. 2015) is the successor of\nLEO (Benzm\u00fcller & Kohlhase 1998b, which was hardwired with\nthe OMEGA proof assistant (LEO stands for Logical Engine of OMEGA).\nThe provers are based on the RUE-resolution calculi developed in\nBenzm\u00fcller 1999a,b. LEO\nwas the first prover to implement calculus rules for extensionality to\navoid cut-simulation effects. LEO-II inherits and adapts them, and\nprovides additional calculus rules for description and choice. The\nprover, which internally collaborates with first-order provers\n(preferably E) and SAT solvers, has pioneered cooperative\nhigher-order/first-order proof automation. Since the prover is often\ntoo weak to find a refutation among the steadily growing set of\nclauses on its own, some of the clauses in LEO-II\u2019s search space\nattain a special status: they are first-order clauses modulo the\napplication of an appropriate transformation function. Therefore,\nLEO-II progressively launches time limited calls with these clauses to\na first-order theorem prover, and when the first-order prover reports\na refutation, LEO-II also terminates. Parts of these ideas were\nalready implemented in the predecessor LEO. Communication between\nLEO-II and the cooperating first-order theorem provers uses the TPTP\nlanguage and standards. LEO-II was the winner of the second THF CASC\ncompetition in 2010.\n\nThe Satallax prover (Brown 2012) is based on a complete ground tableau\ncalculus for Church\u2019s type theory with choice (Backes &\nBrown 2011). An initial tableau branch is formed from the assumptions\nof a conjecture and negation of its conclusion. From that point on,\nSatallax tries to determine unsatisfiability or satisfiability of this\nbranch. Satallax progressively generates higher-order formulas and\ncorresponding propositional clauses. Satallax uses the SAT solver\nMiniSat as an engine to test the current set of propositional clauses\nfor unsatisfiability. If the clauses are unsatisfiable, the original\nbranch is unsatisfiable. Satallax provides calculus rules for\nextensionality, description and choice. If there are no quantifiers at\nfunction types, the generation of higher-order formulas and\ncorresponding clauses may terminate. In that case, if MiniSat reports\nthe final set of clauses as satisfiable, then the original set of\nhigher-order formulas is satisfiable (by a standard model in which all\ntypes are interpreted as finite sets). Satallax was the winner of the\nTHF CASC competition in 2011 and since 2013. \n\nThe Isabelle/HOL system (Nipkow, Wenzel, & Paulson 2002) has\noriginally been designed as an interactive prover. However, in order\nto ease user interaction several automatic proof tactics have been\nadded over the years. By appropriately scheduling a subset of these\nproof tactics, some of which are quite powerful, Isabelle/HOL has\nsince about 2011 been turned also into an automatic theorem prover for\nTPTP THF (and other TPTP syntax formats), that can be run from a\ncommand shell like other provers. The most powerful proof tactics that\nare scheduled by Isabelle/HOL include the Sledgehammer tool\n(Blanchette et al. 2013),\nwhich invokes a sequence of external first-order and higher-order\ntheorem provers, the model finder Nitpick (Blanchette &\nNipkow 2010), the equational reasoner simp, the untyped\ntableau prover blast, the simplifier and classical reasoners\nauto, force, and fast, and the best-first\nsearch procedure best. In contrast to all other automated\ntheorem provers mentioned above, the TPTP incarnation of Isabelle/HOL\ndoes not yet output proof certificates. Isabelle/HOL was the winner of\nthe THF CASC competition in 2012. \n\nThe agsyHOL prover is based on a generic lazy narrowing proof search\nalgorithm. Backtracking is employed and a comparably small search\nstate is maintained. The prover outputs proof terms in sequent style\nwhich can be verified in the Agda system. \n\ncoqATP implements (the non-inductive) part of the calculus of\nconstructions (Bertot & Cast\u00e9ran 2004). The system outputs\nproof terms which are accepted as proofs (after the addition of a few\ndefinitions) by the Coq proof assistant. The prover employs axioms for\nfunctional extensionality, choice, and excluded middle. Boolean\nextensionality is not supported. In addition to axioms, a small\nlibrary of basic lemmas is employed. \n\nThe Leo-III prover implements a paramodulation calculus for\nChurch\u2019s type theory (Steen 2018). The system, which is a\ndescendant of LEO and LEO-II, provides calculus rules for\nextensionality, description and choice. The system has put an emphasis\non the implementation of an efficient set of underlying data\nstructures, on simplification routines and on heuristic rewriting. In\nthe tradition of its predecessors, Leo-III cooperates with first-order\nreasoning tools using translations to many-sorted first-order logic.\nThe prover accepts every common TPTP syntax dialect and is thus very\nwidely applicable. Recently, the prover has also been extended to\nnatively supports almost every normal higher-order modal logic.\n\nZipperposition (Bentkamp et al. 2018) is new and inspiring\nhigher-order theorem prover which, at the current state of\ndevelopment, is still working for a comparably weak fragment of\nChurch\u2019s type theory, called lambda-free higher-order\nlogic (a comprehension-free higher-order logic,\nwhich is nevertheless supporting \u03bb-notation). The system, which\nis based on superposition calculi, is developed bottom up, and it is\nprogressively extended towards stronger fragments of Church\u2019s\ntype theory and to support other relevant extensions such datatypes,\nrecursive functions and arithmetic. \n\nVarious so called proof hammers, in the spirit of\nIsabelle\u2019s Sledgehammer tool, have recently been developed and\nintegrated with modern proof assistants. Prominent examples include\nHOL(y)Hammer (Kaliszyk & Urban 2015) for HOL Light and a similar\nhammer (Czaika & Kaliszyk 2018) for the proof assistant Coq. \n4.4 (Counter-)Model Finding\n\nSupport for finding finite models or countermodels for formulas of\nChurch\u2019s type theory was implemented already in the\ntableau-based prover HOT (Konrad 1998). Restricted (counter-)model\nfinding capabilities are also implemented in the provers Satallax,\nLEO-II and LEO-III. The most advanced (finite) model finding support\nis currently realized in the systems Nitpick, Nunchaku and Refute. These tools\nhave been integrated with the Isabelle proof assistant. Nitpick is\nalso available as a standalone tool that accepts TPTP THF syntax. The\nsystems are particularly valuable for exposing errors and\nmisconceptions in problem encodings, and for revealing bugs in the THF\ntheorem provers.\n5. Applications\n5.1 Semantics of Natural Language\n\nChurch\u2019s type theory plays an important role in the study of the\nformal semantics of natural language. Pioneering work on this was done\nby Richard Montague. See his papers \u201cEnglish as a formal\nlanguage\u201d, \u201cUniversal grammar\u201d, and \u201cThe\nproper treatment of quantification in ordinary English\u201d, which\nare reprinted in Montague 1974. A crucial component of\nMontague\u2019s analysis of natural language is the definition of a\ntensed intensional logic (Montague 1974: 256), which is an enhancement\nof Church\u2019s type theory. Montague Grammar had a huge impact, and\nhas since been developed in many further directions, not least in\nTypelogical/Categorical Grammar. Further related work on intensional\nand higher-order modal logic is presented in Gallin 1975 and Muskens\n2006.\n5.2 Mathematics and Computer Science\n\nProof assistants based on Church\u2019s Type Theory, including\nIsabelle/HOL, HOL Light, HOL4, and PVS, have been successfully\nutilized in a broad range of application in computer science and\nmathematics.\n\nApplications in computer science include the verification of hardware,\nsoftware and security protocols. A prominent example is the\nL4.verified project in which Isabelle/HOL was used to formally prove\nthat the seL4 operating system kernel implements an abstract,\nmathematical model specifying of what the kernel is supposed to do\n(Klein et al. 2018). \n\nIn mathematics proof assistants have been applied for the development\nof libraries mathematical theories and the verification of challenge\ntheorems. An early example is the mathematical library that was\ndeveloped since the eighties in the TPS project. A exemplary list of\ntheorems that were proved automatically with TPS is given in Andrews\net al. 1996. A very prominent recent example is Hales Flyspeck in\nwhich HOL Light was employed to develop a formal proof for\nKepler\u2019s conjecture (Hales et al. 2017). An example that\nstrongly exploits automation support in Isabelle/HOL with Sledgehammer\nand Nitpick is presented in Benzm\u00fcller & Scott forthcoming.\nIn this work different axiom systems for category theory were explored\nand compared. \n\nA solid overview on past and ongoing formalization projects can be\nobtained by consulting respective sources such as Isabelle\u2019s\nArchive of Formal Proofs, the Journal of Formalized Reasoning, or the\nTHF entries in Sutcliffe\u2019s TPTP problem library. \n\nFurther improving proof automation within these proof\nassistants\u2014based on proof hammering tools or on other forms of\nprover integration\u2014is relevant for minimizing interaction effort\nin future applications. \n5.3 Computational Metaphysics and Artificial Intelligence\n\nChurch\u2019s type theory is a Classical logic, but topical\napplications in philosophy and artificial intelligence often require\nexpressive non-classical logics. In order to support such applications\nwith reasoning tools for Church\u2019s type theory, the shallow\nsemantical embedding technique (see also\n Section 1.2.2)\n has been developed that generalizes and extends the ideas underlying\nthe well known standard translation of modal logics to first-order\nlogic. The technique was applied for the assessment of modern variants\nof the ontological argument with a range of higher-order theorem\nprovers, including LEO-II, Satallax, Nitpick and Isabelle/HOL. In the\ncourse of experiments, LEO-II detected an inconsistency in the\npremises of G\u00f6del\u2019s argument, while the provers succeeded\nin automatically proving Scott\u2019s emendation of it and to confirm\nthe consistency of the emended premises. More details on this work are\npresented in a related SEP entry on\n automated reasoning\n (see Section 4.6 on Logic and Philosophy). The semantical embedding\napproach has been adapted and further extended for a range of other\nnon-classical logics and related applications. In philosophy this\nincludes the encoding and formal assessment of ambitious ethical and\nmetaphysical theories, and in artificial intelligence this includes\nthe mechanization of deontic logics and normative reasoning as well as\nan automatic proof of the\n muddy children puzzle (see Appendix B of dynamic epistemic logic),\n which is a famous puzzle in epistemic reasoning, respectively dynamic\nepistemic reasoning.\n", "bibliography": {"categories": [], "cat_ref_text": {"ref_list": ["Andrews, Peter B., 1963, \u201cA Reduction of the Axioms for the\nTheory of Prepositional Types\u201d, <em>Fundamenta\nMathematicae</em>, 52(3): 345\u2013350. doi:10.4064/fm-52-3-345-350", "\u2013\u2013\u2013, 1971, \u201cResolution in Type\nTheory\u201d, <em>The Journal of Symbolic Logic</em>, 36(3):\n414\u2013432. Reprinted in Siekmann &amp; Wrightson 1983 and in\nBenzm\u00fcller et al. 2008. doi:10.2307/2269949\ndoi:10.1007/978-3-642-81955-1", "\u2013\u2013\u2013, 1972a, \u201cGeneral Models and\nExtensionality\u201d, <em>The Journal of Symbolic Logic</em>, 37(2):\n395\u2013397. Reprinted in Benzm\u00fcller et al. 2008.\ndoi:10.2307/2272982", "\u2013\u2013\u2013, 1972b, \u201cGeneral Models, Descriptions,\nand Choice in Type Theory\u201d, <em>The Journal of Symbolic\nLogic</em>, 37(2): 385\u2013394. Reprinted in Benzm\u00fcller et al.\n2008. doi:10.2307/2272981", "\u2013\u2013\u2013, 1974, \u201cProvability in Elementary Type\nTheory\u201d, <em>Zeitschrift f\u00fcr Mathematische Logik und\nGrundlagen der Mathematik</em>, 20(25\u201327): 411\u2013418.\ndoi:10.1002/malq.19740202506", "\u2013\u2013\u2013, 1981, \u201cTheorem Proving via General\nMappings\u201d, <em>Journal of the ACM</em>, 28(2): 193\u2013214.\ndoi:10.1145/322248.322249", "\u2013\u2013\u2013, 2001, \u201cClassical Type Theory\u201d,\nin Robinson and Voronkov 2001, Volume 2, Chapter 15, pp.\n965\u20131007. doi:10.1016/B978-044450813-3/50017-5", "\u2013\u2013\u2013, 2002, <em>An Introduction to Mathematical\nLogic and Type Theory: To Truth Through Proof</em>, (Applied Logic\nSeries 27), second edition, Dordrecht: Springer Netherlands.\ndoi:10.1007/978-94-015-9934-4", "Andrews, Peter B., Matthew Bishop, Sunil Issar, Dan Nesmith, Frank\nPfenning, and Hongwei Xi, 1996, \u201cTPS: A Theorem-Proving System\nfor Classical Type Theory\u201d, <em>Journal of Automated\nReasoning</em>, 16(3): 321\u2013353. Reprinted in Benzm\u00fcller et al.\n2008. doi:10.1007/BF00252180", "Andrews, Peter B. and Chad E. Brown, 2006, \u201cTPS: A Hybrid\nAutomatic-Interactive System for Developing Proofs\u201d, <em>Journal\nof Applied Logic</em>, 4(4): 367\u2013395.\ndoi:10.1016/j.jal.2005.10.002", "Baader, Franz and Wayne Snyder, 2001, \u201cUnification\nTheory\u201d, in Robinson and Voronkov 2001, Volume 1, Chapter 8,\nAmsterdam: Elsevier Science, pp. 445\u2013533.\ndoi:10.1016/B978-044450813-3/50010-2", "Backes, Julian and Chad Edward Brown, 2011, \u201cAnalytic\nTableaux for Higher-Order Logic with Choice\u201d, <em>Journal of\nAutomated Reasoning</em>, 47(4): 451\u2013479.\ndoi:10.1007/s10817-011-9233-2", "Barendregt, H. P., 1984, <em>The Lambda Calculus: Its Syntax and\nSemantics</em>, (Studies in Logic and the Foundations of Mathematics,\n103), revised edition, Amsterdam: North-Holland.", "Barendregt, Henk, Wil Dekkers, and Richard Statman, 2013,\n<em>Lambda Calculus with Types</em>, Cambridge: Cambridge University\nPress. doi:10.1017/CBO9781139032636", "Bentkamp, Alexander, Jasmin Christian Blanchette, Simon Cruanes,\nand Uwe Waldmann, 2018, \u201cSuperposition for Lambda-Free\nHigher-Order Logic\u201d, in Galmiche et al. 2018: 28\u201346.\ndoi:10.1007/978-3-319-94205-6_3", "Benzm\u00fcller, Christoph, 1997, <em>A Calculus and a System\nArchitecture for Extensional Higher-Order Resolution</em>, Technical\nreport 97\u2013198, Department of Mathematical Sciences, Carnegie Mellon\nUniversity. doi:10.1184/r1/6476477.v1", "\u2013\u2013\u2013, 1999a, <em>Equality and Extensionality in\nAutomated Higher-Order Theorem Proving</em>, Ph.D. dissertation,\nComputer Science Department, Universit\u00e4t des Saarlandes.", "\u2013\u2013\u2013, 1999b, \u201cExtensional Higher-Order\nParamodulation and RUE-Resolution\u201d, in Ganzinger 1999:\n399\u2013413. doi:10.1007/3-540-48660-7_39", "\u2013\u2013\u2013, 2019, \u201cUniversal (Meta-)Logical\nReasoning: Recent Successes\u201d, <em>Science of Computer\nProgramming</em>, 172: 48\u201362. doi:10.1016/j.scico.2018.10.008", "Benzm\u00fcller, Christoph and Michael Kohlhase, 1997,\n\u201cModel Existence for Higher Order Logic\u201d. SEKI Report\nSR-97-09.", "\u2013\u2013\u2013, 1998a, \u201cExtensional Higher-Order\nResolution\u201d, Kirchner and Kirchner 1998: 56\u201371.\ndoi:10.1007/BFb0054248", "\u2013\u2013\u2013, 1998b, \u201cSystem Description:\nLeo\u2014A Higher-Order Theorem Prover\u201d, in Kirchner and\nKirchner 1998: 139\u2013143. doi:10.1007/BFb0054256", "Benzm\u00fcller, Christoph, Chad E. Brown, and Michael Kohlhase,\n2004, \u201cHigher-Order Semantics and Extensionality\u201d, <em>The\nJournal of Symbolic Logic</em>, 69(4): 1027\u20131088.\ndoi:10.2178/jsl/1102022211", "\u2013\u2013\u2013, 2009, \u201cCut-Simulation and\nImpredicativity\u201d, <em>Logical Methods in Computer Science</em>,\n5(1): 6. doi:10.2168/LMCS-5(1:6)2009", "Benzm\u00fcller, Christoph, Chad E. Brown, J\u00f6rg Siekmann, and\nRichard Statman (eds.), 2008, <em>Reasoning in Simple Type Theory:\nFestschrift in Honour of Peter B. Andrews on His 70th Birthday</em>,\n(Studies in Logic 17), London: College Publications.", "Benzm\u00fcller, Christoph and Dale Miller, 2014,\n\u201cAutomation of Higher Order Logic\u201d, in <em>Computational\nLogic</em>, (Handbook of the History of Logic, 9), Dov M. Gabbay,\nJ\u00f6rg H. Siekmann, and John Woods (eds.), Amsterdam: Elsevier,\n215\u2013254.", "Benzm\u00fcller, Christoph, Nik Sultana, Lawrence C. Paulson, and\nFrank Thei\u00df, 2015, \u201cThe Higher-Order Prover Leo-II\u201d,\n<em>Journal of Automated Reasoning</em>, 55(4): 389\u2013404.\ndoi:10.1007/s10817-015-9348-y", "Benzm\u00fcller, Christoph and Dana S. Scott, forthcoming,\n\u201cAutomating Free Logic in HOL, with an Experimental Application\nin Category Theory\u201d, <em>Journal of Automated Reasoning</em>,\nFirst online: 1 January 2019. doi:10.1007/s10817-018-09507-7", "Benzm\u00fcller, Christoph and Bruno Woltzenlogel Paleo, 2014,\n\u201cAutomating G\u00f6del\u2019s Ontological Proof of God\u2019s\nExistence with Higher-Order Automated Theorem Provers\u201d, in\n<em>Proceedings of the Twenty-First European Conference on Artificial\nIntelligence (ECAI 2014)</em>, T. Schaub, G. Friedrich, and B.\nO\u2019Sullivan (eds.), (Frontiers in Artificial Intelligence 263),\nAmsterdam: IOS Press, 93\u201398. doi:10.3233/978-1-61499-419-0-93", "Bertot, Yves and Pierre Cast\u00e9ran, 2004, <em>Interactive\nTheorem Proving and Program Development: Coq\u2019Art: The Calculus\nof Inductive Constructions</em>, (Texts in Theoretical Computer\nScience An EATCS Series), Berlin, Heidelberg: Springer Berlin\nHeidelberg. doi:10.1007/978-3-662-07964-5", "Bibel, Wolfgang, 1981, \u201cOn Matrices with Connections\u201d,\n<em>Journal of the ACM</em>, 28(4): 633\u2013645.\ndoi:10.1145/322276.322277", "Bishop, Matthew, 1999, \u201cA Breadth-First Strategy for Mating\nSearch\u201d, in Ganzinger 1999: 359\u2013373.\ndoi:10.1007/3-540-48660-7_32", "Blanchette, Jasmin Christian and Tobias Nipkow, 2010,\n\u201cNitpick: A Counterexample Generator for Higher-Order Logic\nBased on a Relational Model Finder\u201d, in <em>Interactive Theorem\nProving</em>, Matt Kaufmann and Lawrence C. Paulson (eds.), (Lecture\nNotes in Computer Science 6172), Berlin, Heidelberg: Springer Berlin\nHeidelberg, 131\u2013146. doi:10.1007/978-3-642-14052-5_11", "Blanchette, Jasmin Christian, Sascha B\u00f6hme, and Lawrence C.\nPaulson, 2013, \u201cExtending Sledgehammer with SMT Solvers\u201d,\n<em>Journal of Automated Reasoning</em>, 51(1): 109\u2013128.\ndoi:10.1007/s10817-013-9278-5", "Boolos, George, 1987, \u201cA Curious Inference\u201d,\n<em>Journal of Philosophical Logic</em>, 16(1): 1\u201312.\ndoi:10.1007/BF00250612", "Brown, Chad E., 2004, \u201cSet Comprehension in Church\u2019s\nType Theory\u201d, PhD Thesis, Department of Mathematical Sciences,\nCarnegie Mellon University, Pittsburgh, PA.", "\u2013\u2013\u2013, 2007, <em>Automated Reasoning in\nHigher-Order Logic: Set Comprehension and Extensionality in Church`s\nType Theory</em>, (Studies in Logic Logic and Cognitive Systems 10),\nLondon: King\u2019s College Publications.", "\u2013\u2013\u2013, 2012, \u201cSatallax: An Automatic\nHigher-Order Prover\u201d, in <em>Automated Reasoning (IJCAR\n2012)</em>, Bernhard Gramlich, Dale Miller, and Uli Sattler (eds.)\n(Lecture Notes in Computer Science 7364), Berlin, Heidelberg: Springer\nBerlin Heidelberg, 111\u2013117. doi:10.1007/978-3-642-31365-3_11", "Brown, Chad and Gert Smolka, 2010, \u201cAnalytic Tableaux for\nSimple Type Theory and Its First-Order Fragment\u201d, <em>Logical\nMethods in Computer Science</em>, 6(2): 3.\ndoi:10.2168/LMCS-6(2:3)2010", "B\u00fcchi, J. Richard, 1953, \u201cInvestigation of the\nEquivalence of the Axiom of Choice and Zorn\u2019s Lemma from the\nViewpoint of the Hierarchy of Types\u201d, <em>The Journal of\nSymbolic Logic</em>, 18(2): 125\u2013135. doi:10.2307/2268945", "Church, Alonzo, 1932, \u201cA Set of Postulates for the\nFoundation of Logic\u201d, <em>The Annals of Mathematics</em>, 33(2):\n346\u2013366. doi:10.2307/1968337", "\u2013\u2013\u2013, 1940, \u201cA Formulation of the Simple\nTheory of Types\u201d, <em>The Journal of Symbolic Logic</em>, 5(2):\n56\u201368. Reprinted in Benzm\u00fcller et al. 2008.\ndoi:10.2307/2266170", "\u2013\u2013\u2013, 1941, <em>The Calculi of Lambda\nConversion</em>, (Annals of Mathematics Studies 6), Princeton, NJ:\nPrinceton University Press.", "\u2013\u2013\u2013, 1956, <em>Introduction to Mathematical\nLogic</em>, Princeton, NJ: Princeton University Press.", "Czajka, \u0141ukasz and Cezary Kaliszyk, 2018, \u201cHammer for\nCoq: Automation for Dependent Type Theory\u201d, <em>Journal of\nAutomated Reasoning</em>, 61(1\u20134): 423\u2013453.\ndoi:10.1007/s10817-018-9458-4", "Dowek, Gilles, 2001, \u201cHigher-Order Unification and\nMatching\u201d, in Robinson and Voronkov 2001, Volume 2, Chapter 16,\nAmsterdam: Elsevier Science, pp. 1009\u20131062.\ndoi:10.1016/B978-044450813-3/50018-7", "Dowek, Gilles and Benjamin Werner, 2003, \u201cProof\nNormalization Modulo\u201d, <em>The Journal of Symbolic Logic</em>,\n68(4): 1289\u20131316. doi:10.2178/jsl/1067620188", "Farmer, William M., 2008, \u201cThe Seven Virtues of Simple Type\nTheory\u201d, <em>Journal of Applied Logic</em>, 6(3): 267\u2013286.\ndoi:10.1016/j.jal.2007.11.001", "Farmer, William M., Joshua D. Guttman, and F. Javier Thayer, 1993,\n\u201cIMPS: An Interactive Mathematical Proof System\u201d,\n<em>Journal of Automated Reasoning</em>, 11(2): 213\u2013248.\ndoi:10.1007/BF00881906", "Gallin, Daniel, 1975, <em>Intensional and Higher-Order Modal\nLogic</em>, Amsterdam: North-Holland.", "Galmiche, Didier, Stephan Schulz, and Roberto Sebastiani (eds.),\n2018, <em>Automated Reasoning (IJCAR 2018)</em>, (Lecture Notes in\nComputer Science 10900), Cham: Springer International Publishing.\ndoi:10.1007/978-3-319-94205-6", "Ganzinger, Harald (ed.), 1999, <em>Automated\nDeduction\u2014CADE-16</em>, (Lecture Notes in Computer Science,\n1632), Berlin, Heidelberg: Springer Berlin Heidelberg.\ndoi:10.1007/3-540-48660-7", "G\u00f6del, Kurt, 1931, \u201c\u00dcber formal unentscheidbare\nS\u00e4tze der Principia Mathematica und verwandter Systeme I\u201d,\n<em>Monatshefte f\u00fcr Mathematik und Physik</em>, 38(1):\n173\u2013198. Translated in G\u00f6del 1986: 144\u2013195, and in\nvan Heijenoort 1967: 596\u2013616.", "\u2013\u2013\u2013, 1986, <em>Collected Works</em>, Volume I,\nOxford: Oxford University Press.", "Goldfarb, Warren D., 1981, \u201cThe Undecidability of the\nSecond-Order Unification Problem\u201d, <em>Theoretical Computer\nScience</em>, 13(2): 225\u2013230. doi:10.1016/0304-3975(81)90040-2", "Gordon, Michael J. C., 1986, \u201cWhy Higher-Order Logic is a\nGood Formalism for Specifying and Verifying Hardware\u201d, in George\nJ. Milne, and P. A. Subrahmanyam (eds.), <em>Formal Aspects of VLSI\nDesign: Proceedings of the 1985 Edinburgh Workshop on VLSI</em>,\nAmsterdam: North-Holland, pp. 153\u2013177.", "\u2013\u2013\u2013, 1988, \u201cHOL: A Proof Generating System\nfor Higher-Order Logic\u201d, in <em>VLSI Specification, Verification\nand Synthesis</em>, Graham Birtwistle and P. A. Subrahmanyam (eds.),\n(The Kluwer International Series in Engineering and Computer Science\n\n35), Boston, MA: Springer US, 73\u2013128.\ndoi:10.1007/978-1-4613-2007-4_3", "Gordon, M. J., and T. F. Melham, 1993, <em>Introduction to HOL: A\nTheorem-Proving Environment for Higher-Order Logic</em>, Cambridge:\nCambridge University Press.", "Gould, William Eben, 1966, <em>A Matching Procedure for\n\\(\\omega\\)-order Logic</em>, Ph.D. dissertation, Mathematics\nDepartment, Princeton University.\n [<a href=\"https://apps.dtic.mil/dtic/tr/fulltext/u2/646560.pdf\" target=\"other\">Gould 1966 available online</a>]", "Hales, Thomas, Mark Adams, Gertrud Bauer, Tat Dat Dang, John\nHarrison, Le Truong Hoang, Cezary Kaliszyk, et al., 2017, \u201cA\nFormal Proof of the Kepler Conjecture\u201d, <em>Forum of\nMathematics, Pi</em>, 5: e2. doi:10.1017/fmp.2017.1", "Harrison, John, 1996, \u201cHOL Light: A Tutorial\nIntroduction\u201d, in <em>Formal Methods in Computer-Aided\nDesign</em>, Mandayam Srivas and Albert Camilleri (eds.), (Lecture\nNotes in Computer Science 1166), Berlin, Heidelberg: Springer Berlin\nHeidelberg, 265\u2013269. doi:10.1007/BFb0031814", "Henkin, Leon, 1950, \u201cCompleteness in the Theory of\nTypes\u201d, <em>The Journal of Symbolic Logic</em>, 15(2): 81\u201391.\nReprinted in Hintikka 1969 and in Benzm\u00fcller et al. 2008.\ndoi:10.2307/2266967", "\u2013\u2013\u2013, 1963, \u201cA Theory of Prepositional\nTypes\u201d, <em>Fundamenta Mathematicae</em>, 52(3): 323\u2013344.\ndoi:10.4064/fm-52-3-323-344", "\u2013\u2013\u2013, 1975, \u201cIdentity as a Logical\nPrimitive\u201d, <em>Philosophia</em>, 5(1\u20132): 31\u201345.\ndoi:10.1007/BF02380832", "Hilbert, David, 1928, \u201cDie Grundlagen der Mathematik\u201d,\n<em>Abhandlungen aus dem mathematischen Seminar der Hamburgischen\nUniversit\u00e4t</em>, 6: 65\u201385; translated in van Heijenoort\n1967: 464\u2013479.", "Hintikka, Jaakko (ed.), 1969, <em>The Philosophy of\nMathematics</em>, Oxford: Oxford University Press.", "Huet, Gerald P., 1973a, \u201cA Mechanization of Type\nTheory\u201d, in <em>Proceedings of the Third International Joint\nConference on Artificial Intelligence</em> (Stanford University), D.\nE. Walker and L. Norton (eds.), Los Altos, CA: William Kaufman,\n139\u2013146.\n [<a href=\"https://www.ijcai.org/Proceedings/73/Papers/016.pdf\" target=\"other\">Huet 1973a available online</a>]", "\u2013\u2013\u2013, 1973b, \u201cThe Undecidability of\nUnification in Third Order Logic\u201d, <em>Information and\nControl</em>, 22(3): 257\u2013267. doi:10.1016/S0019-9958(73)90301-X", "\u2013\u2013\u2013, 1975, \u201cA Unification Algorithm for\nTyped \u03bb-Calculus\u201d, <em>Theoretical Computer Science</em>,\n1(1): 27\u201357. doi:10.1016/0304-3975(75)90011-0", "Jensen, D.C. and T. Pietrzykowski, 1976, \u201cMechanizing\n\u03c9-Order Type Theory through Unification\u201d, <em>Theoretical\nComputer Science</em>, 3(2): 123\u2013171.\ndoi:10.1016/0304-3975(76)90021-9", "Kaliszyk, Cezary and Josef Urban, 2015, \u201cHOL(y)Hammer:\nOnline ATP Service for HOL Light\u201d, <em>Mathematics in Computer\nScience</em>, 9(1): 5\u201322. doi:10.1007/s11786-014-0182-0", "Kirchner, Claude and H\u00e9l\u00e8ne Kirchner (eds.), 1998,\n<em>Automated Deduction\u2014CADE-15</em>, (Lecture Notes in Computer\nScience, 1421), Berlin, Heidelberg: Springer Berlin Heidelberg.\ndoi:10.1007/BFb0054239", "Klein, Gerwin, June Andronick, Matthew Fernandez, Ihor Kuz, Toby\nMurray, and Gernot Heiser, 2018, \u201cFormally Verified Software in\nthe Real World\u201d, <em>Communications of the ACM</em>, 61(10):\n68\u201377. doi:10.1145/3230627", "Kohlhase, Michael, 1993, \u201cA Unifying Principle for\nExtensional Higher-Order Logic\u201d, Technical Report 93\u2013153,\nDepartment of Mathematics, Carnegie Mellon University.", "\u2013\u2013\u2013, 1995, \u201cHigher-Order Tableaux\u201d,\nin <em>Theorem Proving with Analytic Tableaux and Related\nMethods</em>, Peter Baumgartner, Reiner H\u00e4hnle, and Joachim\nPossega (eds.), (Lecture Notes in Computer Science 918), Berlin,\nHeidelberg: Springer Berlin Heidelberg, 294\u2013309.\ndoi:10.1007/3-540-59338-1_43", "\u2013\u2013\u2013, 1998, \u201cHigher-Order Automated Theorem\nProving\u201d, in <em>Automated Deduction\u2014A Basis for\nApplications</em>, Volume 1, Wolfgang Bibel and Peter H. Schmitt\n(eds.), Dordrecht: Kluwer, 431\u2013462.", "Konrad, Karsten, 1998, \u201cHot: A Concurrent Automated Theorem\nProver Based on Higher-Order Tableaux\u201d, in <em>Theorem Proving\nin Higher Order Logics</em>, Jim Grundy and Malcolm Newey (eds.),\n(Lecture Notes in Computer Science 1479), Berlin, Heidelberg: Springer\nBerlin Heidelberg, 245\u2013261. doi:10.1007/BFb0055140", "Maslov, S. Yu, 1967, \u201cAn Inverse Method for Establishing\nDeducibility of Nonprenex Formulas of Predicate Calculus\u201d,\n<em>Soviet Mathematics Doklady</em>, 8(1): 16\u201319.", "Miller, Dale A., 1983, <em>Proofs in Higher-Order Logic</em>,\nPh.D. dissertation, Mathematics Department, Carnegie Mellon\nUniversity.", "\u2013\u2013\u2013, 1987, \u201cA Compact Representation of\nProofs\u201d, <em>Studia Logica</em>, 46(4): 347\u2013370.\ndoi:10.1007/BF00370646", "\u2013\u2013\u2013, 1991, \u201cA Logic Programming Language\nwith Lambda-Abstraction, Function Variables, and Simple\nUnification\u201d, <em>Journal of Logic and Computation</em>, 1(4):\n497\u2013536. doi:10.1093/logcom/1.4.497", "Mints, G., 1999, \u201cCut-Elimination for Simple Type Theory\nwith an Axiom of Choice\u201d, <em>The Journal of Symbolic\nLogic</em>, 64(2): 479\u2013485. doi:10.2307/2586480", "Montague, Richard, 1974, <em>Formal Philosophy. Selected Papers Of\nRichard Montague</em>, edited and with an introduction by Richmond H.\nThomason, New Haven: Yale University Press.", "Muskens, Reinhard, 2006, \u201cHigher Order Modal Logic\u201d,\nin <em>Handbook of Modal Logic</em>, Patrick Blackburn, Johan Van\nBenthem, and Frank Wolter (eds.), Amsterdam: Elsevier,\n621\u2013653.", "\u2013\u2013\u2013, 2007, \u201cIntensional Models for the\nTheory of Types\u201d, <em>The Journal of Symbolic Logic</em>, 72(1):\n98\u2013118. doi:10.2178/jsl/1174668386", "Nipkow, Tobias, Markus Wenzel, and Lawrence C. Paulson (eds.),\n2002, <em>Isabelle/HOL: A Proof Assistant for Higher-Order Logic</em>,\n(Lecture Notes in Computer Science 2283), Berlin, Heidelberg: Springer\nBerlin Heidelberg. doi:10.1007/3-540-45949-9", "Owre, S., S. Rajan, J. M. Rushby, N. Shankar, and M. Srivas, 1996,\n\u201cPVS: Combining Specification, Proof Checking, and Model\nChecking\u201d, in <em>Computer Aided Verification</em>, Rajeev Alur\nand Thomas A. Henzinger (eds.), (Lecture Notes in Computer Science\n1102), Berlin, Heidelberg: Springer Berlin Heidelberg, 411\u2013414.\ndoi:10.1007/3-540-61474-5_91", "Paulson, Lawrence C, 1988, \u201cIsabelle: The next Seven Hundred\nTheorem Provers\u201d, in <em>9th International Conference on\nAutomated Deduction</em>, Ewing Lusk and Ross Overbeek (eds.),\n(Lecture Notes in Computer Science 310), Berlin/Heidelberg:\nSpringer-Verlag, 772\u2013773. doi:10.1007/BFb0012891", "\u2013\u2013\u2013, 1990, \u201cA Formulation of the Simple\nTheory of Types (for Isabelle)\u201d, in <em>COLOG-88</em>, Per\nMartin-L\u00f6f and Grigori Mints (eds.), (Lecture Notes in Computer\nScience 417), Berlin, Heidelberg: Springer Berlin Heidelberg,\n246\u2013274. doi:10.1007/3-540-52335-9_58", "Prawitz, Dag, 1968, \u201cHauptsatz for Higher Order\nLogic\u201d, <em>The Journal of Symbolic Logic</em>, 33(3):\n452\u2013457. doi:10.2307/2270331", "Quine, W. V., 1956, \u201cUnification of Universes in Set\nTheory\u201d, <em>The Journal of Symbolic Logic</em>, 21(3):\n267\u2013279. doi:10.2307/2269102", "Richardson, Julian, Alan Smaill, and Ian Green, 1998,\n\u201cSystem Description: Proof Planning in Higher-Order Logic with\n\u039bClam\u201d, in Kirchner and Kirchner 1998: 129\u2013133.\ndoi:10.1007/BFb0054254", "Robinson, Alan and Andrei Voronkov (eds.), 2001, <em>Handbook of\nAutomated Reasoning</em>, Volumes 1 and 2, Amsterdam: Elsevier\nScience.", "Russell, Bertrand, 1903, <em>The Principles of Mathematics</em>,\nCambridge: Cambridge University Press.", "\u2013\u2013\u2013, 1908, \u201cMathematical Logic as Based on\nthe Theory of Types\u201d, <em>American Journal of Mathematics</em>,\n30(3): 222\u2013262. Reprinted in van Heijenoort 1967: 150\u2013182.\ndoi:10.2307/2369948", "Sch\u00f6nfinkel, M., 1924, \u201c\u00dcber die Bausteine der\nmathematischen Logik\u201d, <em>Mathematische Annalen</em>,\n92(3\u20134): 305\u2013316. Translated in van Heijenoort 1967: 355\u2013366.\ndoi:10.1007/BF01448013", "Sch\u00fctte, Kurt, 1960, \u201cSyntactical and Semantical\nProperties of Simple Type Theory\u201d, <em>The Journal of Symbolic\nLogic</em>, 25(4): 305\u2013326. doi:10.2307/2963525", "Shankar, Natarajan, 2001, \u201cUsing Decision Procedures with a\nHigher-Order Logic\u201d, in <em>Theorem Proving in Higher Order\nLogics</em>, Richard J. Boulton and Paul B. Jackson (eds.), (Lecture\nNotes in Computer Science 2152), Berlin, Heidelberg: Springer Berlin\nHeidelberg, 5\u201326. doi:10.1007/3-540-44755-5_3", "Siekmann, J\u00f6rg H. and Graham Wrightson (eds.), 1983,\n<em>Automation of Reasoning</em>, (Classical Papers on Computational\nLogic 1967\u20131970: Vol. 2), Berlin, Heidelberg: Springer Berlin\nHeidelberg. doi:10.1007/978-3-642-81955-1", "Siekmann, J\u00f6rg, Christoph Benzm\u00fcller, and Serge\nAutexier, 2006, \u201cComputer Supported Mathematics with\n\u03a9MEGA\u201d, <em>Journal of Applied Logic</em>, 4(4):\n533\u2013559. doi:10.1016/j.jal.2005.10.008", "Smullyan, Raymond M., 1963, \u201cA Unifying Principal in\nQuantification Theory\u201d, <em>Proceedings of the National Academy\nof Sciences</em>, 49(6): 828\u2013832. doi:10.1073/pnas.49.6.828", "\u2013\u2013\u2013, 1995, <em>First-Order Logic</em>, New York:\nDover, second corrected edition.", "Steen, Alexander, 2018, <em>Extensional Paramodulation for\nHigher-Order Logic and its Effective Implementation Leo-III</em>,\nPh.D. dissertation, Series: Dissertations in Artificial Intelligence\n(DISKI), Volume 345, Berlin: AKA-Verlag (IOS Press).", "Steen, Alexander and Christoph Benzm\u00fcller, 2018, \u201cThe\nHigher-Order Prover Leo-III\u201d, in Galmiche et al. 2018:\n108\u2013116. doi:10.1007/978-3-319-94205-6_8", "Stenlund, S\u00f6ren, 1972, <em>Combinators, \u03bb-Terms and\nProof Theory</em>, (Synthese Library 42), Dordrecht: Springer\nNetherlands. doi:10.1007/978-94-010-2913-1", "Sutcliffe, Geoff, 2016, \u201cThe CADE ATP System\nCompetition\u2014CASC\u201d, <em>AI Magazine</em>, 37(2): 99\u2013101.\ndoi:10.1609/aimag.v37i2.2620", "\u2013\u2013\u2013, 2017, \u201cThe TPTP Problem Library and\nAssociated Infrastructure: From CNF to TH0, TPTP v6.4.0\u201d,\n<em>Journal of Automated Reasoning</em>, 59(4): 483\u2013502.\ndoi:10.1007/s10817-017-9407-7", "Sutcliffe, Geoff and Christoph Benzm\u00fcller, 2010,\n\u201cAutomated Reasoning in Higher-Order Logic Using the TPTP THF\nInfrastructure\u201d, <em>Journal of Formalized Reasoning</em>, 3(1):\n1\u201327. doi:10.6092/issn.1972-5787/1710", "Takahashi, Moto-o, 1967, \u201cA Proof of Cut-Elimination Theorem\nin Simple Type-Theory\u201d, <em>Journal of the Mathematical Society\nof Japan</em>, 19(4): 399\u2013410. doi:10.2969/jmsj/01940399", "\u2013\u2013\u2013, 1970, \u201cA System of Simple Type Theory\nof Gentzen Style with Inference on Extensionality, and the Cut\nElimination in It\u201d, <em>Commentarii Mathematici Universitatis\nSancti Pauli</em>, 18(2):129\u2013147.", "Takeuti, Gaisi, 1987, <em>Proof Theory</em>, second edition,\nAmsterdam: North-Holland.", "Tarski, Alfred [Tajtelbaum, Alfred], 1923, \u201cSur Le Terme\nPrimitif de La Logistique\u201d, <em>Fundamenta Mathematicae</em>, 4:\n196\u2013200. Translated in Tarski 1956, 1\u201323.\ndoi:10.4064/fm-4-1-196-200", "\u2013\u2013\u2013, 1956, <em>Logic, Semantics,\nMetamathematics: Papers from 1923 to 1938</em>, Oxford: Oxford\nUniversity Press.", "van Heijenoort, Jean, 1967, <em>From Frege to G\u00f6del. A Source\nBook in Mathematical Logic 1879\u20131931</em>, Cambridge, MA:\nHarvard University Press.", "Whitehead, Alfred N. and Bertrand Russell, 1927a, <em>Principia\nMathematica</em>, Volume 1, Cambridge: Cambridge University Press,\nsecond edition.", "\u2013\u2013\u2013, 1927b, \u201cIncomplete Symbols\u201d, in\nWhitehead &amp; Russell 1927a: 66\u201384; reprinted in van\nHeijenoort 1967: 216\u2013223.", "Yasuhara, Mitsuru, 1975, \u201cThe Axiom of Choice in\nChurch\u2019s Type Theory\u201d (abstract), <em>Notices of the\nAmerican Mathematical Society</em>, 22(January): A34.\n [<a href=\"https://www.ams.org/journals/notices/197501/197501FullIssue.pdf\" target=\"other\">Yashuhara 1975 available online</a>]"]}, "raw_text": "<div id=\"bibliography\">\n<h2 id=\"Bib\">Bibliography</h2>\n<ul class=\"hanging\">\n<li>Andrews, Peter B., 1963, \u201cA Reduction of the Axioms for the\nTheory of Prepositional Types\u201d, <em>Fundamenta\nMathematicae</em>, 52(3): 345\u2013350. doi:10.4064/fm-52-3-345-350</li>\n<li>\u2013\u2013\u2013, 1971, \u201cResolution in Type\nTheory\u201d, <em>The Journal of Symbolic Logic</em>, 36(3):\n414\u2013432. Reprinted in Siekmann &amp; Wrightson 1983 and in\nBenzm\u00fcller et al. 2008. doi:10.2307/2269949\ndoi:10.1007/978-3-642-81955-1</li>\n<li>\u2013\u2013\u2013, 1972a, \u201cGeneral Models and\nExtensionality\u201d, <em>The Journal of Symbolic Logic</em>, 37(2):\n395\u2013397. Reprinted in Benzm\u00fcller et al. 2008.\ndoi:10.2307/2272982</li>\n<li>\u2013\u2013\u2013, 1972b, \u201cGeneral Models, Descriptions,\nand Choice in Type Theory\u201d, <em>The Journal of Symbolic\nLogic</em>, 37(2): 385\u2013394. Reprinted in Benzm\u00fcller et al.\n2008. doi:10.2307/2272981</li>\n<li>\u2013\u2013\u2013, 1974, \u201cProvability in Elementary Type\nTheory\u201d, <em>Zeitschrift f\u00fcr Mathematische Logik und\nGrundlagen der Mathematik</em>, 20(25\u201327): 411\u2013418.\ndoi:10.1002/malq.19740202506</li>\n<li>\u2013\u2013\u2013, 1981, \u201cTheorem Proving via General\nMappings\u201d, <em>Journal of the ACM</em>, 28(2): 193\u2013214.\ndoi:10.1145/322248.322249</li>\n<li>\u2013\u2013\u2013, 2001, \u201cClassical Type Theory\u201d,\nin Robinson and Voronkov 2001, Volume 2, Chapter 15, pp.\n965\u20131007. doi:10.1016/B978-044450813-3/50017-5</li>\n<li>\u2013\u2013\u2013, 2002, <em>An Introduction to Mathematical\nLogic and Type Theory: To Truth Through Proof</em>, (Applied Logic\nSeries 27), second edition, Dordrecht: Springer Netherlands.\ndoi:10.1007/978-94-015-9934-4</li>\n<li>Andrews, Peter B., Matthew Bishop, Sunil Issar, Dan Nesmith, Frank\nPfenning, and Hongwei Xi, 1996, \u201cTPS: A Theorem-Proving System\nfor Classical Type Theory\u201d, <em>Journal of Automated\nReasoning</em>, 16(3): 321\u2013353. Reprinted in Benzm\u00fcller et al.\n2008. doi:10.1007/BF00252180</li>\n<li>Andrews, Peter B. and Chad E. Brown, 2006, \u201cTPS: A Hybrid\nAutomatic-Interactive System for Developing Proofs\u201d, <em>Journal\nof Applied Logic</em>, 4(4): 367\u2013395.\ndoi:10.1016/j.jal.2005.10.002</li>\n<li>Baader, Franz and Wayne Snyder, 2001, \u201cUnification\nTheory\u201d, in Robinson and Voronkov 2001, Volume 1, Chapter 8,\nAmsterdam: Elsevier Science, pp. 445\u2013533.\ndoi:10.1016/B978-044450813-3/50010-2</li>\n<li>Backes, Julian and Chad Edward Brown, 2011, \u201cAnalytic\nTableaux for Higher-Order Logic with Choice\u201d, <em>Journal of\nAutomated Reasoning</em>, 47(4): 451\u2013479.\ndoi:10.1007/s10817-011-9233-2</li>\n<li>Barendregt, H. P., 1984, <em>The Lambda Calculus: Its Syntax and\nSemantics</em>, (Studies in Logic and the Foundations of Mathematics,\n103), revised edition, Amsterdam: North-Holland.</li>\n<li>Barendregt, Henk, Wil Dekkers, and Richard Statman, 2013,\n<em>Lambda Calculus with Types</em>, Cambridge: Cambridge University\nPress. doi:10.1017/CBO9781139032636</li>\n<li>Bentkamp, Alexander, Jasmin Christian Blanchette, Simon Cruanes,\nand Uwe Waldmann, 2018, \u201cSuperposition for Lambda-Free\nHigher-Order Logic\u201d, in Galmiche et al. 2018: 28\u201346.\ndoi:10.1007/978-3-319-94205-6_3</li>\n<li>Benzm\u00fcller, Christoph, 1997, <em>A Calculus and a System\nArchitecture for Extensional Higher-Order Resolution</em>, Technical\nreport 97\u2013198, Department of Mathematical Sciences, Carnegie Mellon\nUniversity. doi:10.1184/r1/6476477.v1</li>\n<li>\u2013\u2013\u2013, 1999a, <em>Equality and Extensionality in\nAutomated Higher-Order Theorem Proving</em>, Ph.D. dissertation,\nComputer Science Department, Universit\u00e4t des Saarlandes.</li>\n<li>\u2013\u2013\u2013, 1999b, \u201cExtensional Higher-Order\nParamodulation and RUE-Resolution\u201d, in Ganzinger 1999:\n399\u2013413. doi:10.1007/3-540-48660-7_39</li>\n<li>\u2013\u2013\u2013, 2019, \u201cUniversal (Meta-)Logical\nReasoning: Recent Successes\u201d, <em>Science of Computer\nProgramming</em>, 172: 48\u201362. doi:10.1016/j.scico.2018.10.008</li>\n<li>Benzm\u00fcller, Christoph and Michael Kohlhase, 1997,\n\u201cModel Existence for Higher Order Logic\u201d. SEKI Report\nSR-97-09.</li>\n<li>\u2013\u2013\u2013, 1998a, \u201cExtensional Higher-Order\nResolution\u201d, Kirchner and Kirchner 1998: 56\u201371.\ndoi:10.1007/BFb0054248</li>\n<li>\u2013\u2013\u2013, 1998b, \u201cSystem Description:\nLeo\u2014A Higher-Order Theorem Prover\u201d, in Kirchner and\nKirchner 1998: 139\u2013143. doi:10.1007/BFb0054256</li>\n<li>Benzm\u00fcller, Christoph, Chad E. Brown, and Michael Kohlhase,\n2004, \u201cHigher-Order Semantics and Extensionality\u201d, <em>The\nJournal of Symbolic Logic</em>, 69(4): 1027\u20131088.\ndoi:10.2178/jsl/1102022211</li>\n<li>\u2013\u2013\u2013, 2009, \u201cCut-Simulation and\nImpredicativity\u201d, <em>Logical Methods in Computer Science</em>,\n5(1): 6. doi:10.2168/LMCS-5(1:6)2009</li>\n<li>Benzm\u00fcller, Christoph, Chad E. Brown, J\u00f6rg Siekmann, and\nRichard Statman (eds.), 2008, <em>Reasoning in Simple Type Theory:\nFestschrift in Honour of Peter B. Andrews on His 70th Birthday</em>,\n(Studies in Logic 17), London: College Publications.</li>\n<li>Benzm\u00fcller, Christoph and Dale Miller, 2014,\n\u201cAutomation of Higher Order Logic\u201d, in <em>Computational\nLogic</em>, (Handbook of the History of Logic, 9), Dov M. Gabbay,\nJ\u00f6rg H. Siekmann, and John Woods (eds.), Amsterdam: Elsevier,\n215\u2013254.</li>\n<li>Benzm\u00fcller, Christoph, Nik Sultana, Lawrence C. Paulson, and\nFrank Thei\u00df, 2015, \u201cThe Higher-Order Prover Leo-II\u201d,\n<em>Journal of Automated Reasoning</em>, 55(4): 389\u2013404.\ndoi:10.1007/s10817-015-9348-y</li>\n<li>Benzm\u00fcller, Christoph and Dana S. Scott, forthcoming,\n\u201cAutomating Free Logic in HOL, with an Experimental Application\nin Category Theory\u201d, <em>Journal of Automated Reasoning</em>,\nFirst online: 1 January 2019. doi:10.1007/s10817-018-09507-7</li>\n<li>Benzm\u00fcller, Christoph and Bruno Woltzenlogel Paleo, 2014,\n\u201cAutomating G\u00f6del\u2019s Ontological Proof of God\u2019s\nExistence with Higher-Order Automated Theorem Provers\u201d, in\n<em>Proceedings of the Twenty-First European Conference on Artificial\nIntelligence (ECAI 2014)</em>, T. Schaub, G. Friedrich, and B.\nO\u2019Sullivan (eds.), (Frontiers in Artificial Intelligence 263),\nAmsterdam: IOS Press, 93\u201398. doi:10.3233/978-1-61499-419-0-93</li>\n<li>Bertot, Yves and Pierre Cast\u00e9ran, 2004, <em>Interactive\nTheorem Proving and Program Development: Coq\u2019Art: The Calculus\nof Inductive Constructions</em>, (Texts in Theoretical Computer\nScience An EATCS Series), Berlin, Heidelberg: Springer Berlin\nHeidelberg. doi:10.1007/978-3-662-07964-5</li>\n<li>Bibel, Wolfgang, 1981, \u201cOn Matrices with Connections\u201d,\n<em>Journal of the ACM</em>, 28(4): 633\u2013645.\ndoi:10.1145/322276.322277</li>\n<li>Bishop, Matthew, 1999, \u201cA Breadth-First Strategy for Mating\nSearch\u201d, in Ganzinger 1999: 359\u2013373.\ndoi:10.1007/3-540-48660-7_32</li>\n<li>Blanchette, Jasmin Christian and Tobias Nipkow, 2010,\n\u201cNitpick: A Counterexample Generator for Higher-Order Logic\nBased on a Relational Model Finder\u201d, in <em>Interactive Theorem\nProving</em>, Matt Kaufmann and Lawrence C. Paulson (eds.), (Lecture\nNotes in Computer Science 6172), Berlin, Heidelberg: Springer Berlin\nHeidelberg, 131\u2013146. doi:10.1007/978-3-642-14052-5_11</li>\n<li>Blanchette, Jasmin Christian, Sascha B\u00f6hme, and Lawrence C.\nPaulson, 2013, \u201cExtending Sledgehammer with SMT Solvers\u201d,\n<em>Journal of Automated Reasoning</em>, 51(1): 109\u2013128.\ndoi:10.1007/s10817-013-9278-5</li>\n<li>Boolos, George, 1987, \u201cA Curious Inference\u201d,\n<em>Journal of Philosophical Logic</em>, 16(1): 1\u201312.\ndoi:10.1007/BF00250612</li>\n<li>Brown, Chad E., 2004, \u201cSet Comprehension in Church\u2019s\nType Theory\u201d, PhD Thesis, Department of Mathematical Sciences,\nCarnegie Mellon University, Pittsburgh, PA.</li>\n<li>\u2013\u2013\u2013, 2007, <em>Automated Reasoning in\nHigher-Order Logic: Set Comprehension and Extensionality in Church`s\nType Theory</em>, (Studies in Logic Logic and Cognitive Systems 10),\nLondon: King\u2019s College Publications.</li>\n<li>\u2013\u2013\u2013, 2012, \u201cSatallax: An Automatic\nHigher-Order Prover\u201d, in <em>Automated Reasoning (IJCAR\n2012)</em>, Bernhard Gramlich, Dale Miller, and Uli Sattler (eds.)\n(Lecture Notes in Computer Science 7364), Berlin, Heidelberg: Springer\nBerlin Heidelberg, 111\u2013117. doi:10.1007/978-3-642-31365-3_11</li>\n<li>Brown, Chad and Gert Smolka, 2010, \u201cAnalytic Tableaux for\nSimple Type Theory and Its First-Order Fragment\u201d, <em>Logical\nMethods in Computer Science</em>, 6(2): 3.\ndoi:10.2168/LMCS-6(2:3)2010</li>\n<li>B\u00fcchi, J. Richard, 1953, \u201cInvestigation of the\nEquivalence of the Axiom of Choice and Zorn\u2019s Lemma from the\nViewpoint of the Hierarchy of Types\u201d, <em>The Journal of\nSymbolic Logic</em>, 18(2): 125\u2013135. doi:10.2307/2268945</li>\n<li>Church, Alonzo, 1932, \u201cA Set of Postulates for the\nFoundation of Logic\u201d, <em>The Annals of Mathematics</em>, 33(2):\n346\u2013366. doi:10.2307/1968337</li>\n<li>\u2013\u2013\u2013, 1940, \u201cA Formulation of the Simple\nTheory of Types\u201d, <em>The Journal of Symbolic Logic</em>, 5(2):\n56\u201368. Reprinted in Benzm\u00fcller et al. 2008.\ndoi:10.2307/2266170</li>\n<li>\u2013\u2013\u2013, 1941, <em>The Calculi of Lambda\nConversion</em>, (Annals of Mathematics Studies 6), Princeton, NJ:\nPrinceton University Press.</li>\n<li>\u2013\u2013\u2013, 1956, <em>Introduction to Mathematical\nLogic</em>, Princeton, NJ: Princeton University Press.</li>\n<li>Czajka, \u0141ukasz and Cezary Kaliszyk, 2018, \u201cHammer for\nCoq: Automation for Dependent Type Theory\u201d, <em>Journal of\nAutomated Reasoning</em>, 61(1\u20134): 423\u2013453.\ndoi:10.1007/s10817-018-9458-4</li>\n<li>Dowek, Gilles, 2001, \u201cHigher-Order Unification and\nMatching\u201d, in Robinson and Voronkov 2001, Volume 2, Chapter 16,\nAmsterdam: Elsevier Science, pp. 1009\u20131062.\ndoi:10.1016/B978-044450813-3/50018-7</li>\n<li>Dowek, Gilles and Benjamin Werner, 2003, \u201cProof\nNormalization Modulo\u201d, <em>The Journal of Symbolic Logic</em>,\n68(4): 1289\u20131316. doi:10.2178/jsl/1067620188</li>\n<li>Farmer, William M., 2008, \u201cThe Seven Virtues of Simple Type\nTheory\u201d, <em>Journal of Applied Logic</em>, 6(3): 267\u2013286.\ndoi:10.1016/j.jal.2007.11.001</li>\n<li>Farmer, William M., Joshua D. Guttman, and F. Javier Thayer, 1993,\n\u201cIMPS: An Interactive Mathematical Proof System\u201d,\n<em>Journal of Automated Reasoning</em>, 11(2): 213\u2013248.\ndoi:10.1007/BF00881906</li>\n<li>Gallin, Daniel, 1975, <em>Intensional and Higher-Order Modal\nLogic</em>, Amsterdam: North-Holland.</li>\n<li>Galmiche, Didier, Stephan Schulz, and Roberto Sebastiani (eds.),\n2018, <em>Automated Reasoning (IJCAR 2018)</em>, (Lecture Notes in\nComputer Science 10900), Cham: Springer International Publishing.\ndoi:10.1007/978-3-319-94205-6</li>\n<li>Ganzinger, Harald (ed.), 1999, <em>Automated\nDeduction\u2014CADE-16</em>, (Lecture Notes in Computer Science,\n1632), Berlin, Heidelberg: Springer Berlin Heidelberg.\ndoi:10.1007/3-540-48660-7</li>\n<li>G\u00f6del, Kurt, 1931, \u201c\u00dcber formal unentscheidbare\nS\u00e4tze der Principia Mathematica und verwandter Systeme I\u201d,\n<em>Monatshefte f\u00fcr Mathematik und Physik</em>, 38(1):\n173\u2013198. Translated in G\u00f6del 1986: 144\u2013195, and in\nvan Heijenoort 1967: 596\u2013616.</li>\n<li>\u2013\u2013\u2013, 1986, <em>Collected Works</em>, Volume I,\nOxford: Oxford University Press.</li>\n<li>Goldfarb, Warren D., 1981, \u201cThe Undecidability of the\nSecond-Order Unification Problem\u201d, <em>Theoretical Computer\nScience</em>, 13(2): 225\u2013230. doi:10.1016/0304-3975(81)90040-2</li>\n<li>Gordon, Michael J. C., 1986, \u201cWhy Higher-Order Logic is a\nGood Formalism for Specifying and Verifying Hardware\u201d, in George\nJ. Milne, and P. A. Subrahmanyam (eds.), <em>Formal Aspects of VLSI\nDesign: Proceedings of the 1985 Edinburgh Workshop on VLSI</em>,\nAmsterdam: North-Holland, pp. 153\u2013177.</li>\n<li>\u2013\u2013\u2013, 1988, \u201cHOL: A Proof Generating System\nfor Higher-Order Logic\u201d, in <em>VLSI Specification, Verification\nand Synthesis</em>, Graham Birtwistle and P. A. Subrahmanyam (eds.),\n(The Kluwer International Series in Engineering and Computer Science\n\n35), Boston, MA: Springer US, 73\u2013128.\ndoi:10.1007/978-1-4613-2007-4_3</li>\n<li>Gordon, M. J., and T. F. Melham, 1993, <em>Introduction to HOL: A\nTheorem-Proving Environment for Higher-Order Logic</em>, Cambridge:\nCambridge University Press.</li>\n<li>Gould, William Eben, 1966, <em>A Matching Procedure for\n\\(\\omega\\)-order Logic</em>, Ph.D. dissertation, Mathematics\nDepartment, Princeton University.\n [<a href=\"https://apps.dtic.mil/dtic/tr/fulltext/u2/646560.pdf\" target=\"other\">Gould 1966 available online</a>]</li>\n<li>Hales, Thomas, Mark Adams, Gertrud Bauer, Tat Dat Dang, John\nHarrison, Le Truong Hoang, Cezary Kaliszyk, et al., 2017, \u201cA\nFormal Proof of the Kepler Conjecture\u201d, <em>Forum of\nMathematics, Pi</em>, 5: e2. doi:10.1017/fmp.2017.1</li>\n<li>Harrison, John, 1996, \u201cHOL Light: A Tutorial\nIntroduction\u201d, in <em>Formal Methods in Computer-Aided\nDesign</em>, Mandayam Srivas and Albert Camilleri (eds.), (Lecture\nNotes in Computer Science 1166), Berlin, Heidelberg: Springer Berlin\nHeidelberg, 265\u2013269. doi:10.1007/BFb0031814</li>\n<li>Henkin, Leon, 1950, \u201cCompleteness in the Theory of\nTypes\u201d, <em>The Journal of Symbolic Logic</em>, 15(2): 81\u201391.\nReprinted in Hintikka 1969 and in Benzm\u00fcller et al. 2008.\ndoi:10.2307/2266967</li>\n<li>\u2013\u2013\u2013, 1963, \u201cA Theory of Prepositional\nTypes\u201d, <em>Fundamenta Mathematicae</em>, 52(3): 323\u2013344.\ndoi:10.4064/fm-52-3-323-344</li>\n<li>\u2013\u2013\u2013, 1975, \u201cIdentity as a Logical\nPrimitive\u201d, <em>Philosophia</em>, 5(1\u20132): 31\u201345.\ndoi:10.1007/BF02380832</li>\n<li>Hilbert, David, 1928, \u201cDie Grundlagen der Mathematik\u201d,\n<em>Abhandlungen aus dem mathematischen Seminar der Hamburgischen\nUniversit\u00e4t</em>, 6: 65\u201385; translated in van Heijenoort\n1967: 464\u2013479.</li>\n<li>Hintikka, Jaakko (ed.), 1969, <em>The Philosophy of\nMathematics</em>, Oxford: Oxford University Press.</li>\n<li>Huet, Gerald P., 1973a, \u201cA Mechanization of Type\nTheory\u201d, in <em>Proceedings of the Third International Joint\nConference on Artificial Intelligence</em> (Stanford University), D.\nE. Walker and L. Norton (eds.), Los Altos, CA: William Kaufman,\n139\u2013146.\n [<a href=\"https://www.ijcai.org/Proceedings/73/Papers/016.pdf\" target=\"other\">Huet 1973a available online</a>]</li>\n<li>\u2013\u2013\u2013, 1973b, \u201cThe Undecidability of\nUnification in Third Order Logic\u201d, <em>Information and\nControl</em>, 22(3): 257\u2013267. doi:10.1016/S0019-9958(73)90301-X</li>\n<li>\u2013\u2013\u2013, 1975, \u201cA Unification Algorithm for\nTyped \u03bb-Calculus\u201d, <em>Theoretical Computer Science</em>,\n1(1): 27\u201357. doi:10.1016/0304-3975(75)90011-0</li>\n<li>Jensen, D.C. and T. Pietrzykowski, 1976, \u201cMechanizing\n\u03c9-Order Type Theory through Unification\u201d, <em>Theoretical\nComputer Science</em>, 3(2): 123\u2013171.\ndoi:10.1016/0304-3975(76)90021-9</li>\n<li>Kaliszyk, Cezary and Josef Urban, 2015, \u201cHOL(y)Hammer:\nOnline ATP Service for HOL Light\u201d, <em>Mathematics in Computer\nScience</em>, 9(1): 5\u201322. doi:10.1007/s11786-014-0182-0</li>\n<li>Kirchner, Claude and H\u00e9l\u00e8ne Kirchner (eds.), 1998,\n<em>Automated Deduction\u2014CADE-15</em>, (Lecture Notes in Computer\nScience, 1421), Berlin, Heidelberg: Springer Berlin Heidelberg.\ndoi:10.1007/BFb0054239</li>\n<li>Klein, Gerwin, June Andronick, Matthew Fernandez, Ihor Kuz, Toby\nMurray, and Gernot Heiser, 2018, \u201cFormally Verified Software in\nthe Real World\u201d, <em>Communications of the ACM</em>, 61(10):\n68\u201377. doi:10.1145/3230627</li>\n<li>Kohlhase, Michael, 1993, \u201cA Unifying Principle for\nExtensional Higher-Order Logic\u201d, Technical Report 93\u2013153,\nDepartment of Mathematics, Carnegie Mellon University.</li>\n<li>\u2013\u2013\u2013, 1995, \u201cHigher-Order Tableaux\u201d,\nin <em>Theorem Proving with Analytic Tableaux and Related\nMethods</em>, Peter Baumgartner, Reiner H\u00e4hnle, and Joachim\nPossega (eds.), (Lecture Notes in Computer Science 918), Berlin,\nHeidelberg: Springer Berlin Heidelberg, 294\u2013309.\ndoi:10.1007/3-540-59338-1_43</li>\n<li>\u2013\u2013\u2013, 1998, \u201cHigher-Order Automated Theorem\nProving\u201d, in <em>Automated Deduction\u2014A Basis for\nApplications</em>, Volume 1, Wolfgang Bibel and Peter H. Schmitt\n(eds.), Dordrecht: Kluwer, 431\u2013462.</li>\n<li>Konrad, Karsten, 1998, \u201cHot: A Concurrent Automated Theorem\nProver Based on Higher-Order Tableaux\u201d, in <em>Theorem Proving\nin Higher Order Logics</em>, Jim Grundy and Malcolm Newey (eds.),\n(Lecture Notes in Computer Science 1479), Berlin, Heidelberg: Springer\nBerlin Heidelberg, 245\u2013261. doi:10.1007/BFb0055140</li>\n<li>Maslov, S. Yu, 1967, \u201cAn Inverse Method for Establishing\nDeducibility of Nonprenex Formulas of Predicate Calculus\u201d,\n<em>Soviet Mathematics Doklady</em>, 8(1): 16\u201319.</li>\n<li>Miller, Dale A., 1983, <em>Proofs in Higher-Order Logic</em>,\nPh.D. dissertation, Mathematics Department, Carnegie Mellon\nUniversity.</li>\n<li>\u2013\u2013\u2013, 1987, \u201cA Compact Representation of\nProofs\u201d, <em>Studia Logica</em>, 46(4): 347\u2013370.\ndoi:10.1007/BF00370646</li>\n<li>\u2013\u2013\u2013, 1991, \u201cA Logic Programming Language\nwith Lambda-Abstraction, Function Variables, and Simple\nUnification\u201d, <em>Journal of Logic and Computation</em>, 1(4):\n497\u2013536. doi:10.1093/logcom/1.4.497</li>\n<li>Mints, G., 1999, \u201cCut-Elimination for Simple Type Theory\nwith an Axiom of Choice\u201d, <em>The Journal of Symbolic\nLogic</em>, 64(2): 479\u2013485. doi:10.2307/2586480</li>\n<li>Montague, Richard, 1974, <em>Formal Philosophy. Selected Papers Of\nRichard Montague</em>, edited and with an introduction by Richmond H.\nThomason, New Haven: Yale University Press.</li>\n<li>Muskens, Reinhard, 2006, \u201cHigher Order Modal Logic\u201d,\nin <em>Handbook of Modal Logic</em>, Patrick Blackburn, Johan Van\nBenthem, and Frank Wolter (eds.), Amsterdam: Elsevier,\n621\u2013653.</li>\n<li>\u2013\u2013\u2013, 2007, \u201cIntensional Models for the\nTheory of Types\u201d, <em>The Journal of Symbolic Logic</em>, 72(1):\n98\u2013118. doi:10.2178/jsl/1174668386</li>\n<li>Nipkow, Tobias, Markus Wenzel, and Lawrence C. Paulson (eds.),\n2002, <em>Isabelle/HOL: A Proof Assistant for Higher-Order Logic</em>,\n(Lecture Notes in Computer Science 2283), Berlin, Heidelberg: Springer\nBerlin Heidelberg. doi:10.1007/3-540-45949-9</li>\n<li>Owre, S., S. Rajan, J. M. Rushby, N. Shankar, and M. Srivas, 1996,\n\u201cPVS: Combining Specification, Proof Checking, and Model\nChecking\u201d, in <em>Computer Aided Verification</em>, Rajeev Alur\nand Thomas A. Henzinger (eds.), (Lecture Notes in Computer Science\n1102), Berlin, Heidelberg: Springer Berlin Heidelberg, 411\u2013414.\ndoi:10.1007/3-540-61474-5_91</li>\n<li>Paulson, Lawrence C, 1988, \u201cIsabelle: The next Seven Hundred\nTheorem Provers\u201d, in <em>9th International Conference on\nAutomated Deduction</em>, Ewing Lusk and Ross Overbeek (eds.),\n(Lecture Notes in Computer Science 310), Berlin/Heidelberg:\nSpringer-Verlag, 772\u2013773. doi:10.1007/BFb0012891</li>\n<li>\u2013\u2013\u2013, 1990, \u201cA Formulation of the Simple\nTheory of Types (for Isabelle)\u201d, in <em>COLOG-88</em>, Per\nMartin-L\u00f6f and Grigori Mints (eds.), (Lecture Notes in Computer\nScience 417), Berlin, Heidelberg: Springer Berlin Heidelberg,\n246\u2013274. doi:10.1007/3-540-52335-9_58</li>\n<li>Prawitz, Dag, 1968, \u201cHauptsatz for Higher Order\nLogic\u201d, <em>The Journal of Symbolic Logic</em>, 33(3):\n452\u2013457. doi:10.2307/2270331</li>\n<li>Quine, W. V., 1956, \u201cUnification of Universes in Set\nTheory\u201d, <em>The Journal of Symbolic Logic</em>, 21(3):\n267\u2013279. doi:10.2307/2269102</li>\n<li>Richardson, Julian, Alan Smaill, and Ian Green, 1998,\n\u201cSystem Description: Proof Planning in Higher-Order Logic with\n\u039bClam\u201d, in Kirchner and Kirchner 1998: 129\u2013133.\ndoi:10.1007/BFb0054254</li>\n<li>Robinson, Alan and Andrei Voronkov (eds.), 2001, <em>Handbook of\nAutomated Reasoning</em>, Volumes 1 and 2, Amsterdam: Elsevier\nScience.</li>\n<li>Russell, Bertrand, 1903, <em>The Principles of Mathematics</em>,\nCambridge: Cambridge University Press.</li>\n<li>\u2013\u2013\u2013, 1908, \u201cMathematical Logic as Based on\nthe Theory of Types\u201d, <em>American Journal of Mathematics</em>,\n30(3): 222\u2013262. Reprinted in van Heijenoort 1967: 150\u2013182.\ndoi:10.2307/2369948</li>\n<li>Sch\u00f6nfinkel, M., 1924, \u201c\u00dcber die Bausteine der\nmathematischen Logik\u201d, <em>Mathematische Annalen</em>,\n92(3\u20134): 305\u2013316. Translated in van Heijenoort 1967: 355\u2013366.\ndoi:10.1007/BF01448013</li>\n<li>Sch\u00fctte, Kurt, 1960, \u201cSyntactical and Semantical\nProperties of Simple Type Theory\u201d, <em>The Journal of Symbolic\nLogic</em>, 25(4): 305\u2013326. doi:10.2307/2963525</li>\n<li>Shankar, Natarajan, 2001, \u201cUsing Decision Procedures with a\nHigher-Order Logic\u201d, in <em>Theorem Proving in Higher Order\nLogics</em>, Richard J. Boulton and Paul B. Jackson (eds.), (Lecture\nNotes in Computer Science 2152), Berlin, Heidelberg: Springer Berlin\nHeidelberg, 5\u201326. doi:10.1007/3-540-44755-5_3</li>\n<li>Siekmann, J\u00f6rg H. and Graham Wrightson (eds.), 1983,\n<em>Automation of Reasoning</em>, (Classical Papers on Computational\nLogic 1967\u20131970: Vol. 2), Berlin, Heidelberg: Springer Berlin\nHeidelberg. doi:10.1007/978-3-642-81955-1</li>\n<li>Siekmann, J\u00f6rg, Christoph Benzm\u00fcller, and Serge\nAutexier, 2006, \u201cComputer Supported Mathematics with\n\u03a9MEGA\u201d, <em>Journal of Applied Logic</em>, 4(4):\n533\u2013559. doi:10.1016/j.jal.2005.10.008</li>\n<li>Smullyan, Raymond M., 1963, \u201cA Unifying Principal in\nQuantification Theory\u201d, <em>Proceedings of the National Academy\nof Sciences</em>, 49(6): 828\u2013832. doi:10.1073/pnas.49.6.828</li>\n<li>\u2013\u2013\u2013, 1995, <em>First-Order Logic</em>, New York:\nDover, second corrected edition.</li>\n<li>Steen, Alexander, 2018, <em>Extensional Paramodulation for\nHigher-Order Logic and its Effective Implementation Leo-III</em>,\nPh.D. dissertation, Series: Dissertations in Artificial Intelligence\n(DISKI), Volume 345, Berlin: AKA-Verlag (IOS Press).</li>\n<li>Steen, Alexander and Christoph Benzm\u00fcller, 2018, \u201cThe\nHigher-Order Prover Leo-III\u201d, in Galmiche et al. 2018:\n108\u2013116. doi:10.1007/978-3-319-94205-6_8</li>\n<li>Stenlund, S\u00f6ren, 1972, <em>Combinators, \u03bb-Terms and\nProof Theory</em>, (Synthese Library 42), Dordrecht: Springer\nNetherlands. doi:10.1007/978-94-010-2913-1</li>\n<li>Sutcliffe, Geoff, 2016, \u201cThe CADE ATP System\nCompetition\u2014CASC\u201d, <em>AI Magazine</em>, 37(2): 99\u2013101.\ndoi:10.1609/aimag.v37i2.2620</li>\n<li>\u2013\u2013\u2013, 2017, \u201cThe TPTP Problem Library and\nAssociated Infrastructure: From CNF to TH0, TPTP v6.4.0\u201d,\n<em>Journal of Automated Reasoning</em>, 59(4): 483\u2013502.\ndoi:10.1007/s10817-017-9407-7</li>\n<li>Sutcliffe, Geoff and Christoph Benzm\u00fcller, 2010,\n\u201cAutomated Reasoning in Higher-Order Logic Using the TPTP THF\nInfrastructure\u201d, <em>Journal of Formalized Reasoning</em>, 3(1):\n1\u201327. doi:10.6092/issn.1972-5787/1710</li>\n<li>Takahashi, Moto-o, 1967, \u201cA Proof of Cut-Elimination Theorem\nin Simple Type-Theory\u201d, <em>Journal of the Mathematical Society\nof Japan</em>, 19(4): 399\u2013410. doi:10.2969/jmsj/01940399</li>\n<li>\u2013\u2013\u2013, 1970, \u201cA System of Simple Type Theory\nof Gentzen Style with Inference on Extensionality, and the Cut\nElimination in It\u201d, <em>Commentarii Mathematici Universitatis\nSancti Pauli</em>, 18(2):129\u2013147.</li>\n<li>Takeuti, Gaisi, 1987, <em>Proof Theory</em>, second edition,\nAmsterdam: North-Holland.</li>\n<li>Tarski, Alfred [Tajtelbaum, Alfred], 1923, \u201cSur Le Terme\nPrimitif de La Logistique\u201d, <em>Fundamenta Mathematicae</em>, 4:\n196\u2013200. Translated in Tarski 1956, 1\u201323.\ndoi:10.4064/fm-4-1-196-200</li>\n<li>\u2013\u2013\u2013, 1956, <em>Logic, Semantics,\nMetamathematics: Papers from 1923 to 1938</em>, Oxford: Oxford\nUniversity Press.</li>\n<li>van Heijenoort, Jean, 1967, <em>From Frege to G\u00f6del. A Source\nBook in Mathematical Logic 1879\u20131931</em>, Cambridge, MA:\nHarvard University Press.</li>\n<li>Whitehead, Alfred N. and Bertrand Russell, 1927a, <em>Principia\nMathematica</em>, Volume 1, Cambridge: Cambridge University Press,\nsecond edition.</li>\n<li>\u2013\u2013\u2013, 1927b, \u201cIncomplete Symbols\u201d, in\nWhitehead &amp; Russell 1927a: 66\u201384; reprinted in van\nHeijenoort 1967: 216\u2013223.</li>\n<li>Yasuhara, Mitsuru, 1975, \u201cThe Axiom of Choice in\nChurch\u2019s Type Theory\u201d (abstract), <em>Notices of the\nAmerican Mathematical Society</em>, 22(January): A34.\n [<a href=\"https://www.ams.org/journals/notices/197501/197501FullIssue.pdf\" target=\"other\">Yashuhara 1975 available online</a>]</li>\n</ul>\n</div>"}, "related_entries": {"entry_list": ["artificial intelligence: logic and", "category theory", "choice, axiom of", "descriptions", "epsilon calculus", "Frege, Gottlob", "G\u00f6del, Kurt: incompleteness theorems", "grammar: typelogical", "lambda calculus, the", "logic, history of: first-order logic", "logic: classical", "logic: deontic", "logic: dynamic epistemic", "logic: modal", "logic: second-order and higher-order", "metaphysics", "ontological arguments", "paradox: Skolem\u2019s", "paradoxes: and contemporary logic", "possibilism-actualism debate", "possible worlds", "Principia Mathematica", "proof theory", "quantifiers and quantification", "Quine, Willard Van Orman", "rational choice, normative: expected utility", "reasoning: automated", "Russell, Bertrand", "semantics: Montague", "Tarski, Alfred", "type theory"], "entry_link": [{"../logic-ai/": "artificial intelligence: logic and"}, {"../category-theory/": "category theory"}, {"../axiom-choice/": "choice, axiom of"}, {"../descriptions/": "descriptions"}, {"../epsilon-calculus/": "epsilon calculus"}, {"../frege/": "Frege, Gottlob"}, {"../goedel-incompleteness/": "G\u00f6del, Kurt: incompleteness theorems"}, {"../typelogical-grammar/": "grammar: typelogical"}, {"../lambda-calculus/": "lambda calculus, the"}, {"../logic-firstorder-emergence/": "logic, history of: first-order logic"}, {"../logic-classical/": "logic: classical"}, {"../logic-deontic/": "logic: deontic"}, {"../dynamic-epistemic/": "logic: dynamic epistemic"}, {"../logic-modal/": "logic: modal"}, {"../logic-higher-order/": "logic: second-order and higher-order"}, {"../metaphysics/": "metaphysics"}, {"../ontological-arguments/": "ontological arguments"}, {"../paradox-skolem/": "paradox: Skolem\u2019s"}, {"../paradoxes-contemporary-logic/": "paradoxes: and contemporary logic"}, {"../possibilism-actualism/": "possibilism-actualism debate"}, {"../possible-worlds/": "possible worlds"}, {"../principia-mathematica/": "Principia Mathematica"}, {"../proof-theory/": "proof theory"}, {"../quantification/": "quantifiers and quantification"}, {"../quine/": "Quine, Willard Van Orman"}, {"../rationality-normative-utility/": "rational choice, normative: expected utility"}, {"../reasoning-automated/": "reasoning: automated"}, {"../russell/": "Russell, Bertrand"}, {"../montague-semantics/": "semantics: Montague"}, {"../tarski/": "Tarski, Alfred"}, {"../type-theory/": "type theory"}]}, "academic_tools": {"listed_text": ["<img alt=\"sep man icon\" src=\"../../symbols/sepman-icon.jpg\"/>", "<a href=\"https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=type-theory-church\" target=\"other\">How to cite this entry</a>.", "<img alt=\"sep man icon\" src=\"../../symbols/sepman-icon.jpg\"/>", "<a href=\"https://leibniz.stanford.edu/friends/preview/type-theory-church/\" target=\"other\">Preview the PDF version of this entry</a> at the\n <a href=\"https://leibniz.stanford.edu/friends/\" target=\"other\">Friends of the SEP Society</a>.", "<img alt=\"inpho icon\" src=\"../../symbols/inpho.png\"/>", "<a href=\"https://www.inphoproject.org/entity?sep=type-theory-church&amp;redirect=True\" target=\"other\">Look up topics and thinkers related to this entry</a>\n at the Internet Philosophy Ontology Project (InPhO).", "<img alt=\"phil papers icon\" src=\"../../symbols/pp.gif\"/>", "<a href=\"https://philpapers.org/sep/type-theory-church/\" target=\"other\">Enhanced bibliography for this entry</a>\nat <a href=\"https://philpapers.org/\" target=\"other\">PhilPapers</a>, with links to its database."], "listed_links": [{"https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=type-theory-church": "How to cite this entry"}, {"https://leibniz.stanford.edu/friends/preview/type-theory-church/": "Preview the PDF version of this entry"}, {"https://leibniz.stanford.edu/friends/": "Friends of the SEP Society"}, {"https://www.inphoproject.org/entity?sep=type-theory-church&redirect=True": "Look up topics and thinkers related to this entry"}, {"https://philpapers.org/sep/type-theory-church/": "Enhanced bibliography for this entry"}, {"https://philpapers.org/": "PhilPapers"}]}, "other_internet_resources": {"listed_text": ["<a href=\"#EarlProoAssi\">4.2 Early Proof Assistants</a>\n<ul>\n<a href=\"http://www.cl.cam.ac.uk/Research/HVG/HOL/\" target=\"other\">HOL</a>\n<a href=\"http://gtps.math.cmu.edu/tps.html\" target=\"other\">TPS</a>\n<a href=\"https://isabelle.in.tum.de\" target=\"other\">Isabelle/HOL</a>\n<a href=\"http://www.csl.sri.com/projects/pvs/\" target=\"other\">PVS</a>\n<a href=\"https://github.com/theoremprover-museum/imps\" target=\"other\">IMPS</a>\n<a href=\"https://github.com/theoremprover-museum/OMEGA/blob/master/prog/top/omega-top.lisp\" target=\"other\">OMEGA</a>\n<a href=\"http://dream.inf.ed.ac.uk/software/lambda-clam/\" target=\"other\">\u03bbClam</a>\n</ul>", "<a href=\"http://www.cl.cam.ac.uk/Research/HVG/HOL/\" target=\"other\">HOL</a>", "<a href=\"http://gtps.math.cmu.edu/tps.html\" target=\"other\">TPS</a>", "<a href=\"https://isabelle.in.tum.de\" target=\"other\">Isabelle/HOL</a>", "<a href=\"http://www.csl.sri.com/projects/pvs/\" target=\"other\">PVS</a>", "<a href=\"https://github.com/theoremprover-museum/imps\" target=\"other\">IMPS</a>", "<a href=\"https://github.com/theoremprover-museum/OMEGA/blob/master/prog/top/omega-top.lisp\" target=\"other\">OMEGA</a>", "<a href=\"http://dream.inf.ed.ac.uk/software/lambda-clam/\" target=\"other\">\u03bbClam</a>", "<a href=\"#AutoTheoProv\">4.3 Automated Theorem Provers</a>\n<ul>\n<a href=\"http://www.tptp.org/cgi-bin/SystemOnTPTP\" target=\"other\">SystemOnTPTP</a>\n<a href=\"http://www.tptp.org/TSTP/\" target=\"other\">TPTP TSTP</a> (proof format)\n<a href=\"http://www.tptp.org/CASC/\" target=\"other\">TPTP CASC</a> (competition)\n<a href=\"http://gtps.math.cmu.edu/tps.html\" target=\"other\">TPS</a>\n<a href=\"http://pvs.csl.sri.com\" target=\"other\">PVS</a>\n<a href=\"http://www.leoprover.org/\" target=\"other\">LEO-II</a>\n<a href=\"http://www.ps.uni-saarland.de/~cebrown/satallax/\" target=\"other\">Satallax</a>\n<a href=\"https://isabelle.in.tum.de\" target=\"other\">Isabelle/HOL</a>\n<a href=\"https://isabelle.in.tum.de/website-Isabelle2009-1/sledgehammer.html\" target=\"other\">Sledgehammer</a>\n<a href=\"https://github.com/frelindb/agsyHOL\" target=\"other\">agsyHOL</a>\n<a href=\"http://hackage.haskell.org/package/Agda\" target=\"other\">Agda</a>\n<a href=\"https://coq.inria.fr\" target=\"other\">Coq</a>\n<a href=\"http://github.com/leoprover/Leo-III\" target=\"other\">Leo-III</a>\n<a href=\"https://github.com/c-cube/zipperposition\" target=\"other\">Zipperposition</a>\n<a href=\"http://cl-informatik.uibk.ac.at/software/hh/\" target=\"other\">HOL(y)Hammer</a>\n<a href=\"https://wwwlehre.dhbw-stuttgart.de/~sschulz/E/E.html\" target=\"other\">E</a>\n<a href=\"https://www.cl.cam.ac.uk/~jrh13/hol-light/\" target=\"other\">HOL light</a>\n</ul>", "<a href=\"http://www.tptp.org/cgi-bin/SystemOnTPTP\" target=\"other\">SystemOnTPTP</a>", "<a href=\"http://www.tptp.org/TSTP/\" target=\"other\">TPTP TSTP</a> (proof format)", "<a href=\"http://www.tptp.org/CASC/\" target=\"other\">TPTP CASC</a> (competition)", "<a href=\"http://gtps.math.cmu.edu/tps.html\" target=\"other\">TPS</a>", "<a href=\"http://pvs.csl.sri.com\" target=\"other\">PVS</a>", "<a href=\"http://www.leoprover.org/\" target=\"other\">LEO-II</a>", "<a href=\"http://www.ps.uni-saarland.de/~cebrown/satallax/\" target=\"other\">Satallax</a>", "<a href=\"https://isabelle.in.tum.de\" target=\"other\">Isabelle/HOL</a>", "<a href=\"https://isabelle.in.tum.de/website-Isabelle2009-1/sledgehammer.html\" target=\"other\">Sledgehammer</a>", "<a href=\"https://github.com/frelindb/agsyHOL\" target=\"other\">agsyHOL</a>", "<a href=\"http://hackage.haskell.org/package/Agda\" target=\"other\">Agda</a>", "<a href=\"https://coq.inria.fr\" target=\"other\">Coq</a>", "<a href=\"http://github.com/leoprover/Leo-III\" target=\"other\">Leo-III</a>", "<a href=\"https://github.com/c-cube/zipperposition\" target=\"other\">Zipperposition</a>", "<a href=\"http://cl-informatik.uibk.ac.at/software/hh/\" target=\"other\">HOL(y)Hammer</a>", "<a href=\"https://wwwlehre.dhbw-stuttgart.de/~sschulz/E/E.html\" target=\"other\">E</a>", "<a href=\"https://www.cl.cam.ac.uk/~jrh13/hol-light/\" target=\"other\">HOL light</a>", " <a href=\"#CounModeFind\">4.4 (Counter-)Model Finding</a>\n<ul>\n<a href=\"https://people.mpi-inf.mpg.de/~jblanche/nitpick.html\" target=\"other\">Nitpick</a>\n<a href=\"https://github.com/nunchaku-inria\" target=\"other\">Nunchaku</a>\n</ul>", "<a href=\"https://people.mpi-inf.mpg.de/~jblanche/nitpick.html\" target=\"other\">Nitpick</a>", "<a href=\"https://github.com/nunchaku-inria\" target=\"other\">Nunchaku</a>", "<a href=\"#MathCompScie\">5.2 Mathematics and Computer Science</a>\n<ul>\n<a href=\"https://trustworthy.systems/projects/TS/l4.verified/\" target=\"other\">L4.verified</a>\n\n<a href=\"https://github.com/flyspeck/flyspeck\" target=\"other\">Flyspeck</a>\n<a href=\"https://www.isa-afp.org\" target=\"other\">Archive of Formal Proofs</a>\n\n<a href=\"https://jfr.unibo.it/issue/view/615\" target=\"other\">Journal of Formalized Reasoning</a>\n<a href=\"http://tptp.org\" target=\"other\">TPTP problem library</a>\n</ul>", "<a href=\"https://trustworthy.systems/projects/TS/l4.verified/\" target=\"other\">L4.verified</a>\n", "<a href=\"https://github.com/flyspeck/flyspeck\" target=\"other\">Flyspeck</a>", "<a href=\"https://www.isa-afp.org\" target=\"other\">Archive of Formal Proofs</a>\n", "<a href=\"https://jfr.unibo.it/issue/view/615\" target=\"other\">Journal of Formalized Reasoning</a>", "<a href=\"http://tptp.org\" target=\"other\">TPTP problem library</a>"], "listed_links": [{"#EarlProoAssi": "4.2 Early Proof Assistants"}, {"http://www.cl.cam.ac.uk/Research/HVG/HOL/": "HOL"}, {"http://gtps.math.cmu.edu/tps.html": "TPS"}, {"https://isabelle.in.tum.de": "Isabelle/HOL"}, {"http://www.csl.sri.com/projects/pvs/": "PVS"}, {"https://github.com/theoremprover-museum/imps": "IMPS"}, {"https://github.com/theoremprover-museum/OMEGA/blob/master/prog/top/omega-top.lisp": "OMEGA"}, {"http://dream.inf.ed.ac.uk/software/lambda-clam/": "\u03bbClam"}, {"#AutoTheoProv": "4.3 Automated Theorem Provers"}, {"http://www.tptp.org/cgi-bin/SystemOnTPTP": "SystemOnTPTP"}, {"http://www.tptp.org/TSTP/": "TPTP TSTP"}, {"http://www.tptp.org/CASC/": "TPTP CASC"}, {"http://gtps.math.cmu.edu/tps.html": "TPS"}, {"http://pvs.csl.sri.com": "PVS"}, {"http://www.leoprover.org/": "LEO-II"}, {"http://www.ps.uni-saarland.de/~cebrown/satallax/": "Satallax"}, {"https://isabelle.in.tum.de": "Isabelle/HOL"}, {"https://isabelle.in.tum.de/website-Isabelle2009-1/sledgehammer.html": "Sledgehammer"}, {"https://github.com/frelindb/agsyHOL": "agsyHOL"}, {"http://hackage.haskell.org/package/Agda": "Agda"}, {"https://coq.inria.fr": "Coq"}, {"http://github.com/leoprover/Leo-III": "Leo-III"}, {"https://github.com/c-cube/zipperposition": "Zipperposition"}, {"http://cl-informatik.uibk.ac.at/software/hh/": "HOL(y)Hammer"}, {"https://wwwlehre.dhbw-stuttgart.de/~sschulz/E/E.html": "E"}, {"https://www.cl.cam.ac.uk/~jrh13/hol-light/": "HOL light"}, {"#CounModeFind": "4.4 (Counter-)Model Finding"}, {"https://people.mpi-inf.mpg.de/~jblanche/nitpick.html": "Nitpick"}, {"https://github.com/nunchaku-inria": "Nunchaku"}, {"#MathCompScie": "5.2 Mathematics and Computer Science"}, {"https://trustworthy.systems/projects/TS/l4.verified/": "L4.verified"}, {"https://github.com/flyspeck/flyspeck": "Flyspeck"}, {"https://www.isa-afp.org": "Archive of Formal Proofs"}, {"https://jfr.unibo.it/issue/view/615": "Journal of Formalized Reasoning"}, {"http://tptp.org": "TPTP problem library"}]}, "tokenized_text": ["1", "syntax", "11", "fundamental", "idea", "start", "informal", "description", "fundamental", "idea", "underlying", "syntax", "church", "formulation", "type", "theory", "entity", "type", "\u03b1", "\u03b2", "type", "type", "function", "element", "type", "\u03b2", "element", "type", "\u03b1", "written", "alpha", "beta", "notation", "introduced", "church", "author", "write", "beta", "rightarrow", "alpha", "instead", "alpha", "beta", "see", "example", "section", "2", "entry", "type", "theory", "noted", "sch\u00f6nfinkel", "1924", "function", "one", "argument", "represented", "term", "function", "one", "argument", "value", "function", "function", "example", "f", "function", "two", "argument", "element", "x", "left", "domain", "f", "function", "g", "depending", "x", "gy", "fxy", "element", "right", "domain", "f", "may", "write", "g", "fx", "regard", "f", "function", "single", "argument", "whose", "value", "argument", "x", "domain", "function", "fx", "whose", "value", "argument", "domain", "fxy", "explicit", "example", "consider", "function", "carry", "pair", "natural", "number", "sum", "may", "denote", "function", "_", "sigma", "sigma", "sigma", "sigma", "type", "natural", "number", "given", "number", "x", "_", "sigma", "sigma", "sigma", "x", "function", "applied", "number", "give", "value", "_", "sigma", "sigma", "sigma", "x", "ordinarily", "abbreviated", "x", "y", "thus", "_", "sigma", "sigma", "sigma", "x", "function", "one", "argument", "add", "x", "number", "think", "_", "sigma", "sigma", "sigma", "function", "one", "argument", "see", "map", "number", "x", "function", "_", "sigma", "sigma", "sigma", "x", "generally", "f", "function", "map", "ntuples", "langle", "w_", "beta", "x_", "gamma", "ldots", "y_", "delta", "z_", "tau", "rangle", "element", "type", "beta", "gamma", "delta", "tau", "respectively", "element", "type", "\u03b1", "may", "assign", "f", "type", "ldots", "alpha", "tau", "delta", "ldots", "gamma", "beta", "customary", "use", "convention", "association", "left", "omit", "parenthesis", "write", "type", "symbol", "simply", "alpha", "tau", "delta", "ldots", "gamma", "beta", "set", "property", "represented", "function", "often", "called", "characteristic", "function", "map", "element", "truth", "value", "element", "set", "property", "question", "iff", "function", "representing", "set", "property", "map", "element", "truth", "statement", "asserted", "speaker", "mean", "true", "x", "mean", "x", "true", "also", "express", "assertion", "map", "x", "truth", "x", "in", "s", "word", "x", "in", "s", "iff", "x", "take", "type", "symbol", "denoting", "type", "truth", "value", "may", "speak", "function", "type", "alpha", "set", "element", "type", "\u03b1", "function", "type", "alpha", "beta", "binary", "relation", "element", "type", "\u03b2", "element", "type", "\u03b1", "example", "sigma", "type", "natural", "number", "order", "relation", "natural", "number", "type", "sigma", "sigma", "natural", "number", "x", "x", "y", "ordinarily", "write", "x", "value", "truth", "iff", "x", "le", "y", "course", "also", "regarded", "function", "map", "natural", "number", "x", "set", "x", "natural", "number", "x", "le", "y", "thus", "set", "property", "relation", "may", "regarded", "particular", "kind", "function", "church", "type", "type", "theory", "thus", "logic", "function", "sense", "tradition", "work", "frege", "begriffsschrift", "opposite", "approach", "would", "reduce", "function", "relation", "approach", "taken", "whitehead", "russell", "1927a", "principia", "mathematica", "expression", "denote", "element", "type", "\u03b1", "called", "wffs", "type", "\u03b1", "thus", "statement", "type", "theory", "wffs", "type", "ba_", "alpha", "wff", "type", "\u03b1", "bu_", "alpha", "beta", "free", "function", "associated", "bu_", "alpha", "beta", "forall", "bv_", "beta", "bu_", "alpha", "beta", "bv_", "beta", "ba_", "alpha", "denoted", "lambda", "bv_", "beta", "ba_", "alpha", "thus", "lambda", "bv_", "beta", "variablebinder", "like", "forall", "bv_", "beta", "exists", "bv_", "beta", "quite", "different", "meaning", "course", "\u03bb", "known", "abstraction", "operator", "lambda", "bv_", "beta", "ba_", "alpha", "denotes", "function", "whose", "value", "argument", "bv_", "beta", "ba_", "alpha", "bv_", "beta", "may", "occur", "free", "ba_", "alpha", "example", "lambda", "n_", "sigma", "4cdot", "n_", "sigma", "3", "denotes", "function", "whose", "value", "natural", "number", "n", "4cdot", "n3", "hence", "apply", "function", "number", "5", "obtain", "lambda", "n_", "sigma", "4cdot", "n_", "sigma", "3", "5", "4cdot", "53", "23", "use", "textsf", "sub", "bb", "bv", "ba", "notation", "result", "substituting", "bb", "bv", "ba", "textsf", "subfree", "bb", "bv", "ba", "notation", "result", "substituting", "bb", "free", "occurrence", "bv", "ba", "process", "replacing", "lambda", "bv_", "beta", "ba_", "alpha", "bb_", "beta", "textsf", "subfree", "bb_", "beta", "bv_", "beta", "ba_", "alpha", "viceversa", "known", "\u03b2conversion", "one", "form", "\u03bbconversion", "course", "ba_", "wff", "type", "lambda", "bv_", "beta", "ba_", "denotes", "set", "element", "bv_", "beta", "type", "beta", "ba_", "true", "set", "may", "also", "denoted", "bv_", "beta", "ba_", "example", "lambda", "x", "x", "denotes", "set", "x", "x", "le", "well", "property", "number", "x", "le", "familiar", "settheoretic", "notation", "lambda", "bv_", "beta", "ba_", "bb_", "beta", "textsf", "subfree", "bb_", "beta", "bv_", "beta", "ba_", "would", "written", "bb_", "beta", "in", "bv_", "beta", "ba_", "equiv", "textsf", "subfree", "bb_", "beta", "bv_", "beta", "ba_", "axiom", "extensionality", "truth", "value", "bc_", "bd_", "type", "bc_", "equiv", "bd_", "equivalent", "bc_", "bd_", "propositional", "connective", "quantifier", "assigned", "type", "denoted", "constant", "type", "negation", "function", "map", "truth", "value", "truth", "value", "type", "similarly", "disjunction", "conjunction", "etc", "binary", "function", "truth", "value", "truth", "value", "type", "statement", "forall", "bx_", "alpha", "ba_", "true", "iff", "set", "lambda", "bx_", "alpha", "ba_", "contains", "element", "type", "\u03b1", "constant", "pi_", "alpha", "introduced", "type", "symbol", "alpha", "denote", "property", "set", "set", "s_", "alpha", "property", "pi_", "alpha", "iff", "s_", "alpha", "contains", "element", "type", "\u03b1", "interpretation", "forall", "s_", "alpha", "left", "pi_", "alpha", "s_", "alpha", "equiv", "forall", "x_", "alpha", "left", "s_", "alpha", "x_", "alpha", "right", "right", "true", "well", "pi_", "alpha", "lambda", "bx_", "alpha", "ba_", "equiv", "forall", "bx_", "alpha", "lambda", "bx_", "alpha", "ba_", "bx_", "alpha", "label", "eqpi", "wff", "ba_", "variable", "bx_", "alpha", "since", "\u03bbconversion", "lambda", "bx_", "alpha", "ba_", "bx_", "alpha", "equiv", "ba_", "equation", "written", "simply", "pi_", "alpha", "lambda", "bx_", "alpha", "ba_", "equiv", "forall", "bx_", "alpha", "ba_", "thus", "forall", "bx_", "alpha", "defined", "term", "pi_", "alpha", "\u03bb", "variablebinder", "needed", "12", "formula", "state", "definition", "formula", "word", "caution", "order", "reader", "may", "accustomed", "thinking", "formula", "expression", "play", "role", "assertion", "formal", "language", "term", "expression", "designates", "object", "church", "terminology", "somewhat", "different", "provides", "uniform", "way", "discussing", "expression", "many", "different", "type", "call", "wellformed", "formula", "type", "\u03b1", "textrm", "wff", "_", "alpha", "would", "standard", "terminology", "called", "term", "type", "\u03b1", "certain", "term", "namely", "type", "would", "called", "formula", "anyhow", "entry", "decided", "stay", "church", "original", "terminology", "another", "remark", "concern", "use", "specific", "mathematical", "notation", "follows", "entry", "distinguishes", "symbol", "imath", "iota_", "alpha", "alpha", "atoi", "first", "symbol", "used", "type", "individual", "second", "symbol", "used", "logical", "constant", "see", "section", "121", "third", "symbol", "used", "variablebinding", "operator", "represents", "definite", "description", "see", "section", "134", "reader", "confuse", "check", "see", "browser", "displaying", "symbol", "correctly", "121", "definition", "type", "symbol", "defined", "inductively", "follows", "imath", "type", "symbol", "denoting", "type", "individual", "may", "also", "additional", "primitive", "type", "symbol", "used", "formalizing", "discipline", "natural", "several", "sort", "individual", "type", "symbol", "denoting", "type", "truth", "value", "\u03b1", "\u03b2", "type", "symbol", "alpha", "beta", "type", "symbol", "denoting", "type", "function", "element", "type", "\u03b2", "element", "type", "\u03b1", "primitive", "symbol", "following", "improper", "symbol", "lambda", "type", "symbol", "\u03b1", "denumerable", "list", "variable", "type", "alpha", "a_", "alpha", "b_", "alpha", "c_", "alpha", "ldots", "logical", "constant", "nsim_", "lor_", "pi_", "alpha", "iota_", "alpha", "alpha", "type", "symbol", "\u03b1", "type", "constant", "indicated", "subscript", "symbol", "nsim_", "denotes", "negation", "lor_", "denotes", "disjunction", "pi_", "alpha", "used", "defining", "universal", "quantifier", "discussed", "iota_", "alpha", "alpha", "serf", "either", "description", "selection", "operator", "discussed", "section", "134", "section", "135", "addition", "may", "constant", "various", "type", "called", "nonlogical", "constant", "parameter", "choice", "parameter", "determines", "particular", "formulation", "system", "type", "theory", "parameter", "typically", "used", "name", "particular", "entity", "discipline", "formalized", "formula", "finite", "sequence", "primitive", "symbol", "certain", "formula", "called", "wellformed", "formula", "wffs", "write", "textrm", "wff", "_", "alpha", "abbreviation", "wff", "type", "\u03b1", "define", "concept", "inductively", "follows", "primitive", "variable", "constant", "type", "\u03b1", "wff", "_", "alpha", "ba_", "alpha", "beta", "bb_", "beta", "wffs", "indicated", "type", "ba_", "alpha", "beta", "bb_", "beta", "wff", "_", "alpha", "bx_", "beta", "variable", "type", "\u03b2", "ba_", "alpha", "wff", "lambda", "bx_", "beta", "ba_", "alpha", "wff", "_", "alpha", "beta", "note", "example", "nsim_", "wff", "_", "b", "ba_", "wff", "_", "nsim_", "ba_", "wff", "_", "usually", "latter", "wff", "simply", "written", "nsim", "ba", "often", "convenient", "avoid", "parenthesis", "bracket", "type", "symbol", "use", "convention", "omitting", "formula", "use", "convention", "association", "right", "may", "write", "lor_", "oo", "ba_", "bb_", "instead", "lor_", "oo", "ba_", "bb_", "type", "corresponding", "convention", "association", "left", "may", "write", "ooo", "instead", "oo", "abbreviation", "ba_", "lor", "bb_", "stand", "lor_", "ooo", "ba_", "bb_", "ba_", "supset", "bb_", "stand", "nsim_", "ba_", "lor", "bb_", "forall", "bx_", "alpha", "ba_", "stand", "pi_", "alpha", "lambda", "bx_", "alpha", "ba_", "propositional", "connective", "existential", "quantifier", "defined", "familiar", "way", "particular", "ba_", "equiv", "bb_", "quad", "text", "stand", "quad", "ba_", "supset", "bb_", "land", "bb_", "supset", "ba_", "sfq_", "alpha", "alpha", "stand", "lambda", "x", "_", "alpha", "lambda", "y", "_", "alpha", "forall", "f_", "alpha", "f_", "alpha", "x_", "alpha", "supset", "f_", "alpha", "y_", "alpha", "ba_", "alpha", "bb_", "alpha", "stand", "sfq_", "alpha", "alpha", "ba_", "alpha", "bb_", "alpha", "last", "definition", "known", "leibnizian", "definition", "equality", "asserts", "x", "every", "property", "x", "actually", "leibniz", "called", "definition", "identity", "indiscernibles", "gave", "form", "biconditional", "x", "x", "exactly", "property", "difficult", "show", "two", "form", "definition", "logically", "equivalent", "122", "example", "provide", "example", "illustrate", "various", "assertion", "concept", "expressed", "church", "type", "theory", "example", "1", "express", "assertion", "napoleon", "charismatic", "introduce", "constant", "const", "charismatic", "_", "imath", "const", "napoleon", "_", "imath", "type", "indicated", "subscript", "obvious", "meaning", "assert", "wff", "const", "charismatic", "_", "imath", "const", "napoleon", "_", "imath", "wish", "express", "assertion", "napoleon", "property", "great", "general", "might", "consider", "interpreting", "mean", "napoleon", "property", "great", "general", "seems", "appropriate", "interpret", "statement", "meaning", "napoleon", "property", "great", "general", "constant", "const", "greatgeneral", "_", "imath", "added", "formal", "language", "expressed", "wff", "forall", "p_", "imath", "forall", "g_", "imath", "const", "greatgeneral", "_", "imath", "g_", "imath", "supset", "p_", "imath", "g_", "imath", "supset", "p_", "imath", "const", "napoleon", "_", "imath", "example", "property", "note", "sentence", "napoleon", "soldier", "admire", "expressed", "similar", "way", "wff", "forall", "x_", "imath", "const", "soldier", "_", "imath", "x_", "imath", "land", "const", "commanderof", "_", "imathimath", "x_", "imath", "const", "napoleon", "_", "imath", "supset", "const", "admires", "_", "imathimath", "x_", "imath", "const", "napoleon", "_", "imath", "\u03bbconversion", "equivalent", "lambda", "n_", "imath", "forall", "x_", "imath", "const", "soldier", "_", "imath", "x_", "imath", "land", "const", "commanderof", "_", "imathimath", "x_", "imath", "n_", "imath", "supset", "const", "admires", "_", "imathimath", "x_", "imath", "n_", "imath", "const", "napoleon", "_", "imath", "statement", "asserts", "one", "property", "napoleon", "admired", "soldier", "property", "expressed", "wff", "lambda", "n_", "imath", "forall", "x_", "imath", "const", "soldier", "_", "imath", "x_", "imath", "land", "const", "commanderof", "_", "imathimath", "x_", "imath", "n_", "imath", "supset", "const", "admires", "_", "imathimath", "x_", "imath", "n_", "imath", "example", "2", "illustrate", "potential", "application", "type", "theory", "following", "fable", "rich", "somewhat", "eccentric", "lady", "named", "sheila", "ostrich", "cheetah", "pet", "wish", "take", "hotel", "remote", "almost", "inaccessible", "farm", "various", "portion", "trip", "may", "involve", "using", "elevator", "boxcar", "airplane", "truck", "small", "boat", "donkey", "cart", "suspension", "bridge", "etc", "pet", "always", "together", "know", "must", "permit", "ostrich", "cheetah", "together", "consider", "certain", "aspect", "problem", "formalized", "sheila", "use", "automated", "reasoning", "system", "help", "analyze", "possibility", "set", "moment", "instant", "interval", "time", "trip", "start", "trip", "location", "const", "hotel", "moment", "const", "start", "end", "location", "const", "farm", "moment", "const", "finish", "moment", "type", "tau", "location", "type", "varrho", "state", "type", "sigma", "specify", "location", "sheila", "ostrich", "cheetah", "given", "moment", "plan", "specify", "entity", "moment", "according", "plan", "function", "moment", "state", "type", "sigma", "tau", "exact", "representation", "state", "need", "concern", "u", "function", "state", "location", "called", "const", "locationofsheila", "const", "locationofostrich", "const", "locationofcheetah", "provide", "indicated", "information", "thus", "const", "locationofsheila", "_", "varrho", "sigma", "p_", "sigma", "tau", "t_", "tau", "location", "sheila", "according", "plan", "p_", "sigma", "tau", "moment", "t_", "tau", "set", "const", "proposal", "_", "sigma", "tau", "set", "plan", "sheila", "considering", "define", "plan", "p", "acceptable", "according", "plan", "group", "start", "hotel", "finish", "farm", "whenever", "ostrich", "cheetah", "together", "sheila", "formally", "define", "const", "acceptable", "_", "sigma", "tau", "begin", "multline", "lambda", "p_", "sigma", "tau", "left", "begin", "aligned", "const", "locationofsheila", "_", "varrho", "sigma", "p_", "sigma", "tau", "const", "start", "_", "tau", "const", "hotel", "_", "varrho", "land", "const", "locationofostrich", "_", "varrho", "sigma", "p_", "sigma", "tau", "const", "start", "_", "tau", "const", "hotel", "_", "varrho", "land", "const", "locationofcheetah", "_", "varrho", "sigma", "p_", "sigma", "tau", "const", "start", "_", "tau", "const", "hotel", "_", "varrho", "land", "const", "locationofsheila", "_", "varrho", "sigma", "p_", "sigma", "tau", "const", "finish", "_", "tau", "const", "farm", "_", "varrho", "land", "const", "locationofostrich", "_", "varrho", "sigma", "p_", "sigma", "tau", "const", "finish", "_", "tau", "const", "farm", "_", "varrho", "land", "const", "locationofcheetah", "_", "varrho", "sigma", "p_", "sigma", "tau", "const", "finish", "_", "tau", "const", "farm", "_", "varrho", "land", "forall", "t_", "tau", "left", "begin", "split", "const", "moment", "_", "tau", "t_", "tau", "supset", "left", "begin", "split", "left", "begin", "split", "const", "locationofostrich", "_", "varrho", "sigma", "p_", "sigma", "tau", "t_", "tau", "const", "locationofcheetah", "_", "varrho", "sigma", "p_", "sigma", "tau", "t_", "tau", "end", "split", "right", "supset", "left", "begin", "split", "const", "locationofsheila", "_", "varrho", "sigma", "p_", "sigma", "tau", "t_", "tau", "const", "locationofcheetah", "_", "varrhosigma", "p_", "sigmatau", "t_", "tau", "end", "split", "right", "end", "split", "right", "end", "split", "right", "end", "aligned", "right", "end", "multline", "express", "assertion", "sheila", "way", "accomplish", "objective", "formula", "exists", "p_", "sigma", "tau", "const", "proposal", "_", "sigma", "tau", "p_", "sigma", "tau", "land", "const", "acceptable", "_", "sigma", "tau", "p_", "sigma", "tau", "example", "3", "provide", "mathematical", "example", "mathematical", "idea", "expressed", "type", "theory", "without", "introducing", "new", "constant", "iterate", "function", "f", "set", "function", "applies", "f", "one", "time", "example", "g", "x", "f", "f", "f", "x", "g", "iterate", "f", "text", "iterate", "_", "imathimath", "imathimath", "f_", "imathimath", "g_", "imathimath", "mean", "g_", "imathimath", "iterate", "f_", "imathimath", "text", "iterate", "_", "imathimath", "imathimath", "defined", "inductively", "lambda", "f_", "imathimath", "lambda", "g_", "imathimath", "forall", "p_", "imathimath", "left", "p_", "imathimath", "f_", "imathimath", "land", "forall", "j_", "imathimath", "left", "p_", "imathimath", "j_", "imathimath", "supset", "p_", "imathimath", "left", "lambda", "x_", "imath", "f_", "imathimath", "left", "j_", "imathimath", "x_", "imath", "right", "right", "right", "supset", "p_", "imathimath", "g_", "imathimath", "right", "thus", "g", "iterate", "f", "g", "every", "set", "p", "function", "contains", "f", "contains", "function", "lambda", "x_", "imath", "f_", "imathimath", "j_", "imathimath", "x_", "imath", "ie", "f", "composed", "j", "whenever", "contains", "j", "fixed", "point", "f", "element", "f", "y", "proved", "iterate", "function", "f", "unique", "fixed", "point", "f", "fixed", "point", "theorem", "expressed", "wff", "begin", "aligned", "forall", "f_", "imathimath", "left", "begin", "split", "exists", "g_", "imathimath", "left", "begin", "split", "text", "iterate", "_", "imathimath", "imathimath", "f_", "imathimath", "g_", "imathimath", "land", "exists", "x_", "imath", "left", "begin", "split", "g_", "imathimath", "x_", "imath", "x_", "imath", "land", "forall", "z_", "imath", "left", "g_", "imathimath", "z_", "imath", "z_", "imath", "supset", "z_", "imath", "x_", "imath", "right", "end", "split", "right", "end", "split", "right", "supset", "exists", "y_", "imath", "f_", "imathimath", "y_", "imath", "y_", "imath", "end", "split", "right", "end", "aligned", "see", "andrew", "et", "al", "1996", "discussion", "theorem", "called", "thm15b", "proved", "automatically", "example", "4", "example", "philosophy", "g\u00f6del", "variant", "ontological", "argument", "existence", "god", "example", "illustrates", "two", "interesting", "aspect", "church", "type", "theory", "employed", "metalogic", "concisely", "embed", "expressive", "logic", "higherorder", "modal", "logic", "assumed", "g\u00f6del", "exploiting", "possible", "world", "semantics", "target", "logic", "syntactic", "element", "defined", "way", "infrastructure", "metalogic", "reused", "much", "possible", "technique", "called", "shallow", "semantical", "embedding", "modal", "operator", "box", "example", "simply", "identified", "taken", "syntactic", "sugar", "\u03bbformula", "lambda", "varphi_", "imath", "lambda", "w_", "imath", "forall", "v_", "imath", "r_", "imathimath", "w_", "imath", "v_", "imath", "supset", "varphi_", "imath", "v_", "imath", "r_", "imathimath", "denotes", "accessibility", "relation", "associated", "box", "type", "imath", "identified", "possible", "world", "moreover", "since", "forall", "x_", "alpha", "ba_", "alpha", "x_", "alpha", "shorthand", "church", "type", "theory", "pi_", "alpha", "lambda", "x_", "alpha", "ba_", "alpha", "x_", "alpha", "modal", "formula", "box", "forall", "x", "bp", "x", "represented", "box", "pi", "lambda", "x_", "alpha", "lambda", "w_", "imath", "bp_", "imathalpha", "x_", "alpha", "w_", "imath", "pi", "stand", "\u03bbterm", "lambda", "phi_", "imathalpha", "lambda", "w_", "imath", "forall", "x_", "alpha", "phi_", "imathalpha", "x_", "alpha", "w_", "imath", "box", "get", "resolved", "described", "choice", "pi", "realizes", "possibilist", "notion", "quantification", "introducing", "binary", "existence", "predicate", "metalogic", "utilizing", "predicate", "additional", "guard", "definition", "pi", "actualist", "notion", "quantification", "obtained", "expressing", "embedded", "modal", "formula", "varphi_", "imath", "globally", "valid", "captured", "formula", "forall", "x_", "imath", "varphi_", "imath", "x_", "imath", "local", "validity", "also", "actuality", "modeled", "varphi_", "imath", "n_", "imath", "n_", "imath", "nominal", "constant", "symbol", "metalogic", "denoting", "particular", "possible", "world", "technique", "exploited", "natural", "encoding", "automated", "assessment", "g\u00f6del", "ontological", "argument", "higherorder", "modal", "logic", "unfolds", "formula", "church", "type", "theory", "higherorder", "theorem", "provers", "applied", "detail", "presented", "section", "6", "logic", "philosophy", "sep", "entry", "automated", "reasoning", "also", "section", "52", "moreover", "see", "benzm\u00fcller", "woltzenlogelpaleo", "2014", "benzm\u00fcller", "2019", "example", "5", "suppose", "omit", "use", "type", "symbol", "definition", "wffs", "write", "formula", "lambda", "xnsim", "xx", "shall", "call", "textrm", "r", "regarded", "denoting", "set", "set", "x", "x", "x", "may", "consider", "formula", "textrm", "r", "r", "express", "assertion", "textrm", "r", "clearly", "prove", "textrm", "r", "r", "equiv", "lambda", "xnsim", "xx", "textrm", "r", "\u03bbconversion", "derive", "textrm", "r", "r", "equiv", "nsim", "textrm", "r", "r", "contradiction", "russell", "paradox", "russell", "discovery", "paradox", "russell", "1903", "101107", "played", "crucial", "role", "development", "type", "theory", "course", "type", "symbol", "present", "textrm", "r", "wellformed", "contradiction", "derived", "13", "axiom", "rule", "inference", "131", "rule", "inference", "alphabetic", "change", "bound", "variable", "alpha", "conversion", "replace", "wellformed", "part", "lambda", "bx_", "beta", "ba_", "alpha", "wff", "lambda", "by_", "beta", "textsf", "sub", "by_", "beta", "bx_", "beta", "ba_", "alpha", "provided", "by_", "beta", "occur", "ba_", "alpha", "bx_", "beta", "bound", "ba_", "alpha", "\u03b2contraction", "replace", "wellformed", "part", "lambda", "bx_", "alpha", "bb_", "beta", "ba_", "alpha", "wff", "textsf", "sub", "ba_", "alpha", "bx_", "alpha", "bb_", "beta", "provided", "bound", "variable", "bb_", "beta", "distinct", "bx_", "alpha", "free", "variable", "ba_", "alpha", "\u03b2expansion", "infer", "bc", "bd", "bd", "inferred", "bc", "single", "application", "\u03b2contraction", "substitution", "bf_", "alpha", "bx_", "alpha", "infer", "bf_", "alpha", "ba_", "alpha", "provided", "bx_", "alpha", "free", "variable", "bf_", "alpha", "modus", "ponens", "ba_", "supset", "bb_", "ba_", "infer", "bb_", "generalization", "bf_", "alpha", "bx_", "alpha", "infer", "pi_", "alpha", "bf_", "alpha", "provided", "bx_", "alpha", "free", "variable", "bf_", "alpha", "132", "elementary", "type", "theory", "start", "listing", "axiom", "shall", "call", "elementary", "type", "theory", "begin", "align", "p_", "lor", "p_", "supset", "p_", "tag", "1", "p_", "supset", "p_", "lor", "q_", "tag", "2", "p_", "lor", "q_", "supset", "q_", "lor", "p_", "tag", "3", "p_", "supset", "q_", "supset", "r_", "lor", "p_", "supset", "r_", "lor", "q_", "tag", "4", "pi_", "alpha", "f_", "alpha", "supset", "f_", "alpha", "x_", "alpha", "tag", "5", "alpha", "forall", "x_", "alpha", "p_", "lor", "f_", "alpha", "x_", "alpha", "supset", "left", "p_", "lor", "pi_", "alpha", "f_", "alpha", "right", "tag", "6", "alpha", "end", "align", "theorem", "elementary", "type", "theory", "theorem", "derived", "using", "rule", "inference", "axiom", "1", "6", "alpha", "type", "symbol", "alpha", "shall", "sometimes", "refer", "elementary", "type", "theory", "ct", "embodies", "logic", "propositional", "connective", "quantifier", "\u03bbconversion", "context", "type", "theory", "illustrate", "rule", "axiom", "introduced", "give", "short", "trivial", "proof", "ct", "following", "wff", "proof", "indicate", "inferred", "proof", "actually", "quite", "inefficient", "since", "line", "3", "used", "later", "line", "7", "derived", "directly", "line", "5", "without", "using", "line", "6", "additional", "proof", "line", "inserted", "illustrate", "relevant", "aspect", "sake", "readability", "many", "bracket", "deleted", "formula", "proof", "diligent", "reader", "able", "restore", "begin", "alignat", "2", "forall", "x_", "imath", "left", "p_", "lor", "f_", "imath", "x_", "imath", "right", "supsetleft", "p_", "lor", "pi_", "imath", "f_", "imath", "right", "text", "axiom", "6", "imath", "tag", "1", "bigg", "lambda", "f_", "imath", "bigg", "forall", "x_", "imath", "p_", "lor", "f_", "imath", "x_", "imath", "supset", "bigg", "p_", "lor", "pi_", "imath", "f_", "imath", "bigg", "bigg", "bigg", "f_", "imath", "text", "\u03b2expansion", "1", "tag", "2", "pi_", "imath", "bigg", "lambda", "f_", "imath", "bigg", "forall", "x_", "imath", "p_", "lor", "f_", "imath", "x_", "imath", "supset", "bigg", "p_", "lor", "pi_", "imath", "f_", "imath", "bigg", "bigg", "bigg", "text", "generalization", "2", "tag", "3", "bigg", "lambda", "f_", "imath", "bigg", "forall", "x_", "imath", "p_", "lor", "f_", "imath", "x_", "imath", "supset", "bigg", "p_", "lor", "pi_", "imath", "f_", "imath", "bigg", "bigg", "bigg", "lambda", "x_", "imath", "r_", "imath", "x_", "imath", "text", "substitution", "2", "tag", "4", "forall", "x_", "imath", "p_", "lor", "lambda", "x_", "imath", "r_", "imath", "x_", "imath", "x_", "imath", "supset", "left", "p_", "lor", "pi_", "imath", "left", "lambda", "x_", "imath", "r_", "imath", "x_", "imath", "right", "right", "text", "\u03b2contraction", "4", "tag", "5", "forall", "x_", "imath", "p_", "lor", "lambda", "y_", "imath", "r_", "imath", "y_", "imath", "x_", "imath", "supset", "left", "p_", "lor", "pi_", "imath", "left", "lambda", "x_", "imath", "r_", "imath", "x_", "imath", "right", "right", "text", "\u03b1conversion", "5", "tag", "6", "forall", "x_", "imath", "left", "p_", "lor", "r_", "imath", "x_", "imath", "right", "supset", "left", "p_", "lor", "pi_", "imath", "left", "lambda", "x_", "imath", "r_", "imath", "x_", "imath", "right", "right", "text", "\u03b2contraction", "6", "tag", "7", "end", "alignat", "note", "3", "written", "forall", "f_", "imath", "forall", "x_", "imath", "p_", "lor", "f_", "imath", "x_", "imath", "supset", "p_", "lor", "forall", "x_", "imath", "f_", "imath", "x_", "imath", "tag", "3", "7", "written", "forall", "x_", "imath", "p_", "lor", "r_", "imath", "x_", "imath", "supset", "p_", "lor", "forall", "x_", "imath", "r_", "imath", "x_", "imath", "tag", "7", "thus", "derived", "well", "known", "law", "quantification", "theory", "illustrate", "one", "possible", "interpretation", "wff", "7", "closely", "related", "axiom", "6", "considering", "situation", "rancher", "put", "horse", "corral", "leaf", "night", "later", "remember", "whether", "closed", "gate", "corral", "reflecting", "situation", "come", "conclusion", "expressed", "7", "take", "horse", "element", "type", "imath", "interpret", "p_", "mean", "gate", "closed", "interpret", "r_", "imath", "r_", "imath", "x_", "imath", "asserts", "x_", "imath", "left", "corral", "interpretation", "7", "say", "true", "every", "horse", "gate", "closed", "horse", "left", "corral", "gate", "closed", "every", "horse", "left", "corral", "axiom", "listed", "add", "axiom", "obtain", "church", "type", "theory", "133", "axiom", "extensionality", "axiom", "boolean", "functional", "extensionality", "following", "begin", "align", "x_", "equiv", "y_", "supset", "x_", "y_", "tag", "7", "forall", "x_", "beta", "f_", "alpha", "beta", "x_", "beta", "g_", "alpha", "beta", "x_", "beta", "supset", "f_", "alpha", "beta", "g_", "alpha", "beta", "tag", "7", "alpha", "beta", "end", "align", "church", "include", "axiom", "7", "list", "axiom", "church", "1940", "mentioned", "possibility", "including", "henkin", "include", "henkin", "1950", "134", "description", "expression", "exists_1bx_", "alpha", "ba_", "stand", "lambda", "p_", "alpha", "exists", "y_", "alpha", "p_", "alpha", "y_", "alpha", "land", "forall", "z_", "alpha", "p_", "alpha", "z_", "alpha", "supset", "z_", "alpha", "y_", "alpha", "lambda", "bx_", "alpha", "ba_", "example", "exists_1", "x_", "alpha", "p_", "alpha", "x_", "alpha", "stand", "lambda", "p_", "alpha", "exists", "y_", "alpha", "p_", "alpha", "y_", "alpha", "land", "forall", "z_", "alpha", "p_", "alpha", "z_", "alpha", "supset", "z_", "alpha", "y_", "alpha", "lambda", "x_", "alpha", "p_", "alpha", "x_", "alpha", "\u03bbconversion", "equivalent", "exists", "y_", "alpha", "lambda", "x_", "alpha", "p_", "alpha", "x_", "alpha", "y_", "alpha", "land", "forall", "z_", "alpha", "lambda", "x_", "alpha", "p_", "alpha", "x_", "alpha", "z_", "alpha", "supset", "z_", "alpha", "y_", "alpha", "reduces", "\u03bbconversion", "exists", "y_", "alpha", "p_", "alpha", "y_", "alpha", "land", "forall", "z_", "alpha", "p_", "alpha", "z_", "alpha", "supset", "z_", "alpha", "y_", "alpha", "asserts", "unique", "element", "property", "p_", "alpha", "example", "see", "general", "exists_1bx_", "alpha", "ba_", "express", "assertion", "unique", "bx_", "alpha", "ba_", "unique", "element", "bx_", "alpha", "convenient", "notation", "atoibx_", "alpha", "ba_", "represent", "expression", "bx_", "alpha", "ba_", "russell", "showed", "whitehead", "russell", "1927b", "provide", "contextual", "definition", "notation", "formulation", "type", "theory", "church", "type", "theory", "atoibx_", "alpha", "ba_", "defined", "iota_", "alpha", "alpha", "lambda", "bx_", "alpha", "ba_", "thus", "atoi", "behaves", "like", "variablebinding", "operator", "defined", "term", "\u03bb", "aid", "constant", "iota_", "alpha", "alpha", "thus", "\u03bb", "still", "variablebinding", "operator", "needed", "since", "ba_", "describes", "bx_", "alpha", "iota_", "alpha", "alpha", "called", "description", "operator", "associated", "notation", "following", "axiom", "description", "exists_1", "x_", "alpha", "p_", "alpha", "x_", "alpha", "supset", "p_", "alpha", "iota_", "alpha", "alpha", "p_", "alpha", "tag", "8", "alpha", "say", "set", "p_", "alpha", "unique", "member", "iota_", "alpha", "alpha", "p_", "alpha", "p_", "alpha", "therefore", "unique", "member", "thus", "axiom", "asserts", "iota_", "alpha", "alpha", "map", "oneelement", "set", "unique", "member", "certain", "hypothesis", "one", "prove", "exists_1bx_", "alpha", "ba_", "using", "axiom", "8", "alpha", "one", "derive", "lambda", "bx_", "alpha", "ba_", "iota_", "alpha", "alpha", "lambda", "bx_", "alpha", "ba_", "also", "written", "lambda", "bx_", "alpha", "ba_", "atoibx_", "alpha", "ba_", "illustrate", "usefulness", "description", "operator", "small", "example", "suppose", "formalized", "theory", "real", "number", "theory", "constant", "1_", "varrho", "times_", "varrho", "varrho", "varrho", "represent", "number", "1", "multiplication", "function", "respectively", "varrho", "type", "real", "number", "represent", "multiplicative", "inverse", "function", "define", "wff", "textrm", "inv", "_", "varrho", "varrho", "lambda", "z_", "varrho", "atoi", "x_", "varrho", "times_", "varrho", "varrho", "varrho", "z_", "varrho", "x_", "varrho", "1_", "varrho", "course", "traditional", "mathematical", "notation", "would", "write", "type", "symbol", "would", "write", "times_", "varrho", "varrho", "varrho", "z_", "varrho", "x_", "varrho", "z", "times", "x", "write", "textrm", "inv", "_", "varrho", "varrho", "z", "z", "1", "thus", "z", "1", "defined", "x", "z", "times", "x", "1", "z", "provably", "0", "able", "prove", "exists_1", "x_", "varrho", "times_", "varrho", "varrho", "varrho", "textrm", "z", "x", "_", "varrho", "1_", "varrho", "z", "times", "z", "1", "1", "establish", "z", "0", "nothing", "significant", "z", "1", "provable", "135", "axiom", "choice", "axiom", "choice", "expressed", "follows", "church", "type", "theory", "exists", "x_", "alpha", "p_", "alpha", "x_", "alpha", "supset", "p_", "alpha", "iota_", "alpha", "alpha", "p_", "alpha", "tag", "9", "alpha", "9", "alpha", "say", "choice", "function", "iota_", "alpha", "alpha", "chooses", "every", "nonempty", "set", "p_", "alpha", "element", "designated", "iota_", "alpha", "alpha", "p_", "alpha", "set", "form", "axiom", "choice", "included", "list", "axiom", "iota_", "alpha", "alpha", "called", "selection", "operator", "instead", "description", "operator", "atoibx_", "alpha", "ba_", "mean", "bx_", "alpha", "ba_", "element", "bx_", "alpha", "selection", "operator", "meaning", "hilbert", "epsilon", "operator", "hilbert", "1928", "however", "provide", "one", "operator", "type", "\u03b1", "natural", "call", "atoi", "definite", "description", "operator", "context", "atoibx_", "alpha", "ba_", "mean", "bx_", "alpha", "ba_", "call", "indefinite", "description", "operator", "context", "atoibx_", "alpha", "ba_", "mean", "bx_", "alpha", "ba_", "clearly", "axiom", "choice", "implies", "axiom", "description", "sometimes", "formulation", "type", "theory", "used", "include", "axiom", "description", "axiom", "choice", "another", "formulation", "axiom", "choice", "simply", "asserts", "existence", "choice", "function", "without", "explicitly", "naming", "exists", "j_", "alpha", "alpha", "forall", "p_", "alpha", "exists", "x_", "alpha", "p_", "alpha", "x_", "alpha", "supset", "p_", "alpha", "j_", "alpha", "alpha", "p_", "alpha", "tag", "text", "ac", "alpha", "normally", "one", "assumes", "axiom", "choice", "type", "theory", "one", "assumes", "axiom", "schema", "asserts", "ac", "alpha", "type", "symbol", "\u03b1", "similar", "remark", "applies", "axiom", "extensionality", "description", "however", "modern", "proof", "system", "church", "type", "theory", "eg", "based", "resolution", "fact", "avoid", "addition", "axiom", "schema", "reason", "explained", "section", "34", "4", "work", "constrained", "goaldirected", "proof", "rule", "instead", "proceeding", "need", "introduce", "terminology", "cq_0", "alternative", "formulation", "church", "type", "theory", "described", "section", "14", "equivalent", "system", "described", "using", "axiom", "1", "8", "type", "symbol", "propositional", "symbol", "occur", "parenthesis", "yasuhara", "1975", "defined", "relation", "ge", "type", "reflexive", "transitive", "closure", "minimal", "relation", "alpha", "beta", "ge", "alpha", "alpha", "beta", "ge", "beta", "established", "alpha", "ge", "beta", "cq_0", "vdash", "ac", "alpha", "supset", "ac", "beta", "given", "set", "type", "none", "propositional", "model", "cq_0", "ac", "alpha", "fails", "alpha", "ge", "beta", "\u03b2", "s", "existence", "choice", "function", "higher", "type", "thus", "entail", "existence", "choice", "function", "lower", "type", "opposite", "generally", "case", "though", "b\u00fcchi", "1953", "shown", "schema", "expressing", "axiom", "choice", "zorn", "lemma", "derived", "relationship", "particular", "type", "involved", "complex", "136", "axiom", "infinity", "one", "define", "natural", "number", "therefore", "basic", "mathematical", "structure", "real", "complex", "number", "type", "theory", "prove", "required", "property", "peano", "postulate", "one", "need", "axiom", "infinity", "many", "viable", "possibility", "axiom", "discussed", "church", "1940", "section", "57", "church", "1956", "section", "60", "andrew", "2002", "14", "formulation", "based", "equality", "section", "121", "nsim_", "lor_", "pi_", "alpha", "taken", "primitive", "constant", "wffs", "sfq_", "alpha", "alpha", "denote", "equality", "relation", "type", "\u03b1", "defined", "term", "present", "alternative", "formulation", "cq_0", "church", "type", "theory", "primitive", "constant", "sfq_", "alpha", "alpha", "denoting", "equality", "nsim_", "lor_", "pi_", "alpha", "defined", "term", "sfq_", "alpha", "alpha", "tarski", "1923", "noted", "context", "higherorder", "logic", "one", "define", "propositional", "connective", "term", "logical", "equivalence", "quantifier", "quine", "1956", "showed", "quantifier", "connective", "defined", "term", "equality", "abstraction", "operator", "\u03bb", "context", "church", "type", "theory", "henkin", "1963", "rediscovered", "definition", "developed", "formulation", "church", "type", "theory", "based", "equality", "restricted", "attention", "propositional", "type", "andrew", "1963", "simplified", "axiom", "system", "cq_0", "based", "idea", "shown", "equivalent", "formulation", "church", "type", "theory", "using", "axiom", "1", "8", "preceding", "section", "section", "thus", "provides", "alternative", "material", "preceding", "section", "121134", "detail", "cq_0", "found", "andrew", "2002", "141", "definition", "type", "symbol", "improper", "symbol", "variable", "cq_0", "defined", "section", "121", "logical", "constant", "cq_0", "sfq_", "alpha", "alpha", "iota_", "imath", "imath", "type", "symbol", "\u03b1", "wffs", "cq_0", "defined", "section", "121", "abbreviation", "ba_", "alpha", "bb_", "alpha", "stand", "sfq_", "alpha", "alpha", "ba_", "alpha", "bb_", "alpha", "ba_", "equiv", "bb_", "stand", "sfq_", "a", "_", "b", "_", "t_", "stand", "sfq_", "sfq_", "f_", "stand", "lambda", "x_", "t_", "lambda", "x_", "x_", "pi_", "alpha", "stand", "sfq_", "alpha", "alpha", "lambda", "x_", "alpha", "t_", "forall", "bx_", "alpha", "ba", "stand", "pi_", "alpha", "lambda", "bx_", "alpha", "ba", "land_", "stand", "lambda", "x_", "lambda", "y_", "lambda", "g_", "g_", "t_", "t_", "lambda", "g_", "g_", "x_", "y_", "ba_", "land", "bb_", "stand", "land_", "ba_", "bb_", "nsim_", "stand", "sfq_", "f_", "t_", "denotes", "truth", "meaning", "pi_", "alpha", "discussed", "section", "11", "see", "definition", "pi_", "alpha", "appropriate", "note", "lambda", "x_", "alpha", "t", "denotes", "set", "element", "type", "\u03b1", "pi_", "alpha", "s_", "alpha", "stand", "sfq_", "alpha", "alpha", "lambda", "x_", "alpha", "s_", "alpha", "respectively", "lambda", "x_", "alpha", "s_", "alpha", "therefore", "pi_", "alpha", "s_", "alpha", "asserts", "s_", "alpha", "set", "element", "type", "\u03b1", "s_", "alpha", "contains", "element", "type", "\u03b1", "seen", "f_", "also", "written", "forall", "x_", "x_", "asserts", "everything", "true", "false", "f_", "denotes", "falsehood", "expression", "lambda", "g_", "g_", "x_", "y_", "used", "represent", "ordered", "pair", "langle", "x_", "y_", "rangle", "conjunction", "x_", "land", "y_", "true", "iff", "x_", "y_", "true", "ie", "iff", "langle", "t_", "t_", "rangle", "langle", "x_", "y_", "rangle", "hence", "x_", "land", "y_", "expressed", "formula", "lambda", "g_", "g_", "t_", "t_", "lambda", "g_", "g_", "x_", "y_", "propositional", "connective", "existential", "quantifier", "easily", "defined", "using", "iota_", "imath", "imath", "one", "define", "description", "operator", "iota_", "alpha", "alpha", "type", "\u03b1", "142", "axiom", "rule", "inference", "cq_0", "single", "rule", "inference", "rule", "r", "bc", "ba_", "alpha", "bb_", "alpha", "infer", "result", "replacing", "one", "occurrence", "ba_", "alpha", "bc", "occurrence", "bb_", "alpha", "provided", "occurrence", "ba_", "alpha", "bc", "occurrence", "variable", "immediately", "preceded", "\u03bb", "axiom", "cq_0", "following", "begin", "align", "g_", "t_", "land", "g_", "f_", "forall", "x_", "g_", "x_", "tag", "1", "x_", "alpha", "y_", "alpha", "supset", "h_", "alpha", "x_", "alpha", "h_", "alpha", "y_", "alpha", "tag", "2", "alpha", "f_", "alpha", "beta", "g_", "alpha", "beta", "forall", "x_", "beta", "f_", "alpha", "beta", "x_", "beta", "g_", "alpha", "beta", "x_", "beta", "tag", "3", "alpha", "beta", "lambda", "bx_", "alpha", "bb_", "beta", "ba_", "alpha", "textsf", "subfree", "ba_", "alpha", "bx_", "alpha", "bb_", "beta", "tag", "4", "quad", "text", "provided", "ba_", "alpha", "text", "free", "bx", "text", "bb_", "beta", "iota_", "imath", "imath", "sfq_", "imathimath", "y_", "imath", "y_", "imath", "tag", "5", "end", "align", "2", "semantics", "natural", "compare", "semantics", "type", "theory", "semantics", "firstorder", "logic", "theorem", "precisely", "wffs", "valid", "interpretation", "intuitive", "point", "view", "natural", "interpretation", "type", "theory", "standard", "model", "defined", "however", "consequence", "g\u00f6del", "incompleteness", "theorem", "g\u00f6del", "1931", "axiom", "1", "9", "suffice", "derive", "wffs", "valid", "standard", "model", "consistent", "recursively", "axiomatized", "extension", "axiom", "suffices", "purpose", "nevertheless", "experience", "show", "axiom", "sufficient", "purpose", "leon", "henkin", "considered", "problem", "clarifying", "sense", "complete", "definition", "theorem", "constitute", "henkin", "1950", "solution", "problem", "often", "referred", "general", "semantics", "henkin", "semantics", "frame", "collection", "cd_", "alpha", "_", "alpha", "nonempty", "domain", "set", "cd_", "alpha", "one", "type", "symbol", "\u03b1", "cd_", "sft", "sff", "sft", "represents", "truth", "sff", "represents", "falsehood", "cd_", "alpha", "beta", "collection", "function", "mapping", "cd_", "beta", "cd_", "alpha", "member", "cd_", "imath", "called", "individual", "interpretation", "langle", "cd_", "alpha", "_", "alpha", "frirangle", "consists", "frame", "function", "fri", "map", "constant", "c", "type", "\u03b1", "appropriate", "element", "cd_", "alpha", "called", "denotation", "c", "logical", "constant", "given", "standard", "denotation", "assignment", "value", "frame", "cd_", "alpha", "_", "alpha", "variable", "function", "phi", "phi", "bx_", "alpha", "in", "cd_", "alpha", "variable", "bx_", "alpha", "notation", "assignment", "phi", "ax", "map", "variable", "x", "value", "identical", "phi", "variable", "symbol", "different", "x", "interpretation", "cm", "langle", "cd_", "alpha", "_", "alpha", "frirangle", "general", "model", "aka", "henkin", "model", "iff", "binary", "function", "cv", "cv_", "phi", "ba_", "alpha", "in", "cd_", "alpha", "assignment", "phi", "wff", "ba_", "alpha", "following", "condition", "satisfied", "assignment", "wffs", "cv_", "phi", "bx_", "alpha", "phi", "bx_", "alpha", "variable", "bx_", "alpha", "cv_", "phi", "a_", "alpha", "fri", "a_", "alpha", "a_", "alpha", "primitive", "constant", "cv_", "phi", "ba_", "alpha", "beta", "bb_", "beta", "cv_", "phi", "ba_", "alpha", "beta", "cv_", "phi", "bb_", "beta", "value", "function", "cv_", "phi", "ba_", "alpha", "beta", "argument", "cv_", "phi", "bb_", "beta", "cv_", "phi", "lambda", "bx_", "alpha", "bb_", "beta", "function", "cd_", "alpha", "cd_", "beta", "whose", "value", "argument", "z", "in", "cd_", "alpha", "cv_", "psi", "bb_", "beta", "psi", "assignment", "psi", "bx_", "alpha", "z", "psi", "by_", "beta", "phi", "by_", "beta", "by_", "beta", "ne", "bx_", "alpha", "interpretation", "cm", "general", "model", "function", "cv", "uniquely", "determined", "cv_", "phi", "ba_", "alpha", "called", "value", "ba_", "alpha", "cm", "respect", "phi", "one", "easily", "show", "following", "statement", "hold", "general", "model", "cm", "assignment", "phi", "wffs", "ba", "bb", "cv_", "phi", "t_", "sft", "cv_", "phi", "f_", "sff", "cv_", "phi", "nsim_", "ba_", "sft", "iff", "cv_", "phi", "ba_", "sff", "cv_", "phi", "ba_", "lor", "bb_", "sft", "iff", "cv_", "phi", "ba_", "sft", "cv_", "phi", "bb_", "sft", "cv_", "phi", "ba_", "land", "bb_", "sft", "iff", "cv_", "phi", "ba_", "sft", "cv_", "phi", "bb_", "sft", "cv_", "phi", "ba_", "supset", "bb_", "sft", "iff", "cv_", "phi", "ba_", "sff", "cv_", "phi", "bb_", "sft", "cv_", "phi", "ba_", "equiv", "bb_", "sft", "iff", "cv_", "phi", "ba_", "cv_", "phi", "bb_", "cv_", "phi", "forall", "bx_", "alpha", "ba", "sft", "iff", "cv_", "phi", "ax", "ba", "sft", "in", "cd_", "alpha", "cv_", "phi", "exists", "bx_", "alpha", "ba", "sft", "iff", "exists", "in", "cd_", "alpha", "cv_", "phi", "ax", "ba", "sft", "semantics", "general", "model", "thus", "expected", "however", "subtlety", "note", "regarding", "following", "condition", "arbitrary", "type", "\u03b1", "equality", "cv_", "phi", "ba_", "alpha", "bb_", "alpha", "sft", "iff", "cv_", "phi", "ba_", "alpha", "cv_", "phi", "bb_", "alpha", "definition", "section", "121", "employed", "equality", "defined", "term", "leibniz", "principle", "statement", "implied", "type", "\u03b1", "hold", "additionally", "require", "domain", "cd_", "alpha", "contain", "unit", "set", "object", "type", "\u03b1", "alternatively", "domain", "cd_", "alphaalpha", "contain", "respective", "identity", "relation", "object", "type", "\u03b1", "entail", "former", "need", "additional", "requirement", "included", "original", "work", "henkin", "1950", "demonstrated", "andrew", "1972a", "instead", "alternative", "definition", "section", "14", "employed", "requirement", "obviously", "met", "due", "presence", "logical", "constant", "sfq_", "alpha", "alpha", "signature", "definition", "denote", "respective", "identity", "relation", "object", "type", "\u03b1", "therefore", "trivially", "ensure", "existence", "general", "model", "cm", "therefore", "natural", "option", "always", "assume", "primitive", "equality", "constant", "type", "\u03b1", "concrete", "choice", "base", "system", "church", "type", "theory", "realized", "andrew", "system", "cq_0", "interpretation", "langle", "cd_", "alpha", "_", "alpha", "frirangle", "standard", "model", "iff", "\u03b1", "beta", "cd_", "alpha", "beta", "set", "function", "cd_", "beta", "cd_", "alpha", "clearly", "standard", "model", "general", "model", "say", "wff", "ba", "valid", "model", "cm", "iff", "cv_", "phi", "ba", "sft", "every", "assignment", "phi", "cm", "model", "set", "ch", "wffs", "model", "wff", "ch", "valid", "wff", "ba", "valid", "general", "standard", "sense", "iff", "ba", "valid", "every", "general", "standard", "model", "clearly", "wff", "valid", "general", "sense", "valid", "standard", "sense", "converse", "statement", "false", "completeness", "soundness", "theorem", "henkin", "1950", "wff", "theorem", "valid", "general", "sense", "frame", "belong", "interpretation", "interpretation", "general", "model", "order", "general", "model", "interpretation", "must", "frame", "satisfying", "certain", "closure", "condition", "discussed", "andrew", "1972b", "basically", "general", "model", "every", "wff", "must", "value", "respect", "assignment", "model", "said", "finite", "iff", "domain", "individual", "finite", "every", "finite", "model", "cq_0", "standard", "andrew", "2002", "theorem", "5404", "every", "set", "sentence", "cq_0", "infinite", "model", "also", "nonstandard", "model", "andrews2002", "theorem", "5506", "understanding", "distinction", "standard", "nonstandard", "model", "clarify", "many", "phenomenon", "example", "shown", "model", "cm", "langle", "cd_", "alpha", "_", "alpha", "frirangle", "cd_", "imath", "infinite", "domain", "cd_", "alpha", "countable", "thus", "cd_", "imath", "cd_", "imath", "countably", "infinite", "must", "bijection", "h", "however", "cantor", "theorem", "provable", "type", "theory", "therefore", "valid", "model", "say", "cd_", "imath", "subset", "member", "seemingly", "paradoxical", "situation", "called", "skolem", "paradox", "resolved", "looking", "carefully", "cantor", "theorem", "ie", "nsim", "exists", "g_", "imathimath", "forall", "f_", "imath", "exists", "j_", "imath", "g_", "imathimath", "j_", "imath", "f_", "imath", "considering", "mean", "model", "theorem", "say", "function", "g", "in", "cd_", "imathimath", "cd_", "imath", "cd_", "imath", "every", "set", "f_", "imath", "in", "cd_", "imath", "range", "usual", "interpretation", "statement", "cd_", "imath", "bigger", "cardinality", "cd_", "imath", "however", "actually", "mean", "model", "h", "cd_", "imathimath", "course", "cm", "must", "nonstandard", "axiom", "choice", "presumably", "true", "standard", "model", "nonstandard", "model", "cq_0", "ac", "imath", "false", "andrew", "1972b", "thus", "ac", "imath", "provable", "cq_0", "thus", "far", "investigation", "model", "theory", "church", "type", "theory", "far", "le", "extensive", "firstorder", "logic", "nevertheless", "work", "method", "constructing", "nonstandard", "model", "type", "theory", "model", "various", "form", "extensionality", "fail", "model", "theory", "arbitrary", "possibly", "incomplete", "set", "logical", "constant", "developing", "general", "method", "establishing", "completeness", "various", "system", "axiom", "respect", "various", "class", "model", "relevant", "paper", "include", "andrew", "1971", "1972a", "b", "henkin", "1975", "related", "work", "found", "benzm\u00fcller", "et", "al", "2004", "brown", "2004", "2007", "muskens", "2007", "3", "metatheory", "31", "lambdaconversion", "first", "three", "rule", "inference", "section", "131", "called", "rule", "\u03bbconversion", "bd", "be", "wffs", "write", "bd", "conv", "be", "indicate", "bd", "converted", "be", "application", "rule", "equivalence", "relation", "wffs", "wff", "bd", "\u03b2normal", "form", "iff", "wellformed", "part", "form", "lambda", "bx_", "alpha", "bb_", "beta", "ba_", "alpha", "every", "wff", "convertible", "one", "\u03b2normal", "form", "indeed", "every", "sequence", "contraction", "application", "rule", "2", "combined", "necessary", "alphabetic", "change", "bound", "variable", "wff", "finite", "obviously", "sequence", "extended", "terminates", "wff", "\u03b2normal", "form", "called", "strong", "normalization", "theorem", "churchrosser", "theorem", "wff", "\u03b2normal", "form", "unique", "modulo", "alphabetic", "change", "bound", "variable", "wff", "ba", "denote", "downarrow", "ba", "first", "wff", "enumeration", "\u03b2normal", "form", "ba", "conv", "downarrow", "ba", "bd", "conv", "be", "downarrow", "bd", "downarrow", "be", "using", "axiom", "extensionality", "one", "obtain", "following", "derived", "rule", "inference", "eta", "contraction", "replace", "wellformed", "part", "lambda", "by_", "beta", "bb_", "alpha", "beta", "by_", "beta", "wff", "bb_", "alpha", "beta", "provided", "by_", "beta", "occur", "free", "bb_", "alpha", "beta", "rule", "inverse", "called", "eta", "expansion", "sometimes", "used", "additional", "rule", "\u03bbconversion", "see", "church", "1941", "stenlund", "1972", "barendregt", "1984", "barendregt", "et", "al", "2013", "information", "\u03bbconversion", "worth", "mentioning", "\u03bbabstraction", "replaces", "need", "comprehension", "axiom", "church", "type", "theory", "32", "higherorder", "unification", "challenge", "higherorder", "unification", "outlined", "briefly", "detail", "topic", "given", "dowek", "2001", "utilization", "higherorder", "theorem", "provers", "also", "discussed", "benzm\u00fcller", "miller", "2014", "definition", "higherorder", "unifier", "pair", "langle", "ba", "bbrangle", "wffs", "substitution", "theta", "free", "occurrence", "variable", "theta", "ba", "theta", "bb", "\u03b2normal", "form", "higherorder", "unifier", "set", "pair", "wffs", "unifier", "pair", "set", "higherorder", "unification", "differs", "firstorder", "unification", "baader", "snyder", "2001", "number", "important", "respect", "particular", "even", "unifier", "pair", "wffs", "exists", "may", "general", "unifier", "gould", "1966", "higherorder", "unification", "undecidable", "huet", "1973b", "even", "secondorder", "case", "goldfarb", "1981", "however", "algorithm", "devised", "huet", "1975", "jensen", "pietrzykowski", "1976", "called", "preunification", "find", "unifier", "set", "pair", "wffs", "one", "exists", "preunifiers", "computed", "huet", "procedure", "substitution", "reduce", "original", "unification", "problem", "one", "involving", "called", "flexflex", "unification", "pair", "flexflex", "pair", "variable", "head", "symbol", "term", "unified", "known", "always", "solution", "concrete", "computation", "solution", "thus", "postponed", "omitted", "preunification", "utilized", "resolution", "based", "theorem", "provers", "mentioned", "section", "4", "pattern", "unification", "refers", "small", "subset", "unification", "problem", "first", "studied", "miller", "1991", "whose", "identification", "important", "construction", "practical", "system", "pattern", "unification", "problem", "every", "occurrence", "existentially", "quantified", "variable", "applied", "list", "argument", "distinct", "variable", "bound", "either", "\u03bbbinder", "universal", "quantifier", "scope", "existential", "quantifier", "thus", "existentially", "quantified", "variable", "applied", "general", "term", "restricted", "set", "bound", "variable", "pattern", "unification", "like", "firstorder", "unification", "decidable", "general", "unifiers", "exist", "solvable", "problem", "pattern", "unification", "preferably", "employed", "applicable", "stateoftheart", "theorem", "provers", "church", "type", "theory", "33", "unifying", "principle", "unifying", "principle", "introduced", "smullyan", "1963", "see", "also", "smullyan", "1995", "tool", "deriving", "number", "basic", "metatheorems", "firstorder", "logic", "uniform", "way", "principle", "extended", "elementary", "type", "theory", "andrew", "1971", "extensional", "type", "theory", "henkin", "general", "semantics", "without", "description", "choice", "benzm\u00fcller", "brown", "kohlhase", "2004", "outline", "extension", "detail", "331", "elementary", "type", "theory", "unifying", "principle", "extended", "elementary", "type", "theory", "system", "ct", "section", "132", "andrew", "1971", "applying", "idea", "takahashi", "1967", "unifying", "principle", "ct", "used", "establish", "cutelimination", "ct", "andrew", "1971", "completeness", "proof", "various", "system", "type", "theory", "huet", "1973a", "kohlhase", "1995", "miller", "1983", "first", "give", "definition", "state", "principle", "definition", "property", "gamma", "finite", "set", "wffs", "_", "abstract", "consistency", "property", "iff", "finite", "set", "cs", "wffs", "_", "following", "property", "hold", "wffs", "b", "gamma", "cs", "atom", "ba", "ba", "in", "cs", "nsim", "ba", "in", "cs", "gamma", "cs", "cup", "ba", "gamma", "cs", "cup", "downarrow", "ba", "gamma", "cs", "cup", "nsim", "nsim", "ba", "gamma", "cs", "cup", "ba", "gamma", "cs", "cup", "ba", "lor", "bb", "gamma", "cs", "cup", "ba", "gamma", "cs", "cup", "bb", "gamma", "cs", "cup", "nsim", "ba", "lor", "bb", "gamma", "cs", "cup", "nsim", "ba", "nsim", "bb", "gamma", "cs", "cup", "pi_", "alpha", "ba_", "alpha", "gamma", "cs", "cup", "pi_", "alpha", "ba_", "alpha", "ba_", "alpha", "bb_", "alpha", "wff", "bb_", "alpha", "gamma", "cs", "cup", "nsim", "pi_", "alpha", "ba_", "alpha", "gamma", "cs", "cup", "nsim", "ba_", "alpha", "bc_", "alpha", "variable", "parameter", "bc_", "alpha", "occur", "free", "ba_", "alpha", "wff", "cs", "note", "consistency", "abstract", "consistency", "property", "unifying", "principle", "ct", "gamma", "abstract", "consistency", "property", "gamma", "cs", "cs", "consistent", "ct", "typical", "application", "unifying", "principle", "suppose", "procedure", "cm", "used", "refute", "set", "sentence", "wish", "show", "complete", "ct", "set", "sentence", "let", "gamma", "cs", "mean", "cs", "refutable", "cm", "show", "gamma", "abstract", "consistency", "property", "suppose", "ba", "theorem", "ct", "nsim", "ba", "inconsistent", "ct", "unifying", "principle", "gamma", "nsim", "ba", "nsim", "ba", "refutable", "cm", "332", "extensional", "type", "theory", "extension", "unifying", "principle", "towards", "church", "type", "theory", "general", "semantics", "studied", "since", "mid", "ninety", "primary", "motivation", "support", "refutational", "completeness", "investigation", "proof", "calculus", "underlying", "emerging", "higherorder", "automated", "theorem", "provers", "see", "section", "4", "initial", "interest", "fragment", "church", "type", "theory", "called", "extensional", "type", "theory", "includes", "extensionality", "axiom", "excludes", "iota_", "alpha", "alpha", "axiom", "description", "choice", "largely", "neglected", "automated", "theorem", "provers", "time", "analogous", "distinction", "made", "extensional", "type", "theory", "defined", "equality", "section", "121", "equality", "defined", "via", "leibniz", "principle", "extensional", "type", "theory", "primitive", "equality", "eg", "system", "cq_0", "section", "14", "alternatively", "system", "based", "logical", "constant", "nsim_", "lor_", "pi_", "alpha", "section", "121", "additional", "primitive", "logical", "constant", "_", "alphaalpha", "added", "first", "attempt", "towards", "unifying", "principle", "extensional", "type", "theory", "primitive", "equality", "presented", "kohlhase", "1993", "condition", "given", "still", "incomplete", "1", "subsequently", "modified", "complemented", "follows", "obtain", "unifying", "principle", "extensional", "type", "theory", "defined", "equality", "benzm\u00fcller", "kohlhase", "1997", "added", "following", "condition", "boolean", "extensionality", "functional", "extensionality", "saturation", "condition", "17", "ct", "presentation", "adapted", "technical", "reason", "also", "employ", "slightly", "stronger", "variant", "condition", "2", "based", "\u03b2conversion", "rather", "\u03b2normalization", "gamma", "cs", "cup", "ba_", "bb_", "gamma", "cs", "cup", "ba_", "bb_", "gamma", "cs", "cup", "nsim", "ba_", "nsim", "bb_", "gamma", "cs", "cup", "ba_", "alphabeta", "bb_", "alphabeta", "gamma", "cs", "cup", "ba_", "alphabeta", "bc_beta", "bb_", "alphabeta", "bc_beta", "parameter", "bc_", "beta", "occur", "free", "cs", "gamma", "cs", "cup", "ba_", "gamma", "cs", "cup", "nsim", "ba_", "saturation", "condition", "10", "required", "properly", "establish", "principle", "however", "since", "condition", "related", "proof", "theoretic", "notion", "cutelimination", "limit", "utility", "principle", "completeness", "proof", "machineoriented", "calculus", "principle", "nevertheless", "used", "benzm\u00fcller", "kohlhase", "1998a", "benzm\u00fcller", "1999a", "b", "obtain", "completeness", "proof", "system", "extensional", "higherorder", "resolution", "principle", "also", "applied", "kohlhase", "1998", "study", "completeness", "related", "extensional", "higherorder", "tableau", "calculus", "2", "extensionality", "rule", "leibniz", "equality", "adapted", "benzm\u00fcller", "kohlhase", "1998a", "respectively", "benzm\u00fcller", "1997", "different", "option", "achieving", "unifying", "principle", "extensional", "type", "theory", "primitive", "equality", "presented", "benzm\u00fcller", "1999a", "work", "primitive", "logical", "constant", "_", "alphaalpha", "used", "addition", "nsim_", "lor_", "pi_", "alpha", "redundant", "choice", "logical", "constant", "rare", "higherorder", "theorem", "provers", "one", "option", "introduce", "reflexivity", "substitutivity", "condition", "alternative", "combine", "reflexivity", "condition", "condition", "connecting", "primitive", "defined", "equality", "substitutivity", "condition", "follows", "note", "introducing", "defined", "notion", "equality", "based", "leibniz", "principle", "course", "still", "possible", "context", "defined", "equality", "denoted", "remainder", "section", "doteq", "properly", "distinguish", "primitive", "equality", "gamma", "cs", "cup", "nsim", "ba_", "alpha", "ba_", "alpha", "gamma", "cs", "cup", "ba_", "alpha", "ba_", "alpha", "gamma", "cs", "cup", "ba_", "alpha", "doteq", "ba_", "alpha", "gamma", "cs", "cup", "ba_", "gamma", "cs", "cup", "nsim", "ba_", "saturation", "condition", "10", "still", "added", "independent", "option", "considered", "principle", "applied", "benzm\u00fcller", "1999a", "b", "prove", "completeness", "extensional", "higherorder", "rueresolution", "3", "calculus", "underlying", "higherorder", "automated", "theorem", "prover", "leo", "successor", "leoii", "benzm\u00fcller", "et", "al", "2004", "principle", "presented", "general", "way", "allows", "various", "possibility", "concerning", "treatment", "extensionality", "equality", "range", "elementary", "type", "theory", "extensional", "type", "theory", "principle", "applied", "obtain", "completeness", "proof", "associated", "range", "natural", "deduction", "calculus", "saturation", "condition", "still", "used", "work", "based", "insight", "brown", "2004", "2007", "thesis", "solution", "replacing", "undesirable", "saturation", "condition", "two", "weaker", "condition", "presented", "benzm\u00fcller", "brown", "kohlhase", "2009", "work", "also", "study", "relation", "saturation", "cutelimination", "two", "weaker", "condition", "termed", "mating", "decomposition", "easier", "demonstrate", "saturation", "completeness", "proof", "machineoriented", "calculus", "omitting", "type", "information", "second", "one", "abusing", "notation", "gamma", "cs", "cup", "nsim", "ba_", "bb_", "atom", "ba_", "bb_", "gamma", "cs", "cup", "nsim", "ba_", "doteq", "bb_", "gamma", "cs", "cup", "nsim", "h", "overline", "ban_", "alphan", "doteq", "h", "overline", "bbn_", "alphan", "head", "symbol", "h_", "betaoverline", "alphan", "parameter", "i", "1", "leq", "leq", "n", "gamma", "cs", "cup", "nsim", "bai_", "alphai", "doteq", "bbi_", "alphai", "modified", "principle", "applied", "benzm\u00fcller", "et", "al", "2009", "show", "completeness", "sequent", "calculus", "extensional", "type", "theory", "defined", "equality", "extended", "unifying", "principle", "extensional", "type", "theory", "primitive", "equality", "presented", "used", "backes", "brown", "2011", "prove", "completeness", "tableau", "calculus", "type", "theory", "incorporates", "axiom", "choice", "closely", "related", "simplified", "principle", "also", "presented", "studied", "steen", "2018", "applied", "showing", "completeness", "paramodulation", "calculus", "steen", "2018", "underlying", "theorem", "prover", "leoiii", "steen", "benzm\u00fcller", "2018", "34", "cutelimination", "cutsimulation", "cutelimination", "proof", "see", "also", "sep", "entry", "proof", "theory", "church", "type", "theory", "often", "closely", "related", "proof", "takahashi", "1967", "1970", "prawitz", "1968", "mint", "1999", "formulation", "type", "theory", "may", "found", "andrew", "1971", "dowek", "werner", "2003", "brown", "2004", "benzm\u00fcller", "et", "al", "2009", "shown", "certain", "wffs", "_", "axiom", "extensionality", "description", "choice", "see", "section", "133", "135", "induction", "used", "justify", "cut", "cutfree", "sequent", "calculus", "elementary", "type", "theory", "moreover", "notion", "cutsimulation", "cutstrong", "axiom", "introduced", "work", "need", "omitting", "defined", "equality", "eliminating", "cutstrong", "axiom", "extensionality", "description", "choice", "induction", "machineoriented", "calculus", "eg", "replacing", "constrained", "goaldirected", "rule", "order", "reduce", "cutsimulation", "effect", "discussed", "major", "challenge", "higherorder", "automated", "theorem", "proving", "word", "including", "cutstrong", "axiom", "machineoriented", "proof", "calculus", "church", "type", "theory", "essentially", "bad", "including", "cut", "rule", "since", "cut", "rule", "mimicked", "35", "expansion", "proof", "expansion", "proof", "generalization", "notion", "herbrand", "expansion", "theorem", "firstorder", "logic", "provides", "elegant", "concise", "nonredundant", "representation", "relationship", "theorem", "tautology", "obtained", "appropriate", "instantiation", "quantifier", "underlies", "various", "proof", "theorem", "miller", "1987", "proved", "wff", "ba", "theorem", "elementary", "type", "theory", "ba", "expansion", "proof", "brown", "2004", "2007", "concept", "generalized", "extensional", "expansion", "proof", "obtain", "analogous", "theorem", "involving", "type", "theory", "extensionality", "36", "decision", "problem", "since", "type", "theory", "includes", "firstorder", "logic", "surprise", "system", "type", "theory", "undecidable", "however", "one", "may", "look", "solvable", "special", "case", "decision", "problem", "example", "system", "cq_", "0", "1", "obtained", "adding", "cq_0", "additional", "axiom", "forall", "x_", "imath", "forall", "y_", "imath", "x_", "imath", "y_", "imath", "decidable", "although", "system", "ct", "elementary", "type", "theory", "analogous", "firstorder", "logic", "certain", "respect", "considerably", "complex", "language", "special", "case", "decision", "problem", "provability", "ct", "seem", "rather", "intractable", "part", "information", "special", "case", "decision", "problem", "may", "found", "andrew", "1974", "summarize", "wff", "form", "exists", "bx1", "ldots", "exists", "bxn", "babb", "theorem", "ct", "iff", "substitution", "theta", "theta", "ba", "conv", "theta", "bb", "particular", "vdash", "babb", "iff", "ba", "conv", "bb", "solves", "decision", "problem", "wffs", "form", "babb", "naturally", "circumstance", "trivial", "equality", "formula", "provable", "ct", "change", "drastically", "axiom", "extensionality", "added", "ct", "vdash", "exists", "bx_", "beta", "babb", "iff", "wff", "be_", "beta", "vdash", "lambda", "bx_", "beta", "babb", "be_", "beta", "decision", "problem", "class", "wffs", "form", "exists", "bx_", "beta", "babb", "unsolvable", "wff", "form", "forall", "bx1", "ldots", "forall", "bxnbc", "bc", "quantifierfree", "provable", "ct", "iff", "downarrow", "bc", "tautologous", "hand", "decision", "problem", "wffs", "form", "exists", "bzbc", "bc", "quantifierfree", "unsolvable", "contrast", "corresponding", "decision", "problem", "firstorder", "logic", "function", "symbol", "known", "solvable", "maslov", "1967", "since", "irrelevant", "vacuous", "quantifier", "always", "introduced", "show", "solvable", "class", "wffs", "ct", "prenex", "normal", "form", "defined", "solely", "structure", "prefix", "existential", "quantifier", "occur", "4", "automation", "41", "machineoriented", "proof", "calculus", "development", "respectively", "improvement", "machineoriented", "proof", "calculus", "church", "type", "theory", "still", "challenge", "research", "topic", "compared", "eg", "theoretical", "practical", "maturity", "achieved", "firstorder", "automated", "theorem", "proving", "area", "still", "infancy", "obviously", "challenge", "also", "much", "bigger", "firstorder", "logic", "practically", "way", "expressive", "nature", "termlanguage", "church", "type", "theory", "cause", "larger", "bushier", "difficult", "traverse", "proof", "search", "space", "firstorder", "logic", "moreover", "remember", "unification", "constitutes", "important", "control", "filter", "mechanism", "firstorder", "theorem", "proving", "undecidable", "general", "type", "theory", "see", "section", "32", "positive", "side", "however", "chance", "find", "significantly", "shorter", "proof", "firstorder", "logic", "well", "illustrated", "small", "concrete", "example", "boolos", "1987", "clearly", "much", "progress", "needed", "leverage", "practical", "relevance", "existing", "calculus", "church", "type", "theory", "implementation", "see", "section", "43", "challenge", "include", "appropriate", "handling", "impredicative", "nature", "church", "type", "theory", "form", "blind", "guessing", "generally", "avoided", "complete", "proof", "procedure", "must", "intelligently", "guided", "eliminationreduction", "cutsimulation", "effect", "see", "section", "34", "caused", "defined", "equality", "cutstrong", "axiom", "eg", "extensionality", "description", "choice", "induction", "search", "space", "general", "undecidability", "unification", "rendering", "rather", "problematic", "filter", "mechanism", "controlling", "proof", "search", "invention", "suitable", "heuristic", "traversing", "search", "space", "provision", "suitable", "termorderings", "effective", "exploitation", "term", "rewriting", "procedure", "development", "efficient", "data", "structure", "combination", "strong", "technical", "support", "essential", "operation", "\u03bbconversion", "substitution", "rewriting", "planned", "future", "edition", "article", "elaborate", "machineoriented", "proof", "calculus", "church", "type", "theory", "time", "however", "provide", "selection", "historical", "recent", "reference", "interested", "reader", "see", "also", "section", "5", "sequent", "calculus", "sch\u00fctte", "1960", "takahashi", "1970", "takeuti", "1987", "mint", "1999", "brown", "2004", "2007", "benzm\u00fcller", "et", "al", "2009", "mating", "method", "andrew", "1981", "bibel", "1981", "bishop", "1999", "resolution", "calculus", "andrew", "1971", "huet", "1973a", "jensen", "pietrzykowski", "1976", "benzm\u00fcller", "1997", "1999a", "benzm\u00fcller", "kohlhase", "1998a", "tableau", "method", "kohlhase", "4", "1995", "1998", "brown", "smolka", "2010", "backes", "brown", "2011", "paramodulation", "calculus", "benzm\u00fcller", "1999a", "b", "steen", "2018", "42", "early", "proof", "assistant", "early", "computer", "system", "proving", "theorem", "church", "type", "theory", "extension", "include", "hol", "gordon", "1988", "gordon", "melham", "1993", "tps", "andrew", "et", "al", "1996", "andrew", "brown", "2006", "isabelle", "paulson", "1988", "1990", "pvs", "owre", "et", "al", "1996", "shankar", "2001", "imp", "farmer", "et", "al", "1993", "hol", "light", "harrison", "1996", "omega", "siekmann", "et", "al", "2006", "\u03bbclam", "richardson", "et", "al", "1998", "see", "internet", "reference", "section", "link", "info", "provers", "mentioned", "later", "majority", "system", "focused", "least", "initially", "interactive", "proof", "provided", "rather", "limited", "support", "additional", "proof", "automation", "full", "proof", "automation", "pioneered", "particular", "tps", "project", "progress", "made", "ninety", "project", "started", "similar", "activity", "respectively", "enforced", "however", "resource", "investment", "achievement", "lacking", "much", "behind", "seen", "firstorder", "theorem", "proving", "significant", "progress", "fostered", "later", "particular", "development", "commonly", "supported", "syntax", "church", "type", "theory", "called", "tptp", "thf", "sutcliffe", "benzm\u00fcller", "2010", "inclusion", "2009", "onwards", "tptp", "thf", "division", "yearly", "casc", "competition", "kind", "world", "championship", "automated", "theorem", "proving", "see", "sutcliffe", "2016", "detail", "43", "automated", "theorem", "provers", "selection", "theorem", "provers", "church", "type", "theory", "presented", "focus", "system", "successfully", "participated", "tptp", "thf", "casc", "competition", "past", "latest", "edition", "mentioned", "system", "accessed", "online", "via", "systemontptp", "infrastructure", "sutcliffe", "2017", "nearly", "mentioned", "system", "produce", "verifiable", "proof", "certificate", "tptp", "tstp", "syntax", "detail", "automation", "church", "type", "theory", "given", "benzm\u00fcller", "miller", "2014", "tps", "prover", "andrew", "et", "al", "1996", "andrew", "brown", "2006", "used", "prove", "theorem", "elementary", "type", "theory", "extensional", "type", "theory", "automatically", "interactively", "semiautomatically", "searching", "proof", "automatically", "tps", "first", "search", "expansion", "proof", "miller", "1987", "extensional", "expansion", "proof", "brown", "2004", "2007", "theorem", "part", "process", "involves", "searching", "acceptable", "mating", "andrew", "1981", "bishop", "1999", "behavior", "tps", "controlled", "set", "flag", "also", "called", "mode", "simple", "scheduling", "mechanism", "employed", "latest", "version", "tps", "sequentially", "run", "fifty", "mode", "limited", "amount", "time", "tps", "winner", "first", "thf", "casc", "competition", "2009", "leoii", "prover", "benzm\u00fcller", "et", "al", "2015", "successor", "leo", "benzm\u00fcller", "kohlhase", "1998b", "hardwired", "omega", "proof", "assistant", "leo", "stand", "logical", "engine", "omega", "provers", "based", "rueresolution", "calculus", "developed", "benzm\u00fcller", "1999a", "b", "leo", "first", "prover", "implement", "calculus", "rule", "extensionality", "avoid", "cutsimulation", "effect", "leoii", "inherits", "adapts", "provides", "additional", "calculus", "rule", "description", "choice", "prover", "internally", "collaborates", "firstorder", "provers", "preferably", "e", "sat", "solver", "pioneered", "cooperative", "higherorderfirstorder", "proof", "automation", "since", "prover", "often", "weak", "find", "refutation", "among", "steadily", "growing", "set", "clause", "clause", "leoii", "search", "space", "attain", "special", "status", "firstorder", "clause", "modulo", "application", "appropriate", "transformation", "function", "therefore", "leoii", "progressively", "launch", "time", "limited", "call", "clause", "firstorder", "theorem", "prover", "firstorder", "prover", "report", "refutation", "leoii", "also", "terminates", "part", "idea", "already", "implemented", "predecessor", "leo", "communication", "leoii", "cooperating", "firstorder", "theorem", "provers", "us", "tptp", "language", "standard", "leoii", "winner", "second", "thf", "casc", "competition", "2010", "satallax", "prover", "brown", "2012", "based", "complete", "ground", "tableau", "calculus", "church", "type", "theory", "choice", "backes", "brown", "2011", "initial", "tableau", "branch", "formed", "assumption", "conjecture", "negation", "conclusion", "point", "satallax", "try", "determine", "unsatisfiability", "satisfiability", "branch", "satallax", "progressively", "generates", "higherorder", "formula", "corresponding", "propositional", "clause", "satallax", "us", "sat", "solver", "minisat", "engine", "test", "current", "set", "propositional", "clause", "unsatisfiability", "clause", "unsatisfiable", "original", "branch", "unsatisfiable", "satallax", "provides", "calculus", "rule", "extensionality", "description", "choice", "quantifier", "function", "type", "generation", "higherorder", "formula", "corresponding", "clause", "may", "terminate", "case", "minisat", "report", "final", "set", "clause", "satisfiable", "original", "set", "higherorder", "formula", "satisfiable", "standard", "model", "type", "interpreted", "finite", "set", "satallax", "winner", "thf", "casc", "competition", "2011", "since", "2013", "isabellehol", "system", "nipkow", "wenzel", "paulson", "2002", "originally", "designed", "interactive", "prover", "however", "order", "ease", "user", "interaction", "several", "automatic", "proof", "tactic", "added", "year", "appropriately", "scheduling", "subset", "proof", "tactic", "quite", "powerful", "isabellehol", "since", "2011", "turned", "also", "automatic", "theorem", "prover", "tptp", "thf", "tptp", "syntax", "format", "run", "command", "shell", "like", "provers", "powerful", "proof", "tactic", "scheduled", "isabellehol", "include", "sledgehammer", "tool", "blanchette", "et", "al", "2013", "invokes", "sequence", "external", "firstorder", "higherorder", "theorem", "provers", "model", "finder", "nitpick", "blanchette", "nipkow", "2010", "equational", "reasoner", "simp", "untyped", "tableau", "prover", "blast", "simplifier", "classical", "reasoner", "auto", "force", "fast", "bestfirst", "search", "procedure", "best", "contrast", "automated", "theorem", "provers", "mentioned", "tptp", "incarnation", "isabellehol", "yet", "output", "proof", "certificate", "isabellehol", "winner", "thf", "casc", "competition", "2012", "agsyhol", "prover", "based", "generic", "lazy", "narrowing", "proof", "search", "algorithm", "backtracking", "employed", "comparably", "small", "search", "state", "maintained", "prover", "output", "proof", "term", "sequent", "style", "verified", "agda", "system", "coqatp", "implement", "noninductive", "part", "calculus", "construction", "bertot", "cast\u00e9ran", "2004", "system", "output", "proof", "term", "accepted", "proof", "addition", "definition", "coq", "proof", "assistant", "prover", "employ", "axiom", "functional", "extensionality", "choice", "excluded", "middle", "boolean", "extensionality", "supported", "addition", "axiom", "small", "library", "basic", "lemma", "employed", "leoiii", "prover", "implement", "paramodulation", "calculus", "church", "type", "theory", "steen", "2018", "system", "descendant", "leo", "leoii", "provides", "calculus", "rule", "extensionality", "description", "choice", "system", "put", "emphasis", "implementation", "efficient", "set", "underlying", "data", "structure", "simplification", "routine", "heuristic", "rewriting", "tradition", "predecessor", "leoiii", "cooperates", "firstorder", "reasoning", "tool", "using", "translation", "manysorted", "firstorder", "logic", "prover", "accepts", "every", "common", "tptp", "syntax", "dialect", "thus", "widely", "applicable", "recently", "prover", "also", "extended", "natively", "support", "almost", "every", "normal", "higherorder", "modal", "logic", "zipperposition", "bentkamp", "et", "al", "2018", "new", "inspiring", "higherorder", "theorem", "prover", "current", "state", "development", "still", "working", "comparably", "weak", "fragment", "church", "type", "theory", "called", "lambdafree", "higherorder", "logic", "comprehensionfree", "higherorder", "logic", "nevertheless", "supporting", "\u03bbnotation", "system", "based", "superposition", "calculus", "developed", "bottom", "progressively", "extended", "towards", "stronger", "fragment", "church", "type", "theory", "support", "relevant", "extension", "datatypes", "recursive", "function", "arithmetic", "various", "called", "proof", "hammer", "spirit", "isabelle", "sledgehammer", "tool", "recently", "developed", "integrated", "modern", "proof", "assistant", "prominent", "example", "include", "hol", "hammer", "kaliszyk", "urban", "2015", "hol", "light", "similar", "hammer", "czaika", "kaliszyk", "2018", "proof", "assistant", "coq", "44", "counter", "model", "finding", "support", "finding", "finite", "model", "countermodels", "formula", "church", "type", "theory", "implemented", "already", "tableaubased", "prover", "hot", "konrad", "1998", "restricted", "counter", "model", "finding", "capability", "also", "implemented", "provers", "satallax", "leoii", "leoiii", "advanced", "finite", "model", "finding", "support", "currently", "realized", "system", "nitpick", "nunchaku", "refute", "tool", "integrated", "isabelle", "proof", "assistant", "nitpick", "also", "available", "standalone", "tool", "accepts", "tptp", "thf", "syntax", "system", "particularly", "valuable", "exposing", "error", "misconception", "problem", "encoding", "revealing", "bug", "thf", "theorem", "provers", "5", "application", "51", "semantics", "natural", "language", "church", "type", "theory", "play", "important", "role", "study", "formal", "semantics", "natural", "language", "pioneering", "work", "done", "richard", "montague", "see", "paper", "english", "formal", "language", "universal", "grammar", "proper", "treatment", "quantification", "ordinary", "english", "reprinted", "montague", "1974", "crucial", "component", "montague", "analysis", "natural", "language", "definition", "tensed", "intensional", "logic", "montague", "1974", "256", "enhancement", "church", "type", "theory", "montague", "grammar", "huge", "impact", "since", "developed", "many", "direction", "least", "typelogicalcategorical", "grammar", "related", "work", "intensional", "higherorder", "modal", "logic", "presented", "gallin", "1975", "muskens", "2006", "52", "mathematics", "computer", "science", "proof", "assistant", "based", "church", "type", "theory", "including", "isabellehol", "hol", "light", "hol4", "pvs", "successfully", "utilized", "broad", "range", "application", "computer", "science", "mathematics", "application", "computer", "science", "include", "verification", "hardware", "software", "security", "protocol", "prominent", "example", "l4verified", "project", "isabellehol", "used", "formally", "prove", "sel4", "operating", "system", "kernel", "implement", "abstract", "mathematical", "model", "specifying", "kernel", "supposed", "klein", "et", "al", "2018", "mathematics", "proof", "assistant", "applied", "development", "library", "mathematical", "theory", "verification", "challenge", "theorem", "early", "example", "mathematical", "library", "developed", "since", "eighty", "tps", "project", "exemplary", "list", "theorem", "proved", "automatically", "tps", "given", "andrew", "et", "al", "1996", "prominent", "recent", "example", "hale", "flyspeck", "hol", "light", "employed", "develop", "formal", "proof", "kepler", "conjecture", "hale", "et", "al", "2017", "example", "strongly", "exploit", "automation", "support", "isabellehol", "sledgehammer", "nitpick", "presented", "benzm\u00fcller", "scott", "forthcoming", "work", "different", "axiom", "system", "category", "theory", "explored", "compared", "solid", "overview", "past", "ongoing", "formalization", "project", "obtained", "consulting", "respective", "source", "isabelle", "archive", "formal", "proof", "journal", "formalized", "reasoning", "thf", "entry", "sutcliffe", "tptp", "problem", "library", "improving", "proof", "automation", "within", "proof", "assistantsbased", "proof", "hammering", "tool", "form", "prover", "integrationis", "relevant", "minimizing", "interaction", "effort", "future", "application", "53", "computational", "metaphysics", "artificial", "intelligence", "church", "type", "theory", "classical", "logic", "topical", "application", "philosophy", "artificial", "intelligence", "often", "require", "expressive", "nonclassical", "logic", "order", "support", "application", "reasoning", "tool", "church", "type", "theory", "shallow", "semantical", "embedding", "technique", "see", "also", "section", "122", "developed", "generalizes", "extends", "idea", "underlying", "well", "known", "standard", "translation", "modal", "logic", "firstorder", "logic", "technique", "applied", "assessment", "modern", "variant", "ontological", "argument", "range", "higherorder", "theorem", "provers", "including", "leoii", "satallax", "nitpick", "isabellehol", "course", "experiment", "leoii", "detected", "inconsistency", "premise", "g\u00f6del", "argument", "provers", "succeeded", "automatically", "proving", "scott", "emendation", "confirm", "consistency", "emended", "premise", "detail", "work", "presented", "related", "sep", "entry", "automated", "reasoning", "see", "section", "46", "logic", "philosophy", "semantical", "embedding", "approach", "adapted", "extended", "range", "nonclassical", "logic", "related", "application", "philosophy", "includes", "encoding", "formal", "assessment", "ambitious", "ethical", "metaphysical", "theory", "artificial", "intelligence", "includes", "mechanization", "deontic", "logic", "normative", "reasoning", "well", "automatic", "proof", "muddy", "child", "puzzle", "see", "appendix", "b", "dynamic", "epistemic", "logic", "famous", "puzzle", "epistemic", "reasoning", "respectively", "dynamic", "epistemic", "reasoning"]}