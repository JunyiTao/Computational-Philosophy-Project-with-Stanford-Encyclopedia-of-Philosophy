{
    "main_text": "Combinatory terms and their main properties || Reduction, equality and their formalizations\n2.1 Reduction, equality and their formalizations\n\nThe paradoxes that were discovered by Georg Cantor and Bertrand\nRussell in the late 19th\u2013early 20th century both involve\nself-membership of a set. The ramified theory of types due to Alfred\nN.\u00a0Whitehead and Bertrand Russell, and\n ZF\n(the formalization of set theory named after Ernst Zermelo and\nAbraham A.\u00a0Fraenkel) exclude self-membership. However, there\nseems to have been always a desire to create a theory that allows\nself-membership or self-application. Indeed, one of Curry\u2019s\nmotivations for the development of CL was the goal to construct a\nformal language that includes a wide range of well-formed expressions,\nsome of which\u2014under certain interpretations\u2014may turn out\nto be meaningless. (This idea may be compared to the\n von Neumann\u2013Bernays\u2013G\u00f6del\nformalization of set theory, in which\u2014without the axiom of\nfoundation\u2014the Russell class can be proved not to be a set,\nhence, to be a proper class.)\n\nA few natural language examples provide a convenient illustration to\nclarify the difference between (1), that is a well-formed (but\nmeaningless) expression and (2), which is a meaningful (but\nill-formed) sentence. (The meaningfulness of (2), of course, should be\ntaken with a grain of salt. In reality,\n Kurt G\u00f6del\nproved the system of PM to be incomplete in 1930. Thus (2) may be\nguessed\u2014using syntactic and semantics clues\u2014to be a\ndistorted version of (2\u2032) Peano arithmetic was proved to be\nincomplete by G\u00f6del in 1930.)\n\n(1)\n\nThe derivative of \\(\\lambda x\\,(x^2+4x-6)\\) wishes to declare that\nfunctions are smart.\n\n(2)\n\nPeano arithmetics prove incomplete with G\u00f6del at 1930.\n\n\n\nAfter these informal motivations, we turn to CL proper and introduce\nsome of its notions a bit more formally.\n\nThe objects in CL are called\nterms.[9]\nTerms may be thought to be interpreted as functions (as further\nexplained in section 4.1). Primitive terms comprise\nvariables and constants, whereas compound terms\nare formed by combining terms. Usually, a denumerable set (i.e., a set\nwith cardinality \\(\\aleph_0\\)) of variables is included, and\nthe constants include some (undefined) combinators. (We use\n\\(x,y,z,v,w,u,x_0,\\ldots\\) as variables in the\nobject language, and \\(M,N,P,Q,\\ldots\\) \nas metavariables that range over terms.)\n\nTerms are inductively defined as follows.\n\n(t1)\n\nIf \\(x\\) is a variable, then \\(x\\) is a term; \n\n(t2)\n\nif \\(c\\) is a constant, then \\(c\\) is a term; \n\n(t3)\n\nif \\(M\\) and \\(N\\) are terms, then (\\(MN\\)) is a term.\n\n\n\nIn the above definition, (t3) conceals the binary operation that\nconjoins the two terms \\(M\\) and \\(N\\). This operation is\ncalled application, and it is often denoted by juxtaposition, that is,\nby placing its two arguments next to each other as in (\\(MN\\)).\n\nApplication is not assumed to possess additional properties (such as\ncommutativity), because its intended interpretation is function\napplication. For instance, \\(((vw)u)\\) and\n\\((v(wu))\\) are distinct terms\u2014just as the derivative \nof \\(\\lambda x.\\,x^2+4x-6\\) applied to 8 (that is,\n(\\(\\lambda x.\\,2x+4)8=20\\)) is different from the derivative of 90 (that is,\n\\((8^2+32-6)'=0\\)). Using \\(\\lambda\\) notation, the two terms in the example\nmay be expressed as\n\\[\n ((\\lambda y.\\,y')(\\lambda x.\\,x^2+4x-6))8\n\\]\n\nvs\n\n\\[\n(\\lambda y.\\,y')((\\lambda x.\\,x^2+4x-6)8).\n\\]\n\n\nIf terms are viewed as structured strings (where parentheses show grouping),\nthen the number of distinct terms associated to a string of length \n\\(n\\) is the Catalan number \\(C_{n-1}\\).  For a\nnon-negative integer \\(n\\) (i.e., for \\(n\\in\\mathbb{N}\\)),\n\\[\nC_n = \\frac{1}{n+1} {2n \\choose n}.\n\\]\n\nThe first seven Catalan numbers are \\(C_0=1\\), \\(C_1=1\\), \\(C_2=2\\), \n\\(C_3=5\\), \\(C_4=14\\), \\(C_5=42\\) and \\(C_6=132\\).  As an\nillustration, we may take\u2014for simplicity\u2014strings consisting\nof \\(x\\)s, because the terms are to differ only in their grouping.\nClearly, if the term is \\(x\\) or \\(xx\\), that is of length 1\nor 2, then there is only one way to form a term, that is, there exists\njust one possible term in each case. If we start with three \\(x\\)s,\nthen we may form \\((xx)x\\) or \\(x(xx)\\). If the length of the term is 4, then\nthe five terms are: \\(xxxx\\), \\(x(xx)x\\), \\(xx(xx)\\), \\(x(xxx)\\) and \\(x(x(xx\n))\\). (It is a useful exercise to try to list the 14 distinct terms that\ncan be formed from 5 \\(x\\)s.)\n\nThe usual notational convention in CL is to drop parentheses\nfrom left-associated terms together with the outmost pair. For\ninstance, \\(xyz\\) would be fully written as \\(((xy)z)\\), whereas \\(xy(xz)\\)\nand \\((xy)(xz)\\) are both \u201cshorthand versions\u201d of\nthe term \\(((xy)(xz))\\) (unlike \\(xyxz\\)). Grouping\nin terms delineates subterms. For instance, \\(xy\\) is a subterm of\neach of the terms mentioned in this paragraph, whereas \\(yz\\)\nand \\(yx\\) are subterms of none of those terms.\n\nSubterms of a term are recursively defined as follows.\n\n(s1)\n\n\\(M\\) is a subterm of \\(M\\);\n\n(s2)\n\nif \\(M\\) is a subterm of \\(N\\) or of \\(P\\), then \\(M\\) is a subterm of \\(NP\\).\n\n\n\nIncidentally, the notion of free variables is straightforwardly\ndefinable now: \\(x\\) is a free variable of \\(M\\) iff\n\\(x\\) is a subterm of \\(M\\). The set of free variables\nof \\(M\\) is sometimes denoted by \\(\\textrm{fv}(M)\\).\n\nAll terms are interpreted as functions, and combinators are functions\ntoo. Similarly, to some numerical and geometrical functions, that can\nbe described and grasped easily, the combinators that are frequently\nencountered can be characterized as perspicuous transformations on\nterms. (Sans serif letters denote combinators and > denotes\none-step reduction.)\n\nDefinition. (Axioms of some well-known combinators)\n\n\n\\(\\textsf{S}xyz \\mathbin{\\triangleright_1} xz(yz)\\)\n\\(\\textsf{K}xy \\mathbin{\\triangleright_1} x\\)\n\\(\\textsf{I}x \\mathbin{\\triangleright_1} x\\)\n\n\\(\\textsf{B}xyz \\mathbin{\\triangleright_1} x(yz)\\)\n\\(\\textsf{T}xy \\mathbin{\\triangleright_1} yx\\)\n\\(\\textsf{C}xyz \\mathbin{\\triangleright_1} xzy\\)\n\n\\(\\textsf{W}xy \\mathbin{\\triangleright_1} xyy\\)\n\\(\\textsf{M}x \\mathbin{\\triangleright_1} xx\\)\n\\(\\textsf{Y}x \\mathbin{\\triangleright_1} x(\\textsf{Y}x)\\)\n\n\\(\\textsf{J}xyzv \\mathbin{\\triangleright_1} xy(xvz)\\)\n\\(\\textsf{B}^\\prime xyz \\mathbin{\\triangleright_1} y(xz)\\)\n\\(\\textsf{V}xyz \\mathbin{\\triangleright_1} zxy\\)\n\n\n\nThese axioms tacitly specify the arity of a combinator as well\nas their reduction (or contraction) pattern. Perhaps,\nthe simplest combinaetor is the identity combinator \\(\\textsf{I}\\),\nthat applied to an argument \\(x\\) returns\nthe same \\(x\\). \\(\\textsf{K}\\) applied to \\(x\\) is\na constant function, because when it is further applied to \\(y\\),\nit yields \\(x\\) as a result, that is, \\(\\textsf{K}\\)\nis a cancellator with respect to its second argument. \\(\\textsf{W}\\)\nand \\(\\textsf{M}\\) are duplicators, because in the result of their\napplication one of the arguments (always) appears\ntwice.[10]\n\\(\\textsf{C}\\), \\(\\textsf{T}\\) and \\(\\textsf{V}\\) are permutators,\nbecause they change the order of some of their arguments. \\(\\textsf{B}\\) is an\nassociator, because \\(\\textsf{B}xyz\\) turns\ninto a term in which \\(y\\) is applied to \\(z\\)\nbefore \\(x\\) is applied to the result. \\(\\textsf{Y}\\) is the fixed\npoint combinator, because for any function \\(x\\),\n\\(\\textsf{Y}x\\)  is the fixed point of that function (see\nsection 2.3). The combinator \\(\\textsf{B}^\\prime\\) is an\nassociator and a permutator, whereas \\(\\textsf{S}\\) and\n\\(\\textsf{J}\\) are also duplicators. \\(\\textsf{S}\\)\nis very special and it is called the strong composition combinator,\nbecause when applied to two functions, let us say, \\(g\\) and \n\\(f\\) (in that order), as well as \\(x\\), then the resulting \nterm \\(gx(fx)\\) expresses the composition of \\(g\\)\nand \\(f\\) both applied to the same argument \\(x\\).\n\nThese informal explications did not mention any restrictions on the\nsort of functions \\(x,y,z,f,g,\\ldots\\) may be. However, the axioms above limit\nthe applicability of the combinators to variables. Intuitively, we would like\nto say that given any terms, that is, any functions \\(M\\) and \\(N\\),\n\\(\\textsf{W}MN\\) one-step reduces to \\(MNN\\) (possibly, as a subterm of\nanother term). For example, \\(M\\) may be \\(\\textsf{K}\\) and \\(N\\) may be\n\\(yy\\), and then \\(\\textsf{WK}(yy)\\triangleright_1\\textsf{K}(yy)\n(yy)\\).  The latter term suggests a further one-step reduction, and\nindeed we might be interested in successive one-step reductions\u2014such as\nthose leading from \\(\\textsf{WK}(yy)\\) to \\(yy\\). A way to\nachieve these goals is to formalize (a theory of) CL starting with the\nstandard inequational logic but to omit the anti-symmetry rule and to\nadd certain other axioms and rules.\n\nInequational Calculus for CL (\\(\\text{CL}_\\triangleright\\)).\n\n\n\\(M\\triangleright M\\)\n\\(\\textsf{S}MNP\\triangleright MP(NP)\\)\n\\(\\quad\\textsf{K}MN\\triangleright M\\)\n\n\n\\(\\dfrac{M\\triangleright N \\quad N\\triangleright P}{M\\triangleright P}\\)\n\\(\\dfrac{M\\triangleright N}{MP\\triangleright NP}\\)\n\\(\\dfrac{M\\triangleright N}{PM\\triangleright PN}\\)\n\n\n\n\nThe use of metavariables encompasses substitution (that we illustrated\nabove on the term \\(\\textsf{W}MN)\\).  The identity axiom and the rule of\ntransitivity imply that \\(\\triangleright\\) is a transitive and reflexive\nrelation. The last two rules characterize application as an operation that\nis monotone in both of its argument places. \\(\\text{CL}_\\triangleright\\)\nincludes only \\(\\textsf{S}\\) and \\(\\textsf{K}\\), because the other combinators\nare definable from them\u2014as we already mentioned in section 1.2, and\nas we explain more precisely toward the end of this section.\n\nThe set of combinators \\(\\{\\textsf{S},\\textsf{K}\\}\\) is called\na combinatory base, that is, these two combinators are the undefined\nconstants of \\(\\text{CL}_\\triangleright\\). To give an idea of a proof in this\ncalculus, the following steps may be pieced together to prove \\(\\textsf{SKK}\n(\\textsf{KSK})\\triangleright \\textsf{S}\\).  \\(\\textsf{KSK}\\triangleright\n\\textsf{S}\\) is an instance of an axiom. Then \\(\\textsf{SKK}(\\textsf{KSK})\n\\triangleright\\textsf{SKKS}\\) is obtained by right monotonicity, and further,\n\\(\\textsf{SKK}(\\textsf{KSK})\\triangleright\\textsf{S}\\) results by instances of\nthe \\(\\textsf{S}\\) and \\(\\textsf{K}\\) axioms together with applications of the\ntransitivity rule.\n\nThe relation \\(\\triangleright\\) is called weak reduction, and it may be \ndefined alternatively as follows. (\u2018Weak reduction\u2019 is a technical\nterm used in CL to distinguish this relation on the set of terms from some\nother relations, one of which is called \u2018strong reduction\u2019.) A\nterm that is either of the form \\(\\textsf{S}MNP\\) or of the form \n\\(\\textsf{K}MN\\) is a redex, and the leading combinators\n(\\(\\textsf{S}\\) and \\(\\textsf{K}\\), respectively) are the heads of the\nredexes. If a term \\(Q\\) contains a subterm of the form \\(\\textsf{S}MNP\\),\nthen \\(Q^\\prime\\); which is obtained by replacing that subterm by \\(MP(NP)\\)\nis a one-step reduct of \\(Q\\). (Similarly, for the redex \\(\\textsf{K}\nMN\\) and \\(M\\).) That is, \\(Q\\triangleright Q^\\prime\\) in both\ncases.  Reduction then may be defined as the reflexive transitive\nclosure of one-step reduction. This notion is completely captured by\n\\(\\text{CL}_\\triangleright\\). The calculus \\(\\text{CL}_\\triangleright\\) is complete\nin the sense that if \\(M\\triangleright N\\) in the sense we have just described,\nthen \\(\\text{CL}_\\triangleright\\) proves \\(M\\triangleright N\\).  (It is easy to see\nthat the converse implication is true too.)\n\nThe notion of reduction is a weaker relation than one-step reduction, and so\nit is useful to distinguish a subclass of terms using the stronger relation. A\nterm is in normal form (nf) when it contains no redexes. Note that\none-step reduction does not need to decrease the total number of redexes that\na term contains, hence, it does not follow that every term can be turned into\na term in nf via finitely many one-step reductions. Indeed, some terms do not\nreduce to a term in nf.\n\nReduction is arguably an important relation between terms that denote\nfunctions. The typical steps in a program execution and in other concrete\ncalculations are function applications rather than moves in the other\ndirection, what is called expansion. However, the notion of the\nequality of functions is familiar to everybody from mathematics, and the\nanalogous notion has been introduced in CL too. The transitive, reflexive,\nsymmetric closure of the one-step reduction relation is called\n(weak) equality. A formalization of equational CL may be obtained by\nextending the standard equational logic with combinatory axioms and rules\ncharacterizing the combinatory constants and the application operation.\n\nEquational Calculus for CL (\\(\\text{CL}_=\\)).\n\n\n\\(M=M\\)\n\\(\\textsf{K}MN=M\\)\n\\(\\textsf{S}MNP=MP(NP)\\)\n \n\n\\(\\dfrac{M=N \\quad N=P}{M=P}\\)\n\\(\\dfrac{M=N}{N=M}\\)\n\\(\\dfrac{M=N}{MP=NP}\\)\n\\(\\dfrac{M=N}{PM=PN}\\)\n\n\n\n\nThe first axiom and the first two rules constitute equational logic. The\nconstants are again the combinators \\(\\textsf{S}\\) and \\(\\textsf{K}\\). Note\nthat \\(\\text{CL}_=\\) could have been defined as an extension of \\(\\text{CL}_\\triangleright\\)\nby adding the rule of symmetry, that would have paralleled the description of\nthe definition of equality from reduction as its transitive, symmetric\nclosure. We chose instead to repeat the inequational axioms and rules with the\nnew notation (and add the rule of symmetry) to make the two definitions\nself-contained and easy to grasp. The two characterizations of \\(=\\)\ncoincide\u2014as those of \\(\\triangleright\\) did.\n\n\\(\\text{CL}_\\triangleright\\) and \\(\\text{CL}_=\\) share a feature that may or may not be\ndesirable\u2014depending on what sort of understanding of functions is to be\ncaptured. To illustrate the issue, let us consider the one-place combinators\n\\(\\textsf{SKK}\\) and \\(\\textsf{SK}(\\textsf{KK})\\). It is easy to verify that\n\\(\\textsf{SKK}M\\triangleright M\\) and \\(\\textsf{SK}(\\textsf{KK})M\n\\triangleright M\\). However, neither \\(\\textsf{SKK}\\triangleright\n\\textsf{SK}(\\textsf{KK})\\) nor \\(\\textsf{SK}(\\textsf{KK})\\triangleright\n\\textsf{SKK}\\) is provable in \\(\\text{CL}_\\triangleright\\); a fortiori, the equality\nof the two terms in not provable in \\(\\text{CL}_=\\). This means that \n\\(\\text{CL}_\\triangleright\\) and \\(\\text{CL}_=\\) formalize intensional notions of\nfunctions, where \u201cintensionality\u201d implies that functions that give\nthe same output on the same input may remain distinguishable.\n\nThe archetypical intensional functions that one is likely to encounter\nare algorithms. As examples, we might think of various specifications\nto calculate the decimal expansion of \\(\\pi\\), or various computer programs\nthat behave in the same way. For instance, compilers (for one and the same\nlanguage) may differ from each other by using or not using some optimizations,\nand thereby, producing programs from a given piece of code that have identical\ninput\u2013output behavior but different run times.\n\nIf functions that are indistinguishable from the point of view of their\ninput\u2013output behavior are to be identified, that is,\nan extensional understanding of functions is sought, then\n\\(\\text{CL}_\\triangleright\\) and \\(\\text{CL}_=\\) have to be extended by the following rule,\n(where the symbol \\(\\ddagger\\) is to be replaced by \\(\\triangleright\\) or\n\\(=\\), respectively). \n\n\\[\n\\frac{Mx\\ddagger Nx}{M\\ddagger N} \n   \\text{ where } x \\text{ is not free in } MN.\n\\]\n\n2.2 Church\u2013Rosser theorems and consistency theorems\n\nThe calculi \\(\\text{CL}_\\triangleright\\) and \\(\\text{CL}_=\\) of the previous section\nformalize reduction and equality. However, \\(\\triangleright\\) and \\(=\\) \nhave some further properties that are important when the terms are thought to\nstand for functions.  The next theorem is one of the earliest and best-known\nresults about CL.\n\nChurch\u2013Rosser theorem (I). If \\(M\\) reduces to \\(N\\) and \\(P\\),\nthen there is a term \\(Q\\) to which both \\(N\\) and \\(P\\) reduce.\n\n\n\nFigure 1. Illustration for the Church\u2013Rosser theorem (I)\n\n\nIf we think that reduction is like computing the value of a function, then the\nChurch\u2013Rosser theorem\u2014in a first approximation\u2014can be\nthought to state that the final result of a series of calculations with a term\nis unique\u2014independently of the order of the steps. This is a slight\noverstatement though, because uniqueness implies that each series of\ncalculations ends (or \u201cloops\u201d on a term). That is, if there is a\nunique final term, then only finitely many distinct consecutive calculation\nsteps are possible.\n\nA coarse analogy with elementary arithmetic operations, perhaps, can shed some\nlight on the situation. The addition and multiplication of natural numbers\nalways yield a natural number. However, if division is included then it is no\nlonger true that all numerical expressions evaluate to a natural number, since\n\\(7/5\\) is a rational number that is not a natural one, and \\(n/0\\) is\nundefined (even if \\(n\\) were real). That is, some numerical expressions do\nnot evaluate to a (natural) number. Although the analogy with combinatory\nterms is not very tight, it is useful. For instance, \\(n/0\\) (assuming that\nthe codomain of the function \\(\\lambda n.\\,n/0\\) is extended to permit \\(r\\)\nto be rational) could be implemented on a computer by a loop (that would never\nterminate when executed if \\(n\\ne0\\)) which would go through an enumeration of\nthe rational numbers trying to find an \\(r\\) such that \\(r\\cdot0=n\\).\n\nThe combinatory terms \\(\\textsf{WWW}\\) and \\(\\textsf{WI}(\\textsf{WI})\\) are,\nperhaps, the simplest examples of terms that do not have a normal form. Both\nterms induce an infinite reduction sequence, that is, an infinite chain\nof successive one-step reductions. To make the example more transparent, let\nus assume for a moment that \\(\\textsf{W}\\), \\(\\textsf{I}\\), \\(\\textsf{C}\\),\netc. are not defined from \\(\\textsf{K}\\) and \\(\\textsf{S}\\), but are primitive\nconstants. The contraction of the only redex in \\(\\textsf{WWW}\\) returns the\nsame term, which shows that uniqueness does not imply that the term is in\nnf. The contraction of the only redex in \\(\\textsf{WI}(\\textsf{WI})\\) gives\n\\(\\textsf{I}(\\textsf{WI})(\\textsf{WI})\\) that further reduces to the term we\nstarted with. A slightly more complicated example of a term that has only\ninfinite reduction sequences is \\(\\textsf{Y}(\\textsf{CKI})\\).  This term has a \nreduction sequence (in which each contracted redex is headed by \n\\(\\textsf{Y}\\)) that contains infinitely many distinct terms. It is also\npossible to create infinite reduction sequences that start with \\(\\textsf{Y}\n(\\textsf{CKI})\\) and have various loops too. To sum up, the\nChurch\u2013Rosser theorem, in general, does not guarantee the uniqueness of\nthe term \\(Q\\). However, if \\(M\\) has a normal form then that is\nunique.\n\nThe Church\u2013Rosser theorem is often stated as follows.\n\nChurch\u2013Rosser theorem (II). If \\(N\\) and \\(P\\) are equal, then\nthere is a term \\(Q\\) to which both \\(N\\) and \\(P\\) reduces.\n\n\n\nFigure 2. Illustration for the Church\u2013Rosser theorem (II)\n\n\nThe second form of the Church\u2013Rosser theorem differs from the first in\nits assumption. From the definition of equality as a superset of\nreduction, it is obvious that the first form of the theorem is implied by the\nsecond. However, despite the weaker assumption in the second formulation of\nthe Church\u2013Rosser theorem, the two theorems are equivalent. \nEquality is the transitive, symmetric closure of reduction, which means that\nif two terms are equal then there is a finite path comprising reduction and\nexpansion steps (which decompose into one-step reductions and one-step\nexpansions, respectively). Then by finitely many applications of the first\nChurch\u2013Rosser theorem (i.e., by induction on the length of the path\nconnecting \\(N\\) and \\(P\\)), the first Church\u2013Rosser theorem implies the\nsecond formulation.\n\nModern proofs of the Church\u2013Rosser theorem for CL proceed\nindirectly because one-step reduction fails to have the diamond property. A\nbinary relation \\(R\\) (e.g., reduction) is said to have the diamond\nproperty when \\(xRy\\) and \\(xRz\\) imply that \\(yRv\\) and \\(zRv\\) for some\n\\(v\\). If a binary relation \\(R\\) has the diamond property, so does its \ntransitive closure. To exploit this insight in the proof of the \nChurch\u2013Rosser theorem, a suitable subrelation of reduction has to\nbe found. The sought after subrelation should possess the diamond property,\nand its reflexive transitive closure should coincide with reduction.\n\nThe following counterexample illustrates that one-step reductions of a term\nmay yield terms that further do not reduce to a common term in one\nstep. \\(\\textsf{SKK}(\\textsf{KKS})\\triangleright_1\\textsf{SKKK}\\)\nand \\(\\textsf{SKK}(\\textsf{KKS})\\triangleright_1\\textsf{K}(\\textsf{KKS})\n(\\textsf{K}(\\textsf{KKS}))\\), and then the potential reduction sequences are\nas follows.\n\n\\(\\textsf{SKKK}\\triangleright_1\\textsf{KK}(\\textsf{KK})\\triangleright_1\n\\textsf{K}\\)\n\\(\\textsf{K}(\\textsf{KKS})(\\textsf{K}(\\textsf{KKS}))\\triangleright_1\n\\textsf{KKS}\\triangleright_1\\textsf{K}\\)\n\\(\\textsf{K}(\\textsf{KKS})(\\textsf{K}(\\textsf{KKS}))\\triangleright_1\n\\textsf{KK}(\\textsf{K}(\\textsf{KKS}))\\triangleright_1\n\\textsf{KK}(\\textsf{KK})\\triangleright_1\\textsf{K}\\)\n\\(\\textsf{K}(\\textsf{KKS})(\\textsf{K}(\\textsf{KKS}))\\triangleright_1\n\\textsf{K}(\\textsf{KKS})(\\textsf{KK})\\triangleright_1\\textsf{KKS}\n\\triangleright_1\\textsf{K}\\)\n\\(\\textsf{K}(\\textsf{KKS})(\\textsf{K}(\\textsf{KKS}))\\triangleright_1\n\\textsf{K}(\\textsf{KKS})(\\textsf{KK})\\triangleright_1\\textsf{KK}\n(\\textsf{KK})\\triangleright_1\\textsf{K}\\)\n\n\nThe failure of the diamond property is obvious once we note that\n\\(\\textsf{SKKK}\\triangleright_1\\textsf{KK}(\\textsf{KK})\\)\n(only), but \\(\\textsf{K}(\\textsf{KKS})(\\textsf{K}(\\textsf{KKS}))\\) does not\nreduce in one step to \\(\\textsf{KK}(\\textsf{KK})\\).\n\nAn appropriate subrelation of reduction is the simultaneous reduction of a\nset of nonoverlapping redexes, which is denoted by \\(\\triangleright\n_\\textrm{sr}\\). \u2018Nonoverlapping\u2019 means that there are no shared\nsubterm occurrences between two redexes. \\(\\triangleright_\\textrm{sr}\\) \nincludes \\(\\triangleright_1\\) because a one-step reduction of a redex may be \nviewed instead as \\(\\triangleright_\\textrm{sr}\\) of a singleton set of\nredexes. \\(\\triangleright_\\textrm{sr}\\) is, obviously, included in \n\\(\\triangleright\\) (i.e., in reduction). These two facts imply that the \nreflexive transitive closure of \\(\\triangleright_\\textrm{sr}\\) is \nreduction\u2014when the tonicity of the reflexive transitive closure\noperation (denoted by \\(^*\\)) is taken into account.\n\n(1)\u2013(3) summarize the key inclusions between the relations\nmentioned.\n\n(1)\n\n\\(\\triangleright_1\\subseteq\\triangleright_\\textrm{sr}\\;\n\\Rightarrow\\;\\triangleright_1^*\\subseteq\\triangleright_\\textrm{sr}^*\\)\n\n(2)\n\n\\(\\triangleright_\\textrm{sr}\\subseteq\\triangleright\n\\;\\Rightarrow\\;\\triangleright_\\textrm{sr}^*\\subseteq\\triangleright^*\\)\n\n(3)\n\n\\(\\triangleright_1^*\\subseteq\\triangleright^*\\quad\n\\textrm{ and }\\quad\\triangleright^*=\\triangleright\\).\n\n\n\nThe central property of \\(\\triangleright_\\textrm{sr}\\) that we need is the\ncontent of the following theorem.\n\nTheorem. (Diamond property for \\(\\triangleright_\\textrm{sr}\\)) If \n\\(M\\triangleright_\\textrm{sr}N\\) and \\(M\\triangleright_\\textrm{sr}P\\) then\nthere is a term \\(Q\\) such that both \\(N\\triangleright_\\textrm{sr}Q\\) and \n\\(P\\triangleright_\\textrm{sr}Q\\).\n\n\nThe proof of this theorem is an easy induction on the term \\(M\\). The\nproperties of \\(\\triangleright_\\textrm{sr}\\) guarantee that one or more\none-step reductions can be performed at once, but the reductions cannot\ninterfere (or overlap) with each other.\n\nThe consistency of CL follows from the Church\u2013Rosser\ntheorem together with the existence of (at least two) distinct normal\nforms.\n\nTheorem. (Consistency) CL is consistent, that is, there are terms that\ndo not reduce to each other, hence they are not equal. \n\n\nNot all terms have an nf, however, many do. Examples, first of all, include\n\\(\\textsf{S}\\) and \\(\\textsf{K}\\). (The variables, if included, of which there\nare \\(\\aleph_0\\) many, are all in nf.) None of these terms contains a redex,\nhence each reduces only to itself. By the Church\u2013Rosser theorem, it is\nexcluded that some term \\(M\\) could reduce to both \\(x\\) and \\(\\textsf{S}\\)\n(making \\(\\textsf{S}\\) equal to \\(x\\)).\n\nThe interaction between infinite reduction sequences and nfs deserves a more\ncareful inspection though. The terms \\(\\textsf{WWW}\\), \\(\\textsf{Y}\n(\\textsf{CKI})\\) and \\(\\textsf{WI}(\\textsf{WI})\\) have only infinite\nreduction sequences. However, the existence of an infinite reduction sequence\nfor a term does not imply that the term has no normal form (when the\ncombinatory base is complete or contains a cancellator). \\(\\textsf{Y}\n(\\textsf{KI})\\) reduces to \\(\\textsf{KI}(\\textsf{Y}(\\textsf{KI}))\\),\n\\(\\textsf{KI}(\\textsf{KI}(\\textsf{Y}(\\textsf{KI})))\\), \\(\\textsf{KI}\n(\\textsf{KI}(\\textsf{KI}(\\textsf{Y}(\\textsf{KI})))),\\ldots\\) as well as to\n\\(\\textsf{I}\\).\n\nA term weakly normalizes when it has an nf, whereas a term strongly\nnormalizes when all its reduction sequences lead to an nf (hence,\nto the nf) of the term. A computational analogue of a strongly\nnormalizing term is a (nondeterministic) program that terminates on every\nbranch of computation, whereas termination on at least one branch is akin to\nweak normalization.\n\nThe importance of normalization led to a whole range of questions (and an\nextensive literature of answers). How does the order of the reduction steps\n(i.e., a reduction strategy) affect finding the nf (if there is one)? Are\nthere combinatory bases that guarantee the existence of normal forms for every\ncombinator over that base? To quickly illustrate possible answers to our\nsample questions, we start with noting that if there is no combinator with a\nduplicative effect in a base, then all combinators over that base strongly\nnormalize. This is a very easy answer, and as a concrete base, we could have,\nfor example, \\(\\{\\textsf{B},\\textsf{C},\\textsf{K}\\}\\) or \\(\\{\\textsf{B},\n\\textsf{C},\\textsf{I}\\}\\), which have some independent interest in view of\ntheir connection to simply typed calculi. However, these bases are far from\nbeing combinatorially complete and even a fixed point combinator is\nundefinable in them.\n\nWe could ask a slightly different question: If we start with the base\n\\(\\{\\textsf{S},\\textsf{K}\\}\\) and we omit \\(\\textsf{S}\\), then we get the base\n\\(\\{\\textsf{K}\\}\\) and all the combinators strongly normalize, but what if we\nomit \\(\\textsf{K}\\)? Do the combinators over \\(\\{\\textsf{S}\\}\\) strongly\nnormalize or at least normalize? The answer is \u201cno.\u201d A term\n(discovered by Henk Barendregt in the early 1970s) that shows the lack of\nstrong normalization is \\(\\textsf{SSS}(\\textsf{SSS})(\\textsf{SSS})\\). The\nfirst \\(\\textsf{S}\\) is the head of a (indeed, the only) redex, and the\nhead reduction sequence of this term is infinite. Since \\(\\{\\textsf{S}\\}\\)\ndoes not contain any combinator with a cancellative effect, the existence of\nan infinite reduction sequence for a term means that the term has no nf. There\nare shorter combinators over the base \\(\\{\\textsf{S}\\}\\) without an nf, for\nexample, \\(\\textsf{S}(\\textsf{SS})\\textsf{SSSSS}\\) comprises only eight\noccurrences of \\(\\textsf{S}\\).\n\nThe sorts of questions we illustrated here (or rather, the answers to them)\ncan become a bit technical, because they often involve concepts and techniques\nfrom graph theory, automata theory and the theory of term-rewriting.\n2.3 The existence of fixed points and combinatorial completeness\n\nSch\u00f6nfinkel proved that \\(\\textsf{S}\\) and \\(\\textsf{K}\\) suffice to\ndefine the other combinators he introduced, and we mentioned in the definition\nof \\(\\text{CL}_\\triangleright\\) that the set of constants is limited to\n\\(\\textsf{S}\\) and \\(\\textsf{K}\\), because other combinators could be defined\nfrom those.\n\nTo demonstrate the sense in which definability is understood here we consider\nthe example of \\(\\textsf{B}\\). The axiom for \\(\\textsf{B}\\) is \\(\\textsf{B}\nxyz\\triangleright_1x(yz)\\), and if we take \\(\\textsf{S}(\\textsf{KS})\n\\textsf{K}\\) instead of \\(\\textsf{B}\\), then the following reduction sequence\nresults.\n\n\\[\n\\textsf{S}(\\textsf{KS})\\textsf{K}xyz\\triangleright_1\\textsf{KS}x\n(\\textsf{K}x)yz\\triangleright_1\\textsf{S}(\\textsf{K}x)yz\\triangleright_1\n\\textsf{K}xz(yz)\\triangleright_1x(yz)\n\\]\n\n\nThe term \\(\\textsf{S}(\\textsf{KS})\\textsf{K}\\) is in nf, however, to be in nf\nis not a requirement for definability. It is more convenient to work with\ndefining terms that are in nf, because an application of a combinator that is\nnot in nf could be started with reducing the combinator to its normal\nform. (Also, there are always infinitely many combinators that reduce to a\ncombinator.) However, note that the preference for choosing combinators in nf\nis not meant to imply that a combinator cannot be defined by two or more terms\nin nf; below we give two definitions (involving only \\(\\textsf{S}\\) and\n\\(\\textsf{K}\\)) for \\(\\textsf{I}\\).\n\nIf the constants are \\(\\textsf{S}\\) and \\(\\textsf{K}\\), then\nthe combinators are all those terms that are formed from \\(\\textsf{S}\\)\nand \\(\\textsf{K}\\) (without variables). Once we have defined \\(\\textsf{B}\\)\nas \\(\\textsf{S}(\\textsf{KS})\\textsf{K}\\), we may use \\(\\textsf{B}\\) in further\ndefinitions as an abbreviation, and we do that primarily to reduce the size of\nthe resulting terms as well as to preserve the transparency of the\ndefinitions.\n\nThe following list gives definitions for the other well-known combinators that\nwe mentioned earlier. (Here \u2018\\(=\\)\u2019 is placed between a definiendum\nand a definiens.)\n\n\n\\(\\textsf{I}=\\textsf{SK}(\\textsf{KK})\\)\n\\(\\textsf{T}=\\textsf{B}(\\textsf{SI})\\textsf{K}\\)\n\\(\\textsf{C}=\\textsf{B}(\\textsf{T}(\\textsf{BBT}))(\\textsf{BBT})\\)\n\n\n\\(\\textsf{W}=\\textsf{CSI}\\)\n\\(\\textsf{M}=\\textsf{SII}\\)\n \\(\\textsf{Y}=\\textsf{BW}(\\textsf{BB}^\\prime\\textsf{M})(\\textsf{BW}(\\textsf{BB}^\\prime\\textsf{M}))\\)\n\n\n\\(\\textsf{V}=\\textsf{BCT}\\)\n\\(\\textsf{B}^\\prime=\\textsf{CB}\\)\n\\(\\textsf{J}=\\textsf{W}(\\textsf{BC}(\\textsf{B}(\\textsf{B}(\\textsf{BC}))(\\textsf{B}(\\textsf{BB})(\\textsf{BB}))))\\)\n\n\n\nThe definitions are easily seen to imply that all these combinators depend on\nboth \\(\\textsf{S}\\) and \\(\\textsf{K}\\), but it is not obvious from the\ndefinitions that the defined combinators are mutually independent, that is,\nthat none of the listed combinators is definable from another one. (Clearly,\nsome subsets suffice to define some of the combinators.) We do not intend to\ngive an exhaustive list of interdefinability between various subsets of these\ncombinators, but to hint at the multiplicity and intricacy of such\ndefinitions, we list a handful of them. We also introduce two further\ncombinators \\(\\textsf{S}^\\prime\\) and \\(\\textsf{R}\\).\n\n\n\\(\\textsf{I}=\\textsf{SKK}\\)\n\\(\\textsf{I}=\\textsf{WK}\\)\n\\(\\textsf{I}=\\textsf{CK}(\\textsf{KK})\\)\n\n\n\\(\\textsf{B}=\\textsf{CB}^\\prime\\)\n\\(\\textsf{S}^\\prime=\\textsf{CS}\\)\n\\(\\textsf{S}=\\textsf{CS}^\\prime\\)\n\n\n\\(\\textsf{W}=\\textsf{S}^\\prime\\textsf{I}\\)\n\\(\\textsf{W}=\\textsf{B}(\\textsf{T}(\\textsf{BM}(\\textsf{BBT})))(\\textsf{BBT})\\)\n\\(\\textsf{W}=\\textsf{C}(\\textsf{S}(\\textsf{CC})(\\textsf{CC}))\\)\n\n\n\\(\\textsf{R}=\\textsf{BBT}\\)\n\\(\\textsf{Y}=\\textsf{BM}(\\textsf{CBM})\\)\n\\(\\textsf{Y}=\\textsf{B}^\\prime(\\textsf{B}^\\prime\\textsf{M})\\textsf{M}\\)\n\n\n\nIf the fixed point combinator \\(\\textsf{Y}\\) is not taken to be a primitive,\nthen there are various ways to define it\u2014so far, we have listed\nthree.\n\nFixed point theorem. For any function \\(M\\), there is a term \\(N\\) such\nthat \\(MN = N\\). \n\n\nThe proof of this theorem is easy using a fixed point combinator, because a\nterm that can play the r\u00f4le of \\(N\\) is \\(\\textsf{Y}M\\).\n\nSome of the definitions of \\(\\textsf{Y}\\) have slightly different properties\nwith respect to reduction. But the importance of the fixed point combinator is\nthat it ensures that all functions have a fixed point and all recursive\nequations can be solved.\n\nBoth Haskell B.\u00a0Curry and Alan Turing defined fixed point combinators (in\nCL or in the \\(\\lambda\\)-calculus). If we consider the definitions\n\n\\[\n\\textsf{Y}_1=\\textsf{BM}(\\textsf{BWB})\n\\quad\n\\textsf{Y}_2=\\textsf{W}(\\textsf{B}(\\textsf{BW}(\\textsf{BT})))(\\textsf{W}(\\textsf{B}(\\textsf{BW}(\\textsf{BT}))))\n\\]\n\n\n(where the subscripts are added to distinguish the two definitions),\nthen we can see that \\(\\textsf{Y}_1 M=M(\\textsf{Y}_1M)\\), but for\n\\(\\textsf{Y}_2\\), \\(\\textsf{Y}_2M\\triangleright M(\\textsf{Y}_2M)\\) holds too.\nIn this respect, \\(\\textsf{Y}_1\\) is similar to Curry\u2019s fixed point combinator\n(and really, to any fixed point combinator), whereas \\(\\textsf{Y}_2\\) is like\nTuring\u2019s fixed point combinator.\n\nThe fixed point theorem demonstrates\u2014to some extent\u2014the\nexpressive power of CL. However, fixed point combinators may be defined from\nbases without a cancellator (as \\(\\textsf{Y}_1\\) and \\(\\textsf{Y}_2\\)\nshow). The full power of CL (with the base \\(\\{\\textsf{S},\\textsf{K}\\}\\)) is\nenunciated by the following theorem.\n\nTheorem. (Combinatorial completeness) If \u00a0\\(f(x_1,\\ldots,x_n)=\nM\\) (where \\(M\\) is a term containing no other variables than those explicitly\nlisted), then there is a combinator \\(\\textsf{X}\\) such that \\(\\textsf{X}\nx_1\\ldots x_n\\) reduces to \\(M\\). \n\n\nThe theorem\u2019s assumption may be strengthened to exclude the\npossibility that some occurrences of \\(x\\) do not occur in \\(M\\). Then\nthe consequent may be strengthened by adding the qualification that\n\\(\\textsf{X}\\) is a relevant combinator, more specifically,\n\\(\\textsf{X}\\) is a combinator over \\(\\{\\textsf{B},\\textsf{W},\n\\textsf{C},\\textsf{I}\\}\\) (a base that does not contain a combinator\nwith cancellative effect), or equivalently, \\(\\textsf{X}\\) is a\ncombinator over \\(\\{\\textsf{I},\\textsf{J}\\}\\).  (These bases\ncorrespond to Church\u2019s preferred\n\\(\\lambda\\textsf{I}\\)-calculus.)\n\nCombinatorial completeness is usually proved via defining a\n\u201cpseudo\u201d \\(\\lambda\\)-abstraction (or bracket\nabstraction) in CL. There are various algorithms to define a bracket\nabstraction operator in CL, that behaves as the \\(\\lambda\\) operator does in a\n\\(\\lambda\\)-calculus. This operator is usually denoted by \\([\\,]\\) or by\n\\(\\lambda^*\\). The algorithms differ from each other in various aspects: (i)\nthe set of combinators they presuppose, (ii) the length of the resulting\nterms, (iii) whether they compose into (syntactic) identity with the algorithm\nthat translates a combinatory term into a \\(\\lambda\\)-term, and (iv) whether\nthey commute with either of the reductions or equalities.\n\nThe first algorithm, the elements of which may already be found in\nSch\u00f6nfinkel (1924), consists of the following clauses that are applied in\nthe order of their listing. \n\n\\[\\begin{align}\n\\tag{k} &[x].\\,M=\\textsf{K}M, \\text{ where } x\\notin\\textrm{fv}(M) \\\\\n\\tag{i} &[x].\\,x=\\textsf{I} \\\\\n\\tag{\\(\\eta\\)} &[x].\\,Mx=M, \\text{ where } x\\notin\\textrm{fv}(M) \\\\\n\\tag{b} &[x].\\,MN=\\textsf{B}M([x].\\,N), \\text{ where } x\\notin\\textrm{fv}(M) \\\\\n\\tag{c} &[x].\\,MN=\\textsf{C}([x].\\,M)N, \\text{ where } x\\notin\\textrm{fv}(N) \\\\\n\\tag{s} &[x].\\,MN=\\textsf{S}([x].\\,M)([x].\\,N)\n\\end{align}\\]\n\n\nFor example, if this algorithm is applied to the term \\(\\lambda xyz.x(yz)\\)\n(that is, to the \\(\\lambda\\)-translation of \\(\\textsf{B}\\)), then the\nresulting term is \\(\\textsf{B}\\).  However, if \\(\\eta\\) is omitted then a much\nlonger term results, namely, \\(\\textsf{C}(\\textsf{BB}(\\textsf{BBI}))(\\textsf{C}\n(\\textsf{BBI})\\textsf{I})\\).  Another algorithm, for example, consists of\nclauses (i), (k) and (s).\n3. Nonclassical logics and typed CL\n3.1 Simple types\n\nCombinatory terms are thought of as functions, and functions are thought to\nhave a domain (a set of possible inputs) and a codomain (a set\nof possible outputs). For example, if a unary function is considered as a set\nof ordered pairs, then the domain and codomain are given by the first and\nsecond projections, respectively. If partial and non-onto functions are\npermitted, then supersets of the sets resulting from the first and\nsecond projections can also be domains and codomains. \n Category theory,\nwhere functions are components of categories (without a set theoretic\nreduction assumed), retains the notions of a domain and a codomain; moreover,\nevery function has a unique domain and codomain.\n\nFunctions that have the same domain and codomain may be quite different,\nhowever, by abstraction, they are of the same sort or type. As a simple\nillustration, let \\(f_1\\) and \\(f_2\\) be two functions defined as \\(f_1=\n\\lambda x.\\,8\\cdot x\\) and \\(f_2=\\lambda x.\\,x/3\\). If \\(x\\) is a variable \nranging over reals, then \\(f_1\\) and \\(f_2\\) have the same domain and codomain\n(i.e., they have the same type \\(\\mathbb{R}\\rightarrow\\mathbb{R}\\)), although\n\\(f_1\\ne f_2\\), because \\(f_1(x)\\ne f_2(x)\\) whenever \\(x\\ne0\\). The usual\nnotation to indicate that a function \\(f\\) has \\(A\\) as its domain and \\(B\\)\nas its codomain is \\(f\\colon A\\rightarrow B\\). It is a happy coincidence that\nnowadays \u2018\\(\\rightarrow\\)\u2019 is often used in logics as a symbol for\nentailment or (nonclassical) implication.\n\nGiven a set of basic types (that we denote by \\(P\\)), types are defined\nas follows.\n\nIf \\(p\\in P\\) then \\(p\\) is a type;\nif \\(A,B\\) are types then \\((A\\rightarrow B)\\) is a type.\n\n\nTo distinguish these types from other types\u2014some of which are introduced\nin the next section\u2014they are called simple types.\n\nThe connection between combinators and types may be explained on the example\nof the identity combinator. Compound combinatory terms are formed by the\napplication operation. Premises of modus ponens can be joined by fusion\n(denoted by \\(\\circ\\)), which is like the application operation in the\nstrongest relevance logic \\(B\\). \\(\\textsf{I}x \\triangleright x\\) and so if\n\\(x\\)'s type is \\(A\\), then \\(\\textsf{I}x\\)'s type should imply \\(A\\). \nFurthermore, \\(\\textsf{I}x\\)'s type should be of the form \\(X\\circ A\\), for\nsome type \\(X\\); then \\(\\textsf{I}\\) can be of type \\(A\\rightarrow A\\). In\nthe example, we fixed \\(x\\)'s type, however, \\(\\textsf{I}\\) can be applied to\nany term, hence, it is more accurate to say that \\(A\\rightarrow A\\) is the\ntype schema of \\(\\textsf{I}\\), or that \\(\\textsf{I}\\)'s type can be any\nformula of the form of self-implication.\n\nThe type-assignment system TA\\(_\\textrm{CL}\\) is formally defined as the\nfollowing deduction system. (When implicational formulas are considered as\ntypes, the usual convention is to omit parentheses by association to the\nright.) \n\n\\[\n\\Delta\\vdash\\textsf{S}\\colon(A\\rightarrow B\\rightarrow C)\\rightarrow (A\\rightarrow B)\\rightarrow A\\rightarrow C\n\\]\n\n\\[\n\\Delta\\vdash\\textsf{K}\\colon A \\rightarrow B\\rightarrow A\n\\]\n\n\\[\n\\frac{\\Delta\\vdash M\\colon A\\rightarrow B \\quad\\Theta\\vdash N\\colon A}\n     {\\Delta,\\Theta\\vdash MN\\colon B}\n\\]\n\n\nExpressions of the form \\(M\\colon A\\) above are called type\nassignments. A characteristic feature of type-assignment systems is that\nif \\(M\\colon A\\) is provable then \\(A\\) is considered to be one of the types\nthat can be assigned to \\(M\\). However, a provable assignment does not\npreclude other types from becoming associated to the same term \\(M\\), that is\na type assignment does not fix the type of a term rigidly. \\(\\Delta\\) and\n\\(\\Theta\\) on the left-hand side of \\(\\vdash\\)  are sets of type assignments\nto variables, and they are assumed to be consistent\u2014meaning that no\nvariable may be assigned two or more types.\n\nType assignment systems are often called Curry-style typing systems. \nAnother way to type terms is by fixing a type for each term, in which case\neach term has exactly one type. Such calculi are called Church-style typing\nsystems. Then, for example, the identity combinator \\(\\textsf{I}\\) of type\n\n\\[\n(A\\rightarrow A\\rightarrow A)\\rightarrow A\\rightarrow A\\rightarrow A\n\\]\n\n is not the same as the identity combinator \\(\\textsf{I}\\) of type\n\n\\[\n((B \\rightarrow B)\\rightarrow B)\\rightarrow(B\\rightarrow B)\\rightarrow B.\n\\]\n\n The two styles of typing have quite a lot in\ncommon, but there are certain differences between them. In particular,\nno self-application is typable in a Church-style typing system,\nwhereas some of those terms can be assigned a type in a Curry-style\ntyping system. Curry-style typing systems proved very useful in\nestablishing various properties of CL and \\(\\lambda\\)-calculi. The\nChurch-style typing, on the other hand, emulates more closely the\ntyping in certain functional programming languages (without\nobjects).\n\nThere is no one-one correspondence between types and combinators in either\nstyle of typing: not all combinators can be assigned a type, and some\nimplicational formulas cannot be assigned to any combinatory term. A\ncombinator that can be assigned a type is said to be typable, and a\ntype that can be assigned to a combinator is said to be inhabited. For\ninstance, \\(\\textsf{M}\\) has no (simple) type, because an implicational\nformula is never identical to its own antecedent. On the other hand, Peirce\u2019s\nlaw, \\(((A\\rightarrow B)\\rightarrow A) \\rightarrow A\\) is not the type of any\ncombinator in the type assignment system TA\\(_\\textrm{CL}\\).  Despite (or,\nindeed, due to) the discrepancy between implicational formulas and combinatory\nterms, classes of implicational formulas that can be assigned to certain sets\nof combinatory terms coincide with sets of theorems of some important\nlogics.\n\nTheorem. \\(A\\rightarrow B\\) is a theorem of the intuitionistic\nimplicational logic, denoted by \\(IPC_\\rightarrow\\) or\n\\(J_\\rightarrow\\), iff for some \\(M\\), \\(M\\colon A\\rightarrow B\\) is a\nprovable type assignment in TA\\(_\\textrm{CL}\\), where the term \\(M\\)\nis built from \\(\\textsf{S}\\) and \\(\\textsf{K}\\), that is, \\(M\\) is a\ncombinator over the base \\(\\{\\textsf{S},\\textsf{K}\\}\\).\n\n\nA combinator that inhabits an implicational theorem encodes a proof of\nthat theorem in the deduction system TA\\(_\\textrm{CL}\\). There is an algorithm\nto recover the formulas that constitute a proof of the type of the combinator,\nmoreover, the algorithm produces a proof that is minimal and well-structured. \nThe correspondence between implicational theorems of intuitionistic logic (and\ntheir proofs) and typable closed \\(\\lambda\\)-terms (or combinators) is called\nthe Curry\u2013Howard isomorphism. The usual notion of a proof in a\nHilbert-style axiomatic system is quite lax, but it can be tidied up to obtain\nthe notion of traversing proofs. In a traversing proof there is a\none-one correspondence between subterms of a combinator and the formulas in\nthe traversing proof as well as between applications and detachments therein\n(cf. Bimb\u00f3 2007).\n\nThe above correspondence can be modified for other implicational logics and\ncombinatory bases. The next theorem lists correspondences that obtain between\nthe implicational fragments of the relevance logics \\(R\\) and \\(T\\) and\nsome combinatory bases that are of interest in themselves.\n\nTheorem. \\(A\\rightarrow B\\) is a theorem of \\(R_{\\rightarrow}\\)\n(or \\(T_{\\rightarrow}\\)) iff for some \\(M\\), \\(M\\colon A\\rightarrow B\\)\nis a provable type assignment where \\(M\\) is a combinator over \\(\\{\\textsf{B},\n\\textsf{I},\\textsf{W},\\textsf{C}\\}\\) (or over \\(\\{\\textsf{B},\\textsf{B}^\\prime,\n\\textsf{I},\\textsf{S},\\textsf{S}^\\prime\\}\\)).\n\n\nThe calculus \\(\\textrm{TA}_\\textrm{CL}\\) may be amended by adding\naxiom schemas for the combinators in the two bases. (The axiom schemas\nof the combinators that are not in these bases may be omitted from the\ncalculus or simply may be neglected in proofs.) The new axioms\nare as follows.\n\n\\[\\begin{align*}\n\\textsf{B} &\\colon\n  (A\\rightarrow B)\\rightarrow(C\\rightarrow A)\\rightarrow C\\rightarrow B \\\\\n\\textsf{B}^\\prime &\\colon\n  (A\\rightarrow B)\\rightarrow(B\\rightarrow C)\\rightarrow A\\rightarrow C \\\\\n\\textsf{C} &\\colon \n  (A\\rightarrow B\\rightarrow C)\\rightarrow B\\rightarrow A\\rightarrow C \\\\\n\\textsf{W} &\\colon\n  (A\\rightarrow A\\rightarrow B)\\rightarrow A\\rightarrow B \\\\\n\\textsf{S}^\\prime &\\colon \n  (A\\rightarrow B)\\rightarrow(A\\rightarrow B\\rightarrow C)\\rightarrow A\\rightarrow C \\\\\n\\textsf{I} &\\colon \n  A\\rightarrow A\n\\end{align*}\\]\n\n\nThe combinatory base \\(\\{\\textsf{B},\\textsf{C},\\textsf{W},\\textsf{I}\\}\\) is\nespecially interesting, because these combinators suffice for a definition of\na bracket abstraction that is equivalent to the \\(\\lambda\\)-abstraction of the\n\\(\\lambda\\textsf{I}\\)-calculus.  To put it differently, all functions that\ndepend on all of their arguments can be defined by this base. The other base\nallows the definition of functions that can be described by terms in the class\nof the so-called hereditary right maximal terms (cf. Bimb\u00f3\n2005). Informally, the idea behind these terms is that functions can be\nenumerated, and then their successive applications should form a sequence in\nwhich the indexes are \u201cglobally increasing.\u201d\n\nA type assignment has two parts: a term and a formula. The\nquestions whether some term can be assigned a type and whether some type can\nbe assigned to a term are the problems of typability and\nof inhabitation, respectively. Although these questions may be posed\nabout one and the same set of type assignments, the computational properties\nof these problems may differ widely.\n\nTheorem. It is decidable if a term \\(M\\) can be assigned a type, that\nis, if \\(M\\) is typable. \n\n\nThe theorem is stated in a rather general way without specifying exactly which\ncombinatory base or which modification of TA\\(_\\textrm{CL}\\) is assumed,\nbecause the theorem holds for any combinatory base. Indeed, there is an\nalgorithm that given a combinator decides if the combinator is typable, and\nfor a typable combinator produces a type too. Of course, in the\ncombinatorially complete base \\(\\{\\textsf{S},\\textsf{K}\\}\\) all the\ncombinators are expressible as terms consisting of these two combinators\nonly. However, this assumption is not needed for a solution of typability,\nthough it might provide an explanation for the existence of a general\nalgorithm.\n\nThe problem of inhabitation does not have a similar general solution,\nbecause the problem of the equality of combinatory terms is undecidable. Given\na set of axiom schemas that are types of combinators with detachment as the\nrule of inference, the problem of the decidability of a logic can be\nviewed as the problem of inhabitation. Indeed, if \\(A\\) is an implicational\nformula, then to decide whether \\(A\\) is a theorem amounts to determining if\nthere is a term (over the base that corresponds to the axiom schemas) that\ncan be assigned \\(A\\) as its type. (Of course, a more sophisticated algorithm\nmay actually produce such a term, in which case it is easy to verify the\ncorrectness of the claim by reconstructing the proof of the theorem.)\n\nTo see from where complications can emerge in the case of decidability, we\ncompare the rule of the formation of terms and the rule\nof detachment. Given a combinatory base and a denumerable set of\nvariables, it is decidable by inspection whether a term is or is\nnot in the set of the generated terms. That is, all the inputs of the rule\nare retained in the output as subterms of the resulting term. In contrast, an\napplication of detachment results in a formula that is a proper subformula of\nthe major premise (and in the exceptional case when the major premise is an\ninstance of self-identity it is identical to the minor premise). The lack of\nthe retention of all subformulas of premises through applications of modus\nponens is the culprit behind the difficulty of some of the decision problems\nof implicational logics. It is then somewhat unsurprising that for many\ndecidable logics there is a decision procedure utilizing sequent calculi in\nwhich the cut theorem and the subformula property hold. A solution to the\nproblem of inhabitation may run into difficulties similar to those that arise\nin decidability problems in general.\n\nFor example, the combinator \\(\\textsf{K}\\) can be assigned the following\ntype. \n\n\n\\[\np\\rightarrow(q\\rightarrow(q\\rightarrow q\\rightarrow q)\\rightarrow(q\n\\rightarrow q)\\rightarrow q\\rightarrow q)\\rightarrow p\n\\]\n\n\n\\(\\textsf{SKK}\\) can be assigned the type \\(p\\rightarrow p\\). There is a\nproof in TA\\(_\\textrm{CL}\\) ending in \\(\\textsf{SKK}\\colon p\\rightarrow p\\) \nthat does not contain the long formula above. However, there is a proof of\n\\(\\textsf{SKK}\\colon p\\rightarrow p\\) that contains the above formula the\nsecond antecedent of which is not a subformula of \\(p\\rightarrow p\\), indeed,\nthe sets of the subformulas of the two formulas are disjoint. (We picked two\ndifferent propositional variables, \\(p\\) and \\(q\\) to emphasize this point.)\nSome important cases of the problem of inhabitation, however, are\ndecidable.\n\nTheorem. It is decidable if a type has an inhabitant over the base\n\\(\\{\\textsf{S},\\textsf{K}\\}\\). \n\n\nThis theorem amounts to the typed version of the decidability of the\nimplicational fragment of \n intuitionistic logic\nthat is part of\n Gentzen\u2019s decidability result\n(dating from 1935).\n\nTheorem. It is decidable if a type has an inhabitant over the base \n\\(\\{\\textsf{I},\\textsf{C},\\textsf{B}^\\prime,\\textsf{W}\\}\\).\n\n\nThe theorem is the typed equivalent of the decidability of the implicational\nfragment of the logic of relevant implication. The decidability\nof \\(R_{\\rightarrow}\\) was proved by Saul A. Kripke in 1959 together\nwith the decidability of the closely related \\(E_{\\rightarrow}\\) (the\nimplicational fragment of the logic of entailment).\n\nTheorem. It is decidable if a type has an inhabitant over the base \n\\(\\{\\textsf{B},\\textsf{B}^\\prime,\\textsf{I},\\textsf{W}\\}\\).\n\n\nthe theorem is the typed version of the decidability of the\nimplicational fragment of the logic of ticket entailment\n\\(T_\\rightarrow\\), that was proved\u2014together with the\ndecidability of \\(R_\\rightarrow\\) (\\(R_\\rightarrow\\) with the truth\nconstant \\(t\\)) and \\(T_\\rightarrow^\\textbf{t}\\) (\\(T_\\rightarrow\\)\nwith the truth constant \\(t\\))\u2014in Bimb\u00f3 and Dunn\n(2012) and Bimb\u00f3 and Dunn (2013). An independent result\n(for \\(T_\\rightarrow\\) only) is in Padovani (2013), which\nextends Broda et al. (2004).\n\nThe decision procedures for \\(T_\\rightarrow^\\textbf{t}\\) and\n\\(R_\\rightarrow^\\textbf{t}\\) do not use \\(\\textrm{TA}_\\textrm{CL}\\) or\naxiomatic calculi, instead, they build upon consecution calculi\n(i.e., sequent calculi in which the structural connective is not\nassumed to be associative). The idea that there is an affinity between\nstructural rules and combinators goes back at least to Curry\n(1963). To tighten the connection, Dunn and Meyer (1997)\nintroduced structurally free logics in which introduction rules\nfor combinators replace structural rules\u2014hence the label for\nthese logics. Bimb\u00f3 and Dunn (2014) introduced a technique to\ngenerate a combinatory inhabitant for theorems of \\(T_\\rightarrow\\)\nfrom their standard proofs in the sequent calculus, which is used in\nthe decision procedure for \\(T_\\rightarrow^\\textbf{t}\\).  Sequent\ncalculi provide better control over proofs than natural deduction or\naxiomatic systems do. The combinatory extraction procedure of\nBimb\u00f3 and Dunn (2014) yields an effective link between\ncombinators and types grounded in sequent calculus proofs, which\nobviates the apparent advantage of \\(\\textrm{TA}_\\textrm{CL}\\) and\naxiomatic systems.\n\nThe rule of substitution is built-in into the formulation of\n\\(\\textrm{TA}_\\textrm{CL}\\) via the rule schema called detachment and the\naxiom schemas for the basic combinators. It is obvious that there are\nformulas of least complexity that are types of \\(\\textsf{S}\\) and\n\\(\\textsf{K}\\), such that all the other types of \\(\\textsf{S}\\) and\n\\(\\textsf{K}\\) are their substitution instances. A formula that has this\nproperty is called a principal type of a combinator. Obviously, a\ncombinator that has a principal type, has denumerably many principal types,\nwhich are all substitution instances of each other; hence, it is justified to\ntalk about the principal type schema of a combinator. The existence of\nprincipal types for complex combinators is not obvious, nevertheless,\nobtains.\n\nTheorem. If the term \\(M\\) is typable, then \\(M\\) has a principal type\nand a principal type schema. \n\n\nPrincipal types and principal type schemas may seem now to be\ninterchangeable everywhere. Thus we could take a slightly different\napproach and define \\(\\textrm{TA}_\\textrm{CL}\\) to include axioms and\nthe rule schema of detachment together with the rule of\nsubstitution. This version of \\(\\textrm{TA}_\\textrm{CL}\\) would\nassume the following form.\n\n\\[\n\\Delta\\vdash\\textsf{S}\\colon(p \\rightarrow q\\rightarrow s)\\rightarrow(p\\rightarrow q)\\rightarrow p\\rightarrow s\n\\]\n\n\\[\n\\Delta\\vdash\\textsf{K}\\colon q\\rightarrow s\\rightarrow q\n\\]\n\n\\[\n\\frac{\\Delta\\vdash M\\colon A\\rightarrow B\\qquad \\Theta\\vdash N\\colon A}\n     {\\Delta,\\Theta\\vdash MN\\colon B}\n\\]\n\n\\[\n\\frac{\\Delta\\vdash M\\colon A}\n     {\\Delta[P/B]\\vdash M\\colon A[P/B]}\n\\]\n\n\nwhere \\(P\\) ranges over propositional variables. (The substitution notation is\nextended\u2014in the obvious way\u2014to sets of type assignments.) Clearly,\nthe two deduction systems are equivalent.\n\nIf substitution were dropped altogether, then the applicability of detachment\nwould become extremely limited, for instance, \\(\\textsf{SK}\\) no longer would\nbe typable. A compromise between having substitution everywhere and having no\nsubstitution at all is to modify the detachment rule so that that includes as\nmuch substitution as necessary to ensure the applicability of the detachment\nrule. Such a rule (without combinatory terms or type assignments) was invented\nin the 1950s by Carew\u00a0A.\u00a0Meredith, and it is usually\ncalled condensed detachment. The key to the applicability of detachment\nis to find a common substitution instance of the minor premise and of the\nantecedent of the major premise. This step is called unification.  (A\nbit more formally, let \\(s(A)\\) denote the application of the substitution\n\\(s\\) to \\(A\\).  Then, the result of the condensed detachment of \\(A\\) from\n\\(B\\rightarrow C\\) is \\(s(C)\\), when there is an \\(s\\) such that \\(s(A)=\ns(B)\\), and for any \\(s_1\\) with this property, there is an \\(s_2\\) such that\n\\(s_1\\) is the composition of \\(s\\) and \\(s_2\\).)\n\nNotice that it is always possible to choose substitution instances of a pair\nof formulas so that the sets of their propositional variables are disjoint,\nbecause formulas are finite objects. The most general common instance\nof two formulas \\(A\\) and \\(B\\) (that do not share a propositional variable)\nis \\(C\\), where \\(C\\) is a substitution instance of both \\(A\\) and \\(B\\), and \npropositional variables are identified by the substitutions only if the\nidentification is necessary to obtain a formula that is a substitution\ninstance of both \\(A\\) and \\(B\\). The unification theorem (specialized\nto simple types) implies that if two formulas \\(A\\) and \\(B\\) have a common\ninstance then there is a formula \\(C\\) such that all the common instances of\n\\(A\\) and \\(B\\) are substitution instances of \\(C\\). Obviously, a pair of\nformulas either has no common instance at all, or it has \\(\\aleph_0\\) many\nmost general common instances.\n\nA famous example of a pair of formulas that have no common instance is\n\\(A\\rightarrow A\\) and \\(A\\rightarrow A\\rightarrow B\\). The instances \\(p\n\\rightarrow p\\) and \\(q\\rightarrow q\\rightarrow r\\) share no propositional\nvariables, however, neither \\(q\\rightarrow q\\) nor \\((q\\rightarrow r)\\rightarrow\nq\\rightarrow r\\) matches the shape of the second formula. To put the problem\ndifferently, \\(q\\) and \\(q\\rightarrow r\\) would have to be unified, but they\ncannot be unified no matter what formula is substituted for \\(q\\). An\nimmediate consequence of this is that \\(\\textsf{WI}\\) is not typable.\n\nOn the other hand,\n\n\\[\n(r\\rightarrow r)\\rightarrow r\\rightarrow r\n\\]\n\n and \n\\[\n((s\\rightarrow s)\\rightarrow s\\rightarrow s)\\rightarrow (s \\rightarrow\ns)\\rightarrow s\\rightarrow s\n\\]\n\n are substitution instances of \\(p\\rightarrow\np\\) and of \\(q\\rightarrow q\\). Furthermore, all simple types are substitution\ninstances of a propositional variable, hence \\(\\textsf{II}\\) can be assigned\nboth the type \\(r\\rightarrow r\\) and the type (\\(s\\rightarrow s)\\rightarrow\ns\\rightarrow s\\)\u2014and, of course, the latter happens to be an instance of \nthe former because \\(A\\rightarrow A\\) is the principal type schema of\n\\(\\textsf{II}\\). If we apply condensed detachment to \\(p\\rightarrow p\\) and\n\\(q\\rightarrow q\\), then we get \\(q\\rightarrow q\\) (via the substitutions\n\\([p/q\\rightarrow q]\\) and \\([q/q])\\), and so condensed detachment yields the\nprincipal type of \\(\\textsf{II}\\). Incidentally, \\(\\textsf{II}\\) and \n\\(\\textsf{I}\\) provide an excellent example to illustrate that distinct\nterms may have the same principal type schema.\n\nCondensed detachment has been used extensively to refine\naxiomatizations of various implicational logics, especially, in search\nfor shorter and fewer axioms. Some logics may be formulated using\naxioms (rather than axiom schemas) together with the rule of condensed\ndetachment\u2014without loss of theorems. All the logics that we\nmentioned so far (\\(J_{\\rightarrow}\\), \\(R_{\\rightarrow}\\),\n\\(T_{\\rightarrow}\\) and \\(E_{\\rightarrow}\\)) are\n\\(\\mathbf{D}\\)-complete, that is, they all may be axiomatized\nby axioms and the rule of condensed detachment. That is, the\nimplicational fragments of classical and intuitionistic logics, and\nthe implicational fragments of the relevance logics \\(R\\), \\(E\\)\nand \\(T\\) are all \\(\\mathbf{D}\\)-complete.  (See Bimb\u00f3 (2007) for\nsome further technical details.)\n\nSimply typed systems have been extended in various directions. Logics often\ncontain connectives beyond implication. It is a natural modification of a type\nassignment system to expand the set of types via including further type\nconstructors. Conjunction and fusion are the easiest to explain or\nmotivate as type constructors, however, disjunction and backward implication\nhave been introduced into types too. Types are useful, because they allow us\nto get a grip on classes of terms from the point of view of their behavior\nwith respect to reduction.\n\nTait\u2019s theorem. If a combinatory term \\(M\\) is typable (with simple\ntypes) then \\(M\\) strongly normalizes, that is, all reduction sequences of\n\\(M\\) are finite (i.e., terminate). \n\n\nThe converse of this claim is, obviously, not true. For example,\n\\(\\textsf{WI}\\) strongly normalizes but untypable, because the antecedent of\ncontraction cannot be unified with any instance of self-implication. The aim\nto extend the set of typable terms led to the introduction of \\(\\land\\) into\ntypes.\n3.2 Intersection types\n\nA different way to look at the problem of typing \\(\\textsf{WI}\\) is to say\nthat \\(\\textsf{W}\\) should have a type similar to the formula \\((A\\rightarrow\n(A\\rightarrow B))\\rightarrow A\\rightarrow B\\), but in which the formulas in\nplace of the two formulas \\(A\\) and \\(A\\rightarrow B\\) in the antecedent can\nbe unified. This is the motivation for the inclusion of conjunction\n(\\(\\land\\)) and top (\\(\\top\\)) as new type constructors.\n\nAn extended type system, that is often called the intersection type\ndiscipline, is due to Mario Coppo and Mariangiola Dezani-Ciancaglini. The\nset of intersection types (denoted by wff) is defined as follows.\n\n\\(p\\in\\textrm{wff}\\) if \\(p\\) is a propositional variable;\n\\(\\top\\in\\textrm{wff}\\), where \\(\\top\\) is a constant proposition;\n\\(A, B\\in\\textrm{wff}\\) implies \\((A\\rightarrow B),(A\\land B)\\in\n\\textrm{wff}\\).\n\n\nOf course, if TA\\(_\\textrm{CL}\\) is augmented with an expanded set of types,\nthen new instances of the previously assigned types become available. However,\nthe gist of having types with the new type constructors \\(\\land\\) and \\(\\top\\)\nis that the set of types has a richer structure than the relationships between\ntypes determined by the rules of substitution and modus ponens.\n\nThe structure of intersection types is described by the\nconjunction\u2013implication fragment of \\(B\\), the basic relevance\nlogic. In the following presentation of this logic, \\(\\le\\) is the main\nconnective (an implication) of a formula and \\(\\Rightarrow\\) separates the\npremises and the conclusion of an inference rule. \n\n\\[\\begin{align*}\nA\\le A\\qquad\nA\\le\\,&\\,\\top\\qquad\\top\\le\\top\\to\\top\\\\\nA\\le A\\land A\\qquad A\\land B&\\;\\le A\\qquad A\\land B\\le B\\\\\nA\\le B,\\,B\\le C&\\;\\Rightarrow A\\le C \\\\\nA\\le B,\\,C\\le D\\Rightarrow&\\; A\\land C\\le B\\land D \\\\\n(A\\rightarrow B)\\land(A\\rightarrow C)\\le&\\;(A\\rightarrow\n(B\\land C)) \\\\\nA\\le B,\\,C\\le D\\Rightarrow&\\; B\\rightarrow C\\le A \\rightarrow D\n\\end{align*}\\]\n\n\nThe axiom schemas for the combinators \\(\\textsf{S}\\),\\(\\textsf{K}\\) and\n\\(\\textsf{I}\\) are as follows. Note that the axiom for \\(\\textsf{S}\\) is not\nsimply a substitution instance (with new connectives included) of the previous\naxiom for \\(\\textsf{S}\\). \n\n\\[\n\\Delta\\vdash\\textsf{S}\\colon(A\\rightarrow B\\rightarrow C)\\rightarrow(D\\rightarrow B)\\rightarrow(A\\land D)\\rightarrow C\n\\]\n\n\\[\n\\Delta\\vdash \\textsf{K}\\colon A\\rightarrow B\\rightarrow A\n  \\qquad\n\\Delta\\vdash \\textsf{I}\\colon A\\rightarrow A\n\\]\n\n\nThere are four new rules added, and there is an axiom for \\(\\top\\).\n\n\n\\[\n\\frac{\\Delta\\vdash M\\colon A\\quad\\Delta\\vdash M\\colon B}\n     {\\Delta\\vdash M\\colon A\\land B}\n\\quad\n\\frac{\\Delta\\vdash M\\colon A\\land B}\n     {\\Delta\\vdash M\\colon A}\n\\quad\n\\frac{\\Delta\\vdash M\\colon A\\land B}\n     {\\Delta\\vdash M\\colon B}\n\\]\n\n\\[\n\\frac{\\Delta\\vdash M\\colon A\\qquad A\\le B B}\n     {\\Delta\\vdash M\\colon B}\n\\quad\n\\Delta\\vdash M\\colon\\top\n\\]\n\n\nThis type assignment system is equivalent to the intersection type assignment\nsystem for the \\(\\lambda\\)-calculus, and it allows a more precise\ncharacterization of classes of terms with respect to the termination of\nreduction sequences.\n\nTheorem.\n(1) A term \\(M\\) normalizes whenever \\(M\\) is typable.\n\n(2) A term \\(M\\) strongly normalizes whenever \\(M\\) is typable and the\nproof does not contain \\(\\top\\).\n4. Models\n\nCL has various kinds of models, three of which are exemplified in some detail\nin this section. Algebraic models (often called \u201cterm\nmodels\u201d) may be constructed without difficulty for both the inequational\nand the equational systems of CL that were introduced in section 2.1. The set\nof terms forms an algebra, and given a suitable equivalence relation (that is\nalso a congruence), the application operation can be lifted to the equivalence\nclasses of terms in the standard way. The quasi-inequational characterization\nof the so obtained algebra provides the basis for an algebraic semantics for\nthese logics. Isolating the Lindenbaum algebra and verifying that it is not a\ntrivial algebra constitutes a consistency proof for \\(\\text{CL}_\\triangleright\\) and\n\\(\\text{CL}_=\\).\n4.1 Scott\u2019s models\n\nDana Scott defined \\(P\\omega\\) and \\(D_\\infty\\) for the \\(\\lambda\\)-calculus. \nWe first outline \\(P\\omega\\)\u2014the so-called graph model, which is\neasier to understand.\n\nThe natural numbers have a very rich structure. \\(P\\omega\\) is the power set\nof the set of natural numbers and it is at the core of the model bearing the\nsame label. Every natural number has a unique representation in base\n\\(2\\). (E.g., \\(7_{10}\\) is \\(111\\), that is, \\(7=1\\cdot2^2+1\\cdot2^1+1\\cdot\n2^0=4+2+1\\).) Each binary representation is of the form\n\n\\[\nb_m\\cdot2^m+b_{m-1} \\cdot2^{m-1}+\\cdots+b_1\\cdot 2^1+b_0\\cdot2^0 ,\n\\]\n\nwhere each \\(b\\) is \\(0\\) or\n\\(1\\). Then each binary number may be viewed as the characteristic function of\na finite subset of natural numbers. (On the left, there are infinitely\nmany zeros, as in \\(\\ldots000111\\), which are omitted.) For a natural number\n\\(n\\), \\(e_n\\) denotes the corresponding finite set of natural numbers. (E.g., \n\\(e_7=\\{0,1,2\\}\\).)\n\nThe positive topology on \\(P\\omega\\) comprises finitely generated open\nsets. Let \\(E\\) denote the finite subsets of \\(\\omega\\). \\(X\\subseteq\nP\\omega\\) is open iff \\(X\\) is a cone (with respect to \\(\\subseteq\\))\ngenerated by a subset of \\(E\\). Given the positive topology, a function\n\\(f\\colon P\\omega\\rightarrow P\\omega\\) turns out to be continuous (in\nthe usual topological sense) iff \\(f(x)=\\cup\\{f(e_n)\\colon e_n\\subseteq x\\}\\), \nwhere \\(e_n\\in E\\). This means that \\(m\\in f(x)\\) iff \\(\\exists e_n\\subseteq\nx.\\, m\\in f(e_n)\\), which leads to a characterization of a continuous function \n\\(f\\) by the pairs of natural numbers \\((n,m)\\).\n\nA one-one correspondence between (ordered) pairs of natural numbers and\nnatural numbers is defined by \n\n\\[\n(n,m) =\n \\frac{[(n+m)\\cdot(n+m+1)]+2\\cdot m}\n      {2}\n\\]\n\n\nThe set of pairs that constitute a (unary) function is sometimes called\nthe graph of the function. The graph of a continuous function \\(f\\colon\nP\\omega\\rightarrow P\\omega\\) is defined by \\(\\textrm{graph}(f)=\\{(n,m)\\colon \nm\\in f(e_n)\\}\\). In order to be able to model type-free\napplication\u2014including self-application\u2014subsets of \\(\\omega\\)\nshould be viewed as functions too. For \\(x, y\\subseteq\\omega\\), the function\ndetermined by \\(y\\) is defined as \\(\\textrm{fun}(y)(x)=\\{m\\colon \\exists\ne_n\\subseteq x.\\,(n,m)\\in y\\}\\). For a continuous function \\(f\\), \n\\(\\textrm{fun}(\\textrm{graph}(f))=f\\) holds.\n\nThe graph model of CL maps terms into subsets of \\(\\omega\\). To start with,\nthe combinators have concrete sets as their interpretations. As a simple\nexample, \\(\\textsf{I}= \\{(n,m)\\colon m\\in e_n\\}\\). Of course, each pair\ncorresponds to an element of \\(\\omega\\), hence, we get a set of natural\nnumbers. In particular, some of the elements are \\(\\{1,6,7,11,15,23,29,30,\n\\ldots\\}\\).\n\nIf the combinators (as well as the variables) are interpreted as subsets of\n\\(\\omega\\), then function application should take the first set (viewed as a\nfunction of type \\(P\\omega\\rightarrow P\\omega)\\) and apply that to the second\nset. \\(\\textrm{fun}(y)\\) is a suitable function that is determined by \\(y\n\\subseteq\\omega\\). In general, if \\(M\\) and \\(N\\) are CL-terms, and \\(I\\) is\nthe interpretation of atomic terms into \\(P\\omega\\), then \\(I\\) is extended to \ncompound terms by \\(I(MN)=\\textrm{fun}(I(M))(I(N))\\). (E.g., let \\(I(x)\\) be\n\\(e_9=\\{0,3\\}\\). \\(I(\\textsf{I}x)=\\textrm{fun}(I(\\textsf{I}))(I(x))=\\{m\\colon \n\\exists e_n\\subseteq I(x).\\,(n, m)\\in I(\\textsf{I})\\}\\). We know what \\(I\n(\\textsf{I})\\) and \\(I(x)\\) are; hence, we get further that \\(I(\\textsf{I}x)=\n\\{m\\colon\\exists e_n\\subseteq e_9.\\,m\\in e_n\\}\\). Of course, \\(\\{0,3\\}\\subseteq\n\\{0,3\\}\\), and so we have that \\(I(\\textsf{I}x)=\\{0,3\\}\\).) This model\nsupports an intensional notion of functions.\n\nThe earliest model for a typefree applicative system as a function\nspace was also given by Scott, a couple of years before the graph model,\nin the late 60s. The following is an outline of some of the key elements of\nthe construction.\n\nIn pure typefree CL, an expression of the form \\(MM\\) is a well-formed term. \nMoreover, terms of this form can enter into provable equations and inequations\nin multiple ways. For example, \\(xx=xx\\) is an axiom, and by one of the rules,\n\\(y(xx)=y(xx)\\) is provable too. A more interesting occurrence of a term of\nthe form \\(MM\\) can be seen in the provable inequation \\(\\textsf{S}\n(\\textsf{SKK})(\\textsf{SKK})x\\triangleright xx\\).\n\nThe set-theoretic reduction of a function yields a set of pairs (in general, a\nset of tuples). In set theory (assuming well-foundedness, of course) a pair\n(e.g., \\(\\{\\{ a\\},\\{ a,b\\}\\}\\)) is\nnever identical to either of its two elements. Therefore, the main question\nconcerning a mathematical model of CL is how to deal\nwith self-application.\n\nScott\u2019s original model is built starting with a complete lattice \\((D,\n\\le)\\). That is, \\((D,\\le)\\) is a partially ordered set in which greatest\nlower bounds (infima) and least upper bounds (suprema) exist for arbitrary\nsets of elements. A function \\(f\\) from \\((D,\\le)\\) into a complete lattice\n\\((E,\\le)\\) is said to be continuous when it preserves the supremum of\neach ideal on \\(D\\), where an ideal is an upward directed downward closed\nsubset.\n\nA topology may be defined on \\(D\\) by selecting certain increasing sets\nas the opens. More precisely, if \\(I\\) is an ideal and \\(C\\) is a cone, then\n\\(C\\) is open iff \\(C\\cap I \\ne\\emptyset\\) provided that \\(\\bigvee I\\in C\\),\nthat is, provided that the supremum of \\(I\\) is an element of \\(C\\).  (For\nexample, complements of principal ideals are open.) \\(f\\) turns out to be\ncontinuous in the usual topological sense, that is, the inverse image of an\nopen set is open, when \\(D\\) and \\(E\\) are taken together with their\ntopologies. This motivates the earlier labeling of these functions as\ncontinuous. Notably, all continuous functions are monotone.\n\nFor the purposes of modeling functions in CL, the interesting functions are\nthose that are continuous on \\(D\\). However, these functions by\nthemselves are not sufficient to obtain a modeling of self-application,\nbecause none of them has as its domain a set of functions\u2014as \\(D\\) is\nnot assumed to be a function space. The solution starts with defining\na hierarchy of function spaces \\(D_0\\), \\(D_1\\), \\(D_2,\\ldots\\) so that\neach function space \\(D_n\\), is a complete lattice on which continuous\nfunctions may be defined (creating the function space \\(D_{n+1}\\)). The\nimportance of selecting continuous functions is that the emerging function\nspace has the same cardinality as the underlying set, which allows us\nto define embeddings between function spaces adjacent within the\nhierarchy.\n\nThe hierarchy of all the function spaces \\(D_n\\) may be accumulated\ntogether. A standard construction in model theory is to form the disjoint\nunion of structures. (Disjointness can always be guaranteed by indexing the\ncarrier sets of the structures.) Scott defined \\(D_\\infty\\) to be\nthe disjoint union of the function spaces \\(D_n\\), for all \\(n\\),\nexcept that the extremal elements are \u201cglued together.\u201d (More\nformally, the top elements and the bottom elements of the function spaces,\nrespectively, are identified with each other.) \\(D_\\infty\\) is a complete\nlattice, and by Tarski\u2019s fixed point theorem, a continuous function that maps \n\\(D_\\infty\\) into \\(D_\\infty\\) has a fixed point, which implies that \\(D\n_\\infty\\) is isomorphic to \\(D_\\infty\\rightarrow D_\\infty\\).\n\nThe above construction may also be conceptualized in terms of strings\nand Cartesian products. The back-and-forth moves between functions of\none and more than one variable\u2014the \u201cuncurrying\u201d and\n\u201ccurrying\u201d of functions\u2014algebraically corresponds to the two\ndirections of residuation. For example, a function \\(f\\colon A\\times\nB\\rightarrow C\\) may be represented by a function \\(f^\\prime\\colon A\n\\rightarrow B\\rightarrow C\\), and vice versa. Thus, without loss of\ngenerality, it is sufficient to consider unary functions. If \\(a\\) is a fixed\nelement of the function space \\(D_\\infty\\), then \\(x = (a,x)\\) holds when\n\\(x\\) is the fixed point of \\(a\\). In terms of tuples, the solution may be\nviewed as the infinite tuple \\((a,(a,(a,\\ldots\\).\n4.2 Relational semantics\n\nA further model that we briefly outline falls into the set-theoretical\nsemantics paradigm of nonclassical logic and it is due to\nJ.\u00a0Michael\u00a0Dunn and Robert\u00a0K.\u00a0Meyer (see Dunn and\nMeyer (1997)). CL and \\(\\lambda\\)-calculi are inherently connected to\nintuitionistic, relevance and other nonclassical logics.  In\nparticular, the \\(\\text{CL}_\\triangleright\\) and \\(\\text{CL}_=\\)\ncalculi are nonclassical logics themselves. Set theoretical semantics\nin which the intensional connectives are modeled from relations on a\ncollection of situations have been the preferred interpretation of\nnonclassical logics since the early 1960s. These sorts of semantics\nare sometimes called \u201cKripke semantics\u201d (because Kripke\nintroduced possible-world semantics for some normal modal logics in\n1959) or \u201cgaggle semantics\u201d (after the pronunciation of\nthe abbreviation \u2018ggl\u2019 that stands for \u201cgeneralized\nGalois logics\u201d introduced by Dunn (1991)).\n\nA model for \\(\\text{CL}_\\triangleright\\) may be defined as follows. Let (\\(W,\\le,\nR,S,K,v)\\) comprise a (nonempty) partially ordered set \\((W,\\le)\\) with a\nthree-place relation \\(R\\) on \\(W\\), and let \\(S\\), \\(K\\in W\\).  Furthermore,\nfor any \\(\\alpha,\\beta,\\gamma,\\delta\\in W\\), the conditions (s) and (k) are\ntrue.\n\n(s)\n\n\\(\\exists \\zeta_1,\\zeta_2,\\zeta_3\\in W.\\,RS\\alpha\\zeta_1\\land R\\zeta_1\n\\beta\\zeta_2\\land R\\zeta_2\\gamma\\delta\\)\n\u00a0\u00a0 implies\n\\(\\exists\\zeta_1,\\zeta_2,\\zeta_3\\in W.\\,R\\alpha\\gamma\\zeta_1\\land\nR\\beta\\gamma\\zeta_2\\land R\\zeta_1\\zeta_2\\delta\\),\n\n(k)\n\n\\(\\exists\\zeta_1\\in W.\\,RK\\alpha\\zeta_1\\land R\\zeta_1\\beta\\gamma\\)\n\u00a0\u00a0 implies\n\\(\\alpha\\le\\gamma.\\)\n\n\n\nThe ternary relation is stipulated to be antitone in its first two argument\nplaces and monotone in the third. These components define a frame for\n\\(\\text{CL}_\\triangleright\\). The valuation function \\(v\\) maps variables \\(x,y,z,\n\\ldots\\) into (nonempty) cones on \\(W\\), and it maps the two primitive\ncombinators \\(\\textsf{S}\\) and \\(\\textsf{K}\\) into the cones generated by\n\\(S\\) and \\(K\\), respectively. Recall, that the standard notation in CL hides\napplication, a binary operation that allows forming compound terms. The next\nclause extends \\(v\\) to compound terms and makes this operation explicit\nagain. \n\n\\[\nv(MN)=\\{\\beta\\colon\\exists\\alpha,\\gamma.\\,R\\alpha\\gamma\\beta\\land\\alpha\n\\in v(M)\\land\\gamma\\in v(N)\\}\n\\]\n\n\nAn inequation \\(M\\triangleright N\\) is valid if \\(v(M)\\subseteq v(N)\\) under\nall valuations on frames for \\(\\text{CL}_\\triangleright\\). (That is, the relationship \nbetween the interpretations of the two terms is invariant whenever \\(v\\) is\nvaried on the set of variables.)\n\nInformally, the underlying set \\(W\\) is a set of situations, and \\(R\\)\nis an accessibility relation connecting situations. All the terms are\ninterpreted as sets of situations, and function application is\nthe existential image operation derived from \\(R\\). A difference from\nthe previous models is that the result of an application of a term to a term\nis not determined by the objects themselves that interpret the two\nterms\u2014rather the application operation is defined from \\(R\\).\n\nThis semantics generalizes the possible worlds semantics for normal modal\nlogics. Therefore, it is important to note that the situations are not\nmaximally consistent theories, rather they are theories possessing the\nproperty that for any pair of formulas they contain a formula that implies\nboth of them. Equivalently, the situations may be taken to be dual ideals on\nthe Lindenbaum algebra of \\(\\text{CL}_\\triangleright\\). These situations are\ntypically consistent in the sense that they do not contain all the terms in\nall but one case. (The notion of negation consistency, of course, cannot be\ndefined for \\(\\text{CL}_\\triangleright\\) or for \\(\\text{CL}_=\\).)\n\nRelational semantics can be defined for \\(\\text{CL}_=\\) along similar lines. Then\nsoundness and completeness\u2014that is, the following\ntheorem\u2014obtains.\n\nTheorem.\n(1) An inequation \\(M\\triangleright N\\) is provable in\n\\(\\text{CL}_\\triangleright\\) if and only if \\(v(M)\\subseteq v(N)\\) in any\nmodel for \\(\\text{CL}_\\triangleright.\\)\n\n(2) An equation \\(M = N\\) is provable in \\(\\text{CL}_=\\) if and only if\n\\(v(M)=v(N)\\) in any model for \\(\\text{CL}_=.\\)\n\nRelational and operational semantics for systems of CL that include dual and\nsymmetric combinators can be found in Bimb\u00f3 (2004).\n5. Computable functions and arithmetic\n\nA remarkable feature of CL is that despite its seeming simplicity it is\na powerful formalism. Of course, the strength of CL cannot be\nappreciated without discovering certain relationships between combinatory\nterms or without an illustration that computable functions are definable.\n\nAn important beginning step in the formalization of mathematics is the\n formalization of arithmetic,\nthat was first achieved by the Dedekind\u2013Peano\naxiomatization. There are various ways to formalize arithmetic in CL; two\nrepresentations of numbers are described in this section together with some\nfunctions on them.\n\nNumbers may be thought to be objects (or abstract objects) of some\nsort. (Here by numbers we mean natural numbers, that is, \\(0\\) and the\npositive integers.) Numbers could be characterized, for example, by\nthe structure they possess as a set. This structure supports properties\nsuch as \\(0\\ne1\\), and that the sum of \\(n\\) and \\(m\\) is the same number as\nthe sum of \\(m\\) and \\(n\\).  Another well-known property of the natural\nnumbers is, for example, the existence of infinitely many prime numbers.\n\nNumbers can be represented in CL by terms, and one way is to choose the terms\n\\(\\textsf{KI}\\), \\(\\textsf{I}\\), \\(\\textsf{SBI}\\), \\(\\textsf{SB}\n(\\textsf{SBI}),\\ldots\\) for \\(0\\), \\(1\\), \\(2\\), \\(3\\), etc. The terms that\nrepresent the arithmetic operations vary, depending on which terms stand for\nthe numbers. Note that unlike the Dedekind\u2013Peano formalization of\narithmetic, CL makes no syntactic distinction that would parallel the\ndifference between individual constants and function symbols\u2014in CL the\nonly objects are terms. The above list of terms already shows the successor\nfunction, which is \\(\\textsf{SB}\\). (\\(\\textsf{SB}(\\textsf{KI})\\) strongly\nequals to \\(\\textsf{I}\\), that is, \\(1\\) is the successor of \\(0\\).)\n\nAddition is the term \\(\\textsf{BS}(\\textsf{BB})\\),\nand multiplication is the term \\(\\textsf{B}\\). The usual recursive\ndefinition of multiplication based on addition may suggest that addition\nshould be a simpler operation than multiplication. However, in CL the numbers \nthemselves are functions, and so they have properties that allows \n\\(\\textsf{B}\\)\u2014a simpler looking term\u2014to be chosen for the\nfunction that is often perceived to be more complex than addition. (The\naddition operation could be defined using primitive recursion, which would\nproduce a more complex term.) As a classical example, we may consider the term\n\\(\\textsf{BII}\\), that is strongly equal to \\(\\textsf{I}\\), that is, \n\\(1\\times1=1\\)\u2014as expected. We do not pursue here this numerical\nrepresentation further. We only note that the shape of these numbers is\nclosely related to Church\u2019s numerals in the \\(\\lambda\\)-calculus, each of\nwhich is a binary function (whereas here, each number is a unary\nfunction).\n\nAnother way to represent numbers in CL is to start with a different choice of\nterms for the numbers. Previously, \\(\\textsf{I}\\) stood for \\(1\\), now we take\n\\(\\textsf{I}\\) to be \\(0\\). The successor of a number \\(n\\) is \\(\\textsf{V}\n(\\textsf{KI})n\\), where the second occurrence of \\(n\\) indicates a numeral,\nthat is, the combinator that represents \\(n\\). (The numeral for \\(n\\) is often\ndenoted\u2014more precisely\u2014by an overlined or otherwise decorated\n\\(n\\). However, the double usage of \\(n\\) in a limited context should not\ncause any confusion.) In other words, the successor function is \n\\(\\textsf{V}(\\textsf{KI})\\). Notice that the numbers in the present\nrepresentation are terms over a more restricted combinatory base than in the\nformer case. For example, no combinator with duplicative effect is definable\nfrom \\(\\{\\textsf{I},\\textsf{K},\\textsf{V}\\}\\).\n\nSome simple recursive functions may be defined as follows. The \npredecessor function \\(P\\) on numbers is \u201c\\(-1\\)\u201d (i.e.,\nsubtracting one) for all numbers greater than or equal to \\(1\\), and the\npredecessor of \\(0\\) is set to be \\(0\\). The next term defines the predecessor\nfunction which is abbreviated by \\(P\\).\n\n\\[\nP=\\textsf{C}(\\textsf{W}(\\textsf{BB}(\\textsf{C}(\\textsf{TK})\\textsf{I})))(\\textsf{KI})\n\\]\n\n\nIf \\(n\\) is a numeral, then \\(Pn\\) reduces to \\(n\\textsf{KI}(n(\n\\textsf{KI}))\\), which suggests that for positive numbers, \\(P\\) could have\nbeen defined to be the term \\(\\textsf{T}(\\textsf{KI})\\), because \n\\(\\textsf{T}(\\textsf{KI})n\\) reduces to \\(n-1\\) whenever \\(n\\) is a term of\nthe form \\(\\textsf{V}(\\textsf{KI})(n-1)\\).\n\nSome models of computation (such as register machines) and certain programming\nlanguages include a test for zero as a primitive construct. It is\nuseful to find a CL-term for a function \\(Z\\) such that \\(Znxy\\) reduces to \\(x\\)\nif \\(n\\) is zero, whereas \\(Znxy\\) reduces to \\(y\\) when \\(n\\) is positive. \n\\(Znxy\\) may be thought of as the conditional instruction \u201cIf \\(n=0\\) \nthen \\(x\\) else \\(y\\),\u201d where \\(x\\) and \\(y\\) are themselves functions. \n(Of course, in the pseudo-code one should have assumed that \\(n\\) is of\ninteger type and cannot take a negative value, that could be guaranteed by a\ndeclaration of variables and an additional conditional statement.) The\nfollowing definition works for branching on zero.\n\n\\[\nZ=\\textsf{TK}\n\\]\n\n\n\\(\\textsf{TK}nxy=n\\textsf{K}xy\\), and if \\(n\\) is zero, that is, \\(n= \n\\textsf{I}\\), then by another step \\(\\textsf{K}xy\\) and then \\(x\\) results;\nwhereas if \\(n\\) is positive, then after a few more reductions, one gets\n\\(\\textsf{KI}xy\\), that is, \\(y\\). The two terms, \\(\\textsf{K}xy\\) and\n\\(\\textsf{KI}xy\\), hint toward an interpretation of \\(\\textsf{K}\\) and\n\\(\\textsf{KI}\\) as truth and falsity, or they can be viewed as\nterms that can select, respectively, the first or the second argument. These\nideas may be further developed into definitions of truth functions and a\nrepresentation of tuples.\n\nAddition may be defined by the recursive equation \\(+mn=Zmn\n(\\textsf{V}(\\textsf{KI})(+(Pm)n))\\), where \\(m\\) and \\(n\\) are numerals, and\n\\(P\\) and \\(Z\\) are the already defined functions. (The abbreviations are used\nto enhance the readability of the terms\u2014they can be replaced everywhere\nby the defining combinators.) To put into words, if \\(m\\) is \\(0\\) then the\nsum is \\(n\\), otherwise \\(m+n\\) is the successor of \\((m-1)+n\\). Of course,\nthis definition closely simulates the definition of addition from recursion\ntheory, where addition is often defined by the two equations \\(+(0,n)=n\\) and\n\\(+(s(m),n)=s(+(m,n))\\) (with \\(s\\) denoting the successor function). The fact\nthat CL can express addition in this form shows\u2014once again\u2014the\nversatility of CL.\n\nCombinatorial completeness guarantees that the term on the right hand side of\nthe defining equation for \\(+\\) (i.e., the term \\(Zmn(\\textsf{V}(\\textsf{KI})\n(+(Pm)n)))\\) can be transformed into a term in which \\(+\\) is the first, \\(m\\)\nand \\(n\\) are the second and third arguments, respectively. Then \\(+\\) can be\ndefined explicitly as the fixed point of the combinator\n\n\\[\n\\textsf{B}(\\textsf{BW})(\\textsf{BW}(\\textsf{B}(\\textsf{B}(\\textsf{C}\n(\\textsf{BB}(\\textsf{BC}(\\textsf{TK})))))(\\textsf{B}(\\textsf{B}(\\textsf{B}\n(\\textsf{V}(\\textsf{KI}))))(\\textsf{CB}(\\textsf{T}(\\textsf{KI})))))).\n\\]\n\n\nOf course, we can abbreviate the so obtained term as \\(+\\) for the sake of\ntransparency, just as we used earlier \\(P\\) and \\(Z\\) as shorthands for longer\ncombinatory terms.\n\nMultiplication is often denoted by \\(\\,\\cdot\\,\\). The recursive\nequation \\(\\,\\cdot\\, mn = Zm\\textsf{I}(+n(\\,\\cdot\\,(Pm)n))\\) defines\nmultiplication and it can be deciphered as \u201cif \\(m\\) is \\(0\\)\nthen the result is \\(0\\), else \\(n\\) is added to the result of\n\\((m-1)\\cdot n\\).\u201d The next step in the definition brings the\nright-hand side term to the form \\(\\textsf{X}\\cdot mn\\), where\n\\(\\textsf{X}\\) does not contain occurrences of \\(\\,\\cdot\\,\\), \\(m\\)\nor \\(n\\). Then taking the fixed point of \\(\\textsf{X}\\), and setting\n\\(\\,\\cdot\\,\\) to be \\(\\textsf{YX}\\) concludes the definition of the\nmultiplication function. For instance, the abstraction can yield the\ncombinator\n\n\\[\n\\textsf{BW}(\\textsf{B}(\\textsf{B}(\\textsf{C}(\\textsf{BB}(\\textsf{C}(\n\\textsf{TK})\\textsf{I}))))(\\textsf{B}(\\textsf{BW})(\\textsf{B}(\\textsf{B}\n(\\textsf{B}(\\textsf{C}+)))(\\textsf{CB}(\\textsf{T}(\\textsf{KI})))))).\n\\]\n\n\nThe factorial function is definable from the predecessor\nfunction plus from multiplication, and it is useful e.g., in\ncombinatorics. The factorial function (denoted by \\(\\,!\\,\\)) is\nrecursively definable by the equation \\(\\,!\\,\nm=Zm(\\textsf{V}(\\textsf{KI})\\textsf{I})(\\cdot m(\\,!  \\,(Pm)))\\), that\nmay be read as \u201cif \\(m\\) is \\(0\\), then \\(\\,!\\, m=1\\), otherwise\n\\(\\,!\\, m\\) equals to \\(m\\) multiplied by the factorial of\n\\(m-1\\).\u201d\n\nOf course, it is not necessary to define various numerical functions by\nsimulating their recursive definitions. As we saw above in the case of the\nfirst representation of numbers, we might just happen to have the right terms\nsuch as \\(\\textsf{BS}(\\textsf{BB})\\) and \\(\\textsf{B}\\), that behave as the\ntarget functions do on numbers. That is, an equally good way to define\narithmetic functions is to simply list some terms and then show that they\nbehave as expected. However, once it has been shown that the basic\nprimitive recursive functions together with recursion\nand minimization can be emulated in CL, we have got not only a nice\ncollection of arithmetic functions in the form of combinators to work with,\nbut also a proof that combinatory logic is sufficiently expressive to\nformalize all partial recursive functions. Indeed, the remaining steps\nof such a proof can be carried out in CL, though the details are beyond the\nscope of this entry.\n5.1 G\u00f6del sentence\n\nThe abbreviations and the interspersed explanations in the sketch above may\nobscure that arithmetic has been formalized in a language that consists of\nfive symbols (when juxtaposition is not counted): \\(\\textsf{S}\\), \n\\(\\textsf{K}\\), \\(=\\) plus two delimiters, \\(\\,(\\,\\) and \n\\(\\,)\\,\\). The finite (and perhaps, surprisingly small) number of\nsymbols and the availability of recursive functions conjure the thought that\nan arithmetization of the syntax of CL could be attempted.\n\nG\u00f6del\nachieved an encoding of a formal language by assigning numbers to symbols,\nformulas and sequences of formulas, which later became known as\n\u201cG\u00f6del numbers.\u201d Concretely, G\u00f6del assigned odd numbers\nto symbols and products of powers of primes (with the number corresponding to \na symbol in the exponent) to sequences of symbols. However, it is possible to \narithmetize the language of CL without placing a strong emphasis on the \nexistence and the properties of prime numbers. (See for example, \nRaymond\u00a0M.\u00a0Smullyan\u2019s books: Smullyan (1985) and Smullyan (1994).) \nThe five symbols get as their G\u00f6del numbers the first five positive \nintegers. A string is assigned the number in base \\(10\\) that results from \nthe concatenation of the corresponding numbers for the symbols.\n\nThe following outline gives the flavor of an analogue of G\u00f6del\u2019s\nincompleteness theorem adapted to CL. It is possible to define a combinator\nsuch that if this combinator is applied to a numeral \\(n\\), then the whole\nterm reduces to the numeral \\(m\\) that is the numeral denoting\nthe G\u00f6del number of the numeral \\(n\\). Slightly more formally,\nthere is a combinator \\(\\delta\\) such that \\(\\delta n = G(n)\\) (where \\(G\n(n)\\) denotes the G\u00f6del number of the expression \\(n\\)). Furthermore,\nthere is a combinatory term, which returns the numeral itself followed by\n\\(G(n)\\), when applied to a numeral \\(n\\). For any term \\(A\\) there is a term\n\\(B\\) such that the equation \\(A(\\delta B)=B\\) is true. This statement (or its\nconcrete variant for a particular formal system) is usually called\nthe second fixed point theorem. Computable characteristic functions of\nrecursive sets of numbers can be represented by combinators with the choice of\n\\(\\textsf{K}\\) for truth and \\(\\textsf{KI}\\) for falsity. The complements of\nsuch functions are computable too. Finally, it can be proved that there is no\ncombinator that represents the set of all true equations. To put it\ndifferently, any combinator either represents a set of equations that fails to\ninclude some true equations, or represents a set of equations that includes\nall true but also some false equations.\n\nAlonzo Church\nproved the undecidability of classical first-order logic relying on \nG\u00f6del\u2019s incompleteness theorem. Dana Scott proved that if \\(A\\) is a \nnonempty proper subset of \\(\\lambda\\)-terms that is closed under equality \nthen \\(A\\) is not recursive. The analogous claim for CL, that follows from \nthe existence of a G\u00f6delian sentence for CL, is that it is \nundecidable if two CL-terms are equal.",
    "section_title": "2.1 Reduction, equality and their formalizations",
    "entry_title": "Combinatory Logic",
    "hierarchy_title": "Combinatory Logic || Combinatory terms and their main properties || Reduction, equality and their formalizations",
    "tokenized_text": [
        "combinatory",
        "term",
        "main",
        "property",
        "reduction",
        "equality",
        "formalization",
        "reduction",
        "equality",
        "formalization",
        "paradox",
        "discovered",
        "georg",
        "cantor",
        "bertrand",
        "russell",
        "late",
        "thearly",
        "th",
        "century",
        "involve",
        "selfmembership",
        "set",
        "ramified",
        "theory",
        "type",
        "due",
        "alfred",
        "n",
        "whitehead",
        "bertrand",
        "russell",
        "zf",
        "formalization",
        "set",
        "theory",
        "named",
        "ernst",
        "zermelo",
        "abraham",
        "a",
        "fraenkel",
        "exclude",
        "selfmembership",
        "however",
        "seems",
        "always",
        "desire",
        "create",
        "theory",
        "allows",
        "selfmembership",
        "selfapplication",
        "indeed",
        "one",
        "curry",
        "motivation",
        "development",
        "cl",
        "goal",
        "construct",
        "formal",
        "language",
        "includes",
        "wide",
        "range",
        "wellformed",
        "expression",
        "whichunder",
        "certain",
        "interpretationsmay",
        "turn",
        "meaningless",
        "idea",
        "may",
        "compared",
        "von",
        "neumannbernaysg\u00f6del",
        "formalization",
        "set",
        "theory",
        "whichwithout",
        "axiom",
        "foundationthe",
        "russell",
        "class",
        "proved",
        "set",
        "hence",
        "proper",
        "class",
        "natural",
        "language",
        "example",
        "provide",
        "convenient",
        "illustration",
        "clarify",
        "difference",
        "wellformed",
        "meaningless",
        "expression",
        "meaningful",
        "illformed",
        "sentence",
        "meaningfulness",
        "course",
        "taken",
        "grain",
        "salt",
        "reality",
        "kurt",
        "g\u00f6del",
        "proved",
        "system",
        "pm",
        "incomplete",
        "thus",
        "may",
        "guessedusing",
        "syntactic",
        "semantics",
        "cluesto",
        "distorted",
        "version",
        "peano",
        "arithmetic",
        "proved",
        "incomplete",
        "g\u00f6del",
        "derivative",
        "lambda",
        "x",
        "xx",
        "wish",
        "declare",
        "function",
        "smart",
        "peano",
        "arithmetic",
        "prove",
        "incomplete",
        "g\u00f6del",
        "informal",
        "motivation",
        "turn",
        "cl",
        "proper",
        "introduce",
        "notion",
        "bit",
        "formally",
        "object",
        "cl",
        "called",
        "term",
        "term",
        "may",
        "thought",
        "interpreted",
        "function",
        "explained",
        "section",
        "primitive",
        "term",
        "comprise",
        "variable",
        "constant",
        "whereas",
        "compound",
        "term",
        "formed",
        "combining",
        "term",
        "usually",
        "denumerable",
        "set",
        "ie",
        "set",
        "cardinality",
        "aleph_",
        "variable",
        "included",
        "constant",
        "include",
        "undefined",
        "combinators",
        "use",
        "x",
        "z",
        "v",
        "w",
        "u",
        "x_",
        "ldots",
        "variable",
        "object",
        "language",
        "n",
        "p",
        "q",
        "ldots",
        "metavariables",
        "range",
        "term",
        "term",
        "inductively",
        "defined",
        "follows",
        "t",
        "x",
        "variable",
        "x",
        "term",
        "t",
        "c",
        "constant",
        "c",
        "term",
        "t",
        "m",
        "n",
        "term",
        "mn",
        "term",
        "definition",
        "t",
        "conceals",
        "binary",
        "operation",
        "conjoins",
        "two",
        "term",
        "m",
        "n",
        "operation",
        "called",
        "application",
        "often",
        "denoted",
        "juxtaposition",
        "placing",
        "two",
        "argument",
        "next",
        "mn",
        "application",
        "assumed",
        "posse",
        "additional",
        "property",
        "commutativity",
        "intended",
        "interpretation",
        "function",
        "application",
        "instance",
        "vw",
        "u",
        "v",
        "wu",
        "distinct",
        "termsjust",
        "derivative",
        "lambda",
        "x",
        "xx",
        "applied",
        "lambda",
        "xx",
        "different",
        "derivative",
        "using",
        "lambda",
        "notation",
        "two",
        "term",
        "example",
        "may",
        "expressed",
        "lambda",
        "y",
        "lambda",
        "x",
        "xx",
        "v",
        "lambda",
        "y",
        "lambda",
        "x",
        "xx",
        "term",
        "viewed",
        "structured",
        "string",
        "parenthesis",
        "show",
        "grouping",
        "number",
        "distinct",
        "term",
        "associated",
        "string",
        "length",
        "n",
        "catalan",
        "number",
        "c_",
        "n",
        "nonnegative",
        "integer",
        "n",
        "ie",
        "ninmathbb",
        "n",
        "c_n",
        "frac",
        "n",
        "n",
        "choose",
        "n",
        "first",
        "seven",
        "catalan",
        "number",
        "c_",
        "c_",
        "c_",
        "c_",
        "c_",
        "c_",
        "c_",
        "illustration",
        "may",
        "takefor",
        "simplicitystrings",
        "consisting",
        "x",
        "term",
        "differ",
        "grouping",
        "clearly",
        "term",
        "x",
        "xx",
        "length",
        "one",
        "way",
        "form",
        "term",
        "exists",
        "one",
        "possible",
        "term",
        "case",
        "start",
        "three",
        "x",
        "may",
        "form",
        "xx",
        "x",
        "x",
        "xx",
        "length",
        "term",
        "five",
        "term",
        "xxxx",
        "x",
        "xx",
        "x",
        "xx",
        "xx",
        "x",
        "xxx",
        "x",
        "x",
        "xx",
        "useful",
        "exercise",
        "try",
        "list",
        "distinct",
        "term",
        "formed",
        "x",
        "s",
        "usual",
        "notational",
        "convention",
        "cl",
        "drop",
        "parenthesis",
        "leftassociated",
        "term",
        "together",
        "outmost",
        "pair",
        "instance",
        "xyz",
        "would",
        "fully",
        "written",
        "xy",
        "z",
        "whereas",
        "xy",
        "xz",
        "xy",
        "xz",
        "shorthand",
        "version",
        "term",
        "xy",
        "xz",
        "unlike",
        "xyxz",
        "grouping",
        "term",
        "delineates",
        "subterms",
        "instance",
        "xy",
        "subterm",
        "term",
        "mentioned",
        "paragraph",
        "whereas",
        "yz",
        "yx",
        "subterms",
        "none",
        "term",
        "subterms",
        "term",
        "recursively",
        "defined",
        "follows",
        "s",
        "m",
        "subterm",
        "m",
        "s",
        "m",
        "subterm",
        "n",
        "p",
        "m",
        "subterm",
        "np",
        "incidentally",
        "notion",
        "free",
        "variable",
        "straightforwardly",
        "definable",
        "x",
        "free",
        "variable",
        "m",
        "iff",
        "x",
        "subterm",
        "m",
        "set",
        "free",
        "variable",
        "m",
        "sometimes",
        "denoted",
        "textrm",
        "fv",
        "term",
        "interpreted",
        "function",
        "combinators",
        "function",
        "similarly",
        "numerical",
        "geometrical",
        "function",
        "described",
        "grasped",
        "easily",
        "combinators",
        "frequently",
        "encountered",
        "characterized",
        "perspicuous",
        "transformation",
        "term",
        "sans",
        "serif",
        "letter",
        "denote",
        "combinators",
        "denotes",
        "onestep",
        "reduction",
        "definition",
        "axiom",
        "wellknown",
        "combinators",
        "textsf",
        "xyz",
        "mathbin",
        "triangleright_",
        "xz",
        "yz",
        "textsf",
        "k",
        "xy",
        "mathbin",
        "triangleright_",
        "x",
        "textsf",
        "x",
        "mathbin",
        "triangleright_",
        "x",
        "textsf",
        "b",
        "xyz",
        "mathbin",
        "triangleright_",
        "x",
        "yz",
        "textsf",
        "xy",
        "mathbin",
        "triangleright_",
        "yx",
        "textsf",
        "c",
        "xyz",
        "mathbin",
        "triangleright_",
        "xzy",
        "textsf",
        "w",
        "xy",
        "mathbin",
        "triangleright_",
        "xyy",
        "textsf",
        "x",
        "mathbin",
        "triangleright_",
        "xx",
        "textsf",
        "x",
        "mathbin",
        "triangleright_",
        "x",
        "textsf",
        "x",
        "textsf",
        "j",
        "xyzv",
        "mathbin",
        "triangleright_",
        "xy",
        "xvz",
        "textsf",
        "b",
        "prime",
        "xyz",
        "mathbin",
        "triangleright_",
        "xz",
        "textsf",
        "v",
        "xyz",
        "mathbin",
        "triangleright_",
        "zxy",
        "axiom",
        "tacitly",
        "specify",
        "arity",
        "combinator",
        "well",
        "reduction",
        "contraction",
        "pattern",
        "perhaps",
        "simplest",
        "combinaetor",
        "identity",
        "combinator",
        "textsf",
        "applied",
        "argument",
        "x",
        "return",
        "x",
        "textsf",
        "k",
        "applied",
        "x",
        "constant",
        "function",
        "applied",
        "y",
        "yield",
        "x",
        "result",
        "textsf",
        "k",
        "cancellator",
        "respect",
        "second",
        "argument",
        "textsf",
        "w",
        "textsf",
        "duplicator",
        "result",
        "application",
        "one",
        "argument",
        "always",
        "appears",
        "twice",
        "textsf",
        "c",
        "textsf",
        "textsf",
        "v",
        "permutators",
        "change",
        "order",
        "argument",
        "textsf",
        "b",
        "associator",
        "textsf",
        "b",
        "xyz",
        "turn",
        "term",
        "y",
        "applied",
        "z",
        "x",
        "applied",
        "result",
        "textsf",
        "fixed",
        "point",
        "combinator",
        "function",
        "x",
        "textsf",
        "x",
        "fixed",
        "point",
        "function",
        "see",
        "section",
        "combinator",
        "textsf",
        "b",
        "prime",
        "associator",
        "permutator",
        "whereas",
        "textsf",
        "textsf",
        "j",
        "also",
        "duplicator",
        "textsf",
        "special",
        "called",
        "strong",
        "composition",
        "combinator",
        "applied",
        "two",
        "function",
        "let",
        "u",
        "say",
        "g",
        "f",
        "order",
        "well",
        "x",
        "resulting",
        "term",
        "gx",
        "fx",
        "express",
        "composition",
        "g",
        "f",
        "applied",
        "argument",
        "x",
        "informal",
        "explication",
        "mention",
        "restriction",
        "sort",
        "function",
        "x",
        "z",
        "f",
        "g",
        "ldots",
        "may",
        "however",
        "axiom",
        "limit",
        "applicability",
        "combinators",
        "variable",
        "intuitively",
        "would",
        "like",
        "say",
        "given",
        "term",
        "function",
        "m",
        "n",
        "textsf",
        "w",
        "mn",
        "onestep",
        "reduces",
        "mnn",
        "possibly",
        "subterm",
        "another",
        "term",
        "example",
        "m",
        "may",
        "textsf",
        "k",
        "n",
        "may",
        "yy",
        "textsf",
        "wk",
        "yy",
        "triangleright_textsf",
        "k",
        "yy",
        "yy",
        "latter",
        "term",
        "suggests",
        "onestep",
        "reduction",
        "indeed",
        "might",
        "interested",
        "successive",
        "onestep",
        "reductionssuch",
        "leading",
        "textsf",
        "wk",
        "yy",
        "yy",
        "way",
        "achieve",
        "goal",
        "formalize",
        "theory",
        "cl",
        "starting",
        "standard",
        "inequational",
        "logic",
        "omit",
        "antisymmetry",
        "rule",
        "add",
        "certain",
        "axiom",
        "rule",
        "inequational",
        "calculus",
        "cl",
        "text",
        "cl",
        "_triangleright",
        "mtriangleright",
        "m",
        "textsf",
        "mnptriangleright",
        "mp",
        "np",
        "quadtextsf",
        "k",
        "mntriangleright",
        "m",
        "dfrac",
        "mtriangleright",
        "n",
        "quad",
        "ntriangleright",
        "p",
        "mtriangleright",
        "p",
        "dfrac",
        "mtriangleright",
        "n",
        "mptriangleright",
        "np",
        "dfrac",
        "mtriangleright",
        "n",
        "pmtriangleright",
        "pn",
        "use",
        "metavariables",
        "encompasses",
        "substitution",
        "illustrated",
        "term",
        "textsf",
        "w",
        "mn",
        "identity",
        "axiom",
        "rule",
        "transitivity",
        "imply",
        "triangleright",
        "transitive",
        "reflexive",
        "relation",
        "last",
        "two",
        "rule",
        "characterize",
        "application",
        "operation",
        "monotone",
        "argument",
        "place",
        "text",
        "cl",
        "_triangleright",
        "includes",
        "textsf",
        "textsf",
        "k",
        "combinators",
        "definable",
        "themas",
        "already",
        "mentioned",
        "section",
        "explain",
        "precisely",
        "toward",
        "end",
        "section",
        "set",
        "combinators",
        "textsf",
        "textsf",
        "k",
        "called",
        "combinatory",
        "base",
        "two",
        "combinators",
        "undefined",
        "constant",
        "text",
        "cl",
        "_triangleright",
        "give",
        "idea",
        "proof",
        "calculus",
        "following",
        "step",
        "may",
        "pieced",
        "together",
        "prove",
        "textsf",
        "skk",
        "textsf",
        "ksk",
        "triangleright",
        "textsf",
        "textsf",
        "ksk",
        "triangleright",
        "textsf",
        "instance",
        "axiom",
        "textsf",
        "skk",
        "textsf",
        "ksk",
        "trianglerighttextsf",
        "skks",
        "obtained",
        "right",
        "monotonicity",
        "textsf",
        "skk",
        "textsf",
        "ksk",
        "trianglerighttextsf",
        "result",
        "instance",
        "textsf",
        "textsf",
        "k",
        "axiom",
        "together",
        "application",
        "transitivity",
        "rule",
        "relation",
        "triangleright",
        "called",
        "weak",
        "reduction",
        "may",
        "defined",
        "alternatively",
        "follows",
        "weak",
        "reduction",
        "technical",
        "term",
        "used",
        "cl",
        "distinguish",
        "relation",
        "set",
        "term",
        "relation",
        "one",
        "called",
        "strong",
        "reduction",
        "term",
        "either",
        "form",
        "textsf",
        "mnp",
        "form",
        "textsf",
        "k",
        "mn",
        "redex",
        "leading",
        "combinators",
        "textsf",
        "textsf",
        "k",
        "respectively",
        "head",
        "redexes",
        "term",
        "q",
        "contains",
        "subterm",
        "form",
        "textsf",
        "mnp",
        "qprime",
        "obtained",
        "replacing",
        "subterm",
        "mp",
        "np",
        "onestep",
        "reduct",
        "q",
        "similarly",
        "redex",
        "textsf",
        "k",
        "mn",
        "m",
        "qtriangleright",
        "qprime",
        "case",
        "reduction",
        "may",
        "defined",
        "reflexive",
        "transitive",
        "closure",
        "onestep",
        "reduction",
        "notion",
        "completely",
        "captured",
        "text",
        "cl",
        "_triangleright",
        "calculus",
        "text",
        "cl",
        "_triangleright",
        "complete",
        "sense",
        "mtriangleright",
        "n",
        "sense",
        "described",
        "text",
        "cl",
        "_triangleright",
        "prof",
        "mtriangleright",
        "n",
        "easy",
        "see",
        "converse",
        "implication",
        "true",
        "notion",
        "reduction",
        "weaker",
        "relation",
        "onestep",
        "reduction",
        "useful",
        "distinguish",
        "subclass",
        "term",
        "using",
        "stronger",
        "relation",
        "term",
        "normal",
        "form",
        "nf",
        "contains",
        "redexes",
        "note",
        "onestep",
        "reduction",
        "need",
        "decrease",
        "total",
        "number",
        "redexes",
        "term",
        "contains",
        "hence",
        "follow",
        "every",
        "term",
        "turned",
        "term",
        "nf",
        "via",
        "finitely",
        "many",
        "onestep",
        "reduction",
        "indeed",
        "term",
        "reduce",
        "term",
        "nf",
        "reduction",
        "arguably",
        "important",
        "relation",
        "term",
        "denote",
        "function",
        "typical",
        "step",
        "program",
        "execution",
        "concrete",
        "calculation",
        "function",
        "application",
        "rather",
        "move",
        "direction",
        "called",
        "expansion",
        "however",
        "notion",
        "equality",
        "function",
        "familiar",
        "everybody",
        "mathematics",
        "analogous",
        "notion",
        "introduced",
        "cl",
        "transitive",
        "reflexive",
        "symmetric",
        "closure",
        "onestep",
        "reduction",
        "relation",
        "called",
        "weak",
        "equality",
        "formalization",
        "equational",
        "cl",
        "may",
        "obtained",
        "extending",
        "standard",
        "equational",
        "logic",
        "combinatory",
        "axiom",
        "rule",
        "characterizing",
        "combinatory",
        "constant",
        "application",
        "operation",
        "equational",
        "calculus",
        "cl",
        "text",
        "cl",
        "_",
        "mm",
        "textsf",
        "k",
        "mnm",
        "textsf",
        "mnpmp",
        "np",
        "dfrac",
        "mn",
        "quad",
        "np",
        "mp",
        "dfrac",
        "mn",
        "nm",
        "dfrac",
        "mn",
        "mpnp",
        "dfrac",
        "mn",
        "pmpn",
        "first",
        "axiom",
        "first",
        "two",
        "rule",
        "constitute",
        "equational",
        "logic",
        "constant",
        "combinators",
        "textsf",
        "textsf",
        "k",
        "note",
        "text",
        "cl",
        "_",
        "could",
        "defined",
        "extension",
        "text",
        "cl",
        "_triangleright",
        "adding",
        "rule",
        "symmetry",
        "would",
        "paralleled",
        "description",
        "definition",
        "equality",
        "reduction",
        "transitive",
        "symmetric",
        "closure",
        "chose",
        "instead",
        "repeat",
        "inequational",
        "axiom",
        "rule",
        "new",
        "notation",
        "add",
        "rule",
        "symmetry",
        "make",
        "two",
        "definition",
        "selfcontained",
        "easy",
        "grasp",
        "two",
        "characterization",
        "coincideas",
        "triangleright",
        "text",
        "cl",
        "_triangleright",
        "text",
        "cl",
        "_",
        "share",
        "feature",
        "may",
        "may",
        "desirabledepending",
        "sort",
        "understanding",
        "function",
        "captured",
        "illustrate",
        "issue",
        "let",
        "u",
        "consider",
        "oneplace",
        "combinators",
        "textsf",
        "skk",
        "textsf",
        "sk",
        "textsf",
        "kk",
        "easy",
        "verify",
        "textsf",
        "skk",
        "mtriangleright",
        "m",
        "textsf",
        "sk",
        "textsf",
        "kk",
        "triangleright",
        "m",
        "however",
        "neither",
        "textsf",
        "skk",
        "triangleright",
        "textsf",
        "sk",
        "textsf",
        "kk",
        "textsf",
        "sk",
        "textsf",
        "kk",
        "triangleright",
        "textsf",
        "skk",
        "provable",
        "text",
        "cl",
        "_triangleright",
        "fortiori",
        "equality",
        "two",
        "term",
        "provable",
        "text",
        "cl",
        "_",
        "mean",
        "text",
        "cl",
        "_triangleright",
        "text",
        "cl",
        "_",
        "formalize",
        "intensional",
        "notion",
        "function",
        "intensionality",
        "implies",
        "function",
        "give",
        "output",
        "input",
        "may",
        "remain",
        "distinguishable",
        "archetypical",
        "intensional",
        "function",
        "one",
        "likely",
        "encounter",
        "algorithm",
        "example",
        "might",
        "think",
        "various",
        "specification",
        "calculate",
        "decimal",
        "expansion",
        "pi",
        "various",
        "computer",
        "program",
        "behave",
        "way",
        "instance",
        "compiler",
        "one",
        "language",
        "may",
        "differ",
        "using",
        "using",
        "optimization",
        "thereby",
        "producing",
        "program",
        "given",
        "piece",
        "code",
        "identical",
        "inputoutput",
        "behavior",
        "different",
        "run",
        "time",
        "function",
        "indistinguishable",
        "point",
        "view",
        "inputoutput",
        "behavior",
        "identified",
        "extensional",
        "understanding",
        "function",
        "sought",
        "text",
        "cl",
        "_triangleright",
        "text",
        "cl",
        "_",
        "extended",
        "following",
        "rule",
        "symbol",
        "ddagger",
        "replaced",
        "triangleright",
        "respectively",
        "frac",
        "mxddagger",
        "nx",
        "mddagger",
        "n",
        "text",
        "x",
        "text",
        "free",
        "mn",
        "churchrosser",
        "theorem",
        "consistency",
        "theorem",
        "calculus",
        "text",
        "cl",
        "_triangleright",
        "text",
        "cl",
        "_",
        "previous",
        "section",
        "formalize",
        "reduction",
        "equality",
        "however",
        "triangleright",
        "property",
        "important",
        "term",
        "thought",
        "stand",
        "function",
        "next",
        "theorem",
        "one",
        "earliest",
        "bestknown",
        "result",
        "cl",
        "churchrosser",
        "theorem",
        "m",
        "reduces",
        "n",
        "p",
        "term",
        "q",
        "n",
        "p",
        "reduce",
        "figure",
        "illustration",
        "churchrosser",
        "theorem",
        "think",
        "reduction",
        "like",
        "computing",
        "value",
        "function",
        "churchrosser",
        "theoremin",
        "first",
        "approximationcan",
        "thought",
        "state",
        "final",
        "result",
        "series",
        "calculation",
        "term",
        "uniqueindependently",
        "order",
        "step",
        "slight",
        "overstatement",
        "though",
        "uniqueness",
        "implies",
        "series",
        "calculation",
        "end",
        "loop",
        "term",
        "unique",
        "final",
        "term",
        "finitely",
        "many",
        "distinct",
        "consecutive",
        "calculation",
        "step",
        "possible",
        "coarse",
        "analogy",
        "elementary",
        "arithmetic",
        "operation",
        "perhaps",
        "shed",
        "light",
        "situation",
        "addition",
        "multiplication",
        "natural",
        "number",
        "always",
        "yield",
        "natural",
        "number",
        "however",
        "division",
        "included",
        "longer",
        "true",
        "numerical",
        "expression",
        "evaluate",
        "natural",
        "number",
        "since",
        "rational",
        "number",
        "natural",
        "one",
        "n",
        "undefined",
        "even",
        "n",
        "real",
        "numerical",
        "expression",
        "evaluate",
        "natural",
        "number",
        "although",
        "analogy",
        "combinatory",
        "term",
        "tight",
        "useful",
        "instance",
        "n",
        "assuming",
        "codomain",
        "function",
        "lambda",
        "n",
        "n",
        "extended",
        "permit",
        "r",
        "rational",
        "could",
        "implemented",
        "computer",
        "loop",
        "would",
        "never",
        "terminate",
        "executed",
        "nne",
        "would",
        "go",
        "enumeration",
        "rational",
        "number",
        "trying",
        "find",
        "r",
        "rcdotn",
        "combinatory",
        "term",
        "textsf",
        "www",
        "textsf",
        "wi",
        "textsf",
        "wi",
        "perhaps",
        "simplest",
        "example",
        "term",
        "normal",
        "form",
        "term",
        "induce",
        "infinite",
        "reduction",
        "sequence",
        "infinite",
        "chain",
        "successive",
        "onestep",
        "reduction",
        "make",
        "example",
        "transparent",
        "let",
        "u",
        "assume",
        "moment",
        "textsf",
        "w",
        "textsf",
        "textsf",
        "c",
        "etc",
        "defined",
        "textsf",
        "k",
        "textsf",
        "primitive",
        "constant",
        "contraction",
        "redex",
        "textsf",
        "www",
        "return",
        "term",
        "show",
        "uniqueness",
        "imply",
        "term",
        "nf",
        "contraction",
        "redex",
        "textsf",
        "wi",
        "textsf",
        "wi",
        "give",
        "textsf",
        "textsf",
        "wi",
        "textsf",
        "wi",
        "reduces",
        "term",
        "started",
        "slightly",
        "complicated",
        "example",
        "term",
        "infinite",
        "reduction",
        "sequence",
        "textsf",
        "textsf",
        "cki",
        "term",
        "reduction",
        "sequence",
        "contracted",
        "redex",
        "headed",
        "textsf",
        "contains",
        "infinitely",
        "many",
        "distinct",
        "term",
        "also",
        "possible",
        "create",
        "infinite",
        "reduction",
        "sequence",
        "start",
        "textsf",
        "textsf",
        "cki",
        "various",
        "loop",
        "sum",
        "churchrosser",
        "theorem",
        "general",
        "guarantee",
        "uniqueness",
        "term",
        "q",
        "however",
        "m",
        "normal",
        "form",
        "unique",
        "churchrosser",
        "theorem",
        "often",
        "stated",
        "follows",
        "churchrosser",
        "theorem",
        "ii",
        "n",
        "p",
        "equal",
        "term",
        "q",
        "n",
        "p",
        "reduces",
        "figure",
        "illustration",
        "churchrosser",
        "theorem",
        "ii",
        "second",
        "form",
        "churchrosser",
        "theorem",
        "differs",
        "first",
        "assumption",
        "definition",
        "equality",
        "superset",
        "reduction",
        "obvious",
        "first",
        "form",
        "theorem",
        "implied",
        "second",
        "however",
        "despite",
        "weaker",
        "assumption",
        "second",
        "formulation",
        "churchrosser",
        "theorem",
        "two",
        "theorem",
        "equivalent",
        "equality",
        "transitive",
        "symmetric",
        "closure",
        "reduction",
        "mean",
        "two",
        "term",
        "equal",
        "finite",
        "path",
        "comprising",
        "reduction",
        "expansion",
        "step",
        "decompose",
        "onestep",
        "reduction",
        "onestep",
        "expansion",
        "respectively",
        "finitely",
        "many",
        "application",
        "first",
        "churchrosser",
        "theorem",
        "ie",
        "induction",
        "length",
        "path",
        "connecting",
        "n",
        "p",
        "first",
        "churchrosser",
        "theorem",
        "implies",
        "second",
        "formulation",
        "modern",
        "proof",
        "churchrosser",
        "theorem",
        "cl",
        "proceed",
        "indirectly",
        "onestep",
        "reduction",
        "fails",
        "diamond",
        "property",
        "binary",
        "relation",
        "r",
        "eg",
        "reduction",
        "said",
        "diamond",
        "property",
        "xry",
        "xrz",
        "imply",
        "yrv",
        "zrv",
        "v",
        "binary",
        "relation",
        "r",
        "diamond",
        "property",
        "transitive",
        "closure",
        "exploit",
        "insight",
        "proof",
        "churchrosser",
        "theorem",
        "suitable",
        "subrelation",
        "reduction",
        "found",
        "sought",
        "subrelation",
        "posse",
        "diamond",
        "property",
        "reflexive",
        "transitive",
        "closure",
        "coincide",
        "reduction",
        "following",
        "counterexample",
        "illustrates",
        "onestep",
        "reduction",
        "term",
        "may",
        "yield",
        "term",
        "reduce",
        "common",
        "term",
        "one",
        "step",
        "textsf",
        "skk",
        "textsf",
        "kks",
        "triangleright_textsf",
        "skkk",
        "textsf",
        "skk",
        "textsf",
        "kks",
        "triangleright_textsf",
        "k",
        "textsf",
        "kks",
        "textsf",
        "k",
        "textsf",
        "kks",
        "potential",
        "reduction",
        "sequence",
        "follows",
        "textsf",
        "skkk",
        "triangleright_textsf",
        "kk",
        "textsf",
        "kk",
        "triangleright_",
        "textsf",
        "k",
        "textsf",
        "k",
        "textsf",
        "kks",
        "textsf",
        "k",
        "textsf",
        "kks",
        "triangleright_",
        "textsf",
        "kks",
        "triangleright_textsf",
        "k",
        "textsf",
        "k",
        "textsf",
        "kks",
        "textsf",
        "k",
        "textsf",
        "kks",
        "triangleright_",
        "textsf",
        "kk",
        "textsf",
        "k",
        "textsf",
        "kks",
        "triangleright_",
        "textsf",
        "kk",
        "textsf",
        "kk",
        "triangleright_textsf",
        "k",
        "textsf",
        "k",
        "textsf",
        "kks",
        "textsf",
        "k",
        "textsf",
        "kks",
        "triangleright_",
        "textsf",
        "k",
        "textsf",
        "kks",
        "textsf",
        "kk",
        "triangleright_textsf",
        "kks",
        "triangleright_textsf",
        "k",
        "textsf",
        "k",
        "textsf",
        "kks",
        "textsf",
        "k",
        "textsf",
        "kks",
        "triangleright_",
        "textsf",
        "k",
        "textsf",
        "kks",
        "textsf",
        "kk",
        "triangleright_textsf",
        "kk",
        "textsf",
        "kk",
        "triangleright_textsf",
        "k",
        "failure",
        "diamond",
        "property",
        "obvious",
        "note",
        "textsf",
        "skkk",
        "triangleright_textsf",
        "kk",
        "textsf",
        "kk",
        "textsf",
        "k",
        "textsf",
        "kks",
        "textsf",
        "k",
        "textsf",
        "kks",
        "reduce",
        "one",
        "step",
        "textsf",
        "kk",
        "textsf",
        "kk",
        "appropriate",
        "subrelation",
        "reduction",
        "simultaneous",
        "reduction",
        "set",
        "nonoverlapping",
        "redexes",
        "denoted",
        "triangleright",
        "_textrm",
        "sr",
        "nonoverlapping",
        "mean",
        "shared",
        "subterm",
        "occurrence",
        "two",
        "redexes",
        "triangleright_textrm",
        "sr",
        "includes",
        "triangleright_",
        "onestep",
        "reduction",
        "redex",
        "may",
        "viewed",
        "instead",
        "triangleright_textrm",
        "sr",
        "singleton",
        "set",
        "redexes",
        "triangleright_textrm",
        "sr",
        "obviously",
        "included",
        "triangleright",
        "ie",
        "reduction",
        "two",
        "fact",
        "imply",
        "reflexive",
        "transitive",
        "closure",
        "triangleright_textrm",
        "sr",
        "reductionwhen",
        "tonicity",
        "reflexive",
        "transitive",
        "closure",
        "operation",
        "denoted",
        "taken",
        "account",
        "summarize",
        "key",
        "inclusion",
        "relation",
        "mentioned",
        "triangleright_subseteqtriangleright_textrm",
        "sr",
        "rightarrow",
        "triangleright_",
        "subseteqtriangleright_textrm",
        "sr",
        "triangleright_textrm",
        "sr",
        "subseteqtriangleright",
        "rightarrow",
        "triangleright_textrm",
        "sr",
        "subseteqtriangleright",
        "triangleright_",
        "subseteqtriangleright",
        "quad",
        "textrm",
        "quadtriangleright",
        "triangleright",
        "central",
        "property",
        "triangleright_textrm",
        "sr",
        "need",
        "content",
        "following",
        "theorem",
        "theorem",
        "diamond",
        "property",
        "triangleright_textrm",
        "sr",
        "mtriangleright_textrm",
        "sr",
        "n",
        "mtriangleright_textrm",
        "sr",
        "p",
        "term",
        "q",
        "ntriangleright_textrm",
        "sr",
        "q",
        "ptriangleright_textrm",
        "sr",
        "q",
        "proof",
        "theorem",
        "easy",
        "induction",
        "term",
        "m",
        "property",
        "triangleright_textrm",
        "sr",
        "guarantee",
        "one",
        "onestep",
        "reduction",
        "performed",
        "reduction",
        "interfere",
        "overlap",
        "consistency",
        "cl",
        "follows",
        "churchrosser",
        "theorem",
        "together",
        "existence",
        "least",
        "two",
        "distinct",
        "normal",
        "form",
        "theorem",
        "consistency",
        "cl",
        "consistent",
        "term",
        "reduce",
        "hence",
        "equal",
        "term",
        "nf",
        "however",
        "many",
        "example",
        "first",
        "include",
        "textsf",
        "textsf",
        "k",
        "variable",
        "included",
        "aleph_",
        "many",
        "nf",
        "none",
        "term",
        "contains",
        "redex",
        "hence",
        "reduces",
        "churchrosser",
        "theorem",
        "excluded",
        "term",
        "m",
        "could",
        "reduce",
        "x",
        "textsf",
        "making",
        "textsf",
        "equal",
        "x",
        "interaction",
        "infinite",
        "reduction",
        "sequence",
        "nfs",
        "deserves",
        "careful",
        "inspection",
        "though",
        "term",
        "textsf",
        "www",
        "textsf",
        "textsf",
        "cki",
        "textsf",
        "wi",
        "textsf",
        "wi",
        "infinite",
        "reduction",
        "sequence",
        "however",
        "existence",
        "infinite",
        "reduction",
        "sequence",
        "term",
        "imply",
        "term",
        "normal",
        "form",
        "combinatory",
        "base",
        "complete",
        "contains",
        "cancellator",
        "textsf",
        "textsf",
        "ki",
        "reduces",
        "textsf",
        "ki",
        "textsf",
        "textsf",
        "ki",
        "textsf",
        "ki",
        "textsf",
        "ki",
        "textsf",
        "textsf",
        "ki",
        "textsf",
        "ki",
        "textsf",
        "ki",
        "textsf",
        "ki",
        "textsf",
        "textsf",
        "ki",
        "ldots",
        "well",
        "textsf",
        "term",
        "weakly",
        "normalizes",
        "nf",
        "whereas",
        "term",
        "strongly",
        "normalizes",
        "reduction",
        "sequence",
        "lead",
        "nf",
        "hence",
        "nf",
        "term",
        "computational",
        "analogue",
        "strongly",
        "normalizing",
        "term",
        "nondeterministic",
        "program",
        "terminates",
        "every",
        "branch",
        "computation",
        "whereas",
        "termination",
        "least",
        "one",
        "branch",
        "akin",
        "weak",
        "normalization",
        "importance",
        "normalization",
        "led",
        "whole",
        "range",
        "question",
        "extensive",
        "literature",
        "answer",
        "order",
        "reduction",
        "step",
        "ie",
        "reduction",
        "strategy",
        "affect",
        "finding",
        "nf",
        "one",
        "combinatory",
        "base",
        "guarantee",
        "existence",
        "normal",
        "form",
        "every",
        "combinator",
        "base",
        "quickly",
        "illustrate",
        "possible",
        "answer",
        "sample",
        "question",
        "start",
        "noting",
        "combinator",
        "duplicative",
        "effect",
        "base",
        "combinators",
        "base",
        "strongly",
        "normalize",
        "easy",
        "answer",
        "concrete",
        "base",
        "could",
        "example",
        "textsf",
        "b",
        "textsf",
        "c",
        "textsf",
        "k",
        "textsf",
        "b",
        "textsf",
        "c",
        "textsf",
        "independent",
        "interest",
        "view",
        "connection",
        "simply",
        "typed",
        "calculus",
        "however",
        "base",
        "far",
        "combinatorially",
        "complete",
        "even",
        "fixed",
        "point",
        "combinator",
        "undefinable",
        "could",
        "ask",
        "slightly",
        "different",
        "question",
        "start",
        "base",
        "textsf",
        "textsf",
        "k",
        "omit",
        "textsf",
        "get",
        "base",
        "textsf",
        "k",
        "combinators",
        "strongly",
        "normalize",
        "omit",
        "textsf",
        "k",
        "combinators",
        "textsf",
        "strongly",
        "normalize",
        "least",
        "normalize",
        "answer",
        "no",
        "term",
        "discovered",
        "henk",
        "barendregt",
        "early",
        "s",
        "show",
        "lack",
        "strong",
        "normalization",
        "textsf",
        "ss",
        "textsf",
        "ss",
        "textsf",
        "ss",
        "first",
        "textsf",
        "head",
        "indeed",
        "redex",
        "head",
        "reduction",
        "sequence",
        "term",
        "infinite",
        "since",
        "textsf",
        "contain",
        "combinator",
        "cancellative",
        "effect",
        "existence",
        "infinite",
        "reduction",
        "sequence",
        "term",
        "mean",
        "term",
        "nf",
        "shorter",
        "combinators",
        "base",
        "textsf",
        "without",
        "nf",
        "example",
        "textsf",
        "textsf",
        "s",
        "textsf",
        "sss",
        "comprises",
        "eight",
        "occurrence",
        "textsf",
        "sort",
        "question",
        "illustrated",
        "rather",
        "answer",
        "become",
        "bit",
        "technical",
        "often",
        "involve",
        "concept",
        "technique",
        "graph",
        "theory",
        "automaton",
        "theory",
        "theory",
        "termrewriting",
        "existence",
        "fixed",
        "point",
        "combinatorial",
        "completeness",
        "sch\u00f6nfinkel",
        "proved",
        "textsf",
        "textsf",
        "k",
        "suffice",
        "define",
        "combinators",
        "introduced",
        "mentioned",
        "definition",
        "text",
        "cl",
        "_triangleright",
        "set",
        "constant",
        "limited",
        "textsf",
        "textsf",
        "k",
        "combinators",
        "could",
        "defined",
        "demonstrate",
        "sense",
        "definability",
        "understood",
        "consider",
        "example",
        "textsf",
        "b",
        "axiom",
        "textsf",
        "b",
        "textsf",
        "b",
        "xyztriangleright_x",
        "yz",
        "take",
        "textsf",
        "textsf",
        "k",
        "textsf",
        "k",
        "instead",
        "textsf",
        "b",
        "following",
        "reduction",
        "sequence",
        "result",
        "textsf",
        "textsf",
        "k",
        "textsf",
        "k",
        "xyztriangleright_textsf",
        "k",
        "x",
        "textsf",
        "k",
        "x",
        "yztriangleright_textsf",
        "textsf",
        "k",
        "x",
        "yztriangleright_",
        "textsf",
        "k",
        "xz",
        "yz",
        "triangleright_x",
        "yz",
        "term",
        "textsf",
        "textsf",
        "k",
        "textsf",
        "k",
        "nf",
        "however",
        "nf",
        "requirement",
        "definability",
        "convenient",
        "work",
        "defining",
        "term",
        "nf",
        "application",
        "combinator",
        "nf",
        "could",
        "started",
        "reducing",
        "combinator",
        "normal",
        "form",
        "also",
        "always",
        "infinitely",
        "many",
        "combinators",
        "reduce",
        "combinator",
        "however",
        "note",
        "preference",
        "choosing",
        "combinators",
        "nf",
        "meant",
        "imply",
        "combinator",
        "defined",
        "two",
        "term",
        "nf",
        "give",
        "two",
        "definition",
        "involving",
        "textsf",
        "textsf",
        "k",
        "textsf",
        "constant",
        "textsf",
        "textsf",
        "k",
        "combinators",
        "term",
        "formed",
        "textsf",
        "textsf",
        "k",
        "without",
        "variable",
        "defined",
        "textsf",
        "b",
        "textsf",
        "textsf",
        "k",
        "textsf",
        "k",
        "may",
        "use",
        "textsf",
        "b",
        "definition",
        "abbreviation",
        "primarily",
        "reduce",
        "size",
        "resulting",
        "term",
        "well",
        "preserve",
        "transparency",
        "definition",
        "following",
        "list",
        "give",
        "definition",
        "wellknown",
        "combinators",
        "mentioned",
        "earlier",
        "placed",
        "definiendum",
        "definiens",
        "textsf",
        "textsf",
        "sk",
        "textsf",
        "kk",
        "textsf",
        "textsf",
        "b",
        "textsf",
        "si",
        "textsf",
        "k",
        "textsf",
        "c",
        "textsf",
        "b",
        "textsf",
        "textsf",
        "bbt",
        "textsf",
        "bbt",
        "textsf",
        "w",
        "textsf",
        "csi",
        "textsf",
        "textsf",
        "sii",
        "textsf",
        "textsf",
        "bw",
        "textsf",
        "bb",
        "primetextsf",
        "textsf",
        "bw",
        "textsf",
        "bb",
        "primetextsf",
        "textsf",
        "v",
        "textsf",
        "bct",
        "textsf",
        "b",
        "primetextsf",
        "cb",
        "textsf",
        "j",
        "textsf",
        "w",
        "textsf",
        "bc",
        "textsf",
        "b",
        "textsf",
        "b",
        "textsf",
        "bc",
        "textsf",
        "b",
        "textsf",
        "bb",
        "textsf",
        "bb",
        "definition",
        "easily",
        "seen",
        "imply",
        "combinators",
        "depend",
        "textsf",
        "textsf",
        "k",
        "obvious",
        "definition",
        "defined",
        "combinators",
        "mutually",
        "independent",
        "none",
        "listed",
        "combinators",
        "definable",
        "another",
        "one",
        "clearly",
        "subset",
        "suffice",
        "define",
        "combinators",
        "intend",
        "give",
        "exhaustive",
        "list",
        "interdefinability",
        "various",
        "subset",
        "combinators",
        "hint",
        "multiplicity",
        "intricacy",
        "definition",
        "list",
        "handful",
        "also",
        "introduce",
        "two",
        "combinators",
        "textsf",
        "prime",
        "textsf",
        "r",
        "textsf",
        "textsf",
        "skk",
        "textsf",
        "textsf",
        "wk",
        "textsf",
        "textsf",
        "ck",
        "textsf",
        "kk",
        "textsf",
        "b",
        "textsf",
        "cb",
        "prime",
        "textsf",
        "primetextsf",
        "c",
        "textsf",
        "textsf",
        "c",
        "prime",
        "textsf",
        "w",
        "textsf",
        "primetextsf",
        "textsf",
        "w",
        "textsf",
        "b",
        "textsf",
        "textsf",
        "bm",
        "textsf",
        "bbt",
        "textsf",
        "bbt",
        "textsf",
        "w",
        "textsf",
        "c",
        "textsf",
        "textsf",
        "cc",
        "textsf",
        "cc",
        "textsf",
        "r",
        "textsf",
        "bbt",
        "textsf",
        "textsf",
        "bm",
        "textsf",
        "cbm",
        "textsf",
        "textsf",
        "b",
        "prime",
        "textsf",
        "b",
        "primetextsf",
        "textsf",
        "fixed",
        "point",
        "combinator",
        "textsf",
        "taken",
        "primitive",
        "various",
        "way",
        "define",
        "itso",
        "far",
        "listed",
        "three",
        "fixed",
        "point",
        "theorem",
        "function",
        "m",
        "term",
        "n",
        "mn",
        "n",
        "proof",
        "theorem",
        "easy",
        "using",
        "fixed",
        "point",
        "combinator",
        "term",
        "play",
        "r\u00f4le",
        "n",
        "textsf",
        "m",
        "definition",
        "textsf",
        "slightly",
        "different",
        "property",
        "respect",
        "reduction",
        "importance",
        "fixed",
        "point",
        "combinator",
        "ensures",
        "function",
        "fixed",
        "point",
        "recursive",
        "equation",
        "solved",
        "haskell",
        "b",
        "curry",
        "alan",
        "turing",
        "defined",
        "fixed",
        "point",
        "combinators",
        "cl",
        "lambda",
        "calculus",
        "consider",
        "definition",
        "textsf",
        "_textsf",
        "bm",
        "textsf",
        "bwb",
        "quad",
        "textsf",
        "_textsf",
        "w",
        "textsf",
        "b",
        "textsf",
        "bw",
        "textsf",
        "bt",
        "textsf",
        "w",
        "textsf",
        "b",
        "textsf",
        "bw",
        "textsf",
        "bt",
        "subscript",
        "added",
        "distinguish",
        "two",
        "definition",
        "see",
        "textsf",
        "_",
        "mm",
        "textsf",
        "_m",
        "textsf",
        "_",
        "textsf",
        "_mtriangleright",
        "textsf",
        "_m",
        "hold",
        "respect",
        "textsf",
        "_",
        "similar",
        "curry",
        "fixed",
        "point",
        "combinator",
        "really",
        "fixed",
        "point",
        "combinator",
        "whereas",
        "textsf",
        "_",
        "like",
        "turing",
        "fixed",
        "point",
        "combinator",
        "fixed",
        "point",
        "theorem",
        "demonstratesto",
        "extentthe",
        "expressive",
        "power",
        "cl",
        "however",
        "fixed",
        "point",
        "combinators",
        "may",
        "defined",
        "base",
        "without",
        "cancellator",
        "textsf",
        "_",
        "textsf",
        "_",
        "show",
        "full",
        "power",
        "cl",
        "base",
        "textsf",
        "textsf",
        "k",
        "enunciated",
        "following",
        "theorem",
        "theorem",
        "combinatorial",
        "completeness",
        "f",
        "x_",
        "ldots",
        "x_n",
        "m",
        "m",
        "term",
        "containing",
        "variable",
        "explicitly",
        "listed",
        "combinator",
        "textsf",
        "x",
        "textsf",
        "x",
        "x_ldots",
        "x_n",
        "reduces",
        "m",
        "theorem",
        "assumption",
        "may",
        "strengthened",
        "exclude",
        "possibility",
        "occurrence",
        "x",
        "occur",
        "m",
        "consequent",
        "may",
        "strengthened",
        "adding",
        "qualification",
        "textsf",
        "x",
        "relevant",
        "combinator",
        "specifically",
        "textsf",
        "x",
        "combinator",
        "textsf",
        "b",
        "textsf",
        "w",
        "textsf",
        "c",
        "textsf",
        "base",
        "contain",
        "combinator",
        "cancellative",
        "effect",
        "equivalently",
        "textsf",
        "x",
        "combinator",
        "textsf",
        "textsf",
        "j",
        "base",
        "correspond",
        "church",
        "preferred",
        "lambdatextsf",
        "calculus",
        "combinatorial",
        "completeness",
        "usually",
        "proved",
        "via",
        "defining",
        "pseudo",
        "lambda",
        "abstraction",
        "bracket",
        "abstraction",
        "cl",
        "various",
        "algorithm",
        "define",
        "bracket",
        "abstraction",
        "operator",
        "cl",
        "behaves",
        "lambda",
        "operator",
        "lambda",
        "calculus",
        "operator",
        "usually",
        "denoted",
        "lambda",
        "algorithm",
        "differ",
        "various",
        "aspect",
        "set",
        "combinators",
        "presuppose",
        "ii",
        "length",
        "resulting",
        "term",
        "iii",
        "whether",
        "compose",
        "syntactic",
        "identity",
        "algorithm",
        "translates",
        "combinatory",
        "term",
        "lambda",
        "term",
        "iv",
        "whether",
        "commute",
        "either",
        "reduction",
        "equality",
        "first",
        "algorithm",
        "element",
        "may",
        "already",
        "found",
        "sch\u00f6nfinkel",
        "consists",
        "following",
        "clause",
        "applied",
        "order",
        "listing",
        "begin",
        "align",
        "tag",
        "k",
        "x",
        "mtextsf",
        "k",
        "text",
        "xnotintextrm",
        "fv",
        "tag",
        "x",
        "xtextsf",
        "tag",
        "eta",
        "x",
        "mxm",
        "text",
        "xnotintextrm",
        "fv",
        "tag",
        "b",
        "x",
        "mntextsf",
        "b",
        "x",
        "n",
        "text",
        "xnotintextrm",
        "fv",
        "tag",
        "c",
        "x",
        "mntextsf",
        "c",
        "x",
        "n",
        "text",
        "xnotintextrm",
        "fv",
        "n",
        "tag",
        "x",
        "mntextsf",
        "x",
        "x",
        "n",
        "end",
        "align",
        "example",
        "algorithm",
        "applied",
        "term",
        "lambda",
        "xyzx",
        "yz",
        "lambda",
        "translation",
        "textsf",
        "b",
        "resulting",
        "term",
        "textsf",
        "b",
        "however",
        "eta",
        "omitted",
        "much",
        "longer",
        "term",
        "result",
        "namely",
        "textsf",
        "c",
        "textsf",
        "bb",
        "textsf",
        "bbi",
        "textsf",
        "c",
        "textsf",
        "bbi",
        "textsf",
        "another",
        "algorithm",
        "example",
        "consists",
        "clause",
        "k",
        "nonclassical",
        "logic",
        "typed",
        "cl",
        "simple",
        "type",
        "combinatory",
        "term",
        "thought",
        "function",
        "function",
        "thought",
        "domain",
        "set",
        "possible",
        "input",
        "codomain",
        "set",
        "possible",
        "output",
        "example",
        "unary",
        "function",
        "considered",
        "set",
        "ordered",
        "pair",
        "domain",
        "codomain",
        "given",
        "first",
        "second",
        "projection",
        "respectively",
        "partial",
        "nononto",
        "function",
        "permitted",
        "supersets",
        "set",
        "resulting",
        "first",
        "second",
        "projection",
        "also",
        "domain",
        "codomains",
        "category",
        "theory",
        "function",
        "component",
        "category",
        "without",
        "set",
        "theoretic",
        "reduction",
        "assumed",
        "retains",
        "notion",
        "domain",
        "codomain",
        "moreover",
        "every",
        "function",
        "unique",
        "domain",
        "codomain",
        "function",
        "domain",
        "codomain",
        "may",
        "quite",
        "different",
        "however",
        "abstraction",
        "sort",
        "type",
        "simple",
        "illustration",
        "let",
        "f_",
        "f_",
        "two",
        "function",
        "defined",
        "f_",
        "lambda",
        "xcdot",
        "x",
        "f_lambda",
        "x",
        "x",
        "x",
        "variable",
        "ranging",
        "real",
        "f_",
        "f_",
        "domain",
        "codomain",
        "ie",
        "type",
        "mathbb",
        "r",
        "rightarrowmathbb",
        "r",
        "although",
        "f_ne",
        "f_",
        "f_",
        "x",
        "ne",
        "f_",
        "x",
        "whenever",
        "xne",
        "usual",
        "notation",
        "indicate",
        "function",
        "f",
        "a",
        "domain",
        "b",
        "codomain",
        "fcolon",
        "arightarrow",
        "b",
        "happy",
        "coincidence",
        "nowadays",
        "rightarrow",
        "often",
        "used",
        "logic",
        "symbol",
        "entailment",
        "nonclassical",
        "implication",
        "given",
        "set",
        "basic",
        "type",
        "denote",
        "p",
        "type",
        "defined",
        "follows",
        "pin",
        "p",
        "p",
        "type",
        "b",
        "type",
        "arightarrow",
        "b",
        "type",
        "distinguish",
        "type",
        "typessome",
        "introduced",
        "next",
        "sectionthey",
        "called",
        "simple",
        "type",
        "connection",
        "combinators",
        "type",
        "may",
        "explained",
        "example",
        "identity",
        "combinator",
        "compound",
        "combinatory",
        "term",
        "formed",
        "application",
        "operation",
        "premise",
        "modus",
        "ponens",
        "joined",
        "fusion",
        "denoted",
        "circ",
        "like",
        "application",
        "operation",
        "strongest",
        "relevance",
        "logic",
        "b",
        "textsf",
        "x",
        "triangleright",
        "x",
        "x",
        "s",
        "type",
        "a",
        "textsf",
        "x",
        "s",
        "type",
        "imply",
        "a",
        "furthermore",
        "textsf",
        "x",
        "s",
        "type",
        "form",
        "xcirc",
        "a",
        "type",
        "x",
        "textsf",
        "type",
        "arightarrow",
        "a",
        "example",
        "fixed",
        "x",
        "s",
        "type",
        "however",
        "textsf",
        "applied",
        "term",
        "hence",
        "accurate",
        "say",
        "arightarrow",
        "a",
        "type",
        "schema",
        "textsf",
        "textsf",
        "s",
        "type",
        "formula",
        "form",
        "selfimplication",
        "typeassignment",
        "system",
        "ta",
        "_textrm",
        "cl",
        "formally",
        "defined",
        "following",
        "deduction",
        "system",
        "implicational",
        "formula",
        "considered",
        "type",
        "usual",
        "convention",
        "omit",
        "parenthesis",
        "association",
        "right",
        "deltavdashtextsf",
        "colon",
        "arightarrow",
        "brightarrow",
        "c",
        "rightarrow",
        "arightarrow",
        "b",
        "rightarrow",
        "arightarrow",
        "c",
        "deltavdashtextsf",
        "k",
        "colon",
        "rightarrow",
        "brightarrow",
        "frac",
        "deltavdash",
        "mcolon",
        "arightarrow",
        "b",
        "quadthetavdash",
        "ncolon",
        "delta",
        "thetavdash",
        "mncolon",
        "b",
        "expression",
        "form",
        "mcolon",
        "a",
        "called",
        "type",
        "assignment",
        "characteristic",
        "feature",
        "typeassignment",
        "system",
        "mcolon",
        "a",
        "provable",
        "a",
        "considered",
        "one",
        "type",
        "assigned",
        "m",
        "however",
        "provable",
        "assignment",
        "preclude",
        "type",
        "becoming",
        "associated",
        "term",
        "m",
        "type",
        "assignment",
        "fix",
        "type",
        "term",
        "rigidly",
        "delta",
        "theta",
        "lefthand",
        "side",
        "vdash",
        "set",
        "type",
        "assignment",
        "variable",
        "assumed",
        "consistentmeaning",
        "variable",
        "may",
        "assigned",
        "two",
        "type",
        "type",
        "assignment",
        "system",
        "often",
        "called",
        "currystyle",
        "typing",
        "system",
        "another",
        "way",
        "type",
        "term",
        "fixing",
        "type",
        "term",
        "case",
        "term",
        "exactly",
        "one",
        "type",
        "calculus",
        "called",
        "churchstyle",
        "typing",
        "system",
        "example",
        "identity",
        "combinator",
        "textsf",
        "type",
        "arightarrow",
        "arightarrow",
        "rightarrow",
        "arightarrow",
        "arightarrow",
        "identity",
        "combinator",
        "textsf",
        "type",
        "b",
        "rightarrow",
        "b",
        "rightarrow",
        "b",
        "rightarrow",
        "brightarrow",
        "b",
        "rightarrow",
        "b",
        "two",
        "style",
        "typing",
        "quite",
        "lot",
        "common",
        "certain",
        "difference",
        "particular",
        "selfapplication",
        "typable",
        "churchstyle",
        "typing",
        "system",
        "whereas",
        "term",
        "assigned",
        "type",
        "currystyle",
        "typing",
        "system",
        "currystyle",
        "typing",
        "system",
        "proved",
        "useful",
        "establishing",
        "various",
        "property",
        "cl",
        "lambda",
        "calculi",
        "churchstyle",
        "typing",
        "hand",
        "emulates",
        "closely",
        "typing",
        "certain",
        "functional",
        "programming",
        "language",
        "without",
        "object",
        "oneone",
        "correspondence",
        "type",
        "combinators",
        "either",
        "style",
        "typing",
        "combinators",
        "assigned",
        "type",
        "implicational",
        "formula",
        "assigned",
        "combinatory",
        "term",
        "combinator",
        "assigned",
        "type",
        "said",
        "typable",
        "type",
        "assigned",
        "combinator",
        "said",
        "inhabited",
        "instance",
        "textsf",
        "simple",
        "type",
        "implicational",
        "formula",
        "never",
        "identical",
        "antecedent",
        "hand",
        "peirce",
        "law",
        "arightarrow",
        "b",
        "rightarrow",
        "rightarrow",
        "a",
        "type",
        "combinator",
        "type",
        "assignment",
        "system",
        "ta",
        "_textrm",
        "cl",
        "despite",
        "indeed",
        "due",
        "discrepancy",
        "implicational",
        "formula",
        "combinatory",
        "term",
        "class",
        "implicational",
        "formula",
        "assigned",
        "certain",
        "set",
        "combinatory",
        "term",
        "coincide",
        "set",
        "theorem",
        "important",
        "logic",
        "theorem",
        "arightarrow",
        "b",
        "theorem",
        "intuitionistic",
        "implicational",
        "logic",
        "denoted",
        "ipc_rightarrow",
        "j_rightarrow",
        "iff",
        "m",
        "mcolon",
        "arightarrow",
        "b",
        "provable",
        "type",
        "assignment",
        "ta",
        "_textrm",
        "cl",
        "term",
        "m",
        "built",
        "textsf",
        "textsf",
        "k",
        "m",
        "combinator",
        "base",
        "textsf",
        "textsf",
        "k",
        "combinator",
        "inhabits",
        "implicational",
        "theorem",
        "encodes",
        "proof",
        "theorem",
        "deduction",
        "system",
        "ta",
        "_textrm",
        "cl",
        "algorithm",
        "recover",
        "formula",
        "constitute",
        "proof",
        "type",
        "combinator",
        "moreover",
        "algorithm",
        "produce",
        "proof",
        "minimal",
        "wellstructured",
        "correspondence",
        "implicational",
        "theorem",
        "intuitionistic",
        "logic",
        "proof",
        "typable",
        "closed",
        "lambda",
        "terms",
        "combinators",
        "called",
        "curryhoward",
        "isomorphism",
        "usual",
        "notion",
        "proof",
        "hilbertstyle",
        "axiomatic",
        "system",
        "quite",
        "lax",
        "tidied",
        "obtain",
        "notion",
        "traversing",
        "proof",
        "traversing",
        "proof",
        "oneone",
        "correspondence",
        "subterms",
        "combinator",
        "formula",
        "traversing",
        "proof",
        "well",
        "application",
        "detachment",
        "therein",
        "cf",
        "bimb\u00f3",
        "correspondence",
        "modified",
        "implicational",
        "logic",
        "combinatory",
        "base",
        "next",
        "theorem",
        "list",
        "correspondence",
        "obtain",
        "implicational",
        "fragment",
        "relevance",
        "logic",
        "r",
        "t",
        "combinatory",
        "base",
        "interest",
        "theorem",
        "arightarrow",
        "b",
        "theorem",
        "r_",
        "rightarrow",
        "t_",
        "rightarrow",
        "iff",
        "m",
        "mcolon",
        "arightarrow",
        "b",
        "provable",
        "type",
        "assignment",
        "m",
        "combinator",
        "textsf",
        "b",
        "textsf",
        "textsf",
        "w",
        "textsf",
        "c",
        "textsf",
        "b",
        "textsf",
        "b",
        "prime",
        "textsf",
        "textsf",
        "textsf",
        "prime",
        "calculus",
        "textrm",
        "ta",
        "_textrm",
        "cl",
        "may",
        "amended",
        "adding",
        "axiom",
        "schema",
        "combinators",
        "two",
        "base",
        "axiom",
        "schema",
        "combinators",
        "base",
        "may",
        "omitted",
        "calculus",
        "simply",
        "may",
        "neglected",
        "proof",
        "new",
        "axiom",
        "follows",
        "begin",
        "align",
        "textsf",
        "b",
        "colon",
        "arightarrow",
        "b",
        "rightarrow",
        "crightarrow",
        "rightarrow",
        "crightarrow",
        "b",
        "textsf",
        "b",
        "prime",
        "colon",
        "arightarrow",
        "b",
        "rightarrow",
        "brightarrow",
        "c",
        "rightarrow",
        "arightarrow",
        "c",
        "textsf",
        "c",
        "colon",
        "arightarrow",
        "brightarrow",
        "c",
        "rightarrow",
        "brightarrow",
        "arightarrow",
        "c",
        "textsf",
        "w",
        "colon",
        "arightarrow",
        "arightarrow",
        "b",
        "rightarrow",
        "arightarrow",
        "b",
        "textsf",
        "prime",
        "colon",
        "arightarrow",
        "b",
        "rightarrow",
        "arightarrow",
        "brightarrow",
        "c",
        "rightarrow",
        "arightarrow",
        "c",
        "textsf",
        "colon",
        "arightarrow",
        "end",
        "align",
        "combinatory",
        "base",
        "textsf",
        "b",
        "textsf",
        "c",
        "textsf",
        "w",
        "textsf",
        "especially",
        "interesting",
        "combinators",
        "suffice",
        "definition",
        "bracket",
        "abstraction",
        "equivalent",
        "lambda",
        "abstraction",
        "lambdatextsf",
        "calculus",
        "put",
        "differently",
        "function",
        "depend",
        "argument",
        "defined",
        "base",
        "base",
        "allows",
        "definition",
        "function",
        "described",
        "term",
        "class",
        "socalled",
        "hereditary",
        "right",
        "maximal",
        "term",
        "cf",
        "bimb\u00f3",
        "informally",
        "idea",
        "behind",
        "term",
        "function",
        "enumerated",
        "successive",
        "application",
        "form",
        "sequence",
        "index",
        "globally",
        "increasing",
        "type",
        "assignment",
        "two",
        "part",
        "term",
        "formula",
        "question",
        "whether",
        "term",
        "assigned",
        "type",
        "whether",
        "type",
        "assigned",
        "term",
        "problem",
        "typability",
        "inhabitation",
        "respectively",
        "although",
        "question",
        "may",
        "posed",
        "one",
        "set",
        "type",
        "assignment",
        "computational",
        "property",
        "problem",
        "may",
        "differ",
        "widely",
        "theorem",
        "decidable",
        "term",
        "m",
        "assigned",
        "type",
        "m",
        "typable",
        "theorem",
        "stated",
        "rather",
        "general",
        "way",
        "without",
        "specifying",
        "exactly",
        "combinatory",
        "base",
        "modification",
        "ta",
        "_textrm",
        "cl",
        "assumed",
        "theorem",
        "hold",
        "combinatory",
        "base",
        "indeed",
        "algorithm",
        "given",
        "combinator",
        "decides",
        "combinator",
        "typable",
        "typable",
        "combinator",
        "produce",
        "type",
        "course",
        "combinatorially",
        "complete",
        "base",
        "textsf",
        "textsf",
        "k",
        "combinators",
        "expressible",
        "term",
        "consisting",
        "two",
        "combinators",
        "however",
        "assumption",
        "needed",
        "solution",
        "typability",
        "though",
        "might",
        "provide",
        "explanation",
        "existence",
        "general",
        "algorithm",
        "problem",
        "inhabitation",
        "similar",
        "general",
        "solution",
        "problem",
        "equality",
        "combinatory",
        "term",
        "undecidable",
        "given",
        "set",
        "axiom",
        "schema",
        "type",
        "combinators",
        "detachment",
        "rule",
        "inference",
        "problem",
        "decidability",
        "logic",
        "viewed",
        "problem",
        "inhabitation",
        "indeed",
        "a",
        "implicational",
        "formula",
        "decide",
        "whether",
        "a",
        "theorem",
        "amount",
        "determining",
        "term",
        "base",
        "corresponds",
        "axiom",
        "schema",
        "assigned",
        "a",
        "type",
        "course",
        "sophisticated",
        "algorithm",
        "may",
        "actually",
        "produce",
        "term",
        "case",
        "easy",
        "verify",
        "correctness",
        "claim",
        "reconstructing",
        "proof",
        "theorem",
        "see",
        "complication",
        "emerge",
        "case",
        "decidability",
        "compare",
        "rule",
        "formation",
        "term",
        "rule",
        "detachment",
        "given",
        "combinatory",
        "base",
        "denumerable",
        "set",
        "variable",
        "decidable",
        "inspection",
        "whether",
        "term",
        "set",
        "generated",
        "term",
        "input",
        "rule",
        "retained",
        "output",
        "subterms",
        "resulting",
        "term",
        "contrast",
        "application",
        "detachment",
        "result",
        "formula",
        "proper",
        "subformula",
        "major",
        "premise",
        "exceptional",
        "case",
        "major",
        "premise",
        "instance",
        "selfidentity",
        "identical",
        "minor",
        "premise",
        "lack",
        "retention",
        "subformulas",
        "premise",
        "application",
        "modus",
        "ponens",
        "culprit",
        "behind",
        "difficulty",
        "decision",
        "problem",
        "implicational",
        "logic",
        "somewhat",
        "unsurprising",
        "many",
        "decidable",
        "logic",
        "decision",
        "procedure",
        "utilizing",
        "sequent",
        "calculus",
        "cut",
        "theorem",
        "subformula",
        "property",
        "hold",
        "solution",
        "problem",
        "inhabitation",
        "may",
        "run",
        "difficulty",
        "similar",
        "arise",
        "decidability",
        "problem",
        "general",
        "example",
        "combinator",
        "textsf",
        "k",
        "assigned",
        "following",
        "type",
        "prightarrow",
        "qrightarrow",
        "qrightarrow",
        "qrightarrow",
        "q",
        "rightarrow",
        "q",
        "rightarrow",
        "q",
        "rightarrow",
        "qrightarrow",
        "q",
        "rightarrow",
        "p",
        "textsf",
        "skk",
        "assigned",
        "type",
        "prightarrow",
        "p",
        "proof",
        "ta",
        "_textrm",
        "cl",
        "ending",
        "textsf",
        "skk",
        "colon",
        "prightarrow",
        "p",
        "contain",
        "long",
        "formula",
        "however",
        "proof",
        "textsf",
        "skk",
        "colon",
        "prightarrow",
        "p",
        "contains",
        "formula",
        "second",
        "antecedent",
        "subformula",
        "prightarrow",
        "p",
        "indeed",
        "set",
        "subformulas",
        "two",
        "formula",
        "disjoint",
        "picked",
        "two",
        "different",
        "propositional",
        "variable",
        "p",
        "q",
        "emphasize",
        "point",
        "important",
        "case",
        "problem",
        "inhabitation",
        "however",
        "decidable",
        "theorem",
        "decidable",
        "type",
        "inhabitant",
        "base",
        "textsf",
        "textsf",
        "k",
        "theorem",
        "amount",
        "typed",
        "version",
        "decidability",
        "implicational",
        "fragment",
        "intuitionistic",
        "logic",
        "part",
        "gentzen",
        "decidability",
        "result",
        "dating",
        "theorem",
        "decidable",
        "type",
        "inhabitant",
        "base",
        "textsf",
        "textsf",
        "c",
        "textsf",
        "b",
        "prime",
        "textsf",
        "w",
        "theorem",
        "typed",
        "equivalent",
        "decidability",
        "implicational",
        "fragment",
        "logic",
        "relevant",
        "implication",
        "decidability",
        "r_",
        "rightarrow",
        "proved",
        "saul",
        "a",
        "kripke",
        "together",
        "decidability",
        "closely",
        "related",
        "e_",
        "rightarrow",
        "implicational",
        "fragment",
        "logic",
        "entailment",
        "theorem",
        "decidable",
        "type",
        "inhabitant",
        "base",
        "textsf",
        "b",
        "textsf",
        "b",
        "prime",
        "textsf",
        "textsf",
        "w",
        "theorem",
        "typed",
        "version",
        "decidability",
        "implicational",
        "fragment",
        "logic",
        "ticket",
        "entailment",
        "t_rightarrow",
        "provedtogether",
        "decidability",
        "r_rightarrow",
        "r_rightarrow",
        "truth",
        "constant",
        "t",
        "t_rightarrowtextbf",
        "t_rightarrow",
        "truth",
        "constant",
        "t",
        "in",
        "bimb\u00f3",
        "dunn",
        "bimb\u00f3",
        "dunn",
        "independent",
        "result",
        "t_rightarrow",
        "padovani",
        "extends",
        "broda",
        "et",
        "al",
        "decision",
        "procedure",
        "t_rightarrowtextbf",
        "r_rightarrowtextbf",
        "use",
        "textrm",
        "ta",
        "_textrm",
        "cl",
        "axiomatic",
        "calculus",
        "instead",
        "build",
        "upon",
        "consecution",
        "calculus",
        "ie",
        "sequent",
        "calculus",
        "structural",
        "connective",
        "assumed",
        "associative",
        "idea",
        "affinity",
        "structural",
        "rule",
        "combinators",
        "go",
        "back",
        "least",
        "curry",
        "tighten",
        "connection",
        "dunn",
        "meyer",
        "introduced",
        "structurally",
        "free",
        "logic",
        "introduction",
        "rule",
        "combinators",
        "replace",
        "structural",
        "ruleshence",
        "label",
        "logic",
        "bimb\u00f3",
        "dunn",
        "introduced",
        "technique",
        "generate",
        "combinatory",
        "inhabitant",
        "theorem",
        "t_rightarrow",
        "standard",
        "proof",
        "sequent",
        "calculus",
        "used",
        "decision",
        "procedure",
        "t_rightarrowtextbf",
        "sequent",
        "calculus",
        "provide",
        "better",
        "control",
        "proof",
        "natural",
        "deduction",
        "axiomatic",
        "system",
        "combinatory",
        "extraction",
        "procedure",
        "bimb\u00f3",
        "dunn",
        "yield",
        "effective",
        "link",
        "combinators",
        "type",
        "grounded",
        "sequent",
        "calculus",
        "proof",
        "obviates",
        "apparent",
        "advantage",
        "textrm",
        "ta",
        "_textrm",
        "cl",
        "axiomatic",
        "system",
        "rule",
        "substitution",
        "builtin",
        "formulation",
        "textrm",
        "ta",
        "_textrm",
        "cl",
        "via",
        "rule",
        "schema",
        "called",
        "detachment",
        "axiom",
        "schema",
        "basic",
        "combinators",
        "obvious",
        "formula",
        "least",
        "complexity",
        "type",
        "textsf",
        "textsf",
        "k",
        "type",
        "textsf",
        "textsf",
        "k",
        "substitution",
        "instance",
        "formula",
        "property",
        "called",
        "principal",
        "type",
        "combinator",
        "obviously",
        "combinator",
        "principal",
        "type",
        "denumerably",
        "many",
        "principal",
        "type",
        "substitution",
        "instance",
        "hence",
        "justified",
        "talk",
        "principal",
        "type",
        "schema",
        "combinator",
        "existence",
        "principal",
        "type",
        "complex",
        "combinators",
        "obvious",
        "nevertheless",
        "obtains",
        "theorem",
        "term",
        "m",
        "typable",
        "m",
        "principal",
        "type",
        "principal",
        "type",
        "schema",
        "principal",
        "type",
        "principal",
        "type",
        "schema",
        "may",
        "seem",
        "interchangeable",
        "everywhere",
        "thus",
        "could",
        "take",
        "slightly",
        "different",
        "approach",
        "define",
        "textrm",
        "ta",
        "_textrm",
        "cl",
        "include",
        "axiom",
        "rule",
        "schema",
        "detachment",
        "together",
        "rule",
        "substitution",
        "version",
        "textrm",
        "ta",
        "_textrm",
        "cl",
        "would",
        "assume",
        "following",
        "form",
        "deltavdashtextsf",
        "colon",
        "p",
        "rightarrow",
        "qrightarrow",
        "rightarrow",
        "prightarrow",
        "q",
        "rightarrow",
        "prightarrow",
        "deltavdashtextsf",
        "k",
        "colon",
        "qrightarrow",
        "srightarrow",
        "q",
        "frac",
        "deltavdash",
        "mcolon",
        "arightarrow",
        "bqquad",
        "thetavdash",
        "ncolon",
        "delta",
        "thetavdash",
        "mncolon",
        "b",
        "frac",
        "deltavdash",
        "mcolon",
        "delta",
        "pb",
        "vdash",
        "mcolon",
        "pb",
        "p",
        "range",
        "propositional",
        "variable",
        "substitution",
        "notation",
        "extendedin",
        "obvious",
        "wayto",
        "set",
        "type",
        "assignment",
        "clearly",
        "two",
        "deduction",
        "system",
        "equivalent",
        "substitution",
        "dropped",
        "altogether",
        "applicability",
        "detachment",
        "would",
        "become",
        "extremely",
        "limited",
        "instance",
        "textsf",
        "sk",
        "longer",
        "would",
        "typable",
        "compromise",
        "substitution",
        "everywhere",
        "substitution",
        "modify",
        "detachment",
        "rule",
        "includes",
        "much",
        "substitution",
        "necessary",
        "ensure",
        "applicability",
        "detachment",
        "rule",
        "rule",
        "without",
        "combinatory",
        "term",
        "type",
        "assignment",
        "invented",
        "s",
        "carew",
        "a",
        "meredith",
        "usually",
        "called",
        "condensed",
        "detachment",
        "key",
        "applicability",
        "detachment",
        "find",
        "common",
        "substitution",
        "instance",
        "minor",
        "premise",
        "antecedent",
        "major",
        "premise",
        "step",
        "called",
        "unification",
        "bit",
        "formally",
        "let",
        "denote",
        "application",
        "substitution",
        "s",
        "a",
        "result",
        "condensed",
        "detachment",
        "a",
        "brightarrow",
        "c",
        "c",
        "s",
        "b",
        "s_",
        "property",
        "s_",
        "s_",
        "composition",
        "s",
        "s_",
        "notice",
        "always",
        "possible",
        "choose",
        "substitution",
        "instance",
        "pair",
        "formula",
        "set",
        "propositional",
        "variable",
        "disjoint",
        "formula",
        "finite",
        "object",
        "general",
        "common",
        "instance",
        "two",
        "formula",
        "a",
        "b",
        "share",
        "propositional",
        "variable",
        "c",
        "c",
        "substitution",
        "instance",
        "a",
        "b",
        "propositional",
        "variable",
        "identified",
        "substitution",
        "identification",
        "necessary",
        "obtain",
        "formula",
        "substitution",
        "instance",
        "a",
        "b",
        "unification",
        "theorem",
        "specialized",
        "simple",
        "type",
        "implies",
        "two",
        "formula",
        "a",
        "b",
        "common",
        "instance",
        "formula",
        "c",
        "common",
        "instance",
        "a",
        "b",
        "substitution",
        "instance",
        "c",
        "obviously",
        "pair",
        "formula",
        "either",
        "common",
        "instance",
        "aleph_",
        "many",
        "general",
        "common",
        "instance",
        "famous",
        "example",
        "pair",
        "formula",
        "common",
        "instance",
        "arightarrow",
        "a",
        "arightarrow",
        "arightarrow",
        "b",
        "instance",
        "p",
        "rightarrow",
        "p",
        "qrightarrow",
        "qrightarrow",
        "r",
        "share",
        "propositional",
        "variable",
        "however",
        "neither",
        "qrightarrow",
        "q",
        "qrightarrow",
        "r",
        "rightarrow",
        "qrightarrow",
        "r",
        "match",
        "shape",
        "second",
        "formula",
        "put",
        "problem",
        "differently",
        "q",
        "qrightarrow",
        "r",
        "would",
        "unified",
        "unified",
        "matter",
        "formula",
        "substituted",
        "q",
        "immediate",
        "consequence",
        "textsf",
        "wi",
        "typable",
        "hand",
        "rrightarrow",
        "r",
        "rightarrow",
        "rrightarrow",
        "r",
        "srightarrow",
        "rightarrow",
        "srightarrow",
        "rightarrow",
        "rightarrow",
        "rightarrow",
        "srightarrow",
        "substitution",
        "instance",
        "prightarrow",
        "p",
        "qrightarrow",
        "q",
        "furthermore",
        "simple",
        "type",
        "substitution",
        "instance",
        "propositional",
        "variable",
        "hence",
        "textsf",
        "ii",
        "assigned",
        "type",
        "rrightarrow",
        "r",
        "type",
        "srightarrow",
        "rightarrow",
        "srightarrow",
        "s",
        "and",
        "course",
        "latter",
        "happens",
        "instance",
        "former",
        "arightarrow",
        "a",
        "principal",
        "type",
        "schema",
        "textsf",
        "ii",
        "apply",
        "condensed",
        "detachment",
        "prightarrow",
        "p",
        "qrightarrow",
        "q",
        "get",
        "qrightarrow",
        "q",
        "via",
        "substitution",
        "pqrightarrow",
        "q",
        "qq",
        "condensed",
        "detachment",
        "yield",
        "principal",
        "type",
        "textsf",
        "ii",
        "incidentally",
        "textsf",
        "ii",
        "textsf",
        "provide",
        "excellent",
        "example",
        "illustrate",
        "distinct",
        "term",
        "may",
        "principal",
        "type",
        "schema",
        "condensed",
        "detachment",
        "used",
        "extensively",
        "refine",
        "axiomatizations",
        "various",
        "implicational",
        "logic",
        "especially",
        "search",
        "shorter",
        "fewer",
        "axiom",
        "logic",
        "may",
        "formulated",
        "using",
        "axiom",
        "rather",
        "axiom",
        "schema",
        "together",
        "rule",
        "condensed",
        "detachmentwithout",
        "loss",
        "theorem",
        "logic",
        "mentioned",
        "far",
        "j_",
        "rightarrow",
        "r_",
        "rightarrow",
        "t_",
        "rightarrow",
        "e_",
        "rightarrow",
        "mathbf",
        "complete",
        "may",
        "axiomatized",
        "axiom",
        "rule",
        "condensed",
        "detachment",
        "implicational",
        "fragment",
        "classical",
        "intuitionistic",
        "logic",
        "implicational",
        "fragment",
        "relevance",
        "logic",
        "r",
        "e",
        "t",
        "mathbf",
        "complete",
        "see",
        "bimb\u00f3",
        "technical",
        "detail",
        "simply",
        "typed",
        "system",
        "extended",
        "various",
        "direction",
        "logic",
        "often",
        "contain",
        "connective",
        "beyond",
        "implication",
        "natural",
        "modification",
        "type",
        "assignment",
        "system",
        "expand",
        "set",
        "type",
        "via",
        "including",
        "type",
        "constructor",
        "conjunction",
        "fusion",
        "easiest",
        "explain",
        "motivate",
        "type",
        "constructor",
        "however",
        "disjunction",
        "backward",
        "implication",
        "introduced",
        "type",
        "type",
        "useful",
        "allow",
        "u",
        "get",
        "grip",
        "class",
        "term",
        "point",
        "view",
        "behavior",
        "respect",
        "reduction",
        "tait",
        "theorem",
        "combinatory",
        "term",
        "m",
        "typable",
        "simple",
        "type",
        "m",
        "strongly",
        "normalizes",
        "reduction",
        "sequence",
        "m",
        "finite",
        "ie",
        "terminate",
        "converse",
        "claim",
        "obviously",
        "true",
        "example",
        "textsf",
        "wi",
        "strongly",
        "normalizes",
        "untypable",
        "antecedent",
        "contraction",
        "unified",
        "instance",
        "selfimplication",
        "aim",
        "extend",
        "set",
        "typable",
        "term",
        "led",
        "introduction",
        "land",
        "type",
        "intersection",
        "type",
        "different",
        "way",
        "look",
        "problem",
        "typing",
        "textsf",
        "wi",
        "say",
        "textsf",
        "w",
        "type",
        "similar",
        "formula",
        "arightarrow",
        "arightarrow",
        "b",
        "rightarrow",
        "arightarrow",
        "b",
        "formula",
        "place",
        "two",
        "formula",
        "a",
        "arightarrow",
        "b",
        "antecedent",
        "unified",
        "motivation",
        "inclusion",
        "conjunction",
        "land",
        "top",
        "top",
        "new",
        "type",
        "constructor",
        "extended",
        "type",
        "system",
        "often",
        "called",
        "intersection",
        "type",
        "discipline",
        "due",
        "mario",
        "coppo",
        "mariangiola",
        "dezaniciancaglini",
        "set",
        "intersection",
        "type",
        "denoted",
        "wff",
        "defined",
        "follows",
        "pintextrm",
        "wff",
        "p",
        "propositional",
        "variable",
        "topintextrm",
        "wff",
        "top",
        "constant",
        "proposition",
        "bintextrm",
        "wff",
        "implies",
        "arightarrow",
        "b",
        "aland",
        "b",
        "in",
        "textrm",
        "wff",
        "course",
        "ta",
        "_textrm",
        "cl",
        "augmented",
        "expanded",
        "set",
        "type",
        "new",
        "instance",
        "previously",
        "assigned",
        "type",
        "become",
        "available",
        "however",
        "gist",
        "type",
        "new",
        "type",
        "constructor",
        "land",
        "top",
        "set",
        "type",
        "richer",
        "structure",
        "relationship",
        "type",
        "determined",
        "rule",
        "substitution",
        "modus",
        "ponens",
        "structure",
        "intersection",
        "type",
        "described",
        "conjunctionimplication",
        "fragment",
        "b",
        "basic",
        "relevance",
        "logic",
        "following",
        "presentation",
        "logic",
        "le",
        "main",
        "connective",
        "implication",
        "formula",
        "rightarrow",
        "separate",
        "premise",
        "conclusion",
        "inference",
        "rule",
        "begin",
        "align",
        "ale",
        "aqquad",
        "ale",
        "topqquadtopletoptotop",
        "ale",
        "aland",
        "aqquad",
        "aland",
        "b",
        "le",
        "aqquad",
        "aland",
        "ble",
        "b",
        "ale",
        "b",
        "ble",
        "c",
        "rightarrow",
        "ale",
        "c",
        "ale",
        "b",
        "cle",
        "drightarrow",
        "aland",
        "cle",
        "bland",
        "arightarrow",
        "b",
        "land",
        "arightarrow",
        "c",
        "le",
        "arightarrow",
        "bland",
        "c",
        "ale",
        "b",
        "cle",
        "drightarrow",
        "brightarrow",
        "cle",
        "rightarrow",
        "end",
        "align",
        "axiom",
        "schema",
        "combinators",
        "textsf",
        "textsf",
        "k",
        "textsf",
        "follows",
        "note",
        "axiom",
        "textsf",
        "simply",
        "substitution",
        "instance",
        "new",
        "connective",
        "included",
        "previous",
        "axiom",
        "textsf",
        "deltavdashtextsf",
        "colon",
        "arightarrow",
        "brightarrow",
        "c",
        "rightarrow",
        "drightarrow",
        "b",
        "rightarrow",
        "aland",
        "rightarrow",
        "c",
        "deltavdash",
        "textsf",
        "k",
        "colon",
        "arightarrow",
        "brightarrow",
        "qquad",
        "deltavdash",
        "textsf",
        "colon",
        "arightarrow",
        "four",
        "new",
        "rule",
        "added",
        "axiom",
        "top",
        "frac",
        "deltavdash",
        "mcolon",
        "aquaddeltavdash",
        "mcolon",
        "b",
        "deltavdash",
        "mcolon",
        "aland",
        "b",
        "quad",
        "frac",
        "deltavdash",
        "mcolon",
        "aland",
        "b",
        "deltavdash",
        "mcolon",
        "quad",
        "frac",
        "deltavdash",
        "mcolon",
        "aland",
        "b",
        "deltavdash",
        "mcolon",
        "b",
        "frac",
        "deltavdash",
        "mcolon",
        "aqquad",
        "ale",
        "b",
        "b",
        "deltavdash",
        "mcolon",
        "b",
        "quad",
        "deltavdash",
        "mcolontop",
        "type",
        "assignment",
        "system",
        "equivalent",
        "intersection",
        "type",
        "assignment",
        "system",
        "lambda",
        "calculus",
        "allows",
        "precise",
        "characterization",
        "class",
        "term",
        "respect",
        "termination",
        "reduction",
        "sequence",
        "theorem",
        "term",
        "m",
        "normalizes",
        "whenever",
        "m",
        "typable",
        "term",
        "m",
        "strongly",
        "normalizes",
        "whenever",
        "m",
        "typable",
        "proof",
        "contain",
        "top",
        "model",
        "cl",
        "various",
        "kind",
        "model",
        "three",
        "exemplified",
        "detail",
        "section",
        "algebraic",
        "model",
        "often",
        "called",
        "term",
        "model",
        "may",
        "constructed",
        "without",
        "difficulty",
        "inequational",
        "equational",
        "system",
        "cl",
        "introduced",
        "section",
        "set",
        "term",
        "form",
        "algebra",
        "given",
        "suitable",
        "equivalence",
        "relation",
        "also",
        "congruence",
        "application",
        "operation",
        "lifted",
        "equivalence",
        "class",
        "term",
        "standard",
        "way",
        "quasiinequational",
        "characterization",
        "obtained",
        "algebra",
        "provides",
        "basis",
        "algebraic",
        "semantics",
        "logic",
        "isolating",
        "lindenbaum",
        "algebra",
        "verifying",
        "trivial",
        "algebra",
        "constitutes",
        "consistency",
        "proof",
        "text",
        "cl",
        "_triangleright",
        "text",
        "cl",
        "_",
        "scott",
        "model",
        "dana",
        "scott",
        "defined",
        "pomega",
        "d_infty",
        "lambda",
        "calculus",
        "first",
        "outline",
        "pomega",
        "the",
        "socalled",
        "graph",
        "model",
        "easier",
        "understand",
        "natural",
        "number",
        "rich",
        "structure",
        "pomega",
        "power",
        "set",
        "set",
        "natural",
        "number",
        "core",
        "model",
        "bearing",
        "label",
        "every",
        "natural",
        "number",
        "unique",
        "representation",
        "base",
        "eg",
        "_",
        "cdotcdotcdot",
        "binary",
        "representation",
        "form",
        "b_mcdotmb_",
        "m",
        "cdot",
        "m",
        "cdotsb_cdot",
        "b_cdot",
        "b",
        "binary",
        "number",
        "may",
        "viewed",
        "characteristic",
        "function",
        "finite",
        "subset",
        "natural",
        "number",
        "left",
        "infinitely",
        "many",
        "zero",
        "ldots",
        "omitted",
        "natural",
        "number",
        "n",
        "e_n",
        "denotes",
        "corresponding",
        "finite",
        "set",
        "natural",
        "number",
        "eg",
        "e_",
        "positive",
        "topology",
        "pomega",
        "comprises",
        "finitely",
        "generated",
        "open",
        "set",
        "let",
        "e",
        "denote",
        "finite",
        "subset",
        "omega",
        "xsubseteq",
        "pomega",
        "open",
        "iff",
        "x",
        "cone",
        "respect",
        "subseteq",
        "generated",
        "subset",
        "e",
        "given",
        "positive",
        "topology",
        "function",
        "fcolon",
        "pomegarightarrow",
        "pomega",
        "turn",
        "continuous",
        "usual",
        "topological",
        "sense",
        "iff",
        "f",
        "x",
        "cup",
        "f",
        "e_n",
        "colon",
        "e_nsubseteq",
        "x",
        "e_nin",
        "e",
        "mean",
        "min",
        "f",
        "x",
        "iff",
        "exists",
        "e_nsubseteq",
        "x",
        "min",
        "f",
        "e_n",
        "lead",
        "characterization",
        "continuous",
        "function",
        "f",
        "pair",
        "natural",
        "number",
        "n",
        "oneone",
        "correspondence",
        "ordered",
        "pair",
        "natural",
        "number",
        "natural",
        "number",
        "defined",
        "n",
        "frac",
        "nm",
        "cdot",
        "nm",
        "cdot",
        "set",
        "pair",
        "constitute",
        "unary",
        "function",
        "sometimes",
        "called",
        "graph",
        "function",
        "graph",
        "continuous",
        "function",
        "fcolon",
        "pomegarightarrow",
        "pomega",
        "defined",
        "textrm",
        "graph",
        "f",
        "n",
        "colon",
        "min",
        "f",
        "e_n",
        "order",
        "able",
        "model",
        "typefree",
        "applicationincluding",
        "selfapplicationsubsets",
        "omega",
        "viewed",
        "function",
        "x",
        "ysubseteqomega",
        "function",
        "determined",
        "y",
        "defined",
        "textrm",
        "fun",
        "x",
        "mcolon",
        "exists",
        "e_nsubseteq",
        "x",
        "n",
        "in",
        "y",
        "continuous",
        "function",
        "f",
        "textrm",
        "fun",
        "textrm",
        "graph",
        "f",
        "f",
        "hold",
        "graph",
        "model",
        "cl",
        "map",
        "term",
        "subset",
        "omega",
        "start",
        "combinators",
        "concrete",
        "set",
        "interpretation",
        "simple",
        "example",
        "textsf",
        "n",
        "colon",
        "min",
        "e_n",
        "course",
        "pair",
        "corresponds",
        "element",
        "omega",
        "hence",
        "get",
        "set",
        "natural",
        "number",
        "particular",
        "element",
        "ldots",
        "combinators",
        "well",
        "variable",
        "interpreted",
        "subset",
        "omega",
        "function",
        "application",
        "take",
        "first",
        "set",
        "viewed",
        "function",
        "type",
        "pomegarightarrow",
        "pomega",
        "apply",
        "second",
        "set",
        "textrm",
        "fun",
        "suitable",
        "function",
        "determined",
        "subseteqomega",
        "general",
        "m",
        "n",
        "clterms",
        "i",
        "interpretation",
        "atomic",
        "term",
        "pomega",
        "i",
        "extended",
        "compound",
        "term",
        "mn",
        "textrm",
        "fun",
        "n",
        "eg",
        "let",
        "x",
        "e_",
        "textsf",
        "x",
        "textrm",
        "fun",
        "textsf",
        "x",
        "mcolon",
        "exists",
        "e_nsubseteq",
        "x",
        "n",
        "in",
        "textsf",
        "know",
        "textsf",
        "x",
        "hence",
        "get",
        "textsf",
        "x",
        "mcolonexists",
        "e_nsubseteq",
        "e_",
        "min",
        "e_n",
        "course",
        "subseteq",
        "textsf",
        "x",
        "model",
        "support",
        "intensional",
        "notion",
        "function",
        "earliest",
        "model",
        "typefree",
        "applicative",
        "system",
        "function",
        "space",
        "also",
        "given",
        "scott",
        "couple",
        "year",
        "graph",
        "model",
        "late",
        "following",
        "outline",
        "key",
        "element",
        "construction",
        "pure",
        "typefree",
        "cl",
        "expression",
        "form",
        "mm",
        "wellformed",
        "term",
        "moreover",
        "term",
        "form",
        "enter",
        "provable",
        "equation",
        "inequations",
        "multiple",
        "way",
        "example",
        "xxxx",
        "axiom",
        "one",
        "rule",
        "xx",
        "y",
        "xx",
        "provable",
        "interesting",
        "occurrence",
        "term",
        "form",
        "mm",
        "seen",
        "provable",
        "inequation",
        "textsf",
        "textsf",
        "skk",
        "textsf",
        "skk",
        "xtriangleright",
        "xx",
        "settheoretic",
        "reduction",
        "function",
        "yield",
        "set",
        "pair",
        "general",
        "set",
        "tuples",
        "set",
        "theory",
        "assuming",
        "wellfoundedness",
        "course",
        "pair",
        "eg",
        "a",
        "b",
        "never",
        "identical",
        "either",
        "two",
        "element",
        "therefore",
        "main",
        "question",
        "concerning",
        "mathematical",
        "model",
        "cl",
        "deal",
        "selfapplication",
        "scott",
        "original",
        "model",
        "built",
        "starting",
        "complete",
        "lattice",
        "le",
        "le",
        "partially",
        "ordered",
        "set",
        "greatest",
        "lower",
        "bound",
        "infima",
        "least",
        "upper",
        "bound",
        "suprema",
        "exist",
        "arbitrary",
        "set",
        "element",
        "function",
        "f",
        "le",
        "complete",
        "lattice",
        "e",
        "le",
        "said",
        "continuous",
        "preserve",
        "supremum",
        "ideal",
        "d",
        "ideal",
        "upward",
        "directed",
        "downward",
        "closed",
        "subset",
        "topology",
        "may",
        "defined",
        "d",
        "selecting",
        "certain",
        "increasing",
        "set",
        "open",
        "precisely",
        "i",
        "ideal",
        "c",
        "cone",
        "c",
        "open",
        "iff",
        "ccap",
        "neemptyset",
        "provided",
        "bigvee",
        "iin",
        "c",
        "provided",
        "supremum",
        "i",
        "element",
        "c",
        "example",
        "complement",
        "principal",
        "ideal",
        "open",
        "f",
        "turn",
        "continuous",
        "usual",
        "topological",
        "sense",
        "inverse",
        "image",
        "open",
        "set",
        "open",
        "d",
        "e",
        "taken",
        "together",
        "topology",
        "motivates",
        "earlier",
        "labeling",
        "function",
        "continuous",
        "notably",
        "continuous",
        "function",
        "monotone",
        "purpose",
        "modeling",
        "function",
        "cl",
        "interesting",
        "function",
        "continuous",
        "d",
        "however",
        "function",
        "sufficient",
        "obtain",
        "modeling",
        "selfapplication",
        "none",
        "domain",
        "set",
        "functionsas",
        "d",
        "assumed",
        "function",
        "space",
        "solution",
        "start",
        "defining",
        "hierarchy",
        "function",
        "space",
        "d_",
        "d_",
        "d_",
        "ldots",
        "function",
        "space",
        "d_n",
        "complete",
        "lattice",
        "continuous",
        "function",
        "may",
        "defined",
        "creating",
        "function",
        "space",
        "d_",
        "n",
        "importance",
        "selecting",
        "continuous",
        "function",
        "emerging",
        "function",
        "space",
        "cardinality",
        "underlying",
        "set",
        "allows",
        "u",
        "define",
        "embeddings",
        "function",
        "space",
        "adjacent",
        "within",
        "hierarchy",
        "hierarchy",
        "function",
        "space",
        "d_n",
        "may",
        "accumulated",
        "together",
        "standard",
        "construction",
        "model",
        "theory",
        "form",
        "disjoint",
        "union",
        "structure",
        "disjointness",
        "always",
        "guaranteed",
        "indexing",
        "carrier",
        "set",
        "structure",
        "scott",
        "defined",
        "d_infty",
        "disjoint",
        "union",
        "function",
        "space",
        "d_n",
        "n",
        "except",
        "extremal",
        "element",
        "glued",
        "together",
        "formally",
        "top",
        "element",
        "bottom",
        "element",
        "function",
        "space",
        "respectively",
        "identified",
        "d_infty",
        "complete",
        "lattice",
        "tarski",
        "fixed",
        "point",
        "theorem",
        "continuous",
        "function",
        "map",
        "d_infty",
        "d_infty",
        "fixed",
        "point",
        "implies",
        "_infty",
        "isomorphic",
        "d_inftyrightarrow",
        "d_infty",
        "construction",
        "may",
        "also",
        "conceptualized",
        "term",
        "string",
        "cartesian",
        "product",
        "backandforth",
        "move",
        "function",
        "one",
        "one",
        "variablethe",
        "uncurrying",
        "currying",
        "functionsalgebraically",
        "corresponds",
        "two",
        "direction",
        "residuation",
        "example",
        "function",
        "fcolon",
        "atimes",
        "brightarrow",
        "c",
        "may",
        "represented",
        "function",
        "fprimecolon",
        "rightarrow",
        "brightarrow",
        "c",
        "vice",
        "versa",
        "thus",
        "without",
        "loss",
        "generality",
        "sufficient",
        "consider",
        "unary",
        "function",
        "a",
        "fixed",
        "element",
        "function",
        "space",
        "d_infty",
        "x",
        "x",
        "hold",
        "x",
        "fixed",
        "point",
        "a",
        "term",
        "tuples",
        "solution",
        "may",
        "viewed",
        "infinite",
        "tuple",
        "ldots",
        "relational",
        "semantics",
        "model",
        "briefly",
        "outline",
        "fall",
        "settheoretical",
        "semantics",
        "paradigm",
        "nonclassical",
        "logic",
        "due",
        "j",
        "michael",
        "dunn",
        "robert",
        "k",
        "meyer",
        "see",
        "dunn",
        "meyer",
        "cl",
        "lambda",
        "calculi",
        "inherently",
        "connected",
        "intuitionistic",
        "relevance",
        "nonclassical",
        "logic",
        "particular",
        "text",
        "cl",
        "_triangleright",
        "text",
        "cl",
        "_",
        "calculus",
        "nonclassical",
        "logic",
        "set",
        "theoretical",
        "semantics",
        "intensional",
        "connective",
        "modeled",
        "relation",
        "collection",
        "situation",
        "preferred",
        "interpretation",
        "nonclassical",
        "logic",
        "since",
        "early",
        "s",
        "sort",
        "semantics",
        "sometimes",
        "called",
        "kripke",
        "semantics",
        "kripke",
        "introduced",
        "possibleworld",
        "semantics",
        "normal",
        "modal",
        "logic",
        "gaggle",
        "semantics",
        "pronunciation",
        "abbreviation",
        "ggl",
        "stand",
        "generalized",
        "galois",
        "logic",
        "introduced",
        "dunn",
        "model",
        "text",
        "cl",
        "_triangleright",
        "may",
        "defined",
        "follows",
        "let",
        "w",
        "le",
        "r",
        "k",
        "v",
        "comprise",
        "nonempty",
        "partially",
        "ordered",
        "set",
        "w",
        "le",
        "threeplace",
        "relation",
        "r",
        "w",
        "let",
        "s",
        "kin",
        "w",
        "furthermore",
        "alpha",
        "beta",
        "gamma",
        "deltain",
        "w",
        "condition",
        "k",
        "true",
        "exists",
        "zeta_",
        "zeta_",
        "zeta_in",
        "w",
        "rsalphazeta_land",
        "rzeta_",
        "betazeta_land",
        "rzeta_gammadelta",
        "implies",
        "existszeta_",
        "zeta_",
        "zeta_in",
        "w",
        "ralphagammazeta_land",
        "rbetagammazeta_land",
        "rzeta_zeta_delta",
        "k",
        "existszeta_in",
        "w",
        "rkalphazeta_land",
        "rzeta_betagamma",
        "implies",
        "alphalegamma",
        "ternary",
        "relation",
        "stipulated",
        "antitone",
        "first",
        "two",
        "argument",
        "place",
        "monotone",
        "third",
        "component",
        "define",
        "frame",
        "text",
        "cl",
        "_triangleright",
        "valuation",
        "function",
        "v",
        "map",
        "variable",
        "x",
        "z",
        "ldots",
        "nonempty",
        "cone",
        "w",
        "map",
        "two",
        "primitive",
        "combinators",
        "textsf",
        "textsf",
        "k",
        "cone",
        "generated",
        "s",
        "k",
        "respectively",
        "recall",
        "standard",
        "notation",
        "cl",
        "hide",
        "application",
        "binary",
        "operation",
        "allows",
        "forming",
        "compound",
        "term",
        "next",
        "clause",
        "extends",
        "v",
        "compound",
        "term",
        "make",
        "operation",
        "explicit",
        "v",
        "mn",
        "betacolonexistsalpha",
        "gamma",
        "ralphagammabetalandalpha",
        "in",
        "v",
        "landgammain",
        "v",
        "n",
        "inequation",
        "mtriangleright",
        "n",
        "valid",
        "v",
        "subseteq",
        "v",
        "n",
        "valuation",
        "frame",
        "text",
        "cl",
        "_triangleright",
        "relationship",
        "interpretation",
        "two",
        "term",
        "invariant",
        "whenever",
        "v",
        "varied",
        "set",
        "variable",
        "informally",
        "underlying",
        "set",
        "w",
        "set",
        "situation",
        "r",
        "accessibility",
        "relation",
        "connecting",
        "situation",
        "term",
        "interpreted",
        "set",
        "situation",
        "function",
        "application",
        "existential",
        "image",
        "operation",
        "derived",
        "r",
        "difference",
        "previous",
        "model",
        "result",
        "application",
        "term",
        "term",
        "determined",
        "object",
        "interpret",
        "two",
        "termsrather",
        "application",
        "operation",
        "defined",
        "r",
        "semantics",
        "generalizes",
        "possible",
        "world",
        "semantics",
        "normal",
        "modal",
        "logic",
        "therefore",
        "important",
        "note",
        "situation",
        "maximally",
        "consistent",
        "theory",
        "rather",
        "theory",
        "possessing",
        "property",
        "pair",
        "formula",
        "contain",
        "formula",
        "implies",
        "equivalently",
        "situation",
        "may",
        "taken",
        "dual",
        "ideal",
        "lindenbaum",
        "algebra",
        "text",
        "cl",
        "_triangleright",
        "situation",
        "typically",
        "consistent",
        "sense",
        "contain",
        "term",
        "one",
        "case",
        "notion",
        "negation",
        "consistency",
        "course",
        "defined",
        "text",
        "cl",
        "_triangleright",
        "text",
        "cl",
        "_",
        "relational",
        "semantics",
        "defined",
        "text",
        "cl",
        "_",
        "along",
        "similar",
        "line",
        "soundness",
        "completenessthat",
        "following",
        "theoremobtains",
        "theorem",
        "inequation",
        "mtriangleright",
        "n",
        "provable",
        "text",
        "cl",
        "_triangleright",
        "v",
        "subseteq",
        "v",
        "n",
        "model",
        "text",
        "cl",
        "_triangleright",
        "equation",
        "n",
        "provable",
        "text",
        "cl",
        "_",
        "v",
        "v",
        "n",
        "model",
        "text",
        "cl",
        "_",
        "relational",
        "operational",
        "semantics",
        "system",
        "cl",
        "include",
        "dual",
        "symmetric",
        "combinators",
        "found",
        "bimb\u00f3",
        "computable",
        "function",
        "arithmetic",
        "remarkable",
        "feature",
        "cl",
        "despite",
        "seeming",
        "simplicity",
        "powerful",
        "formalism",
        "course",
        "strength",
        "cl",
        "appreciated",
        "without",
        "discovering",
        "certain",
        "relationship",
        "combinatory",
        "term",
        "without",
        "illustration",
        "computable",
        "function",
        "definable",
        "important",
        "beginning",
        "step",
        "formalization",
        "mathematics",
        "formalization",
        "arithmetic",
        "first",
        "achieved",
        "dedekindpeano",
        "axiomatization",
        "various",
        "way",
        "formalize",
        "arithmetic",
        "cl",
        "two",
        "representation",
        "number",
        "described",
        "section",
        "together",
        "function",
        "number",
        "may",
        "thought",
        "object",
        "abstract",
        "object",
        "sort",
        "number",
        "mean",
        "natural",
        "number",
        "positive",
        "integer",
        "number",
        "could",
        "characterized",
        "example",
        "structure",
        "posse",
        "set",
        "structure",
        "support",
        "property",
        "ne",
        "sum",
        "n",
        "m",
        "number",
        "sum",
        "m",
        "n",
        "another",
        "wellknown",
        "property",
        "natural",
        "number",
        "example",
        "existence",
        "infinitely",
        "many",
        "prime",
        "number",
        "number",
        "represented",
        "cl",
        "term",
        "one",
        "way",
        "choose",
        "term",
        "textsf",
        "ki",
        "textsf",
        "textsf",
        "sbi",
        "textsf",
        "sb",
        "textsf",
        "sbi",
        "ldots",
        "etc",
        "term",
        "represent",
        "arithmetic",
        "operation",
        "vary",
        "depending",
        "term",
        "stand",
        "number",
        "note",
        "unlike",
        "dedekindpeano",
        "formalization",
        "arithmetic",
        "cl",
        "make",
        "syntactic",
        "distinction",
        "would",
        "parallel",
        "difference",
        "individual",
        "constant",
        "function",
        "symbolsin",
        "cl",
        "object",
        "term",
        "list",
        "term",
        "already",
        "show",
        "successor",
        "function",
        "textsf",
        "sb",
        "textsf",
        "sb",
        "textsf",
        "ki",
        "strongly",
        "equal",
        "textsf",
        "successor",
        "addition",
        "term",
        "textsf",
        "b",
        "textsf",
        "bb",
        "multiplication",
        "term",
        "textsf",
        "b",
        "usual",
        "recursive",
        "definition",
        "multiplication",
        "based",
        "addition",
        "may",
        "suggest",
        "addition",
        "simpler",
        "operation",
        "multiplication",
        "however",
        "cl",
        "number",
        "function",
        "property",
        "allows",
        "textsf",
        "b",
        "a",
        "simpler",
        "looking",
        "termto",
        "chosen",
        "function",
        "often",
        "perceived",
        "complex",
        "addition",
        "addition",
        "operation",
        "could",
        "defined",
        "using",
        "primitive",
        "recursion",
        "would",
        "produce",
        "complex",
        "term",
        "classical",
        "example",
        "may",
        "consider",
        "term",
        "textsf",
        "bii",
        "strongly",
        "equal",
        "textsf",
        "times",
        "as",
        "expected",
        "pursue",
        "numerical",
        "representation",
        "note",
        "shape",
        "number",
        "closely",
        "related",
        "church",
        "numeral",
        "lambda",
        "calculus",
        "binary",
        "function",
        "whereas",
        "number",
        "unary",
        "function",
        "another",
        "way",
        "represent",
        "number",
        "cl",
        "start",
        "different",
        "choice",
        "term",
        "number",
        "previously",
        "textsf",
        "stood",
        "take",
        "textsf",
        "successor",
        "number",
        "n",
        "textsf",
        "v",
        "textsf",
        "ki",
        "n",
        "second",
        "occurrence",
        "n",
        "indicates",
        "numeral",
        "combinator",
        "represents",
        "n",
        "numeral",
        "n",
        "often",
        "denotedmore",
        "preciselyby",
        "overlined",
        "otherwise",
        "decorated",
        "n",
        "however",
        "double",
        "usage",
        "n",
        "limited",
        "context",
        "cause",
        "confusion",
        "word",
        "successor",
        "function",
        "textsf",
        "v",
        "textsf",
        "ki",
        "notice",
        "number",
        "present",
        "representation",
        "term",
        "restricted",
        "combinatory",
        "base",
        "former",
        "case",
        "example",
        "combinator",
        "duplicative",
        "effect",
        "definable",
        "textsf",
        "textsf",
        "k",
        "textsf",
        "v",
        "simple",
        "recursive",
        "function",
        "may",
        "defined",
        "follows",
        "predecessor",
        "function",
        "p",
        "number",
        "ie",
        "subtracting",
        "one",
        "number",
        "greater",
        "equal",
        "predecessor",
        "set",
        "next",
        "term",
        "defines",
        "predecessor",
        "function",
        "abbreviated",
        "p",
        "ptextsf",
        "c",
        "textsf",
        "w",
        "textsf",
        "bb",
        "textsf",
        "c",
        "textsf",
        "tk",
        "textsf",
        "textsf",
        "ki",
        "n",
        "numeral",
        "pn",
        "reduces",
        "ntextsf",
        "ki",
        "n",
        "textsf",
        "ki",
        "suggests",
        "positive",
        "number",
        "p",
        "could",
        "defined",
        "term",
        "textsf",
        "textsf",
        "ki",
        "textsf",
        "textsf",
        "ki",
        "n",
        "reduces",
        "n",
        "whenever",
        "n",
        "term",
        "form",
        "textsf",
        "v",
        "textsf",
        "ki",
        "n",
        "model",
        "computation",
        "register",
        "machine",
        "certain",
        "programming",
        "language",
        "include",
        "test",
        "zero",
        "primitive",
        "construct",
        "useful",
        "find",
        "clterm",
        "function",
        "z",
        "znxy",
        "reduces",
        "x",
        "n",
        "zero",
        "whereas",
        "znxy",
        "reduces",
        "y",
        "n",
        "positive",
        "znxy",
        "may",
        "thought",
        "conditional",
        "instruction",
        "n",
        "x",
        "else",
        "y",
        "x",
        "y",
        "function",
        "course",
        "pseudocode",
        "one",
        "assumed",
        "n",
        "integer",
        "type",
        "take",
        "negative",
        "value",
        "could",
        "guaranteed",
        "declaration",
        "variable",
        "additional",
        "conditional",
        "statement",
        "following",
        "definition",
        "work",
        "branching",
        "zero",
        "ztextsf",
        "tk",
        "textsf",
        "tk",
        "nxyntextsf",
        "k",
        "xy",
        "n",
        "zero",
        "n",
        "textsf",
        "another",
        "step",
        "textsf",
        "k",
        "xy",
        "x",
        "result",
        "whereas",
        "n",
        "positive",
        "reduction",
        "one",
        "get",
        "textsf",
        "ki",
        "xy",
        "y",
        "two",
        "term",
        "textsf",
        "k",
        "xy",
        "textsf",
        "ki",
        "xy",
        "hint",
        "toward",
        "interpretation",
        "textsf",
        "k",
        "textsf",
        "ki",
        "truth",
        "falsity",
        "viewed",
        "term",
        "select",
        "respectively",
        "first",
        "second",
        "argument",
        "idea",
        "may",
        "developed",
        "definition",
        "truth",
        "function",
        "representation",
        "tuples",
        "addition",
        "may",
        "defined",
        "recursive",
        "equation",
        "mnzmn",
        "textsf",
        "v",
        "textsf",
        "ki",
        "pm",
        "n",
        "m",
        "n",
        "numeral",
        "p",
        "z",
        "already",
        "defined",
        "function",
        "abbreviation",
        "used",
        "enhance",
        "readability",
        "termsthey",
        "replaced",
        "everywhere",
        "defining",
        "combinators",
        "put",
        "word",
        "m",
        "sum",
        "n",
        "otherwise",
        "mn",
        "successor",
        "m",
        "n",
        "course",
        "definition",
        "closely",
        "simulates",
        "definition",
        "addition",
        "recursion",
        "theory",
        "addition",
        "often",
        "defined",
        "two",
        "equation",
        "n",
        "n",
        "n",
        "s",
        "n",
        "s",
        "denoting",
        "successor",
        "function",
        "fact",
        "cl",
        "express",
        "addition",
        "form",
        "showsonce",
        "againthe",
        "versatility",
        "cl",
        "combinatorial",
        "completeness",
        "guarantee",
        "term",
        "right",
        "hand",
        "side",
        "defining",
        "equation",
        "ie",
        "term",
        "zmn",
        "textsf",
        "v",
        "textsf",
        "ki",
        "pm",
        "n",
        "transformed",
        "term",
        "first",
        "m",
        "n",
        "second",
        "third",
        "argument",
        "respectively",
        "defined",
        "explicitly",
        "fixed",
        "point",
        "combinator",
        "textsf",
        "b",
        "textsf",
        "bw",
        "textsf",
        "bw",
        "textsf",
        "b",
        "textsf",
        "b",
        "textsf",
        "c",
        "textsf",
        "bb",
        "textsf",
        "bc",
        "textsf",
        "tk",
        "textsf",
        "b",
        "textsf",
        "b",
        "textsf",
        "b",
        "textsf",
        "v",
        "textsf",
        "ki",
        "textsf",
        "cb",
        "textsf",
        "textsf",
        "ki",
        "course",
        "abbreviate",
        "obtained",
        "term",
        "sake",
        "transparency",
        "used",
        "earlier",
        "p",
        "z",
        "shorthand",
        "longer",
        "combinatory",
        "term",
        "multiplication",
        "often",
        "denoted",
        "cdot",
        "recursive",
        "equation",
        "cdot",
        "mn",
        "zmtextsf",
        "n",
        "cdot",
        "pm",
        "n",
        "defines",
        "multiplication",
        "deciphered",
        "m",
        "result",
        "else",
        "n",
        "added",
        "result",
        "m",
        "cdot",
        "n",
        "next",
        "step",
        "definition",
        "brings",
        "righthand",
        "side",
        "term",
        "form",
        "textsf",
        "x",
        "cdot",
        "mn",
        "textsf",
        "x",
        "contain",
        "occurrence",
        "cdot",
        "m",
        "n",
        "taking",
        "fixed",
        "point",
        "textsf",
        "x",
        "setting",
        "cdot",
        "textsf",
        "yx",
        "concludes",
        "definition",
        "multiplication",
        "function",
        "instance",
        "abstraction",
        "yield",
        "combinator",
        "textsf",
        "bw",
        "textsf",
        "b",
        "textsf",
        "b",
        "textsf",
        "c",
        "textsf",
        "bb",
        "textsf",
        "c",
        "textsf",
        "tk",
        "textsf",
        "textsf",
        "b",
        "textsf",
        "bw",
        "textsf",
        "b",
        "textsf",
        "b",
        "textsf",
        "b",
        "textsf",
        "c",
        "textsf",
        "cb",
        "textsf",
        "textsf",
        "ki",
        "factorial",
        "function",
        "definable",
        "predecessor",
        "function",
        "plus",
        "multiplication",
        "useful",
        "eg",
        "combinatorics",
        "factorial",
        "function",
        "denoted",
        "recursively",
        "definable",
        "equation",
        "mzm",
        "textsf",
        "v",
        "textsf",
        "ki",
        "textsf",
        "cdot",
        "pm",
        "may",
        "read",
        "m",
        "m",
        "otherwise",
        "m",
        "equal",
        "m",
        "multiplied",
        "factorial",
        "m",
        "course",
        "necessary",
        "define",
        "various",
        "numerical",
        "function",
        "simulating",
        "recursive",
        "definition",
        "saw",
        "case",
        "first",
        "representation",
        "number",
        "might",
        "happen",
        "right",
        "term",
        "textsf",
        "b",
        "textsf",
        "bb",
        "textsf",
        "b",
        "behave",
        "target",
        "function",
        "number",
        "equally",
        "good",
        "way",
        "define",
        "arithmetic",
        "function",
        "simply",
        "list",
        "term",
        "show",
        "behave",
        "expected",
        "however",
        "shown",
        "basic",
        "primitive",
        "recursive",
        "function",
        "together",
        "recursion",
        "minimization",
        "emulated",
        "cl",
        "got",
        "nice",
        "collection",
        "arithmetic",
        "function",
        "form",
        "combinators",
        "work",
        "also",
        "proof",
        "combinatory",
        "logic",
        "sufficiently",
        "expressive",
        "formalize",
        "partial",
        "recursive",
        "function",
        "indeed",
        "remaining",
        "step",
        "proof",
        "carried",
        "cl",
        "though",
        "detail",
        "beyond",
        "scope",
        "entry",
        "g\u00f6del",
        "sentence",
        "abbreviation",
        "interspersed",
        "explanation",
        "sketch",
        "may",
        "obscure",
        "arithmetic",
        "formalized",
        "language",
        "consists",
        "five",
        "symbol",
        "juxtaposition",
        "counted",
        "textsf",
        "textsf",
        "k",
        "plus",
        "two",
        "delimiters",
        "finite",
        "perhaps",
        "surprisingly",
        "small",
        "number",
        "symbol",
        "availability",
        "recursive",
        "function",
        "conjure",
        "thought",
        "arithmetization",
        "syntax",
        "cl",
        "could",
        "attempted",
        "g\u00f6del",
        "achieved",
        "encoding",
        "formal",
        "language",
        "assigning",
        "number",
        "symbol",
        "formula",
        "sequence",
        "formula",
        "later",
        "became",
        "known",
        "g\u00f6del",
        "numbers",
        "concretely",
        "g\u00f6del",
        "assigned",
        "odd",
        "number",
        "symbol",
        "product",
        "power",
        "prime",
        "number",
        "corresponding",
        "symbol",
        "exponent",
        "sequence",
        "symbol",
        "however",
        "possible",
        "arithmetize",
        "language",
        "cl",
        "without",
        "placing",
        "strong",
        "emphasis",
        "existence",
        "property",
        "prime",
        "number",
        "see",
        "example",
        "raymond",
        "m",
        "smullyan",
        "book",
        "smullyan",
        "smullyan",
        "five",
        "symbol",
        "get",
        "g\u00f6del",
        "number",
        "first",
        "five",
        "positive",
        "integer",
        "string",
        "assigned",
        "number",
        "base",
        "result",
        "concatenation",
        "corresponding",
        "number",
        "symbol",
        "following",
        "outline",
        "give",
        "flavor",
        "analogue",
        "g\u00f6del",
        "incompleteness",
        "theorem",
        "adapted",
        "cl",
        "possible",
        "define",
        "combinator",
        "combinator",
        "applied",
        "numeral",
        "n",
        "whole",
        "term",
        "reduces",
        "numeral",
        "m",
        "numeral",
        "denoting",
        "g\u00f6del",
        "number",
        "numeral",
        "n",
        "slightly",
        "formally",
        "combinator",
        "delta",
        "delta",
        "n",
        "g",
        "n",
        "g",
        "n",
        "denotes",
        "g\u00f6del",
        "number",
        "expression",
        "n",
        "furthermore",
        "combinatory",
        "term",
        "return",
        "numeral",
        "followed",
        "g",
        "n",
        "applied",
        "numeral",
        "n",
        "term",
        "a",
        "term",
        "b",
        "equation",
        "delta",
        "b",
        "b",
        "true",
        "statement",
        "concrete",
        "variant",
        "particular",
        "formal",
        "system",
        "usually",
        "called",
        "second",
        "fixed",
        "point",
        "theorem",
        "computable",
        "characteristic",
        "function",
        "recursive",
        "set",
        "number",
        "represented",
        "combinators",
        "choice",
        "textsf",
        "k",
        "truth",
        "textsf",
        "ki",
        "falsity",
        "complement",
        "function",
        "computable",
        "finally",
        "proved",
        "combinator",
        "represents",
        "set",
        "true",
        "equation",
        "put",
        "differently",
        "combinator",
        "either",
        "represents",
        "set",
        "equation",
        "fails",
        "include",
        "true",
        "equation",
        "represents",
        "set",
        "equation",
        "includes",
        "true",
        "also",
        "false",
        "equation",
        "alonzo",
        "church",
        "proved",
        "undecidability",
        "classical",
        "firstorder",
        "logic",
        "relying",
        "g\u00f6del",
        "incompleteness",
        "theorem",
        "dana",
        "scott",
        "proved",
        "a",
        "nonempty",
        "proper",
        "subset",
        "lambda",
        "terms",
        "closed",
        "equality",
        "a",
        "recursive",
        "analogous",
        "claim",
        "cl",
        "follows",
        "existence",
        "g\u00f6delian",
        "sentence",
        "cl",
        "undecidable",
        "two",
        "clterms",
        "equal"
    ]
}