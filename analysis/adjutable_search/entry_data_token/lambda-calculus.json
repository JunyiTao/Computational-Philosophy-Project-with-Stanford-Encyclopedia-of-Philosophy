{"url": "lambda-calculus", "title": "The Lambda Calculus", "authorship": {"year": "Copyright \u00a9 2023", "author_text": "Jesse Alama\n\nJohannes Korbmacher\n<j.korbmacher@uu.nl>", "author_links": [{"https://mally.stanford.edu/alama-cv.html": "Jesse Alama"}, {"http://jkorbmacher.org/": "Johannes Korbmacher"}, {"mailto:j%2ekorbmacher%40uu%2enl": "j.korbmacher@uu.nl"}], "raw_html": "<div id=\"article-copyright\">\n<p>\n<a href=\"../../info.html#c\">Copyright \u00a9 2023</a> by\n\n<br/>\n<a href=\"https://mally.stanford.edu/alama-cv.html\" target=\"other\">Jesse Alama</a>\n<br/>\n<a href=\"http://jkorbmacher.org/\" target=\"other\">Johannes Korbmacher</a>\n&lt;<a href=\"mailto:j%2ekorbmacher%40uu%2enl\"><em>j<abbr title=\" dot \">.</abbr>korbmacher<abbr title=\" at \">@</abbr>uu<abbr title=\" dot \">.</abbr>nl</em></a>&gt;\n    </p>\n</div>"}, "pubinfo": ["First published Wed Dec 12, 2012", "substantive revision Tue Jul 25, 2023"], "preamble": "\n\nThe \\(\\lambda\\)-calculus is, at heart, a simple notation for functions\nand application. The main ideas are applying a function to an\nargument and forming functions by abstraction. The syntax of\nbasic \\(\\lambda\\)-calculus is quite sparse, making it an elegant,\nfocused notation for representing functions. Functions and arguments\nare on a par with one another. The result is a non-extensional theory\nof functions as rules of computation, contrasting with an extensional\ntheory of functions as sets of ordered pairs. Despite its sparse\nsyntax, the expressiveness and flexibility of the \\(\\lambda\\)-calculus\nmake it a cornucopia of logic and mathematics. This entry develops\nsome of the central highlights of the field and prepares the reader\nfor further study of the subject and its applications in philosophy,\nlinguistics, computer science, and logic.\n", "toc": [{"#Int": "1. Introduction"}, {"#MulArgOpe": "1.1 Multi-argument operations"}, {"#Non-Extensionality": "1.2 Non-Extensionality"}, {"#Syn": "2. Syntax"}, {"#VarBouFre": "2.1 Variables, bound and free"}, {"#Com": "2.2 Combinators"}, {"#BriHisLCal": "3. Brief history of \\(\\lambda\\)-calculus"}, {"#Red": "4. Reduction"}, {"#OthNotRed": "4.1 Other notions of reduction"}, {"#RedStr": "4.2 Reduction strategies"}, {"#LThe": "5. \\(\\lambda\\)-theories"}, {"#BasTheL": "5.1 The basic theory \\(\\lambda\\)"}, {"#ExtBasTheL": "5.2 Extending the basic theory \\(\\lambda\\)"}, {"#ConLCal": "6. Consistency of the \\(\\lambda\\)-calculus"}, {"#SemLCal": "7. Semantics of \\(\\lambda\\)-calculus"}, {"#LamMod": "7.1 \\(\\lambda\\)-Models"}, {"#ModCon": "7.2 Model Constructions"}, {"#ExtVar": "8. Extensions and Variations"}, {"#ComLog": "8.1 Combinatory logic"}, {"#AddTyp": "8.2 Adding types"}, {"#App": "9. Applications"}, {"#LogLaL": "9.1 Logic \u00e0 la \\(\\lambda\\)"}, {"#Computing": "9.2 Computing"}, {"#Relations": "9.3 Relations"}, {"#Bib": "Bibliography"}, {"#Aca": "Academic Tools"}, {"#Oth": "Other Internet Resources"}, {"#Rel": "Related Entries"}], "main_text": "\n1. Introduction\n\nThe \\(\\lambda\\)-calculus is an elegant notation for working with\napplications of functions to arguments. To\ntake a mathematical example, suppose we are given a simple polynomial\nsuch as \\(x^2 -2\\cdot x+5\\). What is the value of this expression when\n\\(x = 2\\)? We compute this by \u2018plugging in\u2019 2 for \\(x\\) in\nthe expression: we get \\(2^2 -2\\cdot 2+5\\), which we can further\nreduce to get the answer 5. To use the \\(\\lambda\\)-calculus to\nrepresent the situation, we start with the \\(\\lambda\\)-term\n\n\\[\n\\lambda x[x^2 -2\\cdot x+5].\n\\]\n\n\nThe \\(\\lambda\\) operators allows us to abstract over \\(x\\).\nOne can intuitively read \u2018\\(\\lambda x[x^2 -2\\cdot x+5]\\)\u2019\nas an expression that is waiting for a value \\(a\\) for the variable\n\\(x\\). When given such a value \\(a\\) (such as the number 2), the value\nof the expression is \\(a^2 -2\\cdot a+5\\). The\n\u2018\\(\\lambda\\)\u2019 on its own has no significance; it merely\nbinds the variable \\(x\\), guarding it, as it were, from\noutside interference. The terminology in \\(\\lambda\\)-calculus is that\nwe want to apply this expression to an argument, and\nget a value. We write \u2018\\(Ma\\)\u2019 to denote the application\nof the function \\(M\\) to the argument \\(a\\). Continuing with the\nexample, we get: \n\\[\\begin{align}\n(\\lambda x[x^2 -2\\cdot x+5])2 \\rhd 2^2& -2\\cdot 2+5\n   &\\langle \\text{Substitute 2 for } x\\rangle \\\\\n&= 4-4+5\n   &\\langle\\text{Arithmetic}\\rangle \\\\\n&= 5 \n   &\\langle\\text{Arithmetic}\\rangle\n\\end{align}\\]\n\n\nThe first step of this calculation, plugging in \u20182\u2019 for\noccurrences of \\(x\\) in the expression \u2018\\(x^2 -\n2\\cdot x + 5\\)\u2019, is the passage from an\nabstraction term to another term by the\noperation of substitution. The remaining equalities are justified by\ncomputing with natural numbers.\n\nThis example suggests the central principle of the\n\\(\\lambda\\)-calculus, called\n\\(\\beta\\)-reduction, which is also sometimes\ncalled \\(\\beta\\)-conversion: \n\\[\n\\tag{\\(\\beta\\)}\n(\\lambda x[M])N \\rhd M[x := N]\n\\]\n\n\nThe understanding is that we can reduce or contract\n\\((\\rhd)\\) an application \\((\\lambda xM)N\\) of an abstraction term\n(the left-hand side, \\(\\lambda xM)\\) to something (the right-hand\nside, \\(N)\\) by simply plugging in \\(N\\) for the occurrences of \\(x\\)\ninside \\(M\\) (that\u2019s what the notation \u2018\\(M[x :=\nN]\\)\u2019 expresses). \\(\\beta\\)-reduction,\nor \\(\\beta\\)-conversion, is the heart of the\n\\(\\lambda\\)-calculus. When one actually applies \\(\\beta\\)-reduction to\nreduce a term, there is an important proviso that has to be observed.\nBut this will be described in Section 2.1, when we discuss bound and\nfree variables.\n1.1 Multi-argument operations\n\nWhat about functions of multiple arguments? Can the\n\\(\\lambda\\)-calculus represent operations such as computing the length\nof the hypotenuse of a right triangle:\n\nHypotenuse of a right triangle with legs of length \\(x\\) and \\(y\n\\Rightarrow \\sqrt{x^2 + y^2}\\).\n\nThe length-of-hypotenuse operation maps two positive real numbers\n\\(x\\) and \\(y\\) to another positive real number. One can represent\nsuch multiple-arity operations using the apparatus of the\n\\(\\lambda\\)-calculus by viewing the operation as taking one input at a\ntime. Thus, the operation can be seen as taking one input, \\(x\\), a\npositive real number, and producing as its value not a\nnumber, but an operation: namely, the operation that\ntakes a positive real number \\(y\\) as input and produces as output the\npositive real number \\(\\sqrt{x^2 + y^2}\\). One could summarize the\ndiscussion by saying that the operation, hypotenuse-length,\nthat computes\nthe length of the hypotenuse of a right triangle given the lengths\n\\(a\\) and \\(b\\) of its legs, is:\n\nhypotenuse-length \\(:=\n\\lambda a[\\lambda b[\\sqrt{a^2 + b^2}]]\\)\n\nBy the principle of \\(\\beta\\)-reduction, we have, for example, that\nhypotenuse-length 3, the\napplication of hypotenuse-length\nto 3, is\n\\(\\lambda b[\\sqrt{3^2 + b^2}]\\), which is a function of that is\n\u2018waiting\u2019 for another argument. The \\(\\lambda\\)-term hypotenuse-length\n3 can be viewed\nas a function that computes the length of the hypotenuse of a right\ntriangle one of whose legs has length 3. We find, finally, that (hypotenuse-length\n3)4\u2014the\napplication of hypotenuse-length\nto 3 and then to\n4\u2014is 5, as expected.\n\nAnother way to understand the reduction of many-place functions to\none-place functions is to imagine a machine \\(M\\) that initially\nstarts out by loading the first \\(a\\) of multiple arguments \\(a,\nb,\\ldots\\) into memory. If one then suspends the machine after it has\nloaded the first argument into memory, one can view the result as\nanother machine M\\(_a\\) that is awaiting one fewer input; the first\nargument is now fixed.\n1.2 Non-Extensionality\n\nAn important philosophical issue concerning the \\(\\lambda\\)-calculus\nis the question of its underlying concept of functions. In set theory,\na function is standardly understood as a set of argument-value pairs.\nMore specifically, a function is understood as a set \\(f\\) of ordered\npairs satisfying the property that \\((x,y) \\in f\\) and \\((x,z) \\in f\\)\nimplies \\(y = z\\). If \\(f\\) is a function and \\((x,y) \\in f\\), this\nmeans that the function f assigns the value \\(y\\) to the argument\n\\(x\\). This is the concept of\nfunctions-as-sets. Consequently, the notion\nof equality of functions-as-sets is equality qua sets, which,\nunder the standard principle of extensionality, entails that two\nfunctions are equal precisely when they contain the same ordered\npairs. In other words, two functions are identical if and only if they\nassign the same values to the same arguments. In this sense,\nfunctions-as-sets are extensional objects.\n\nIn contrast, the notion of a function at work in \\(\\lambda\\)-calculus\nis one where functions are understood as rules: a function is\ngiven by a rule for how to determine its values from its arguments.\nMore specifically, we can view a \\(\\lambda\\)-term \\(\\lambda x[M]\\) as\na description of an operation that, given \\(x\\), produces \\(M\\); the\nbody \\(M\\) of the abstraction term is, essentially, a rule\nfor what to do with \\(x\\). This is the conception of\nfunctions-as-rules. Intuitively, given rules\n\\(M\\) and \\(N\\), we cannot in general decide whether \\(\\lambda x[M]\\)\nis equal to \\(\\lambda x[N]\\). The two terms might \u2018behave\u2019\nthe same (have the same value given the same arguments), but it may\nnot be clear what resources are needed for showing the equality of the\nterms. In this sense, functions-as-rules are non-extensional\nobjects.\n\nTo distinguish the extensional concept of functions-as-sets from the\nnon-extensional concept of functions-as-rules, the latter is often\nreferred to as an \u2018intensional\u2019 function concept,\nin part because of the ostensibly intensional concept of a rule\ninvolved. This terminology is particularly predominant in the\ncommunity of mathematical logicians and philosophers of mathematics\nworking on the foundations of mathematics. But from the perspective of\nthe philosophy of language, the terminology can be somewhat\nmisleading, since in this context, the extensional-intensional\ndistinction has a slightly different meaning.\n\nIn the standard possible-worlds framework of philosophical semantics,\nwe would distinguish between an extensional and an intensional\nfunction concept as follows. Let us say that two functions are\nextensionally equivalent at a world if and only if they\nassign the same values to the same arguments at that world. And let us\nsay that two functions are intensionally equivalent if and\nonly if they assign the same values to the same arguments at\nevery possible-world. To illustrate, consider the functions\nhighest-mountain-on-earth and\nhighest-mountain-in-the-Himalayas,\nwhere highest-mountain-on-earth\nassigns\nthe highest mountain on earth as the value to every argument and highest-mountain-in-the-Himalayas\nassigns the highest mountain in the Himalayas as the value to every\nargument. The two functions are extensionally equivalent (at the\nactual world), but not intensionally so. At the actual world, the two\nfunctions assign the same value to every argument, namely Mt. Everest.\nNow consider a world where Mt. Everest is not the highest mountain on\nearth, but say, Mt. Rushmore is. Suppose further that this is so, just\nbecause Mt. Rushmore is 30.000 feet/9.100 m higher than it is at the\nactual world, while Mt. Everest, with its roughly 29.000 feet/8.800 m,\nis still the highest mountain in the Himalayas. At that world, highest-mountain-on-earth\nnow\nassigns Mt. Rushmore as the value to every argument, while highest-mountain-in-the-Himalayas\nstill assigns Mt. Everest to every object. In other words, highest-mountain-on-earth\nand highest-mountain-in-the-Himalayas\nare extensionally equivalent (at the actual world) but not\nintensionally equivalent.\n\nA function concept may now be called extensional if and only\nif it requires functions that are extensionally equivalent at the\nactual world to be identical. And a function concept may be classified\nas intensional if and only if it requires intensionally\nequivalent functions to be identical. Note that these classifications\nare conceptually different from the distinctions commonly used in the\nfoundations of mathematics. On the terminology used in the foundations\nof mathematics, functions-as-sets are classified as extensional since\nthey use the axiom of extensionality as their criterion of identity,\nand functions-as-rules are classified as intensional because they rely\non the ostensibly intensional concept of a rule. In the present\npossible-worlds terminology, function concepts are classified as\nextensional or intensional based of their behavior at\npossible-worlds.\n\nAn issue from which conceptual confusion might arise is that the two\nterminologies potentially pass different verdicts on the function\nconcept at work in the \\(\\lambda\\)-calculus. To see this, consider the\nfollowing two functions: \n\\[\\begin{align}\n\\addone &:= \\lambda x[x+1] \\\\\n\\addtwosubtractone &:= \\lambda x[[x+2]-1] \n\\end{align}\\]\n\n\nThese two functions are clearly extensionally equivalent: they assign\nthe same value to the same input at the actual world. Moreover, given\nstandard assumptions in possible worlds semantics, the two functions\nare also intensionally equivalent. If we assume that\nmathematical facts, like facts about addition and subtraction, are\nnecessary in the sense that they are the same at every possible world,\nthen we get that the two functions give the same value to the\narguments at every possible world. So, an intensional\nfunction concept would require the two functions to be identical. In\nthe \\(\\lambda\\)-calculus, however, it\u2019s not clear at all that we\nshould identify the two functions. Formally speaking, without the help\nof some other principle, we cannot show that the two \\(\\lambda\\)-terms\ndenote the same function. Moreover, informally speaking, on the\nconception of functions-as-rules, it\u2019s not even clear\nthat we should identify them: the two terms involve genuinely\ndifferent rules, and so we might be tempted to say that they denote\ndifferent functions.\n\nA function concept that allows for intensionally equivalent functions\nto be distinct is called hyperintensional.\nThe point is that in possible-worlds terminology, the function concept\nat work in the \\(\\lambda\\)-calculus may be regarded not as intentional\nbut hyperintensional\u2014in contrast to what the\nterminology common in the foundations of mathematics says. Note that\nit\u2019s unclear how an intensional semantic framework, like the\npossible-worlds framework, could even in principle account for a\nnon-intensional function concept. On the semantics of the\n\\(\\lambda\\)-calculus, see section\n 7.\n The point here was simply to clarify any conceptual confusions that\nmight arise from different terminologies at play in philosophical\ndiscourse.\n\nThe hyperintensionality of the \\(\\lambda\\)-calculus is particularly\nimportant when it comes to its applications as a theory of not only\nfunctions, but more generally \\(n\\)-ary relations. On this,\nsee section\n 9.3.\n It is effectively the hyperintensionality of the \\(\\lambda\\)-calculus\nthat makes it an attractive tool in this context. It should be noted,\nhowever, that the \\(\\lambda\\)-calculus can be made extensional (as\nwell as intensional) by postulating additional laws concerning the\nequality of \\(\\lambda\\)-terms. On this, see section\n 5.\n2. Syntax\n\nThe official syntax of the \\(\\lambda\\)-calculus is quite simple; it is\ncontained in the next definition.\n\n\nDefinition For the alphabet of the language of the\n\\(\\lambda\\)-calculus we take the left and right parentheses, left and\nright square brackets, the symbol \u2018\\(\\lambda\\)\u2019, and an\ninfinite set of variables. The class of\n\\(\\lambda\\)-terms is defined inductively as\nfollows:\n\nEvery variable is a \\(\\lambda\\)-term.\nIf \\(M\\) and \\(N\\) are \\(\\lambda\\)-terms, then so is\n\\((MN)\\).\nIf \\(M\\) is a \\(\\lambda\\)-term and \\(x\\) is a variable, then\n\\((\\lambda x[M])\\) is a \\(\\lambda\\)-term.\n\n\nBy \u2018term\u2019 we always mean \u2018\\(\\lambda\\)-term\u2019.\nTerms formed according to rule (2) are called application\nterms. Terms formed according to rule (3) are called\nabstraction terms.\n\n\nAs is common when dealing with formal languages that have grouping\nsymbols (the left and right parenthesis, in our case), some\nparentheses will be omitted when it is safe to do so (that is, when\nthey can be reintroduced in only one sensible way). Juxtaposing more\nthan two \\(\\lambda\\)-terms is, strictly speaking, illegal. To avoid\nthe tedium of always writing all needed parentheses, we adopt the\nfollowing convention:\n\nConvention (association to the left): When more than\ntwo terms \\(M_1 M_2 M_3 \\ldots M_n\\) are juxtaposed we can recover the\nmissing parentheses by associating to the\nleft: reading from left to right, group \\(M_1\\) and\n\\(M_2\\) together, yielding \\((M_1 M_2)M_3 \\ldots M_n\\); then group\n\\((M_1 M_2)\\) with \\(M_3\\): \\(((M_1 M_2)M_3)\\ldots M_n\\), and so\nforth.\n\nThe convention thus gives a unique reading to any sequence of\n\\(\\lambda\\)-terms whose length is greater than 2.\n2.1 Variables, bound and free\n\nThe function of \\(\\lambda\\) in an abstraction term \\((\\lambda x[M]\\))\nis that it binds the variable appearing\nimmediately after it in the term \\(M\\). Thus \\(\\lambda\\) is analogous\nto the universal and existential quantifiers \\(\\forall\\) and\n\\(\\exists\\) of first-order logic. One can define, analogously, the\nnotions of free and bound variable in the expected way, as\nfollows.\n\n\nDefinition The syntactic functions \\(\\mathbf{FV}\\)\nand \\(\\mathbf{BV}\\) (for \u2018free variable\u2019 and \u2018bound\nvariable\u2019, respectively) are defined on the set of\n\\(\\lambda\\)-terms by structural induction thus:\n\nFor every variable \\(x\\), term \\(M\\), and term \\(N\\):\n\n\\[\\begin{array}{lll}\n  &\\text{Free}\n  &\\text{Bound} \\\\\n(1)\n  &\\mathbf{FV}(x) = \\{ x \\} \\quad \n  &\\mathbf{BV}(x) =  \\varnothing \\\\\n(2)\n  &\\mathbf{FV}(MN) = \\mathbf{FV}(M) \\cup \\mathbf{FV}(N)\n  &\\mathbf{BV}(MN) = \\mathbf{BV}(M) \\cup \\mathbf{BV}(N) \\\\\n(3)\n  &\\mathbf{FV}(\\lambda x[M]) = \\mathbf{FV}(M) - \\{ x \\}\n  &\\mathbf{BV}(\\lambda x[M]) = \\mathbf{BV}(M) \\cup \\{ x \\}\n\\end{array}\\]\n\n\nIf \\(\\mathbf{FV}(M) = \\varnothing\\) then \\(M\\) is called a\ncombinator.\n\n\nClause (3) in the two definitions supports the intention that\n\\(\\lambda\\) binds variables (ensures that they are not free). Note the\ndifference between \\(\\mathbf{BV}\\) and \\(\\mathbf{FV}\\) for\nvariables.\n\nAs is typical in other subjects where the concepts appear, such as\nfirst-order logic, one needs to be careful about the issue; a casual\nattitude about substitution can lead to syntactic\n difficulties.[1]\n We can defend a casual attitude by adopting the convention that we\nare interested not in terms themselves, but in a certain equivalence\nclass of terms. We now define substitution, and then lay down a\nconvention that allows us to avoid such difficulties.\n\n\nDefinition (substitution) We write \u2018\\(M[x :=\nN]\\)\u2019 to denote the substitution of \\(N\\) for the free\noccurrences of \\(x\\) in \\(M\\). A precise\n definition[2]\n by recursion on the set of \\(\\lambda\\)-terms is as follows: for all\nterms \\(A\\), \\(B\\), and \\(M\\), and for all variables \\(x\\) and \\(y\\),\nwe define\n\n\\(x[x := M] \\equiv M\\) \n\\(y[x := M] \\equiv y\\) (\\(y\\) distinct from \\(x)\\)\n\\((AB)[x := M] \\equiv A[x := M]B[x := M]\\)\n\\((\\lambda x[A])[x := M] \\equiv \\lambda x[A]\\)\n\\((\\lambda y[A])[x := M] \\equiv \\lambda y[A[x := M]]\\) (\\(y\\)\ndistinct from \\(x)\\)\n\n\n\nClause (1) of the definition simply says that if we are to substitute\n\\(M\\) for \\(x\\) and we are dealing simply with \\(x\\), then the result\nis just \\(M\\). Clause (2) says that nothing happens when we are\ndealing (only) with a variable different from \\(x\\) but we are to\nsubstitute something for \\(x\\). Clause (3) tells us that substitution\nunconditionally distributes over applications. Clauses (4) and (5)\nconcern abstraction terms and parallel clauses (1) and (2) (or rather,\nclauses (2) and (1), in opposite order): If the bound variable \\(z\\)\nof the abstraction term \\(\\lambda z[A]\\) is identical to the variable\n\\(x\\) for which we are to do a substitution, then we do not perform\nany substitution (that is, substitution \u201cstops\u201d). This\ncoheres with the intention that \\(M[x := N]\\) is supposed to denote\nthe substitution of \\(N\\) for the free occurrences of \\(x\\)\nin \\(M\\). If \\(M\\) is an abstraction term \\(\\lambda x[A]\\) whose bound\nvariable is \\(x\\), then \\(x\\) does not occurr freely in \\(M\\), so\nthere is nothing to do. This explains clause 4. Clause (5), finally,\nsays that if the bound variable of an abstraction term differs from\n\\(x\\), then at least \\(x\\) has the \u201cchance \u201d to occur\nfreely in the abstraction term, and substitution continues into the\nbody of the abstraction term.\n\n\nDefinition (change of bound variables,\n\\(\\alpha\\)-convertibility). The term \\(N\\) is obtained from the term\n\\(M\\) by a change of bound variables if,\nroughly, any abstraction term \\(\\lambda x[A]\\) inside \\(M\\) has been\nreplaced by \\(\\lambda y[A[x := y]]\\).\n\nLet us say that terms \\(M\\) and \\(N\\) are\n\\(\\alpha\\)-convertible if there is a\nsequence of changes of bound variables starting from \\(M\\) and ending\nat \\(N\\).\n\nAxiom. \\(\\beta\\)-conversion\n(stated with a no-capture proviso):\n\n\\( (\\lambda x[M])N \\rhd M[x := N]\\),\n\nprovided no variable that occurrs free in \\(N\\) becomes bound after\nits substitution into \\(M\\).\n\n\nRoughly, we need to adhere to the principle that free variables ought\nto remain free; when an occurrence of a variable is threatened to\nbecome bound by a substitution, simply perform enough\n\\(\\alpha\\)-conversions to sidestep the problem. If we keep this in\nmind, we can work with \\(\\lambda\\)-calculus without worrying about\nthese nettlesome syntactic difficulties. So, for example, we\ncan\u2019t apply the function \\(\\lambda x[\\lambda y[x(y-5)]]\\) to the\nargument \\(2y\\) because upon substitution of \u201c\\(2y\\)\u201d for\n\u201c\\(x\\)\u201d, the \u201c\\(y\\)\u201d in \u201c\\(2y\\)\u201d\nwould be captured by the variable-binding operator \u201c\\(\\lambda\ny\\)\u201d. Such a substitution would yield a function different from\nthe one intended. However, we can first transform \\(\\lambda x[\\lambda\ny[x(y-5)]]\\) to \\(\\lambda x[\\lambda z[x(z-5)]]\\) by\n\\(\\alpha\\)-conversion, and then apply this latter function to the\nargument \\(2y\\). So whereas the following is not a valid use\nof \\(\\beta\\)-conversion: \n\\[ (\\lambda x[\\lambda y[x(y-5)]])2y  \\rhd \\lambda y[2y(y-5)]\\]\n we can validly use\n\\(\\beta\\)-conversion to conclude: \n\\[ (\\lambda x[\\lambda z[x(z-5)]])2y \\rhd \\lambda z[2y(z-5)]\\]\n This example helps one\nto see why the proviso to \\(\\beta\\)-conversion is so important. The\nproviso is really no different from the one used in the statement of\nan axiom of the predicate calculus, namely: \\(\\forall x\\phi \\to\n\\phi^{\\tau}_x\\), provided no variable that is free in the term\n\\(\\tau\\) before the substitution becomes bound after the\nsubstitution.\n\nThe syntax of \\(\\lambda\\)-calculus is quite flexible. One can form all\nsorts of terms, even self-applications such as \\(xx\\). Such terms\nappear at first blush to be suspicious; one might suspect that using\nsuch terms could lead to inconsistency, and in any case one might find\noneself reaching for a tool with which to forbid such terms. If one\nwere to view functions and sets of ordered pairs of a certain kind,\nthen the \\(x\\) in \\(xx\\) would be a function (set of ordered pairs)\nthat contains as an element a pair \\((x,y)\\) whose first element would\nbe \\(x\\) itself. But no set can contain itself in this way, lest the\naxiom of foundation (or regularity) be violated. Thus, from a set\ntheoretical perspective such terms are clearly dubious. Below one can\nfind a brief sketch of one such tool, type theory. But in fact such\nterms do not lead to inconsistency and serve a useful purpose in the\ncontext of \\(\\lambda\\)-calculus. Moreover, forbidding such terms, as\nin type theory, does not come for free (e.g., some of the\nexpressiveness of untyped \\(\\lambda\\)-calculus is lost).\n2.2 Combinators\n\nAs defined earlier, a combinator is a\n\\(\\lambda\\)-term with no free variables. One can intuitively\nunderstand combinators as \u2018completely specified\u2019\noperations, since they have no free variables. There are a handful of\ncombinators that have proven useful in the history of\n\\(\\lambda\\)-calculus; the next table highlights some of these special\ncombinators. Many more could be given (and obviously there are\ninfinitely many combinators), but the following have concise\ndefinitions and have proved their utility. Below is a table of some\nstandard \\(\\lambda\\)-terms and combinators.\n\n\nName\nDefinition & Comments \n\n\\(\\bS\\)\n\\(\\lambda x[\\lambda y[\\lambda z[xz(yz)]]]\\)\n\nKeep in mind that \u2018\\(xz(yz)\\)\u2019 is to be understood as the\napplication \\((xz)(yz)\\) of \\(xz\\) to \\(yz. \\bS\\) can thus be\nunderstood as a substitute-and-apply operator: \\(z\\)\n\u2018intervenes\u2019 between \\(x\\) and \\(y\\): instead of applying\n\\(x\\) to \\(y\\), we apply \\(xz\\) to \\(yz\\). \n\n\\(\\mathbf{K}\\)\n\\(\\lambda x[\\lambda y[x]]\\)\n\nThe value of \\(\\mathbf{K}M\\) is the constant function whose value for\nany argument is simply \\(M.\\) \n\n\\(\\mathbf{I}\\)\n\\(\\lambda x[x]\\)\n\nThe identity function. \n\n\\(\\mathbf{B}\\)\n\\(\\lambda x[\\lambda y[\\lambda z[x(yz)]]]\\)\n\nRecall that \u2018\\(xyz\\)\u2019 is to be understood as \\((xy)z\\), so\nthis combinator is not a trivial identity function. \n\n\\(\\mathbf{C}\\)\n\\(\\lambda x[\\lambda y[\\lambda z[xzy]]]\\)\n\nSwaps an argument. \n\n\\(\\mathbf{T}\\)\n\\(\\lambda x[\\lambda y[x]]\\)\n\nTruth value true. Identical to \\(\\mathbf{K}\\). We shall see later how\nthese representations of truth values plays a role in the blending of\nlogic and \\(\\lambda\\)-calculus. \n\n\\(\\mathbf{F}\\)\n\\(\\lambda x[\\lambda y[y]]\\)\n\nTruth value false. \n\n\\(\\boldsymbol{\\omega}\\)\n\\(\\lambda x[xx]\\)\n\nSelf-application combinator \n\n\\(\\boldsymbol{\\Omega}\\)\n\\(\\boldsymbol{\\omega \\omega}\\)\n\nSelf-application of the self-application combinator. Reduces to\nitself. \n\n\\(\\mathbf{Y}\\)\n\\(\\lambda f[(\\lambda x[f(xx)])(\\lambda x[f(xx)]\\))]\n\nCurry\u2019s paradoxical combinator. For every \\(\\lambda\\)-term\n\\(X\\), we have: \n\\[\\begin{align}\n\\mathbf{Y}X &\\rhd (\\lambda x[X(xx)])(\\lambda x[X(xx)]) \\\\\n   &\\rhd X((\\lambda x[X(xx)])(\\lambda x[X(xx)]))\n\\end{align}\\]\n The first step in the reduction shows that\n\\(\\mathbf{Y}\\)X reduces to the application term \\((\\lambda\nx[X(xx)])(\\lambda x[X(xx)]\\)), which is recurring in the third step.\nThus, \\(\\mathbf{Y}\\) has the curious property that \\(\\mathbf{Y}\\)X and\nX\\((\\mathbf{Y}\\)X) reduce to a common term. \n\n\\(\\boldsymbol{\\Theta}\\)\n\\((\\lambda x[\\lambda f[f(xxf)]])(\\lambda x[\\lambda f[f(xxf)]]\\))\n\nTuring\u2019s fixed-point combinator. For every \\(\\lambda\\)-term\n\\(X\\), \\(\\boldsymbol{\\Theta}X\\) reduces to\n\\(X(\\boldsymbol{\\Theta}X)\\), which one can confirm by hand.\n(Curry\u2019s paradoxical combinator \\(\\mathbf{Y}\\) does not have\nthis property.) \n\n\nBelow is a table of notational conventions employed in this entry.\n\n\nNotation\nReading & Comments \n\n\\(MN\\)\nThe application of the function \\(M\\) to the argument \\(N\\).\n\n\nUsually, parentheses are used to separate the function from the\nargument, like so: \u2018\\(M(N)\\)\u2019. However, in\n\\(\\lambda\\)-calculus and kindred subjects the parentheses are used as\ngrouping symbols. Thus, it is safe to write the function and the\nargument adjacent to one other. \n\n\\(PQR\\)\nThe application of the function \\(PQ\\)\u2014which is itself the\napplication of the function \\(P\\) to the argument \\(Q\\)\u2014to\n\\(R\\).\n\n\nIf we do not use parentheses to separate function and argument, how\nare we to disambiguate expressions that involve three or more terms,\nsuch as \u2018\\(PQR\\)\u2019? Recall our convention that we are to\nunderstand such officially illegal expressions by working from left to\nright, always putting parentheses around adjacent terms. Thus,\n\u2018\\(PQR\\)\u2019 is to be understood as \\((PQ)R\\).\n\u2018\\(PQRS\\)\u2019 is \\(((PQ)R)S\\). The expression\n\u2018\\((PQ)R\\)\u2019 is disambiguated; by our convention, it is\nidentical to \\(PQR\\). The expression \u2018\\(P(QR)\\)\u2019 is also\nexplicitly disambiguated; it is distinct from \\(PQR\\) because it is\nthe application of \\(P\\) to the argument \\(QR\\) (which is itself the\napplication of the function \\(Q\\) to the argument \\(R)\\).\n\n\n\\((\\lambda x[M])\\)\nThe \\(\\lambda\\) term that binds the\nvariable \\(x\\) in the \\(\\boldsymbol{body}\\) term \\(M\\).\n\n\nThe official vocabulary of the \\(\\lambda\\)-calculus consists of the\nsymbol \u2018\\(\\lambda\\)\u2019, left \u2018(\u2019and right\n\u2018)\u2019 parentheses, and a set of variables (assumed to be\ndistinct from the three symbols \u2018\\(\\lambda\\)\u2019,\n\u2018(\u2019, and \u2018)\u2019 lest we have syntactic\nchaos).\n\nAlternative notation. It is not necessary to include\ntwo kinds of grouping symbols (parentheses and square brackets) in the\nsyntax. Parentheses or square brackets alone would obviously suffice.\nThe two kinds of brackets are employed in this entry for the sake of\nreadability. Given the two kinds of grouping symbols, we could\neconomize further and omit the parentheses from abstraction terms, so\nthat \u2018\\((\\lambda x[M]\\))\u2019 would be written as\n\u2018\\(\\lambda x[M]\\)\u2019.\n\nSome authors write \u2018\\(\\lambda x.M\\)\u2019 or \u2018\\(\\lambda\nx\\cdot M\\)\u2019, with a full stop or a centered dot separating the\nbound variable from the body of the abstraction term. As with the\nsquare brackets, these devices are intended to assist reading\n\\(\\lambda\\)-terms; they are usually not part of the official syntax.\n(One sees this device used in earlier works of logic, such as\nPrincipia Mathematica, where the function of the symbol\n. in expressions such as \u2018\\(\\forall\nx\\).\\(\\phi\\)\u2019 is to get us to read the whole of\nthe formula \\(\\phi\\) as under the scope of the \\(\\forall x\\).)\n\nSome authors write abstraction terms without any device separating the\nbound variable from the body: such terms are crisply written as, e.g.,\n\u2018\\(\\lambda xx\\)\u2019, \u2018\\(\\lambda yx\\)\u2019. The\npractice is not without its merits: it is about as concise as one can\nask for, and permits an even simpler official syntax of the\n\\(\\lambda\\)-calculus. But this practice is not flawless. In\n\u2018\\(\\lambda xyz\\)\u2019, is the bound variable \\(x\\) or is it\n\\(xy\\)? Usually the names of variables are single letters, and\ntheoretically this is clearly sufficient. But it seems unduly\nrestrictive to forbid the practice of giving longer names to\nvariables; indeed, such constructions arise naturally in computer\nprogramming languages.\n\nFor the sake of uniformity, we will adopt the square bracket notation\nin this entry. (Incidentally, this notation is used in (Turing,\n1937).)  \n\n\\(M[x := A]\\)\nThe \\(\\lambda\\)-term that is obtained by substituting the\n\\(\\lambda\\)-term A for all free occurrences of \\(x\\) inside \\(M\\).\n\n\nA bewildering array of notations to represent substitution can be\nfound in the literature on \\(\\lambda\\)-calculus and kindred\nsubjects: \n\\[\nM[x/A], M[A/x], M_{x}^A, M_{A}^x, [x/A]M,\\ldots\n\\]\n\n\nWhich notation to use for substitution seems to be a personal matter.\nIn this entry we use a linear notation, eschewing superscripts and\nsubscripts. The practice of representing substitution with\n\u2018:=\u2019 comes from computer science, where \u2018:=\u2019\nis read in some programming languages as assigning a value to a\nvariable.\n\nAs with the square brackets employed to write abstraction terms, the\nsquare brackets employed to write substitution are not officially part\nof the syntax of the \\(\\lambda\\)-calculus. \\(M\\) and A are terms,\n\\(x\\) is a variable; \\(M[x := A]\\) is another term.  \n\n\\(M \\equiv N\\)\nThe \\(\\lambda\\)-terms \\(M\\) and \\(N\\) are identical: understood\nas sequences of symbols, \\(M\\) and \\(N\\) have the same length and\ncorresponding symbols of the sequences are identical.\n\n\nThe syntactic identity relation \\(\\equiv\\) is not part of the official\nsyntax of \\(\\lambda\\)-calculus; this relation between\n\\(\\lambda\\)-terms belongs to the metatheory of \\(\\lambda\\)-calculus.\nIt is clearly a rather strict notion of equality between\n\\(\\lambda\\)-terms. Thus, it is not the case (if \\(x\\) and \\(y\\) are\ndistinct variables) that \\(\\lambda x[x] \\equiv\n\\lambda y[y]\\), even though these two terms clearly\n\u2018behave\u2019 in the same way in the sense that both are\nexpressions of the identity operation \\(x \\Rightarrow x\\). Later we\nwill develop formal theories of equality of \\(\\lambda\\)-terms with the\naim of capturing this intuitive equality of \\(\\lambda x[x]\\) and\n\\(\\lambda y[y]\\). \n\n3. Brief history of \\(\\lambda\\)-calculus\n\n\\(\\lambda\\)-calculus arose from the study of functions as rules.\nAlready the essential ingredients of the subject can be found in\nFrege\u2019s pioneering work (Frege, 1893). Frege observed, as we did\nabove, that in the study of functions it is sufficient to focus on\nunary functions (i.e., functions that take exactly one argument). (The\nprocedure of viewing a multiple-arity operation as a sequence of\nabstractions that yield an equivalent unary operation is called\ncurrying the operation. Perhaps it would be\nmore historically accurate to call the operation\nfregeing, but there are often miscarriages\nof justice in the appellation of mathematical ideas.) In the 1920s,\nthe mathematician Moses Sch\u00f6nfinkel took the subject further with\nhis study of so-called combinators. As was common in the\nearly days of the subject, Sch\u00f6nfinkel was interested in the\nkinds of transformations that one sees in formal logic, and his\ncombinators were intended to be a contribution to the foundations of\nformal logic. By analogy with the reduction that one sees in classical\npropositional logic with the Sheffer stroke, Sch\u00f6finkel\nestablished the astonishing result that the all functions (in the\nsense of all transformations) could be given in terms of the\ncombinators \\(\\mathbf{K}\\) and \\(\\bS\\); later we will see the\ndefinition of these combinators.\n\nTheorem For every term \\(M\\) made up of\n\\(\\mathbf{K}\\) and \\(\\bS\\) and the variable \\(x\\), there exists a term\n\\(F\\) (built only from \\(\\mathbf{K}\\) and \\(\\bS)\\) such that we can\nderive \\(Fx = M\\).\n\n(The proof that these two suffice to represent all functions is beyond\nthe scope of this entry. For further discussion, see the entry on\n combinatory logic.)\n One can prove the theorem constructively: there is an algorithm that,\ngiven \\(M\\), produces the required \\(F\\). Church called this \\(F\\)\n\u2018\\(\\lambda x[M]\\)\u2019 (Church,\n 1932).[3]\n From this perspective, the \\(\\beta\\)-rule can be justified: if\n\u2018\\(\\lambda x[M]\\)\u2019 is to be a function \\(F\\) satisfying\n\\(Fx = M\\), then \\(\\lambda x[M]\\)x should transform to \\(M\\). This is\njust a special case of the more general principle that for all \\(N,\n(\\lambda x[M])N\\) should transform to \\(M[x := N]\\).\n\nAlthough today we have more clearly delimited systems of abstraction\nand rewriting, in its early days \\(\\lambda\\)-calculus and combinatory\nlogic (\u00e0 la Sch\u00f6nfinkel) were bound up with investigations\nof foundations of mathematics. In the hands of Curry, Church, Kleene,\nand Rosser (some of the pioneers in the subject) the focus was on\ndefining mathematical objects and carrying out logical reasoning\ninside the these new systems. It turned out that these early attempts\nat so-called illative \\(\\lambda\\)-calculus and combinatory logic were\ninconsistent. Curry isolated and polished the inconsistency; the\nresult is now known as Curry\u2019s paradox. See the entry on\n Curry\u2019s paradox\n and appendix B of (Barendregt, 1985).\n\nThe \\(\\lambda\\)-calculus earns a special place in the history of logic\nbecause it was the source of the first undecidable problem. The\nproblem is: given \\(\\lambda\\)-terms \\(M\\) and \\(N\\), determine whether\n\\(M = N\\). (A theory of equational reasoning\nabout \\(\\lambda\\)-terms has not yet been defined; the definition will\ncome later.) This problem was shown to be undecidable.\n\nAnother early problem in the \\(\\lambda\\)-calculus was whether it is\nconsistent at all. In this context, inconsistency means that all terms\nare equal: one can reduce any \\(\\lambda\\)-term \\(M\\) to any other\n\\(\\lambda\\)-term \\(N\\). That this is not the case is an early result\nof \\(\\lambda\\)-calculus. Initially one had results showing that\ncertain terms were not interconvertible (e.g., \\(\\mathbf{K}\\) and\n\\(\\bS)\\); later, a much more powerful result, the so-called\nChurch-Rosser theorem, helped shed more light on \\(\\beta\\)-conversion\nand could be used to give quick proofs of the non-inter-convertibility\nof whole classes of \\(\\lambda\\)-terms. See below for more detailed\ndiscussion of consistency.\n\nThe \\(\\lambda\\)-calculus was a somewhat obscure formalism until the\n1960s, when, at last, a \u2018mathematical\u2019 semantics was\nfound. Its relation to programming languages was also clarified. Till\nthen the only models of \\(\\lambda\\)-calculus were\n\u2018syntactic\u2019, that is, were generated in the style of\nHenkin and consisted of equivalence classes of \\(\\lambda\\)-terms (for\nsuitable notions of equivalence). Applications in the semantics of\nnatural language, thanks to developments by Montague and other\nlinguists, helped to \u2018spread the word\u2019 about the subject.\nSince then the \\(\\lambda\\)-calculus enjoys a respectable place in\nmathematical logic, computer science, linguistics (see, e.g., Heim and\nKratzer 1998), and kindred fields.\n4. Reduction\n\nVarious notions of reduction for \\(\\lambda\\)-terms are available, but\nthe principal one is \\(\\beta\\)-reduction, which we have already seen\nearlier. Earlier we used the notation \u2018\\(\\rhd\\)\u2019; we can\nbe more precise. In this section we discuss \\(\\beta\\)-reduction and\nsome extensions.\n\n\nDefinition (one-step \\(\\beta\\)-reduction\n\\(\\rhd_{\\beta ,1})\\) For \\(\\lambda\\)-terms \\(A\\) and \\(B\\), we say\nthat \\(A\\) \\(\\beta\\)-reduces in one step to \\(B\\), written \\(A\n\\rhd_{\\beta ,1} B\\), just in case there exists an (occurrence of a)\nsubterm \\(C\\) of \\(A\\), a variable \\(x\\), and \\(\\lambda\\)-terms \\(M\\)\nand \\(N\\) such that \\(C \\equiv(\\lambda x[M])N\\) and \\(B\\) is \\(A\\)\nexcept that the occurrence of \\(C\\) in \\(A\\) is replaced by \\(M[x :=\nN]\\).\n\n\nHere are some examples of \\(\\beta\\)-reduction:\n\n\n\nThe variable \\(x\\) does not \\(\\beta\\)-reduce to anything. (It does not\nhave the right shape: it is simply a variable, not an application term\nwhose left-hand side is an abstraction term.)\n\n\n\\((\\lambda x[x])a \\rhd_{\\beta ,1} a\\).\n\n\nIf \\(x\\) and \\(y\\) are distinct variables, then \\((\\lambda x[y])a\n\\rhd_{\\beta ,1} y\\).\n\n\nThe \\(\\lambda\\)-term \\((\\lambda x[(\\lambda y[xy])a])b]\\)\n\\(\\beta\\)-reduces in one step to two different \\(\\lambda\\)-terms:\n\n\\[\n(\\lambda x[(\\lambda y[xy])a])b \\rhd_{\\beta ,1} (\\lambda y[by])a\n\\]\n\n\nand \n\\[\n(\\lambda x[(\\lambda y[xy])a])b \\rhd_{\\beta ,1} (\\lambda x[xa])b\n\\]\n\n\nMoreover, one can check that these two terms \\(\\beta\\)-reduce in one\nstep to a common term: \\(ba\\). We thus have:\n\n\n\n\n\\((\\lambda y[by])a\\)\n\n \n\n\n\\(\\nearrow\\)\n\n\\(\\searrow\\)\n \n\n\\((\\lambda x[(\\lambda y[xy])a])b\\)\n\n\n\n\\(ba\\) \n\n\n\\(\\searrow\\)\n\n\\(\\nearrow\\)\n \n\n\n\n\\((\\lambda x[xa])b\\)\n\n \n \n\n\nAs with any binary relation, one can ask many questions about the\nrelation \\(\\rhd_{\\beta ,1}\\) holding between \\(\\lambda\\)-terms, and\none can define various derived notions in terms of \\(\\rhd_{\\beta\n,1}\\).\n\n\nDefinition A \\(\\beta\\)-reduction\nsequence from a \\(\\lambda\\)-term \\(A\\) to a\n\\(\\lambda\\)-term \\(B\\) is a finite sequence \\(s_1 , \\ldots s_n\\) of\n\\(\\lambda\\)-terms starting with \\(A\\), ending with \\(B\\), and whose\nadjacent terms \\((s_k,s_{k+1})\\) satisfy the property that \\(s_k\n\\rhd_{\\beta ,1} s_{k+1}\\).\n\nMore generally, any sequence \\(s\\)\u2014finite or\ninfinite\u2014starting with a \\(\\lambda\\)-term \\(A\\) is said to be a\n\\(\\beta\\)-reduction sequence commencing with \\(A\\) provided that the\nadjacent terms \\((s_k,s_{k+1})\\) of \\(s\\) satisfy the property that\n\\(s_k \\rhd_{\\beta ,1} s_{k+1}\\).\n\n\n\n\nContinuing with \\(\\beta\\)-reduction Example 1, there are no\n\\(\\beta\\)-reduction sequences at all commencing with the variable\n\\(x\\).\n\n\nContinuing with \\(\\beta\\)-reduction Example 2, the two-term\nsequence \n\\[\n(\\lambda x[x])a, a\n\\]\n\n\nis a \\(\\beta\\)-reduction sequence from \\((\\lambda x[x])a\\) to \\(a\\).\nIf \\(a\\) is a variable, then this \\(\\beta\\)-reduction sequence cannot\nbe prolonged, and there are no other \\(\\beta\\)-reduction sequences\ncommencing with \\((\\lambda x[x])a\\); thus, the set of\n\\(\\beta\\)-reduction sequences commencing with \\((\\lambda x[x])a\\) is\nfinite and contains no infinite sequences.\nThe combinator\n\\(\\boldsymbol{\\Omega}\\) has the curious property that \\(\\Omega\n\\rhd_{\\beta ,1} \\Omega\\). Every term of every \\(\\beta\\)-reduction\nsequence commencing with \\(\\boldsymbol{\\Omega}\\) (finite or infinite)\nis equal to \\(\\boldsymbol{\\Omega}\\).\n\n\nConsider the term \\(\\mathbf{K}a\\boldsymbol{\\Omega}\\). There are\ninfinitely many reduction sequences commencing with this term:\n\n\\(\\bK a\\boldsymbol{\\Omega} \\rhd_{\\beta ,1} a\\)\n\\(\\bK a\\boldsymbol{\\Omega} \\rhd_{\\beta ,1} \\bK\na\\boldsymbol{\\Omega} \\rhd_{\\beta ,1} a\\)\n\\(\\bK a\\boldsymbol{\\Omega} \\rhd_{\\beta ,1} \\bK\na\\boldsymbol{\\Omega} \\rhd_{\\beta ,1} \\bK a\\boldsymbol{\\Omega}\n\\rhd_{\\beta ,1} a\\)\n\\(\\bK a\\boldsymbol{\\Omega} \\rhd_{\\beta ,1} \\bK\na\\boldsymbol{\\Omega} \\rhd_{\\beta ,1} \\bK a\\boldsymbol{\\Omega}\n\\ldots\\)\n\n\nIf \\(a\\) is a variable, one can see that all finite reduction\nsequences commencing with \\(\\bK a\\boldsymbol{\\Omega}\\) end at \\(a\\),\nand there is exactly one infinite reduction sequence. \n\n\nDefinition A\n\\(\\beta\\)-redex of a \\(\\lambda\\)-term \\(M\\)\nis (an occurrence of) a subterm of \\(M\\) of the form \\((\\lambda\nx[P])Q\\). (\u2018redex\u2019 comes from \u2018reducible\nexpression.) A \\(\\beta\\)-redex is simply a candidate for an\napplication of \\(\\beta\\)-reduction. Doing so, one\ncontracts the \\(\\beta\\)-redex. A term is\nsaid to be in \\(\\beta\\)-normal form if it\nhas no \\(\\beta\\)-redexes.\n\n(Can a term have multiple \\(\\beta\\)-normal forms? The answer is\nliterally \u2018yes\u2019, but substantially the answer is\n\u2018no\u2019: If a \\(M\\) and \\(M'\\) are \\(\\beta\\)-normal forms of\nsome term, then \\(M\\) is \\(\\alpha\\)-convertible to \\(M'\\) Thus,\n\\(\\beta\\)-normal forms are unique up to changes of bound\nvariables.)\n\nSo far we have focused only on one step of \\(\\beta\\)-reduction. One\ncan combine multiple \\(\\beta\\)-reduction steps into one by taking the\ntransitive closure of the relation \\(\\rhd_{\\beta ,1}\\).\n\n\nDefinition For \\(\\lambda\\)-terms \\(A\\) and \\(B\\), one\nsays that \\(A\\) \\(\\beta\\)-reduces to \\(B\\),\nwritten \\(A \\rhd_{\\beta} B\\), if either \\(A \\equiv B\\) or there exists\na finite \\(\\beta\\)-reduction sequence from \\(A\\) to \\(B\\).\n\nDefinition A term \\(M\\) has a\n\\(\\beta\\)-normal form if there exists a term \\(N\\) such\nthat \\(N\\) is in \\(\\beta\\)-normal form an \\(M \\rhd_{\\beta} N\\).\n\n\nReducibility as defined is a one-way relation: it is generally not\ntrue that if \\(A \\rhd_{\\beta} B\\), then \\(B \\rhd_{\\beta} A\\). However,\ndepending on one\u2019s purposes, one may wish to treat \\(A\\) and\n\\(B\\) as equivalent if either \\(A\\) reduces to \\(B\\) or \\(B\\) reduces\nto \\(A\\). Doing so amounts to considering the reflexive, symmetric,\nand transitive closure of the relation \\(\\rhd_{\\beta ,1,}\\).\n\nDefinition For \\(\\lambda\\)-terms \\(A\\) and \\(B\\), we\nsay that \\(A =_{\\beta} B\\) if either \\(A \\equiv B\\) or there exists a\nsequence \\(s_1 , \\ldots s_n\\) starting with \\(A\\), ending with \\(B\\),\nand whose adjacent terms \\((s_k,s_{k+1})\\) are such that either \\(s_k\n\\rhd_{\\beta ,1} s_{k+1}\\) or \\(s_{k+1} \\rhd_{\\beta ,1} s_k\\).\n4.1 Other notions of reduction\n\nWe have thus far developed the theory of \\(\\beta\\)-reduction. This is\nby no means the only notion of reduction available in the\n\\(\\lambda\\)-calculus. In addition to \\(\\beta\\)-reduction, a standard\nrelation between \\(\\lambda\\)-terms is that of\n\\(\\eta\\)-reduction:\n\n\nDefinition (one-step \\(\\eta\\)-reduction) For\n\\(\\lambda\\)-terms \\(A\\) and \\(B\\), we say that \\(A\\) \\(\\beta\n\\eta\\)-reduces in one step to \\(B\\), written \\(A \\rhd_{\\beta \\eta ,1}\nB\\), just in case there exists an (occurrence of a) subterm \\(C\\) of\n\\(A\\), a variable \\(x\\), and \\(\\lambda\\)-terms \\(M\\) and \\(N\\) such\nthat either\n\n\\(C \\equiv(\\lambda x[M])N\\) and \\(B\\) is \\(A\\) except that the\noccurrence of \\(C\\) in \\(A\\) is replaced by \\(M[x := N]\\)\n\nor\n\n\\(C \\equiv(\\lambda x[Mx]\\)) and \\(B\\) is \\(A\\) except that the\noccurrence of \\(C\\) in \\(A\\) is replaced by \\(M\\).\n\n\nThe first clause in the definition of \\(\\rhd_{\\beta \\eta ,1}\\) ensures\nthat the relation extends the relation of one-step\n\\(\\beta\\)-reduction. As we did for the relation of one-step\n\\(\\beta\\)-reduction, we can replay the development for\n\\(\\eta\\)-reduction. Thus, one has the notion of an \\(\\eta\\)-redex, and\nfrom \\(\\rhd_{\\eta ,1}\\) one can define the relation \\(\\rhd_{\\eta}\\)\nbetween \\(\\lambda\\)-terms as the reflexive and transitive closure of\n\\(\\rhd_{\\eta ,1}\\), which captures zero-or-more-steps of\n\\(\\eta\\)-reduction. Then one defines \\(=_{\\eta}\\) as the symmetric and\ntransitive closure of \\(\\rhd_{\\eta}\\).\n\nIf \\(A \\rhd_{\\eta ,1} B\\), then the length of \\(B\\) is strictly\nsmaller than that of \\(A\\). Thus, there can be no infinite\n\\(\\eta\\)-reductions. This is not the case of \\(\\beta\\)-reduction, as\nwe saw above in\n \\(\\beta\\)-reduction sequence examples 3\n and\n 4.\n\nOne can combine notions of reduction. One useful combination is to\nblend \\(\\beta\\)- and \\(\\eta\\)-reduction.\n\nDefinition (one-step \\(\\beta \\eta\\)-reduction)\n\\(\\lambda x[Mx] \\rhd_{\\beta \\eta ,1} M\\) and \\((\\lambda x[M]N))\n\\rhd_{\\beta \\eta ,1} M[x := N]\\). A \\(\\lambda\\)-term \\(A\\) \\(\\beta\n\\eta\\)-reduces in one step to a \\(\\lambda\\)-term \\(B\\) just in case\neither \\(A\\) \\(\\beta\\)-reduces to \\(B\\) in one step or \\(A\\)\n\\(\\eta\\)-reduces to \\(B\\) in one step.\n\nAgain, one can replay the basic concepts of reduction, as we did for\n\\(\\beta\\)-reduction, for this new notion of reduction \\(\\beta\n\\eta\\).\n4.2 Reduction strategies\n\nRecall that a term is said to be in \\(\\beta\\)-normal form if it has no\n\\(\\beta\\)-redexes, that is, subterms of the shape \\((\\lambda x[M]\\))N.\nA term has a \\(\\beta\\)-normal form if it can be reduced to a term in\n\\(\\beta\\)-normal form. It should be intuitively clear that if a term\nhas a \\(\\beta\\)-normal form, then we can find one by exhaustively\ncontracting all all \\(\\beta\\)-redexes of the term, then exhaustively\ncontracting all \\(\\beta\\)-redexes of all resulting terms, and so\nforth. To say that a term has a \\(\\beta\\)-normal form amounts to\nsaying that this blind search for one will eventually terminate.\n\nBlind search for \\(\\beta\\)-normal forms is not satisfactory. In\naddition to be aesthetically unpleasant, it can be quite inefficient:\nthere may not be any need to exhaustively contract all\n\\(\\beta\\)-redexes. What is wanted is a\nstrategy\u2014preferably, a computable one\u2014for finding\na \\(\\beta\\)-normal form. The problem is to effectively decide, if\nthere are multiple \\(\\beta\\)-redexes of a term, which ought to be\nreduced.\n\nDefinition A \\(\\beta\\)-reduction\nstrategy is a function whose domain is the set of all\n\\(\\lambda\\)-terms and whose value on a term \\(M\\) not in\n\\(\\beta\\)-normal form is a redex subterm of \\(M\\), and whose value on\nall terms M in \\(\\beta\\)-normal form is simply \\(M\\).\n\nIn other words, a \\(\\beta\\)-reduction strategy selects, whenever a\nterm has multiple \\(\\beta\\)-redexes, which one should be contracted.\n(If a term is in \\(\\beta\\)-normal form, then nothing is to be done,\nwhich is why we require in the definition of \\(\\beta\\)-reduction\nstrategy that it does not change any term in \\(\\beta\\)-normal form.)\nOne can represent a strategy \\(S\\) as a relation \\(\\rhd_S\\) on\n\\(\\lambda\\)-terms, with the understanding that \\(M \\rhd_S N\\) provided\nthat \\(N\\) is obtained from \\(M\\) in one step by adhering to the\nstrategy S. When viewed as relations, strategies constitute a\nsubrelation of \\(\\rhd_{\\beta ,1}\\).\n\nA \\(\\beta\\)-reduction strategy may or may not have the property that\nadhering to the strategy will ensure that we (eventually) reach a\n\\(\\beta\\)-normal form, if one exists.\n\nDefinition A \\(\\beta\\)-reduction strategy \\(S\\) is\nnormalizing if for all \\(\\lambda\\)-terms\n\\(M\\), if \\(M\\) has a \\(\\beta\\)-normal form \\(N\\), then the sequence\n\\(M, S(M), S(S(M)),\\ldots\\) terminates at \\(N\\).\n\nSome \\(\\beta\\)-reduction strategies are normalizing, but others are\nnot.\n\nThe rightmost strategy, whereby we\nalways choose to reduce the rightmost \\(\\beta\\)-redex (if there are\nany \\(\\beta\\)-redexes) is not normalizing. Consider, for example, the\nterm KI\\(\\Omega\\). This term has two\n\\(\\beta\\)-redexes: itself, and \\(\\Omega\\) (which,\nrecall, is the term\n\\(\\omega\\omega\\equiv(\\lambda\\)x[\\(xx])(\\lambda\\)x[\\(xx]\\))). By\nworking with left-hand \\(\\beta\\)-redexes, we can \\(\\beta\\)-reduce\nKI\\(\\Omega\\) to \\(\\mathbf{I}\\) in two steps. If we\ninsist on working with the rightmost \\(\\beta\\)-redex\n\\(\\Omega\\) we reduce KI(\\(\\Omega\\))\nto \\(\\mathbf{KI}\\)(\\(\\Omega \\)), then\n\\(\\mathbf{KI}\\)(\\(\\Omega\\)), \u2026.\nThe leftmost strategy, whereby we always\nchoose to reduce the leftmost \\(\\beta\\)-redex (if there are any\n\\(\\beta\\)-redexes) is normalizing. The proof of this fact is beyond\nthe scope of this entry; see (Barendregt, 1985, section 13.2) for\ndetails.\n\n\nOnce we have defined a reduction strategy, it is natural to ask\nwhether one can improve it. If a term has a \\(\\beta\\)-normal form,\nthen a strategy will discover a normal form; but might there be a\nshorter \\(\\beta\\)-reduction sequence that reaches the same normal form\n(or a term that is \\(\\alpha\\)-convertible to that normal form)? This\nis the question of optimality. Defining optimal strategies\nand showing that they are optimal is generally considerably more\ndifficult than simply defining a strategy. For more discussion, see\n(Barendregt, 1984 chapter 10).\n\nFor the sake of concreteness, we have discussed only\n\\(\\beta\\)-reduction strategies. But in the definitions above the\nnotion of reduction \\(\\beta\\) is but one possibility. For any notion\n\\(R\\) of reduction we have the associated theory of \\(R\\)-reduction\nstrategies, and one can replay the problems of normalizability,\noptimality, etc., for \\(R\\).\n5. \\(\\lambda\\)-theories\n\nWe discussed earlier how the \\(\\lambda\\)-calculus is a non-extensional\ntheory of functions. If, in the non-extensional spirit, we understand\n\\(\\lambda\\)-terms as descriptions, how should we treat equality of\n\\(\\lambda\\)-terms? Various approaches are available. In this section,\nlet us treat the equality relation = as a primitive, undefined\nrelation holding between two \\(\\lambda\\)-terms, and try to\naxiomatize the properties that equality should have. The task\nis to identity axioms and formulate suitable rules of\ninference concerning the equality of\n\\(\\lambda\\)-terms.\n\nSome obvious properties of equality, having nothing to do with\n\\(\\lambda\\)-calculus, are as follows: \n\\[\\tag{Reflexivity}\n\\frac{}{X=X}\n\\]\n \n\\[\\tag{Symmetry}\n\\frac{X=Y}{Y=X}\n\\]\n\n\\[\\tag{Transitivity}\n\\frac{X=Y \\quad Y=Z}{X=Z}\n\\]\n\n\nAs is standard in proof theory, the way to read these rules of\ninference is that above the horizontal rule \\(\\frac{}{\\phantom{X=X}}\\)\nare the premises of the rule (which are\nequations) and the equation below the horizontal rule is the\nconclusion of the rule of inference. In the\ncase of the reflexivity rule, nothing is written above the horizontal\nrule. We understand such a case as saying that, for all terms \\(X\\),\nwe may infer the equation \\(X = X\\) from no premises.\n5.1 The basic theory \\(\\lambda\\)\n\nThe three rules of inference listed in the previous section governing\nequality have nothing to do with the \\(\\lambda\\)-calculus. The\nfollowing lists rules of inference that relate the undefined notion of\nequality and the two term-building operations of the\n\\(\\lambda\\)-calculus, application and abstraction. \n\\[\n\\frac{M=N}{AM=AN} \\quad \\frac{M=N}{MA=NA}\n\\]\n\n\\[\n\\tag{\\(\\boldsymbol{\\xi}\\)}\n\\frac{M=N}{\\lambda x[M] = \\lambda x[N]}\n\\]\n\n\nTogether, these rules of inference say that = is a\ncongruence relation on the set of\n\\(\\lambda\\)-terms: it \u2018preserves\u2019 both the application and\nabstraction term-building operations\n\nThe final rule of inference, \\(\\beta\\)-conversion, is the most\nimportant: \n\\[\\tag{\\(\\boldsymbol{\\beta}\\)}\n\\frac{}{(\\lambda x[M])A = M[x := A]}\n\\]\n\n\nAs before with the reflexivity rule, the rule \\(\\boldsymbol{\\beta}\\)\nhas no premises: for any variable \\(x\\) and any terms \\(M\\) and \\(A\\),\none can infer the equation \\((\\lambda x[M])A = M[x := A]\\) at any\npoint in a formal derivation in the theory\n\\(\\boldsymbol{\\lambda}\\).\n5.2 Extending the basic theory \\(\\lambda\\)\n\nA number of extensions to \\(\\boldsymbol{\\lambda}\\) are available.\nConsider, for example, the rule (\\(\\boldsymbol{\\eta}\\)), which\nexpresses the principle of \\(\\eta\\)-reduction as a rule of\ninference: \n\\[\\tag{\\(\\boldsymbol{\\eta}\\)}\n\\frac{}{\\lambda x[Mx] = M} \\text{ provided } x \\not\\in \\mathbf{FV}(M)\n\\]\n\n\nRule \\(\\boldsymbol{\\eta}\\) tells us that a certain kind of abstraction\nis otiose: it is safe to identify \\(M\\) with the function that, given\nan argument \\(x\\), applies \\(M\\) to \\(x\\). Through this rule we can\nalso see that all terms are effectively functions. One can intuitively\njustify this rule using the principle of \\(\\beta\\)-reduction.\n\n\\[\\tag{\\(\\mathbf{Ext}\\)}\n\\frac{Mx=Nx}{M=N}\\text{ provided } x \\not\\in \\mathbf{FV}(M) \\cup \\mathbf{FV}(N)\n\\]\n\n\nOne can view rule \\(\\mathbf{Ext}\\) as a kind of generalization\nprinciple. If we have derived that \\(Mx = Nx\\), but \\(x\\) figures in\nneither \\(M\\) nor \\(N\\), then we have effectively shown that \\(M\\) and\n\\(N\\) are alike. Compare this principle to the principle of universal\ngeneralization in first-order logic: if we have derived \\(\\phi(x)\\)\nfrom a set \\(\\Gamma\\) of hypotheses in which \\(x\\) is not free, then\nwe can conclude that \\(\\Gamma\\) derives \\(\\forall x\\phi\\).\n\nAnother productive principle in the \\(\\lambda\\)-calculus permits us to\nidentify terms that \u2018act\u2019 the same: \n\\[\\tag{\\(\\boldsymbol{\\omega}\\)}\n\\frac{\\text{For all terms }x, Mx=Nx}{M=N}\n\\]\n\n\nThe rule \\(\\boldsymbol{\\omega}\\) has infinitely many hypotheses: on\nthe assumption that \\(Mx = Nx\\), no matter what \\(x\\) may be, then we\ncan conclude that \\(M = N\\). The \\(\\boldsymbol{\\omega}\\) rule is an\nanalogue in the \\(\\lambda\\)-calculus of the rule of inference under\nthe same name in formal number theory, according to which one can\nconclude the universal formula \\(\\forall x\\phi\\) provided one has\nproofs for \\(\\phi(x := \\mathbf{0}), \\phi(x := \\mathbf{1}),\\ldots\\) .\nNote that unlike the rule \\(\\mathbf{Ext}\\), the condition that \\(x\\)\nnot occur freely in \\(M\\) or \\(N\\) does not arise.\n6. Consistency of the \\(\\lambda\\)-calculus\n\nIs the \\(\\lambda\\)-calculus consistent? The question might not be\nwell-posed. The \\(\\lambda\\)-calculus is not a logic for reasoning\nabout propositions; there is no apparent notion of contradiction\n\\((\\bot)\\) or a method of forming absurd propositions (e.g., \\(p\n\\wedge \\neg p)\\). Thus \u2018inconsistency\u2019 of the\n\\(\\lambda\\)-calculus cannot mean that \\(\\bot\\), or some formula\ntantamount to \\(\\bot\\), is derivable. A suitable notion of\n\u2018consistent\u2019 is, however, available. Intuitively, a logic\nis inconsistent if it permits us to derive too much. The theory\n\\(\\lambda\\) is a theory of equations. We can thus\ntake inconsistency of \\(\\lambda\\) to mean: all\nequations are derivable. Such a property, if it were true of\n\\(\\lambda\\), would clearly show that\n\\(\\lambda\\) is of little use as a formal theory.\n\nEarly formulations of the idea of \\(\\lambda\\)-calculus by A. Church\nwere indeed inconsistent; see (Barendregt, 1985, appendix 2) or\n(Rosser, 1985) for a discussion. To take a concrete problem: how do we\nknow that the equation \\(\\bK = \\mathbf{I}\\) is not a theorem of\n\\(\\lambda\\)? The two terms are obviously intuitively\ndistinct. \\(\\bK\\) is a function of two arguments, whereas\n\\(\\mathbf{I}\\) is a function of one argument. If we could show that\n\\(\\bK = \\mathbf{I}\\), then we could show that \\(\\mathbf{KK} =\n\\mathbf{IK}\\), whence \\(\\mathbf{KK} = \\bK\\) would be a theorem of\n\\(\\lambda\\), along with many other equations that\nstrike us as intuitively unacceptable. But when we\u2019re\ninvestigating a formal theory such as \\(\\lambda\\),\nintuitive unacceptability by no means implies underivability. What is\nmissing is a deeper understanding of \\(\\beta\\)-reduction.\n\nAn early result that gave such an understanding is known as the\nChurch-Rosser theorem:\n\nTheorem (Church-Rosser) If \\(P \\rhd_{\\beta} Q\\) and\n\\(P \\rhd_{\\beta}\\) R, then there exists a term \\(S\\) such that both\n\\(Q \\rhd_{\\beta} S\\) and \\(R \\rhd_{\\beta} S\\).\n\n(The proof of this theorem is quite non-trivial and is well-beyond the\nscope of this entry.) The result is a deep fact about\n\\(\\beta\\)-reduction. It says that no matter how we diverge from \\(P\\)\nby \\(\\beta\\)-reductions, we can always converge again to a common\nterm.\n\nThe Church-Rosser theorem gives us, among other things, that the plain\n\\(\\lambda\\)-calculus\u2014that is, the theory\n\\(\\lambda\\) of equations between\n\\(\\lambda\\)-terms\u2014is consistent, in the sense that not all\nequations are derivable.\n\nAs an illustration, we can use the Church-Rosser theorem to solve the\nearlier problem of showing that the two terms \\(\\bK\\) and\n\\(\\mathbf{I}\\) are not identified by \\(\\lambda\\). The\ntwo terms are in \\(\\beta\\)-normal form, so from them there are no\n\\(\\beta\\)-reduction sequences at all. If \\(\\bK = \\mathbf{I}\\) were a\ntheorem of \\(\\lambda\\), then there would be a term\n\\(M\\) from which there is a \\(\\beta\\)-reduction path to both\n\\(\\mathbf{I}\\) and \\(\\bK\\). The Church-Rosser theorem then implies the\ntwo paths diverging from \\(M\\) can be merged. But this is impossible,\nsince \\(\\bK\\) and \\(\\mathbf{I}\\) are distinct \\(\\beta\\)-normal\nforms.\n\nThe Church-Rosser theorem implies the existence of \\(\\beta\\)-reduction\nsequences commencing from \\(\\bK\\) and from \\(\\mathbf{I}\\) that end at\na common term. But there are no \\(\\beta\\)-reduction sequences at all\ncommencing from \\(\\mathbf{I}\\), because it is in \\(\\beta\\)-normal\nform, and likewise for \\(\\bK\\).\n\nTheorem \\(\\lambda\\) is consistent,\nin the sense that not every equation is a theorem.\n\nTo prove the theorem, it is sufficient to produce one underivable\nequation. We have already worked through an example: we used the\nChurch-Rosser theorem to show that the equation \\(\\bK = \\mathbf{I}\\)\nis not a theorem of \\(\\lambda\\). Of course,\nthere\u2019s nothing special about these two terms. A significant\ngeneralization of this result is available: if \\(M\\) and \\(N\\) in\n\\(\\beta\\)-normal form but \\(M\\) is distinct from \\(N\\), then the\nequation \\(M = N\\) is not a theorem of\n\\(\\lambda\\). (This simple condition for\nunderivability does not generally hold if we add additional rules of\ninference to \\(\\lambda\\).) \n\nThe theories \\(\\lambda \\eta\\) and \\(\\lambda\n\\omega\\) are likewise consistent. One can prove these\nconsistency results along the lines of the consistency proof for\n\\(\\lambda\\) by extending the Church-Rosser theorem to\nthe wider senses of derivability of these theories.\n7. Semantics of \\(\\lambda\\)-calculus\n\nAs we\u2019ve said at the outset, the \\(\\lambda\\)-calculus is, at\nheart, about functions and their applications. But it is surprisingly\ndifficult to cash this idea out in semantic terms. A natural approach\nwould be to try to associate with every \\(\\lambda\\)-term \\(M\\) a\nfunction \\(f_M\\) over some domain \\(D\\) and to interpret application\nterms \\((MN)\\) using function application as \\(f_M(f_N).\\) But this\nidea quickly runs into difficulties. To begin with, it\u2019s easy to\nsee that, in this context, we can\u2019t use the standard\nset-theoretic concept of functions-as-sets (see section\n 1.2\n of this entry). According to this concept, remember, a function \\(f\\)\nis a set of argument-value pairs, where every argument gets assigned a\nunique value. The problem arises in the context of\nself-applications. Remember from section\n 2.1\n that the untyped \\(\\lambda\\)-calculus allows \\(\\lambda\\)-terms such\nas \\((xx)\\), which intuitively apply \\(x\\) to itself. On the semantic\npicture we\u2019re exploring, we can obtain the associated function\n\\(f_{(xx)}\\) for the term \\((xx)\\) by taking the function \\(f_x\\) for\n\\(x\\) and applying it to itself: \n\\[\nf_{(xx)}=f_x(f_x)\n\\]\n\n\nBut following functions-as-sets, this would mean that the set\n\\(f_x\\) needs to contain an argument-value pair that has \\(f_x\\) as\nits first component and \\(f_{(xx)}\\) as the second:  \n\\[\nf_{x}=\\{\\ldots, (f_{x},f_{(xx)})), \\ldots\\}\n\\]\n\n\nBut this would make \\(f_x\\) a non-well-founded object: defining\n\\(f_x\\) would involve \\(f_x\\) itself. In fact, sets like this are\nexcluded in standard axiomatic set theory by the axiom of foundation\n(also known as the axiom of regularity). \u2014This is further\nsemantic evidence that the concept of a function underlying\nthe \\(\\lambda\\)-calculus can\u2019t be the extensional\nfunctions-as-sets concept. \n\nBut the problem runs even deeper than that. Even when we use a\nnon-extensional notion of a function, such as the functions-as-rules\nconception (see again section\n 1.2),\n we run into difficulties. In the untyped \\(\\lambda\\)-calculus,\neverything can both be function and an argument to functions.\nCorrespondingly, we should want our domain \\(D\\) to include, in some\nsense, the function space \\(D^D\\), which contains all and only the\nfunctions with both arguments and values from \\(D\\). To see this:\n\nEvery element of \\(D\\) can be a function that applies to elements\nof \\(D\\), and what\u2019s returned can then be again be an argument\nfor elements of \\(D\\). So, every element of \\(D\\) intuitively\ncorresponds to a member of \\(D^D\\).\nIf, in turn, we take a member of \\(D^D\\), i.e., a function with\narguments and values from \\(D\\), this is precisely the kind of thing\nwe want to include in our domain \\(D\\). So, intuitively, we want every\nmember of \\(D^D\\) to correspond to a member of \\(D\\).\n\n\nIn short, we want there to be a one-to-one correspondence\nbetween our domain and its own function space, i.e., we want them to\nsatisfy the \u2018equation\u2019 \\(X\\cong X^X\\). But this is\nimpossible since it contradicts Cantor\u2019s theorem.\n\nGiven these difficulties, the question arises whether it\u2019s\npossible to give a set-theoretic model for the \\(\\lambda\\)-calculus in\nthe first place? It turns out that it is. D. Scott was the first to\ndescribe such a model in an unpublished manuscript from 1969. This\nmodel, \\(D_\\infty\\), solves the aforementioned problems with\nCantor\u2019s theorem by suitably restricting the function space\n\\(D^D\\), by only letting some members of \\(D^D\\) correspond\nto members of \\(D\\). Covering Scott\u2019s construction goes beyond\nthe scope of this entry, since it involves advanced tools from algebra\nand topology; see (Meyer 1982), (Barendregt, 1985, chapter 18.2), or\n(Hindley and Seldin, 2008, chapter 16) for details. Instead,\nwe\u2019ll discuss the more general question: What is a\nmodel for the \\(\\lambda\\)-calculus? That is, leaving aside for a\nmoment the question whether sets are functions, rules, or something\naltogether different, we ask what kind of mathematical structure a\nmodel for the \\(\\lambda\\)-calculus is in the first place.\n7.1 \\(\\lambda\\)-Models\n\nIt turns out that there are multiple, essentially equivalent, ways of\ndefining the notion of a model for the \\(\\lambda\\)-calculus; see\n(Barendregt, 1985, chapter 5) or (Hindley and Seldin, 2008, chapter\n15). In the following, we\u2019ll discuss what we consider the most\npalatable notion for philosophers familiar with the standard semantics\nfor first-order logic (see, e.g., the entry on\n Classical Logic ),\n the so-called syntactical\n\\(\\lambda\\)-models. These models first appear in the\nwork of (Hindley and Longo, 1980), (Koymans, 1982), and (Meyer 1982).\nThey derive their name from the fact that their clauses closely\ncorrespond to the syntactic rules of the calculus\n\\(\\boldsymbol{\\lambda}\\). This is somewhat unsatisfactory and\nmotivates \u2018syntax-free\u2019 definitions (see below). At the\nsame time, the syntactical \\(\\lambda\\)-models provide a fairly\ntransparent and accessible route into the world of \\(\\lambda\\)-models.\nIn addition, despite their conceptual shortcomings, syntactical models\nhave proven a technically useful tool in the semantical study of the\n\\(\\lambda\\)-calculus.\n\nIn order to avoid the set-theoretic problems mentioned above, most\ndefinitions of \\(\\lambda\\)-models use so-called\napplicative structures. The idea is to treat\nthe denotations of \\(\\lambda\\)-terms not as set-theoretic functions,\nbut as unanalyzed, first-order \u2018function-objects\u2019,\ninstead. Correspondingly, then, we treat function application as an\nunanalyzed binary operation on these function-objects:\n\n\nDefinition An applicative structure is a\npair \\((D,\\cdot)\\), where \\(D\\) is some set and \\(\\cdot\\) a binary\noperation on \\(D\\). To avoid trivial models, we usually assume that\n\\(D\\) has at least two elements.\n\n\nApplicative structures are, in a sense, first-order models of function\nspaces that satisfy the problematic equation \\(X\\cong X^X\\).\n\\(\\lambda\\)-models, in turn, are defined over them.\n\nFor the definition of our \\(\\lambda\\)-models, we work with\nvaluations\u2014a concept familiar from\nfirst-order semantics. Valuations assign denotations to the variables\nand are used primarily in the semantic clauses for the\n\\(\\lambda\\)-operator. Additionally, they can be used to express\ngeneral claims over the domain, in a way that is familiar from the\nsemantics for the first-order quantifiers \\(\\exists x\\) and \\(\\forall\nx\\).\n\n\nDefinition A valuation in an applicative\nstructure \\((D,\\cdot)\\) is a function \\(\\rho\\) that assigns an element\n\\(\\rho(x)\\in D\\) to every variable \\(x\\).\n\n\nAs a useful piece of notation, for \\(\\rho\\) a valuation in some\napplicative structure \\((D,\\cdot)\\), \\(x\\) a variable, and \\(d\\in D\\)\nan object, we define the valuation \\(\\rho[x\\mapsto d]\\) by saying\nthat: \n\\[\\rho[x\\mapsto d](y)=\\begin{cases} d & \\text{ if }y=x\\\\\n  \\rho(y) & \\text{otherwise}\\end{cases}\\]\n That is, \\(\\rho[x\\mapsto d]\\) is the result of\nchanging the value of \\(x\\) to be \\(d\\), while leaving all other other\nvalues under \\(\\rho\\) unchanged.\n\n\nDefinition A syntactical \\(\\lambda\\)-model\nis a triple \\(\\mathfrak{M}=(D,\\cdot,\\llbracket \\ \\rrbracket)\\), where\n\\((D,\\cdot)\\) is an applicative structure and \\(\\llbracket \\\n\\rrbracket\\) is a function that assigns to every \\(\\lambda\\)-term M\nand valuation \\(\\rho\\) a denotation \\(\\llbracket M\\rrbracket_\\rho\\in\nD\\) subject to the following constraints:\n\n\\(\\llbracket x\\rrbracket_\\rho=\\rho(x)\\)\n\\(\\llbracket MN\\rrbracket_\\rho=\\llbracket M\\rrbracket_\\rho\\cdot\n\\llbracket N\\rrbracket_\\rho\\)\n\\(\\llbracket \\lambda xM\\rrbracket_\\rho\\cdot d=\\llbracket\nM\\rrbracket_{\\rho[x\\mapsto d]}\\), for all \\(d\\in D\\)\n\\(\\llbracket \\lambda xM\\rrbracket_\\rho = \\llbracket \\lambda\nxN\\rrbracket_\\rho\\), whenever for all \\(d\\in D\\), we have \\(\\llbracket\nM\\rrbracket_{\\rho[x\\mapsto d]}=\\llbracket N\\rrbracket_{\\rho[x\\mapsto\nd]}\\)\n\\(\\llbracket M\\rrbracket_\\rho=\\llbracket M\\rrbracket_\\sigma\\),\nwhenever \\(\\rho(x)=\\sigma(x)\\) for all \\(x\\in \\mathbf{FV}(M)\\)\n\n\n\nIntuitively, in a model \\(\\mathfrak{M}\\), \\(\\llbracket\nM\\rrbracket_\\rho\\) is the function-object denoted by the\n\\(\\lambda\\)-term \\(M\\) under the valuation \\(\\rho\\).\n\nIt is now straight-forward to define what it means for a\n\\(\\lambda\\)-model \\(\\mathfrak{M}\\) to satisfy an equation \\(M=N\\),\nsymbolically \\(\\mathfrak{M}\\vDash M=N\\):\n\n\nDefinition (satisfaction). \n\\[\\mathfrak{M}\\vDash M=N\\text{ iff for all }\\rho\\text{, we have }\n\\llbracket M\\rrbracket_\\rho=\\llbracket N\\rrbracket_\\rho\\]\n\n\n\nIn words: an equation \\(M=N\\) holds in a model \\(\\mathfrak{M}\\) just\nin case the \\(\\lambda\\)-terms \\(M\\) and \\(N\\) have the same denotation\nunder every valuation in the underlying applicative structure.\n\nNote that clauses 3. and 4. from the definition of a syntactical\n\\(\\lambda\\)-model directly mirror the \\(\\boldsymbol{\\lambda}\\)-rules\n\\(\\boldsymbol{\\beta}\\) and \\(\\boldsymbol{\\xi}\\), respectively (see\nsection\n 5.1\n above). This is the \u2018syntactic\u2019 nature of our models.\nWhile this might be semantically unsatisfactory (see below), it makes\nit relatively straight-forward to prove a soundness theorem for the\nsemantics provided by the syntactical \\(\\lambda\\)-models; see\n(Barendregt, 1985, Theorem 5.3.4) and (Hindley and Seldin, 2008.\nTheorem 15.12):\n\nTheorem For all terms \\(M,N\\), if \\(M=N\\) is\nderivable in \\(\\boldsymbol{\\lambda}\\), then for all syntactical\n\\(\\lambda\\)-models \\(\\mathfrak{M}\\), we have that \\(\\mathfrak{M}\\vDash\nM=N\\). \n\nThis theorem provides a first \u2018sanity-check\u2019 for the\nsemantics. But note that, so far, we haven\u2019t shown that there\nexist any syntactical \\(\\lambda\\)-models at all.\n\nThis worry is addressed by constructing so-called \u2018term\nmodels\u2019, which are not unlike the well-known Henkin\nconstructions from first-order semantics. In order to define these\nmodels, we first need the notion of a\n\\(\\boldsymbol{\\lambda}\\)-equivalence class for a given\n\\(\\lambda\\)-term \\(M\\). This class contains precisely the terms that\n\\(\\boldsymbol{\\lambda}\\) proves identical to \\(M\\):  \n\\[\n[M]_{\\boldsymbol{\\lambda}}=\\{N:\\boldsymbol{\\lambda}\\text{ proves }M=N\\}\n\\]\n\n\nWe then define the term model for\n\\(\\boldsymbol{\\lambda}\\), \\(\\mathfrak{T}\\), by setting:\n\n\\(D=\\{[M]_\\boldsymbol{\\lambda}:M\\text{ is a\n}\\lambda\\text{-term}\\}\\)\n\\([M]_\\boldsymbol{\\lambda}\\cdot\n[N]_\\boldsymbol{\\lambda}=[MN]_\\boldsymbol{\\lambda}\\) \n \\(\\llbracket\nM\\rrbracket_\\rho=[M[x_1:=N_1]\\ldots[x_n:=N_n]]_\\boldsymbol{\\lambda}\\),\nwhere \\(\\mathbf{FV}(M)=\\{x_1,\\ldots,x_n\\}\\) and \\(\\rho(x_1)=N_1,\n\\ldots,\\rho(x_n)=N_n\\) \n\n\nIt is easily seen that this indeed defines a syntactical\n\\(\\lambda\\)-model. In fact, it is easily checked that in the term\nmodel for \\(\\boldsymbol{\\lambda}\\), we have that: \n\\[ \\mathfrak{T}\\vDash M=N\\text{ iff\n}\\boldsymbol{\\lambda}\\text{ derives }M=N. \\]\n\n\nThis paves a way for a very simple completeness proof for\n\\(\\boldsymbol{\\lambda}\\) with respect to the class of syntactical\n\\(\\lambda\\)-models; see (Meyer, 1982, 98\u201399) for one of the few\nexplicit mentions of this kind of result in the literature:\n\nTheorem For all terms \\(M,N\\), if for all syntactical\n\\(\\lambda\\)-models \\(\\mathfrak{M}\\), we have that \\(\\mathfrak{M}\\vDash\nM=N\\), then \\(M=N\\) is derivable in \\(\\boldsymbol{\\lambda}\\). \n\nThe proof is a simple proof by contraposition, which uses the term\nmodel \\(\\mathfrak{T}\\) as a countermodel to any non-derivable identity\nin \\(\\boldsymbol{\\lambda}\\).\n\nBut there are reasons to be dissatisfied with the syntactical\n\\(\\lambda\\)-models as a semantics for the \\(\\lambda\\)-calculus. For\none, by virtue of clauses 3. and 4. mirroring rules\n\\(\\boldsymbol{\\beta}\\) and \\(\\boldsymbol{\\xi}\\), the soundness result\nis \u2018baked into\u2019 the semantics, as it were. This is\nunsatisfactory from a semantic perspective since it means that via the\nsyntactical \\(\\lambda\\)-models, we don\u2019t really learn anything\ndirectly about what conditions an applicative structure needs to\nsatisfy in order to adequately model the \\(\\lambda\\)-calculus.\n\nA related worry is that the clauses 3. and 4. are not\nrecursive in nature. That is, they don\u2019t allow us to\ncompute the denotation of a complex \\(\\lambda\\)-term from the\ndenotations of its parts and information about the syntactic operation\nused to combine them. In our syntax (see section\n 2),\n there are two ways of constructing complex \\(\\lambda\\)-terms:\napplication terms of the form \\(MN\\) and abstraction terms of the form\n\\((\\lambda x[M])\\). Clause 1. of our syntactical \\(\\lambda\\)-models is\na recursive clause for the syntactical application operation, but we\ndon\u2019t have a recursive clause for the syntactical operation of\n\\(\\lambda\\)-abstraction. Clauses 3. and 4. are rather conditions on\nthe denotation function \\(\\llbracket \\ \\rrbracket\\) than recursive\nclauses. This is unsatisfactory since it means that we\u2019re not\nreally given a compositional semantics for the \\(\\lambda\\)-operator by\nthe syntactical \\(\\lambda\\)-models.\n\nThese worries are taken care of in the development of\nsyntax-free \\(\\lambda\\)-models. A\ncomprehensive discussion of syntax-free models goes beyond the scope\nof this entry; but see (Barendregt, 1985, chapter 5.2) and (Hinley and\nSeldin, 2008, chapter 15B) for the details. Suffice it to say that the\ndefinition of syntax-free \\(\\lambda\\)-models involves determining\nprecisely under which conditions an applicative structure is suitable\nfor interpreting the \\(\\lambda\\)-calculus. The resulting\n\\(\\lambda\\)-models, then, indeed provide (something much closer to) a\nrecursive, compositional semantics, where the syntactical operation of\n\\(\\lambda\\)-abstraction is interepreted by a corresponding semantic\noperation on applicative structures.\n\nIt is worth noting, however, that syntactical \\(\\lambda\\)-models and\nthe syntax-free \\(\\lambda\\)-models are, in a certain sense,\nequivalent: every syntactical \\(\\lambda\\)-model defines a syntax-free\n\\(\\lambda\\)-model and vice versa; see (Barendregt, 1985, theorem\n5.3.6) and (Hinley and Seldin, 2008, theorem 15.20) for the details.\nFrom a technical perspective, this result allows us to freely move\nbetween the different presentations of \\(\\lambda\\)-models and to use,\nin a given context, the notion of a model that is most expedient. At\nthe same time, there may be philosophical reasons to prefer\none presentation over the other, such as the semantic worries about\nsyntactical \\(\\lambda\\)-models mentioned above.\n\nBefore moving to model constructions, let us briefly mention that\nthere are various ways of approaching \\(\\lambda\\)-models. One\nparticularly interesting approach we\u2019ve neglected so far is from\nthe perspective of category theory and categorical logic. There are\nwell-known model descriptions using so-called \u2018Cartesian closed\ncategories\u2019; see (Koymans, 1982). Covering these model\ndescriptions goes beyond the scope of the present entry since it\nrequires a familiarity with a wide range of concepts from category\ntheory; see the entry\n Category Theory\n for a sense of the machinery involved. For the details of these model\ndescriptions, instead, (Barendregt, 1985, sections 5.4\u20136). In recent\nyears, there has been a renewed interest in categorical approaches to\nthe \\(\\lambda\\)-calculus, which have mainly focused on typed versions\nof the \\(\\lambda\\)-calculus (see sections\n 8.2\n and\n 9.1.2\n below) but also include the untyped \\(\\lambda\\)-calculus discussed in\nthis article. See, for example, (Hyland, 2017) for a recent\ndiscussion.\n7.2 Model Constructions\n\nThe term model we\u2019ve seen in section\n 7.1\n is rather trivial: it directly reflects the syntactic structure of\nthe \\(\\lambda\\)-terms by modeling precisely syntactic equality modulo\n\\(\\boldsymbol{\\lambda}\\)-provable equality. This makes the term model\nmathematically and philosophically rather uninteresting. The\nconstruction and study of more interesting concrete \\(\\lambda\\)-models\nis one of the principal aims of the model theory for the\n\\(\\lambda\\)-calculus.\n\nWe\u2019ve already mentioned what\u2019s perhaps the most important,\nbut was definitely the first non-trivial model for the\n\\(\\lambda\\)-calculus: Scott\u2019s \\(D_\\infty\\). But there are also\nother interesting model constructions, such as Plotkin and\nScott\u2019s graph model \\(P_\\omega\\), first described in (Plotkin\n1972) and (Scott, 1974). These model constructions, however, usually\nrely on fairly involved mathematical methods, both for their\ndefinitions and for verifying that they are indeed \\(\\lambda\\)-models.\nConsequently, covering these constructions goes beyond the scope of\nthis entry; see (Hinley and Seldin, 2008, chapter 16F) for an overview\nof various model constructions and (Barendregt, 1985, chapter 18) for\nmany of the formal details.\n\nOne of the advantages of having different models is that one sees\ndifferent aspects of equality in the \\(\\lambda\\)-calculus: each of the\ndifferent models takes a different view on what \\(\\lambda\\)-terms get\nidentified. An interesting question in this context is: What is\nthe \\(\\lambda\\)-theory of a given class of models? In this\ncontext, we call a class \\(\\mathcal{C}\\) of \\(\\lambda\\)-models\ncomplete just in case every (consistent) \\(\\lambda\\)-theory\nis satisfied by some model in \\(\\mathcal{C}\\). See (Salibra, 2003) for\nan overview of various completeness and incompleteness\nresults for interesting classes of \\(\\lambda\\)-models.\n8. Extensions and Variations\n8.1 Combinatory logic\n\nA sister formalism of the \\(\\lambda\\)-calculus, developed slightly\nearlier, deals with variable-free combinations.\nCombinatory logic is indeed even simpler\nthan the \\(\\lambda\\)-calculus, since it lacks a notion of variable\nbinding.\n\nThe language of combinatory logic is built up from\ncombinators and variables. There is some\nflexibility in precisely which combinators are chosen as basic, but\nsome standard ones are \\(\\mathbf{I}, \\bK , \\bS, \\mathbf{B}\\) and\n\\(\\mathbf{C}\\). (The names are not arbitrary.)\n\nAs with the \\(\\lambda\\)-calculus, with combinatory logic one is\ninterested in reducibility and provability. The\nprincipal reduction relations are:\n\n\nCombinator\nReduction Axiom\n\n\\(\\bI\\)\n\\(\\bI x = x\\) \n\n\\(\\bK\\)\n\\(\\bK xy = x\\) \n\n\\(\\bS\\)\n\\(\\bS xyz = xz(yz)\\) \n\n\\(\\bB\\)\n\\(\\bB xyz = x(yz)\\) \n\n\\(\\bC\\)\n\\(\\bC xyz = xzy\\) \n\n\nThere is a passage from \\(\\lambda\\)-calculus to combinatory logic via\ntranslation. It turns out that although combinatory logic lacks a\nnotion of abstraction, one can define such a notion and thereby\nsimulate the \\(\\lambda\\)-calculus in combinatory logic. Here is one\ntranslation; it is defined recursively.\n\n\nRule\nExpression\nTranslation\nCondition \n\n1\n\\(x\\)\n\\(x\\)\n(unconditional) \n\n2\n\\(MN\\)\nM\\(^*\\)N\\(^*\\)\n(unconditional) \n\n3\n\\(\\lambda x[M]\\)\n\\(\\bK\\)M\n\\(x\\) does not occur freely in M \n\n4\n\\(\\lambda x[x]\\)\n\\(\\bI\\)\n(unconditional) \n\n5\n\\(\\lambda x[Mx]\\)\nM\n\\(x\\) does not occur freely in M \n\n6\n\\(\\lambda x[MN]\\)\n\\(\\bB M(\\lambda x[N)]^*\\)\n\\(x\\) does not occur freely in M \n\n7\n\\(\\lambda x[MN]\\)\n\\(\\bC (\\lambda x[M])^*\\)N\n\\(x\\) does not occur freely in \\(N\\) \n\n8\n\\(\\lambda x[MN]\\)\n\\(\\bS M^*N^*\\)\n\\(x\\) occurs freely in both \\(M\\) and \\(N\\) \n\n\nThis translation works inside-out, rather than outside-in. To\nillustrate:\n\n\n\nThe translation of the term \\(\\lambda y[y]\\), a representative of the\nidentity function, is mapped by this translation to the identity\ncombinator \\(\\bI\\) (because of Rule 4), as expected.\n\n\nThe \\(\\lambda\\)-term \\(\\lambda x[\\lambda y[x]]\\) that we have been\ncalling \u2018\\(\\bK\\)\u2019is mapped by this translation to:\n\n\\[\\begin{align}\n\\lambda x[\\lambda y[x]] \n  &\\equiv \\lambda x[\\bK x]  &\\langle \\text{Rule 1}\\rangle \\\\\n  &\\equiv \\bK   &\\langle \\text{Rule 3} \\rangle\n\\end{align}\\]\n \n\n\nThe \\(\\lambda\\)-term \\(\\lambda x[\\lambda y[yx]]\\) that switches its\ntwo arguments is mapped by this translation to: \n\\[\\begin{align}\n\\lambda x[\\lambda y[yx]] \n &\\equiv \\lambda x[\\bC(\\lambda y[y])^* x]  &\\langle\\text{Rule 8}\\rangle \\\\\n &\\equiv \\lambda x[\\bC\\bI x]  &\\langle\\lambda y[y] \\equiv \\bI,\\text{ by Rule 4}\\rangle \\\\\n &\\equiv \\bB\\bC\\bI)(\\lambda x[x])^*  &\\langle\\text{Rule 7}\\rangle \\\\\n &\\equiv \\bB(\\bC\\bI)\\bI  &\\langle(\\lambda x[x])^* \\equiv \\bI,\\text{ by Rule 4}\\rangle\n\\end{align}\\]\n\n\nWe can confirm that the \\(\\lambda\\)-term \\(\\lambda x[\\lambda y[yx]]\\)\nand the translated combinatory logic term \\(\\bB(\\bC\\bI)\\bI\\) have\nanalogous applicative behavior: for all \\(\\lambda\\)-terms \\(P\\) and\n\\(Q\\) we have \n\\[\n(\\lambda x[\\lambda y[yx]])PQ \\rhd (\\lambda y[yP]) \\rhd QP;\n\\]\n\n\nlikewise, for all combinatory logic terms \\(P\\) and \\(Q\\) we have\n\n\\[\n\\bB(\\bC\\bI)\\bI PQ \\rhd (\\bC\\bI)(\\bI P)Q \\rhd \\bI Q(\\bI P) \\rhd Q(\\bI P) \\rhd QP\n\\]\n \n\n\nWe can give but a glimpse of combinatory logic; for more on the\nsubject, consult the entry on\n combinatory logic.\n Many of the issues discussed here for \\(\\lambda\\)-calculus have\nanalogues in combinatory logic, and vice versa.\n8.2 Adding types\n\nIn many contexts of reasoning and computing it is natural to\ndistinguish between different kinds of objects. The way this\ndistinction is introduced is by requiring that certain formulas,\nfunctions, or relations accept arguments or permit substitution only\nof some kinds of objects rather than others. We might require, for\nexample, that addition + take numbers as arguments. The effect of this\nrestriction is to forbid, say, the addition of 5 and the identity\nfunction \\(\\lambda\n x.x\\).[4]\n Regimenting objects into types is also the idea behind the passage\nfrom (unsorted, or one-sorted) first-order logic to\nmany-sorted first-order logic. (See (Enderton, 2001) and\n(Manzano, 2005) for more about many-sorted first-order logic.) As it\nstands, the \\(\\lambda\\)-calculus does not support this kind of\ndiscrimination; any term can be applied to any other term.\n\nIt is straightforward to extend the untyped \\(\\lambda\\)-calculus so\nthat it discriminates between different kinds of objects. This entry\nlimits itself to the type-free \\(\\lambda\\)-calculus. See the\nentries on\n type theory\n and\n Church\u2019s type theory\n for a detailed discussion of the extensions of \\(\\lambda\\)-calculus\nthat we get when we add types, and see (Barendregt, Dekkers, Statman,\n2013) for a book length treatment of the subject.\n\nFrom a model-theoretic perspective, it\u2019s interesting to add that\n(Scott, 1980) uses the semantic fact that categorical models for the\nuntyped \\(\\lambda\\)-calculus (see section\n 7.1)\n derive from the categorical models of the typed \\(\\lambda\\)-calculus\nto argue for a conceptual priority of the typed over the untyped\ncalculus.\n9. Applications\n9.1 Logic \u00e0 la \\(\\lambda\\)\n\nHere are two senses in which \\(\\lambda\\)-calculus is connected with\nlogic.\n9.1.1 Terms as logical constants\n\nIn the\n table of combinators\n above, we defined combinators \\(\\bT\\) and \\(\\bF\\) and said that they\nserve as representations in the \\(\\lambda\\)-calculus of the truth\nvalues true and false, respectively. How do these terms function as\ntruth values?\n\nIt turns out that when one is treating \\(\\lambda\\)-calculus as a kind\nof programming language, one can write conditional statements\n\u201cIf \\(P\\) then \\(A\\) else \\(B\\)\u201d simply as \\(PAB\\), where\nof course \\(P, A\\), and \\(B\\) are understood as \\(\\lambda\\)-terms. If\n\\(P \\rhd \\bT\\), that is, P is \u2018true\u2019, then we have\n\n\\[\n\\text{if-}P\\text{-then-}A\\text{-else-}B := PAB \\rhd \\bT AB \\rhd A,\n\\]\n\n\n(recall that, by definition, \\(\\bT \\equiv \\bK\\)) and if \\(P \\rhd\n\\bF\\), that is, \\(P\\) is \u2018false\u2019, then \n\\[\n\\text{if-}P\\text{-then-}A\\text{-else-}B := PAB \\rhd \\bF AB \\rhd B,\n\\]\n\n\n(recall that, by definition, \\(\\mathbf{F} \\equiv \\mathbf{KI})\\) which\nis just what we expect from a notion of if-then-else. If \\(P\\) reduces\nneither to \\(\\mathbf{T}\\) nor \\(\\mathbf{F}\\), then we cannot in\ngeneral say what \\(\\text{if-}P\\text{-then-}A\\text{-else-}B\\) is. \n\nThe encoding we\u2019ve just sketched of some of the familiar truth\nvalues and logical connectives of classical truth-table logic does not\nshow that \\(\\lambda\\)-calculus and classical logic are intimately\nrelated. The encoding shows little more than embeddibility of the\nrules of computation of classical truth-table logic in\n\\(\\lambda\\)-calculus. Logics other than classical truth-table logic\ncan likewise be represented in the \\(\\lambda\\)-calculus, if one has\nsufficient computable ingredients for the logic in question (e.g., if\nthe logical consequence relation is computable, or if a derivability\nrelation is computable, etc.). For more on computing with\n\\(\\lambda\\)-calculus, see section\n 9.2\n below. A more intrinsic relationship between logic and\n\\(\\lambda\\)-calculus is discussed in the next section.\n9.1.2 Typed \\(\\lambda\\)-calculus and the Curry-Howard-de Bruijn correspondence\n\nThe correspondence to be descried here between logic and the\n\\(\\lambda\\)-calculus is seen with the help of an apparatus known as\ntypes. This section sketches the beginnings of the\ndevelopment of the subject known as type\ntheory. We are interested in developing type theory only\nso far as to make the so-called Curry-Howard-de Bruijn correspondence\nvisible. A more detailed treatment can be found in the entry on\n type theory;\n see also (Hindley, 1997) and (Barendregt, Dekkers, Statman,\n2013).\n\nType theory enriches the untyped \\(\\lambda\\)-calculus by requiring\nthat terms be given types. In the untyped\n\\(\\lambda\\)-calculus, the application \\(MN\\) is a legal term\nregardless of what \\(M\\) and \\(N\\) are. Such freedom permits one to\nform such suspicious terms as \\(xx\\), and thence terms such as the\nparadoxical combinator \\(\\mathbf{Y}\\). One might wish to exclude terms\nlike \\(xx\\) on the grounds that \\(x\\) is serving both as a function\n(on the left-hand side of the application) and as an argument (on the\nright-hand side of the application). Type theory gives us the\nresources for making this intuitive argument more precise.\n\n\nAssigning types to terms The language of type theory\nbegins with an (infinite) set of type\nvariables (which is assumed to be disjoint from the set\nof variables of the \\(\\lambda\\)-calculus and from the symbol\n\u2018\\(\\lambda\\)\u2019 itself). The set of types is made up of type\nvariables and the operation \\(\\sigma \\rightarrow \\tau\\). Variables in\ntype theory now come with a type annotation\n(unlike the unadorned term variables of untyped \\(\\lambda\\)-calculus).\nTyped variables are rendered \u2018\\(x : \\sigma\\)\u2019; the\nintuitive reading is \u2018the variable \\(x\\) has the type\n\\(\\sigma\\)\u2019. The intuitive reading of the judgment \u2018\\(t :\n\\sigma \\rightarrow \\tau\\)\u2019 is that the term \\(t\\) is a function\nthat transforms arguments of type \\(\\sigma\\) into arguments of type\n\\(\\tau\\). Given an assignment of types to term variables, one has the\ntyping rules: \n\\[\n(M : \\sigma \\rightarrow \\tau)(N : \\sigma) : \\tau\n\\]\n\n\nand \n\\[\n(\\lambda x : \\sigma[M : \\tau]) : \\sigma \\rightarrow \\tau\n\\]\n\n\nThe above two rules define the assignment of types to applications and\nto abstraction terms. The set of terms of type theory is the set of\nterms built up according to these formation rules.\n\n\nThe above definition of the set of terms of type theory is sufficient\nto rule out terms such as \\(xx\\). Of course, \u2018\\(xx\\)\u2019 is\nnot a typed term at all for the simple reason that no types have been\nassigned to it. What is meant is that there is no type \\(\\sigma\\) that\ncould be assigned to \\(x\\) such that \u2018\\(xx\\)\u2019 could be\nannotated in a legal way to make a typed term. We cannot assign to\n\\(x\\) a type variable, because then the type of the left-hand \\(x\\)\nwould fail to be a function type (i.e., a type of the shape\n\u2018\\(\\sigma \\rightarrow \\tau\\)\u2019). Moreover, we cannot assign\nto \\(x\\) a function type \\(\\sigma \\rightarrow \\tau\\), because then\nthen \\(\\sigma\\) would be equal to \\(\\sigma \\rightarrow \\tau\\), which\nis impossible.\n\nAs a leading example, consider the types that are assigned to the\ncombinators \\(\\bI\\), \\(\\bK\\), and \\(\\bS\\):\n\n\nCombinator\u00a0\u00a0\nType[5]\n\n\n\\(\\bI\\)\n\\(a \\rightarrow a\\) \n\n\\(\\bK\\)\n\\(a \\rightarrow(b \\rightarrow a)\\) \n\n\\(\\bS\\)\n\\( (a \\rightarrow(b \\rightarrow c)) \\rightarrow ((a \\rightarrow\nb) \\rightarrow(a \\rightarrow c))\\) \n\n\n(See Hindley (1997) Table of principal types for a more\nextensive listing.) If we read \u2018\\(\\rightarrow\\)\u2019 as\nimplication and type variables as propositional variables, then we\nrecognize three familiar tautologies in the right-hand column of the\ntable. The language used is meager: there are only propositional\nvariables and implication; there are no other connectives.\n\nThe table suggests an interesting correspondence between the typed\n\\(\\lambda\\)-calculus and formal logic. Could it really be that the\ntypes assigned to formulas, when understood as logical formulas, are\nvalid? Yes, though \u2018validity\u2019 needs to understood not as\nclassical validity:\n\nTheorem If \\(\\tau\\) is the type of some\n\\(\\lambda\\)-term, then \\(\\tau\\) is intuitionistically valid.\n\nThe converse of this theorem holds as well:\n\nTheorem If \\(\\phi\\) is an intuitionistically valid\nlogical formula whose only connective is implication\n\\((\\rightarrow)\\), then \\(\\phi\\) is the type of some\n\\(\\lambda\\)-term.\n\nThe correspondence can be seen when one identifies intuitionistic\nvalidity with derivability in a certain natural deduction formalism.\nFor a proof of these two theorems, see (Hindley, 1997, chapter 6).\n\nThe correspondence expressed by the previous two theorems between\nintuitionistic validity and typability is known as the\nCurry-Howard-de Bruijn correspondence, after three logicians\nwho noticed it independently. The correspondence, as stated, is\nbetween only propositional intuitionistic logic, restricted to the\nfragment containing only the implication connective \\(\\rightarrow\\).\nOne can extend the correspondence to other connectives and to\nquantifiers, too, but the most crisp correspondence is at the level of\nthe implication-only fragment. For details, see (Howard, 1980).\n9.2 Computing\n\nOne can represent natural numbers in a simple way, as follows:\n\nDefinition (ordered tuples, natural numbers) The\nordered tuple \\(\\langle a_0,\\ldots a_n\\rangle\\) of \\(\\lambda\\)-terms\nis defined as \\(\\lambda x[x a_0\\ldots a_n]\\). One then defines the\n\\(\\lambda\\)-term \\(\\ulcorner n\\urcorner\\) corresponding to the natural\nnumber \\(n\\) as: \\(\\ulcorner 0\\urcorner = \\mathbf{I}\\) and, for every\n\\(k\\), \\(\\ulcorner k + 1\\urcorner = \\langle \\mathbf{F}, \\ulcorner\nk\\urcorner\\rangle\\).\n\n\n\nThe \\(\\lambda\\)-term corresponding to the number 1, on this\nrepresentation, is: \n\\[\\begin{align}\n\\ulcorner 1 \\urcorner &\\equiv \\langle\\bF,\\ulcorner 0\\urcorner\\rangle \\\\\n  &\\equiv \\langle\\bF,\\bI\\rangle \\\\\n  &\\equiv \\lambda x[x\\mathbf{FI}]\n\\end{align}\\]\n \n\n\nThe \\(\\lambda\\)-term corresponding to the number 2, on this\nrepresentation, is: \n\\[\\begin{align}\n\\ulcorner 2 \\urcorner &\\equiv \\langle\\bF,\\ulcorner 1\\urcorner\\rangle \\\\\n  &\\equiv \\lambda x[x\\mathbf{F}\\lambda x[x\\mathbf{FI}]]\n\\end{align}\\]\n \n\n\nSimilarly, \\(\\ulcorner 3\\urcorner\\) is \\(\\lambda x[x\\mathbf{F}\\lambda\nx[x\\mathbf{F}\\lambda x[x\\mathbf{FI}]]]\\).\n\n\nVarious representations of natural numbers are available; this\nrepresentation is but\n one.[6]\n\nUsing the ingredients provided by the \\(\\lambda\\)-calculus, one can\nrepresent all recursive functions. This shows that the model is\nexactly as expressive as other models of computing, such as Turing\nmachines and register machines.  For a more detailed discussion of the\nrelation between these different models of computing, see the \nsection comparing the Turing and Church approaches in the\nentry on the\nChurch-Turing Thesis.\n\n\nTheorem For every recursive function \\(f\\) of arity\n\\(n\\), there exists a \\(\\lambda\\)-term \\(f^*\\) such that\n\n\nfor all natural numbers \\(a_1,\\ldots a_n\\): \\(f(a_1,\\ldots a_n) = y\\)\niff \\(\\boldsymbol{\\lambda} \\vdash f^*\\langle\n\\bar{a}_1,\\ldots,\\bar{a}_n\\rangle = \\bar{y}\\) \n\n\n\nFor a proof, see\n the appendix.\n\nSince the class of recursive functions is an adequate representation\nof the class of all computable (number-theoretic) functions, thanks to\nthe work above we find that all computable (number-theoretic)\nfunctions can be faithfully represented in the\n\\(\\lambda\\)-calculus.\n9.3 Relations\n\nThe motivation for the \\(\\lambda\\)-calculus given at the beginning of\nthe entry was based on reading \\(\\lambda\\)-expressions as descriptions\nof functions. Thus, we have understood \u2018\\(\\lambda x[M]\\)\u2019\nto be a (or the) function that, given \\(x\\), gives \\(M\\) (which\ngenerally, though not necessarily, involves x). But it is not\nnecessary to read \\(\\lambda\\)-terms as functions. One could understand\n\\(\\lambda\\)-terms as denoting relations, and read an abstraction term\n\u2018\\(\\lambda x[M]\\)\u2019 as the unary relation (or property)\n\\(R\\) that holds of an argument \\(x\\) just in case \\(M\\) does (see\nCarnap 1947, p. 3). On the relational reading, we can understand an\napplication term \\(MN\\) as a form of predication. One can make sense\nof these terms using the principle of \\(\\beta\\)-conversion:\n\n\\[\n(\\lambda x[M])a = M[x := A],\n\\]\n\n\nwhich says that the abstraction relation \\(\\lambda x[M]\\), predicated\nof A, is the relation obtained by plugging in A for all free\noccurrences of \\(x\\) inside \\(M\\).\n\nAs a concrete example of this kind of approach to\n\\(\\lambda\\)-calculus, consider an extension of first-order logic where\none can form new atomic formulas using \\(\\lambda\\)-terms, in the\nfollowing way:\n\n\nSyntax: For any formula \\(\\phi\\) and any finite\nsequence \\(x_1 , \\ldots ,x_n\\) of variables, the expression\n\u2018\\(\\lambda x_1 \\ldots x_n [\\phi]\\)\u2019 is a predicate symbol\nof arity n. Extend the notion of free and bound variables (using the\nfunctions \\(\\mathbf{FV}\\) and \\(\\mathbf{BV})\\) in such a way that\n\n\\[\n\\mathbf{FV}(\\lambda x_1 \\ldots x_n [\\phi]) = \\mathbf{FV}(\\phi) - \\{ x_1 , \\ldots x_n \\}\n\\]\n\n\nand \n\\[\n\\mathbf{BV}(\\lambda x_1 \\ldots x_n [\\phi]) = \\mathbf{BV}(\\phi) \\cup \\{ x_1 , \\ldots x_n \\}\n\\]\n\n\nDeduction Assume as axioms the universal closures of\nall equivalences \n\\[\n\\lambda x_1 \\ldots x_n [\\phi](t_1 ,\\ldots t_n) \\leftrightarrow \\phi[x_1 ,\\ldots x_n := t_1,\\ldots t_n]\n\\]\n\n\nwhere \\(\\phi[x_1 ,\\ldots x_n := t_1,\\ldots t_n]\\) denotes the\nsimultaneous substitution of the terms \\(t_k\\) for the variables\n\\(x_k\\) \\((1 \\le k \\le n)\\).\n\nSemantics For a first-order structure \\(A\\) and an\nassignment \\(s\\) of elements of \\(A\\) to variables, define\n\n\\[\\begin{align}\nA \\vDash &\\lambda x_1 \\ldots x_n [\\phi](t_1 ,\\ldots t_n) [s] \\text{ iff } \\\\\n         &A \\vDash \\phi[x_1 ,\\ldots x_n := t_1,\\ldots t_n] [s]\n\\end{align}\\]\n\n\n\nAccording to this approach, one can use a \\(\\lambda\\) to treat\nessentially any formula, even complex ones, as if they were atomic. We\nsee the principle of \\(\\beta\\)-reduction in the deductive and semantic\nparts. That this approach adheres to the relational reading of\n\\(\\lambda\\) terms can be seen clearly in the semantics: according to\nthe standard Tarski-style semantics for first-order logic, the\ninterpretation of a formula (possibly with free variables) denotes a\nset of tuples of elements of the structure, as we vary the variable\nassignment that assigns elements of the structure to the\nvariables.\n\nOne can \u2018internalize\u2019 this functional approach. This is\ndone in the case of various property theories, formal\ntheories for reasoning about properties as metaphysical objects\n(Bealer 1982, Zalta 1983, Menzel 1986, 1993, and Turner 1987). This\nkind of theory is employed in certain metaphysical investigations\nwhere properties are metaphysical entities to be investigated. In\nthese theories, metaphysical relations are (or are among) the objects\nof interest; just as we add term-building symbols + and \\(\\times\\) in\nformal theories of arithmetic to build numbers, \\(\\lambda\\) is used in\nproperty theory to build relations. This approach contrasts with the\napproach above. There, \\(\\lambda\\) was added to the grammar of\nfirst-order logic by making it a recipe for building atomic formulas;\nit was a new formula-building operator, like \\(\\vee\\) or\n\\(\\rightarrow\\) or the other connectives. In the case of property\ntheories, the \\(\\lambda\\) plays a role more like + and \\(\\times\\) in\nformal theories of arithmetic: it is used to construct relations\n(which, in this setting, are to be understood as a kind of\nmetaphysical object). Unlike + and \\(\\times\\), though, the \\(\\lambda\\)\nbinds variables.\n\nTo give an illustration of how \\(\\lambda\\) is used in this setting,\nlet us inspect the grammar of a typical application (McMichael and\nZalta, 1980). One typically has a predication operator (or,\nmore precisely, a family of predication operators) \\(p_k (k \\ge 0)\\).\nIn a language where we have terms \\(\\mary\\) and \\(\\john\\) and a binary\nrelation loves, we can formally express:\n\nJohn loves Mary: \\(\\loves(\\john ,\\mary)\\)\nThe property that John loves Mary: \\(\\lambda[\\loves(\\john\n,\\mary)]\\) (note that the \\(\\lambda\\) is binding no variables; we\nmight call this \u2018vacuous binding\u2019. Such properties can be\nunderstood as propositions.)\nThe property of an object \\(x\\) that John loves it: \\(\\lambda x\n[\\loves(\\john,x)]\\).\nThe property that Mary is loved by something: \\(\\lambda[\\exists\nx(\\loves(x,\\mary))]\\) (another instance of vacuous binding, viz.,\nproposition)\nThe predication of the property of \\(x\\) that John loves \\(x\\) to\nMary: \\(p_1 (\\lambda x[\\loves(\\john,x)],\\mary)\\).\nThe (0-ary) predication of the property that John loves Mary:\n\\(p_0 (\\lambda x[\\loves(\\john,\\mary)])\\).\nThe property of objects \\(x\\) and \\(y\\) that \\(x\\) loves \\(y\\):\n\\(\\lambda xy[\\loves(x,y)]\\).\nThe property of an objects \\(x\\) that \\(x\\) loves itself:\n\\(\\lambda x[\\loves(x,x)]\\).\nThe predication of the property of objects \\(x\\) and \\(y\\) that\n\\(x\\) loves \\(y\\) to John and Mary (in that order): \\(p_2 (\\lambda\nxy[\\loves(x,y)],\\john,\\mary)\\).\n\n\nWe reason with these \\(\\lambda\\)-terms using a \\(\\beta\\)-conversion\nprinciple such as: \n\\[\\begin{align}\np_n (\\lambda x_1,&\\ldots x_n [A], t_1 , \\ldots ,t_n) \\leftrightarrow \\\\\n                 &A[x_1 ,\\ldots x_n := t_1,\\ldots, t_n]\n\\end{align}\\]\n\n\nFormally, the predication operator p\\(_k\\) is a \\((k+1)\\)-ary\npredicate symbol. The first argument is intended to be a\n\\(\\lambda\\)-term of \\(k\\) arguments, and the rest of the arguments are\nintended to be the arguments of the body of the \\(\\lambda\\)-term. The\n\\(\\beta\\)-principle above says that the predication of an \\(n\\)-ary\n\\(\\lambda\\)-term \\(L\\) to \\(n\\) terms holds precisely when the body of\n\\(L\\) holds of those terms.\n\nIt turns out that in these theories, we may or may not be able to be\nfully committed to the principle of \\(\\beta\\)-conversion. Indeed, in\nsome property theories, the full principle of \\(\\beta\\)-conversion\nleads to paradox, because one can replay a Russell-style argument when\nthe full principle of \\(\\beta\\)-conversion is in place. In such\nsettings, one restricts the formation of \\(\\lambda\\)-formulas by\nrequiring that the body of a \\(\\lambda\\)-term not contain further\n\\(\\lambda\\)-terms or quantifiers. For further discussion, see (Orilia,\n2000).\n\nOne of the reasons why property theories formulated in the\n\\(\\lambda\\)-calculus are of a particular philosophical importance is\nthe hyperintensional nature of the calculus (see section\n 1.2).\n A property concept may be called\n\u2018hyperintensional\u2019 if and only if it does not\nidentify necessarily coextensional properties, i.e., properties that\nare instanciated by exactly the same objects at every possible world.\nThe properties and relations described by the theories of Bealer,\nZalta, Menzel, and Turner have exactly this characteristic. In other\nwords, the theories are hyperintensional property theories. Recent\nyears have seen a significant rise of interest in hyperintensional\nconcepts of properties in metaphysics (Nolan 2014), and\ncorrespondingly property theories formulated in the\n\\(\\lambda\\)-calculus will likely experience a rise of interest as\nwell.\n\nIn the context of the foundations of mathematics, Zalta and\nOppenheimer (2011) argue for the conceptual priority of the relational\ninterpretation of \\(\\lambda\\)-terms over the functional one. \n\n", "bibliography": {"categories": [], "cat_ref_text": {"ref_list": ["Baader, Franz and Tobias Nipkow, 1999, <em>Term Rewriting and All\nThat</em>, Cambridge: Cambridge University Press.", "Barendregt, Henk, 1985, <em>The Lambda Calculus: Its Syntax and\nSemantics</em> (Studies in Logic and the Foundations of Mathematics\n103), 2nd edition, Amsterdam: North-Holland.", "Barendregt, Henk, 1993, \u201cLambda calculi with types\u201d,\nin S. Abramsky, D. Gabbay, T. Maibaum, and H. Barendregt (eds.),\n<em>Handbook of Logic in Computer Science</em> (Volume 2), New York:\nOxford University Press, pp. 117\u2013309.", "Barendregt, Henk, Wil Dekkers, and Richard Statman., 2013,\n<em>Lambda Calculus With Types</em>, Cambridge: Cambridge University\nPress.", "Bealer, George, 1982, <em>Quality and Concept</em>, Oxford:\nClarendon Press.", "van Benthem, Johan, 1998, <em>A Manual of Intensional Logic</em>,\nStanford: CSLI Publications.", "Carnap, Rudolf, 1947, <em>Meaning and Necessity</em>, Chicago:\nUniversity of Chicago Press.", "Church, Alonzo, 1932, \u201cA set of postulates for the\nfoundation of logic\u201d, <em>Annals of Mathematics</em> (2nd\nSeries), 33(2): 346\u2013366.", "Cutland, Nigel J., 1980, <em>Computability</em>, Cambridge:\nCambridge University Press.", "Doets, Kees and Jan van Eijk, 2004, <em>The Haskell Road to Logic,\nMaths and Programming</em>, London: College Publications.", "Enderton, Herbert B., 2001, <em>A Mathematical Introduction to\nLogic</em>, 2nd edition, San Diego: Harcourt/Academic Press.", "Frege, Gottlob, 1893, <em>Grundgesetze der Arithmetik</em>, Jena:\nVerlag Hermann Pohle, Band I; partial translation as <em>The Basic\nLaws of Arithmetic</em>, M. Furth (trans.), Berkeley: University of\nCalifornia Press, 1964.", "Kleene, Stephen C., 1981, \u201cOrigins of recursive function\ntheory\u201d, <em>Annals of the History of Computing</em>, 3(1):\n52\u201367.", "Heim, Irene and Angelika Kratzer, 1998, <em>Semantics in\nGenerative Grammar</em>, Malden, MA: Blackwell.", "Hindley, J. Roger, 1997, <em>Basic Simple Type Theory</em>\n(Cambridge Tracts in Theoretical Computer Science 42), New York:\nCambridge University Press.", "Hindley, J. Roger and G. Longo, 1980, \u201cLambda-calculus\nModels and Extensionality.\u201d <em>Zeitschrift f\u00fcr\nmathematische Logik und Grundlagen der Mathematik</em>, 26:\n289\u2013310.", "Hindley, J. Roger and Jonathan P. Seldin, 2008,\n<em>Lambda-Calculus and Combinators: An Introduction</em>, 2nd\nedition, Cambridge: Cambridge University Press.", "Howard, William A., 1980, \u201cThe formula-as-types notion of\nconstruction\u201d, in J. Hindley and J. Seldin (eds.), <em>To H. B.\nCurry: Essays on Combinatory Logic, Lambda-Calculus, and\nFormalism</em>, London: Academic Press, pp. 479\u2013490.", "Hyland, J. Martin E., 2017, \u201cClassical Lambda Calculus in\nModern Dress\u201d, <em>Mathematical Structures in Computer\nScience</em>, 27(5): 762\u2013781.", "Koymans, C.P.J., 1982, \u201cModels of the Lambda\nCalculus\u201d, <em>Information and Control</em>, 52:\n306\u2013332.", "Manzano, Maria, 2005, <em>Extensions of First-order Logic</em>\n(Cambridge Tracts in Theoretical Computer Science 19), Cambridge:\nCambridge University Press.", "McCarthy, John, 1960, \u201cRecursive functions of symbolic\nexpressions and their computation by machine (Part I)\u201d,\n<em>Communications of the ACM</em>, 3(4): 184\u2013195.", "McMichael, Alan and Edward N. Zalta, 1980, \u201cAn alternative\ntheory of nonexistent objects\u201d, <em>Journal of Philosophical\nLogic</em>, 9: 297\u2013313.", "Menzel, Christopher, 1986, \u201cA complete, type-free second\norder logic of properties, relations, and propositions\u201d,\nTechnical Report #CSLI-86-40, Stanford: CSLI Publications.", "Menzel, Christopher, 1993, \u201cThe proper treatment of\npredication in fine-grained intensional logic\u201d,\n<em>Philosophical Perspectives</em> 7: 61\u201386.", "Meyer, Albert R., 1982, \u201cWhat is a model of the lambda\ncalculus?\u201d, In <em>Information and Control</em>, 52(1):\n87\u2013122.", "Nederpelt, Rob, with Herman Geuvers and Roel de Vriejer (eds.),\n1994, <em>Selected Papers on Automath</em> (Studies in Logic and the\nFoundations of Mathematics 133), Amsterdam: North-Holland.", "Nolan, Daniel, 2014, \u201cHyperintensional metaphysics\u201d,\n<em>Philosophical Studies</em>, 171(1); 149\u2013160.", "Orilia, Francesco, 2000, \u201cProperty theory and the revision\ntheory of definitions\u201d, <em>Journal of Symbolic Logic</em>,\n65(1): 212\u2013246.", "Partee, Barbara H., with Alice ter Meulen and Robert E. Wall,\n1990, <em>Mathematical Methods in Linguistics</em>, Berlin:\nSpringer.", "Plotkin, G.D., 1972, <em>A Set-Theoretical Definition of\nApplication</em>, School of Artificial Intelligence, Memo MIP-R-95,\nUniversity of Edinburgh.", "Revesz, George E., 1988, <em>Lambda-Calculus, Combinators, and\nFunctional Programming</em>, Cambridge: Cambridge University Press;\nreprinted 2008.", "Rosser, J. Barkley, 1984, \u201cHighlights of the History of the\nLambda-Calculus\u201d, <em>Annals of the History of Computing</em>,\n6(4): 337\u2013349.", "Salibra, Antonio, 2003, \u201cLambda calculus: models and\ntheories\u201d, in <em>Proceedings of the Third AMAST Workshop on\nAlgebraic Methods in Language Processing (AMiLP-2003)</em>, No. 21,\nUniversity of Twente, pp. 39\u201354.", "Sch\u00f6nfinkel, Moses, 1924, \u201cOn the building blocks of\nmathematical logic\u201d, in J. van Heijenoort (ed.), <em>From Frege\nto G\u00f6del: A Source Book in Mathematical Logic</em>, Cambridge,\nMA: Harvard University Press, 1967, pp. 355\u2013366.", "Scott, Dana, 1974, \u201cThe LAMBDA language\u201d, <em>Journal\nof Symbolic Logic</em>, 39: 425\u2013427.", "\u2013\u2013\u2013, 1980, \u201cLambda Calculus: Some Models,\nSome Philosophy\u201d, in J. Barwise, H.J. Keisler, and K. Kunen\n(eds.), <em>The Kleene Symposium</em>, Amsterdam: North-Holland, pp.\n223\u2013265.", "Troelstra, Anne and Helmut Schwichtenberg, 2000, <em>Basic Proof\nTheory</em> (Cambridge Tracts in Theoretical Computer Science 43), 2nd\nedition, Cambridge: Cambridge University Press.", "Turing, Alan M., 1937, \u201cComputability and\n\\(\\lambda\\)-definability\u201d, <em>Journal of Symbolic Logic</em>,\n2(4): 153\u2013163.", "Turner, Richard, 1987, \u201cA theory of properties\u201d,\n<em>Journal of Symbolic Logic</em>, 52(2): 455\u2013472.", "Zalta, Edward N., 1983, <em>Abstract Objects: An Introduction to\nAxiomatic Metaphysics</em>, Dordrecht: D. Reidel.", "Zalta, Edward N. and Paul Oppenheimer, 2011, \u201cRelations\nversus functions at the foundations of logic: type-theoretic\nconsiderations\u201d, <em>Journal of Logic and Computation</em> 21:\n351\u2013374.", "Zerpa, L., 2021, \u201cThe Teaching and Learning of the Untyped\nLambda Calculus Through Web-Based e-Learning Tools\u201d, in K. Arai\n<em>Intelligent Computing</em> (Lecture Notes in Networks and Systems:\nVolume 285), Cham: Springer, pp. 419\u2013436."]}, "raw_text": "<div id=\"bibliography\">\n<h2><a name=\"Bib\">Bibliography</a></h2>\n<ul class=\"hanging\">\n<li>Baader, Franz and Tobias Nipkow, 1999, <em>Term Rewriting and All\nThat</em>, Cambridge: Cambridge University Press.</li>\n<li>Barendregt, Henk, 1985, <em>The Lambda Calculus: Its Syntax and\nSemantics</em> (Studies in Logic and the Foundations of Mathematics\n103), 2nd edition, Amsterdam: North-Holland.</li>\n<li>Barendregt, Henk, 1993, \u201cLambda calculi with types\u201d,\nin S. Abramsky, D. Gabbay, T. Maibaum, and H. Barendregt (eds.),\n<em>Handbook of Logic in Computer Science</em> (Volume 2), New York:\nOxford University Press, pp. 117\u2013309.</li>\n<li>Barendregt, Henk, Wil Dekkers, and Richard Statman., 2013,\n<em>Lambda Calculus With Types</em>, Cambridge: Cambridge University\nPress.</li>\n<li>Bealer, George, 1982, <em>Quality and Concept</em>, Oxford:\nClarendon Press.</li>\n<li>van Benthem, Johan, 1998, <em>A Manual of Intensional Logic</em>,\nStanford: CSLI Publications.</li>\n<li>Carnap, Rudolf, 1947, <em>Meaning and Necessity</em>, Chicago:\nUniversity of Chicago Press.</li>\n<li>Church, Alonzo, 1932, \u201cA set of postulates for the\nfoundation of logic\u201d, <em>Annals of Mathematics</em> (2nd\nSeries), 33(2): 346\u2013366.</li>\n<li>Cutland, Nigel J., 1980, <em>Computability</em>, Cambridge:\nCambridge University Press.</li>\n<li>Doets, Kees and Jan van Eijk, 2004, <em>The Haskell Road to Logic,\nMaths and Programming</em>, London: College Publications.</li>\n<li>Enderton, Herbert B., 2001, <em>A Mathematical Introduction to\nLogic</em>, 2nd edition, San Diego: Harcourt/Academic Press.</li>\n<li>Frege, Gottlob, 1893, <em>Grundgesetze der Arithmetik</em>, Jena:\nVerlag Hermann Pohle, Band I; partial translation as <em>The Basic\nLaws of Arithmetic</em>, M. Furth (trans.), Berkeley: University of\nCalifornia Press, 1964.</li>\n<li>Kleene, Stephen C., 1981, \u201cOrigins of recursive function\ntheory\u201d, <em>Annals of the History of Computing</em>, 3(1):\n52\u201367.</li>\n<li>Heim, Irene and Angelika Kratzer, 1998, <em>Semantics in\nGenerative Grammar</em>, Malden, MA: Blackwell.</li>\n<li>Hindley, J. Roger, 1997, <em>Basic Simple Type Theory</em>\n(Cambridge Tracts in Theoretical Computer Science 42), New York:\nCambridge University Press.</li>\n<li>Hindley, J. Roger and G. Longo, 1980, \u201cLambda-calculus\nModels and Extensionality.\u201d <em>Zeitschrift f\u00fcr\nmathematische Logik und Grundlagen der Mathematik</em>, 26:\n289\u2013310.</li>\n<li>Hindley, J. Roger and Jonathan P. Seldin, 2008,\n<em>Lambda-Calculus and Combinators: An Introduction</em>, 2nd\nedition, Cambridge: Cambridge University Press.</li>\n<li>Howard, William A., 1980, \u201cThe formula-as-types notion of\nconstruction\u201d, in J. Hindley and J. Seldin (eds.), <em>To H. B.\nCurry: Essays on Combinatory Logic, Lambda-Calculus, and\nFormalism</em>, London: Academic Press, pp. 479\u2013490.</li>\n<li>Hyland, J. Martin E., 2017, \u201cClassical Lambda Calculus in\nModern Dress\u201d, <em>Mathematical Structures in Computer\nScience</em>, 27(5): 762\u2013781.</li>\n<li>Koymans, C.P.J., 1982, \u201cModels of the Lambda\nCalculus\u201d, <em>Information and Control</em>, 52:\n306\u2013332.</li>\n<li>Manzano, Maria, 2005, <em>Extensions of First-order Logic</em>\n(Cambridge Tracts in Theoretical Computer Science 19), Cambridge:\nCambridge University Press.</li>\n<li>McCarthy, John, 1960, \u201cRecursive functions of symbolic\nexpressions and their computation by machine (Part I)\u201d,\n<em>Communications of the ACM</em>, 3(4): 184\u2013195.</li>\n<li>McMichael, Alan and Edward N. Zalta, 1980, \u201cAn alternative\ntheory of nonexistent objects\u201d, <em>Journal of Philosophical\nLogic</em>, 9: 297\u2013313.</li>\n<li>Menzel, Christopher, 1986, \u201cA complete, type-free second\norder logic of properties, relations, and propositions\u201d,\nTechnical Report #CSLI-86-40, Stanford: CSLI Publications.</li>\n<li>Menzel, Christopher, 1993, \u201cThe proper treatment of\npredication in fine-grained intensional logic\u201d,\n<em>Philosophical Perspectives</em> 7: 61\u201386.</li>\n<li>Meyer, Albert R., 1982, \u201cWhat is a model of the lambda\ncalculus?\u201d, In <em>Information and Control</em>, 52(1):\n87\u2013122.</li>\n<li>Nederpelt, Rob, with Herman Geuvers and Roel de Vriejer (eds.),\n1994, <em>Selected Papers on Automath</em> (Studies in Logic and the\nFoundations of Mathematics 133), Amsterdam: North-Holland.</li>\n<li>Nolan, Daniel, 2014, \u201cHyperintensional metaphysics\u201d,\n<em>Philosophical Studies</em>, 171(1); 149\u2013160.</li>\n<li>Orilia, Francesco, 2000, \u201cProperty theory and the revision\ntheory of definitions\u201d, <em>Journal of Symbolic Logic</em>,\n65(1): 212\u2013246.</li>\n<li>Partee, Barbara H., with Alice ter Meulen and Robert E. Wall,\n1990, <em>Mathematical Methods in Linguistics</em>, Berlin:\nSpringer.</li>\n<li>Plotkin, G.D., 1972, <em>A Set-Theoretical Definition of\nApplication</em>, School of Artificial Intelligence, Memo MIP-R-95,\nUniversity of Edinburgh.</li>\n<li>Revesz, George E., 1988, <em>Lambda-Calculus, Combinators, and\nFunctional Programming</em>, Cambridge: Cambridge University Press;\nreprinted 2008.</li>\n<li>Rosser, J. Barkley, 1984, \u201cHighlights of the History of the\nLambda-Calculus\u201d, <em>Annals of the History of Computing</em>,\n6(4): 337\u2013349.</li>\n<li>Salibra, Antonio, 2003, \u201cLambda calculus: models and\ntheories\u201d, in <em>Proceedings of the Third AMAST Workshop on\nAlgebraic Methods in Language Processing (AMiLP-2003)</em>, No. 21,\nUniversity of Twente, pp. 39\u201354.</li>\n<li>Sch\u00f6nfinkel, Moses, 1924, \u201cOn the building blocks of\nmathematical logic\u201d, in J. van Heijenoort (ed.), <em>From Frege\nto G\u00f6del: A Source Book in Mathematical Logic</em>, Cambridge,\nMA: Harvard University Press, 1967, pp. 355\u2013366.</li>\n<li>Scott, Dana, 1974, \u201cThe LAMBDA language\u201d, <em>Journal\nof Symbolic Logic</em>, 39: 425\u2013427.</li>\n<li>\u2013\u2013\u2013, 1980, \u201cLambda Calculus: Some Models,\nSome Philosophy\u201d, in J. Barwise, H.J. Keisler, and K. Kunen\n(eds.), <em>The Kleene Symposium</em>, Amsterdam: North-Holland, pp.\n223\u2013265.</li>\n<li>Troelstra, Anne and Helmut Schwichtenberg, 2000, <em>Basic Proof\nTheory</em> (Cambridge Tracts in Theoretical Computer Science 43), 2nd\nedition, Cambridge: Cambridge University Press.</li>\n<li>Turing, Alan M., 1937, \u201cComputability and\n\\(\\lambda\\)-definability\u201d, <em>Journal of Symbolic Logic</em>,\n2(4): 153\u2013163.</li>\n<li>Turner, Richard, 1987, \u201cA theory of properties\u201d,\n<em>Journal of Symbolic Logic</em>, 52(2): 455\u2013472.</li>\n<li>Zalta, Edward N., 1983, <em>Abstract Objects: An Introduction to\nAxiomatic Metaphysics</em>, Dordrecht: D. Reidel.</li>\n<li>Zalta, Edward N. and Paul Oppenheimer, 2011, \u201cRelations\nversus functions at the foundations of logic: type-theoretic\nconsiderations\u201d, <em>Journal of Logic and Computation</em> 21:\n351\u2013374.</li>\n<li>Zerpa, L., 2021, \u201cThe Teaching and Learning of the Untyped\nLambda Calculus Through Web-Based e-Learning Tools\u201d, in K. Arai\n<em>Intelligent Computing</em> (Lecture Notes in Networks and Systems:\nVolume 285), Cham: Springer, pp. 419\u2013436.</li>\n</ul>\n</div>"}, "related_entries": {"entry_list": ["computer science, philosophy of", "Curry\u2019s paradox", "logic: combinatory", "logic: intensional", "logic: intuitionistic", "logic: second-order and higher-order", "properties", "semantics: Montague", "type theory", "type theory: Church\u2019s type theory"], "entry_link": [{"../computer-science/": "computer science, philosophy of"}, {"../curry-paradox/": "Curry\u2019s paradox"}, {"../logic-combinatory/": "logic: combinatory"}, {"../logic-intensional/": "logic: intensional"}, {"../logic-intuitionistic/": "logic: intuitionistic"}, {"../logic-higher-order/": "logic: second-order and higher-order"}, {"../properties/": "properties"}, {"../montague-semantics/": "semantics: Montague"}, {"../type-theory/": "type theory"}, {"../type-theory-church/": "type theory: Church\u2019s type theory"}]}, "academic_tools": {"listed_text": ["<img alt=\"sep man icon\" src=\"../../symbols/sepman-icon.jpg\"/>", "<a href=\"https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=lambda-calculus\" target=\"other\">How to cite this entry</a>.", "<img alt=\"sep man icon\" src=\"../../symbols/sepman-icon.jpg\"/>", "<a href=\"https://leibniz.stanford.edu/friends/preview/lambda-calculus/\" target=\"other\">Preview the PDF version of this entry</a> at the\n <a href=\"https://leibniz.stanford.edu/friends/\" target=\"other\">Friends of the SEP Society</a>.", "<img alt=\"inpho icon\" src=\"../../symbols/inpho.png\"/>", "<a href=\"https://www.inphoproject.org/entity?sep=lambda-calculus&amp;redirect=True\" target=\"other\">Look up topics and thinkers related to this entry</a>\n at the Internet Philosophy Ontology Project (InPhO).", "<img alt=\"phil papers icon\" src=\"../../symbols/pp.gif\"/>", "<a href=\"https://philpapers.org/sep/lambda-calculus/\" target=\"other\">Enhanced bibliography for this entry</a>\nat <a href=\"https://philpapers.org/\" target=\"other\">PhilPapers</a>, with links to its database."], "listed_links": [{"https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=lambda-calculus": "How to cite this entry"}, {"https://leibniz.stanford.edu/friends/preview/lambda-calculus/": "Preview the PDF version of this entry"}, {"https://leibniz.stanford.edu/friends/": "Friends of the SEP Society"}, {"https://www.inphoproject.org/entity?sep=lambda-calculus&redirect=True": "Look up topics and thinkers related to this entry"}, {"https://philpapers.org/sep/lambda-calculus/": "Enhanced bibliography for this entry"}, {"https://philpapers.org/": "PhilPapers"}]}, "other_internet_resources": {"listed_text": ["<a href=\"http://lambdacalculator.com/\" target=\"other\">The Lambda Calculator</a>,\n a tool for working with \\(\\lambda\\)-terms with an eye toward their\nuse in formal semantics of natural language.", "<a href=\"http://lambda.jimpryor.net/code/lambda_evaluator/\" target=\"other\">Lambda Evaluator</a>,\n for visualizing reductions. Standard combinators and Church numerals\nare predefined.", "<a href=\"http://www.itu.dk/people/sestoft/lamreduce/index.html\" target=\"other\">Lambda calculus reduction workbench</a>,\n for visualizing reduction strategies.", "<a href=\"http://turing100.acm.org/lambda_calculus_timeline.pdf\" target=\"other\">\u201c\\(\\lambda\\)-Calculus: Then and Now,\u201d</a>\n useful handout on the milestones in, contributors to, and\nbibliography on the \\(\\lambda\\)-calculus, presented at the several\nTuring Centennial conferences. There also exists a\n <a href=\"https://www.youtube.com/watch?v=7cPtCpyBPNI\" target=\"other\">video recording</a>\n of the lecture given on the occasion of Princeton University\u2019s\ncelebration of the Turing Centennial in 2012. "], "listed_links": [{"http://lambdacalculator.com/": "The Lambda Calculator"}, {"http://lambda.jimpryor.net/code/lambda_evaluator/": "Lambda Evaluator"}, {"http://www.itu.dk/people/sestoft/lamreduce/index.html": "Lambda calculus reduction workbench"}, {"http://turing100.acm.org/lambda_calculus_timeline.pdf": "\u201c\\(\\lambda\\)-Calculus: Then and Now,\u201d"}, {"https://www.youtube.com/watch?v=7cPtCpyBPNI": "video recording"}]}, "tokenized_text": ["1", "introduction", "lambda", "calculus", "elegant", "notation", "working", "application", "function", "argument", "take", "mathematical", "example", "suppose", "given", "simple", "polynomial", "x2", "2cdot", "x5", "value", "expression", "x", "2", "compute", "plugging", "2", "x", "expression", "get", "22", "2cdot", "25", "reduce", "get", "answer", "5", "use", "lambda", "calculus", "represent", "situation", "start", "lambda", "term", "lambda", "x", "x2", "2cdot", "x5", "lambda", "operator", "allows", "u", "abstract", "x", "one", "intuitively", "read", "lambda", "x", "x2", "2cdot", "x5", "expression", "waiting", "value", "a", "variable", "x", "given", "value", "a", "number", "2", "value", "expression", "a2", "2cdot", "a5", "lambda", "significance", "merely", "bind", "variable", "x", "guarding", "outside", "interference", "terminology", "lambda", "calculus", "want", "apply", "expression", "argument", "get", "value", "write", "ma", "denote", "application", "function", "m", "argument", "a", "continuing", "example", "get", "begin", "align", "lambda", "x", "x2", "2cdot", "x5", "2", "rhd", "22", "2cdot", "25", "langle", "text", "substitute", "2", "xrangle", "445", "langletext", "arithmetic", "rangle", "5", "langletext", "arithmetic", "rangle", "end", "align", "first", "step", "calculation", "plugging", "2", "occurrence", "x", "expression", "x2", "2cdot", "x", "5", "passage", "abstraction", "term", "another", "term", "operation", "substitution", "remaining", "equality", "justified", "computing", "natural", "number", "example", "suggests", "central", "principle", "lambda", "calculus", "called", "beta", "reduction", "also", "sometimes", "called", "beta", "conversion", "tag", "beta", "lambda", "x", "n", "rhd", "x", "n", "understanding", "reduce", "contract", "rhd", "application", "lambda", "xm", "n", "abstraction", "term", "lefthand", "side", "lambda", "xm", "something", "righthand", "side", "n", "simply", "plugging", "n", "occurrence", "x", "inside", "m", "notation", "x", "n", "express", "beta", "reduction", "beta", "conversion", "heart", "lambda", "calculus", "one", "actually", "applies", "beta", "reduction", "reduce", "term", "important", "proviso", "observed", "described", "section", "21", "discus", "bound", "free", "variable", "11", "multiargument", "operation", "function", "multiple", "argument", "lambda", "calculus", "represent", "operation", "computing", "length", "hypotenuse", "right", "triangle", "hypotenuse", "right", "triangle", "leg", "length", "x", "rightarrow", "sqrt", "x2", "y2", "lengthofhypotenuse", "operation", "map", "two", "positive", "real", "number", "x", "y", "another", "positive", "real", "number", "one", "represent", "multiplearity", "operation", "using", "apparatus", "lambda", "calculus", "viewing", "operation", "taking", "one", "input", "time", "thus", "operation", "seen", "taking", "one", "input", "x", "positive", "real", "number", "producing", "value", "number", "operation", "namely", "operation", "take", "positive", "real", "number", "y", "input", "produce", "output", "positive", "real", "number", "sqrt", "x2", "y2", "one", "could", "summarize", "discussion", "saying", "operation", "hypotenuselength", "computes", "length", "hypotenuse", "right", "triangle", "given", "length", "a", "b", "leg", "hypotenuselength", "lambda", "lambda", "b", "sqrt", "a2", "b2", "principle", "beta", "reduction", "example", "hypotenuselength", "3", "application", "hypotenuselength", "3", "lambda", "b", "sqrt", "32", "b2", "function", "waiting", "another", "argument", "lambda", "term", "hypotenuselength", "3", "viewed", "function", "computes", "length", "hypotenuse", "right", "triangle", "one", "whose", "leg", "length", "3", "find", "finally", "hypotenuselength", "3", "4the", "application", "hypotenuselength", "3", "4is", "5", "expected", "another", "way", "understand", "reduction", "manyplace", "function", "oneplace", "function", "imagine", "machine", "m", "initially", "start", "loading", "first", "a", "multiple", "argument", "b", "ldots", "memory", "one", "suspends", "machine", "loaded", "first", "argument", "memory", "one", "view", "result", "another", "machine", "m", "_a", "awaiting", "one", "fewer", "input", "first", "argument", "fixed", "12", "nonextensionality", "important", "philosophical", "issue", "concerning", "lambda", "calculus", "question", "underlying", "concept", "function", "set", "theory", "function", "standardly", "understood", "set", "argumentvalue", "pair", "specifically", "function", "understood", "set", "f", "ordered", "pair", "satisfying", "property", "x", "in", "f", "x", "z", "in", "f", "implies", "z", "f", "function", "x", "in", "f", "mean", "function", "f", "assigns", "value", "y", "argument", "x", "concept", "functionsassets", "consequently", "notion", "equality", "functionsassets", "equality", "qua", "set", "standard", "principle", "extensionality", "entail", "two", "function", "equal", "precisely", "contain", "ordered", "pair", "word", "two", "function", "identical", "assign", "value", "argument", "sense", "functionsassets", "extensional", "object", "contrast", "notion", "function", "work", "lambda", "calculus", "one", "function", "understood", "rule", "function", "given", "rule", "determine", "value", "argument", "specifically", "view", "lambda", "term", "lambda", "x", "description", "operation", "given", "x", "produce", "m", "body", "m", "abstraction", "term", "essentially", "rule", "x", "conception", "functionsasrules", "intuitively", "given", "rule", "m", "n", "general", "decide", "whether", "lambda", "x", "equal", "lambda", "x", "n", "two", "term", "might", "behave", "value", "given", "argument", "may", "clear", "resource", "needed", "showing", "equality", "term", "sense", "functionsasrules", "nonextensional", "object", "distinguish", "extensional", "concept", "functionsassets", "nonextensional", "concept", "functionsasrules", "latter", "often", "referred", "intensional", "function", "concept", "part", "ostensibly", "intensional", "concept", "rule", "involved", "terminology", "particularly", "predominant", "community", "mathematical", "logician", "philosopher", "mathematics", "working", "foundation", "mathematics", "perspective", "philosophy", "language", "terminology", "somewhat", "misleading", "since", "context", "extensionalintensional", "distinction", "slightly", "different", "meaning", "standard", "possibleworlds", "framework", "philosophical", "semantics", "would", "distinguish", "extensional", "intensional", "function", "concept", "follows", "let", "u", "say", "two", "function", "extensionally", "equivalent", "world", "assign", "value", "argument", "world", "let", "u", "say", "two", "function", "intensionally", "equivalent", "assign", "value", "argument", "every", "possibleworld", "illustrate", "consider", "function", "highestmountainonearth", "highestmountaininthehimalayas", "highestmountainonearth", "assigns", "highest", "mountain", "earth", "value", "every", "argument", "highestmountaininthehimalayas", "assigns", "highest", "mountain", "himalaya", "value", "every", "argument", "two", "function", "extensionally", "equivalent", "actual", "world", "intensionally", "actual", "world", "two", "function", "assign", "value", "every", "argument", "namely", "mt", "everest", "consider", "world", "mt", "everest", "highest", "mountain", "earth", "say", "mt", "rushmore", "suppose", "mt", "rushmore", "30000", "feet9100", "higher", "actual", "world", "mt", "everest", "roughly", "29000", "feet8800", "still", "highest", "mountain", "himalaya", "world", "highestmountainonearth", "assigns", "mt", "rushmore", "value", "every", "argument", "highestmountaininthehimalayas", "still", "assigns", "mt", "everest", "every", "object", "word", "highestmountainonearth", "highestmountaininthehimalayas", "extensionally", "equivalent", "actual", "world", "intensionally", "equivalent", "function", "concept", "may", "called", "extensional", "requires", "function", "extensionally", "equivalent", "actual", "world", "identical", "function", "concept", "may", "classified", "intensional", "requires", "intensionally", "equivalent", "function", "identical", "note", "classification", "conceptually", "different", "distinction", "commonly", "used", "foundation", "mathematics", "terminology", "used", "foundation", "mathematics", "functionsassets", "classified", "extensional", "since", "use", "axiom", "extensionality", "criterion", "identity", "functionsasrules", "classified", "intensional", "rely", "ostensibly", "intensional", "concept", "rule", "present", "possibleworlds", "terminology", "function", "concept", "classified", "extensional", "intensional", "based", "behavior", "possibleworlds", "issue", "conceptual", "confusion", "might", "arise", "two", "terminology", "potentially", "pas", "different", "verdict", "function", "concept", "work", "lambda", "calculus", "see", "consider", "following", "two", "function", "begin", "align", "addone", "lambda", "x", "x1", "addtwosubtractone", "lambda", "x", "x2", "1", "end", "align", "two", "function", "clearly", "extensionally", "equivalent", "assign", "value", "input", "actual", "world", "moreover", "given", "standard", "assumption", "possible", "world", "semantics", "two", "function", "also", "intensionally", "equivalent", "assume", "mathematical", "fact", "like", "fact", "addition", "subtraction", "necessary", "sense", "every", "possible", "world", "get", "two", "function", "give", "value", "argument", "every", "possible", "world", "intensional", "function", "concept", "would", "require", "two", "function", "identical", "lambda", "calculus", "however", "clear", "identify", "two", "function", "formally", "speaking", "without", "help", "principle", "show", "two", "lambda", "terms", "denote", "function", "moreover", "informally", "speaking", "conception", "functionsasrules", "even", "clear", "identify", "two", "term", "involve", "genuinely", "different", "rule", "might", "tempted", "say", "denote", "different", "function", "function", "concept", "allows", "intensionally", "equivalent", "function", "distinct", "called", "hyperintensional", "point", "possibleworlds", "terminology", "function", "concept", "work", "lambda", "calculus", "may", "regarded", "intentional", "hyperintensionalin", "contrast", "terminology", "common", "foundation", "mathematics", "say", "note", "unclear", "intensional", "semantic", "framework", "like", "possibleworlds", "framework", "could", "even", "principle", "account", "nonintensional", "function", "concept", "semantics", "lambda", "calculus", "see", "section", "7", "point", "simply", "clarify", "conceptual", "confusion", "might", "arise", "different", "terminology", "play", "philosophical", "discourse", "hyperintensionality", "lambda", "calculus", "particularly", "important", "come", "application", "theory", "function", "generally", "n", "ary", "relation", "see", "section", "93", "effectively", "hyperintensionality", "lambda", "calculus", "make", "attractive", "tool", "context", "noted", "however", "lambda", "calculus", "made", "extensional", "well", "intensional", "postulating", "additional", "law", "concerning", "equality", "lambda", "terms", "see", "section", "5", "2", "syntax", "official", "syntax", "lambda", "calculus", "quite", "simple", "contained", "next", "definition", "definition", "alphabet", "language", "lambda", "calculus", "take", "left", "right", "parenthesis", "left", "right", "square", "bracket", "symbol", "lambda", "infinite", "set", "variable", "class", "lambda", "terms", "defined", "inductively", "follows", "every", "variable", "lambda", "term", "m", "n", "lambda", "terms", "mn", "m", "lambda", "term", "x", "variable", "lambda", "x", "lambda", "term", "term", "always", "mean", "lambda", "term", "term", "formed", "according", "rule", "2", "called", "application", "term", "term", "formed", "according", "rule", "3", "called", "abstraction", "term", "common", "dealing", "formal", "language", "grouping", "symbol", "left", "right", "parenthesis", "case", "parenthesis", "omitted", "safe", "reintroduced", "one", "sensible", "way", "juxtaposing", "two", "lambda", "terms", "strictly", "speaking", "illegal", "avoid", "tedium", "always", "writing", "needed", "parenthesis", "adopt", "following", "convention", "convention", "association", "left", "two", "term", "m_1", "m_2", "m_3", "ldots", "m_n", "juxtaposed", "recover", "missing", "parenthesis", "associating", "left", "reading", "left", "right", "group", "m_1", "m_2", "together", "yielding", "m_1", "m_2", "m_3", "ldots", "m_n", "group", "m_1", "m_2", "m_3", "m_1", "m_2", "m_3", "ldots", "m_n", "forth", "convention", "thus", "give", "unique", "reading", "sequence", "lambda", "terms", "whose", "length", "greater", "2", "21", "variable", "bound", "free", "function", "lambda", "abstraction", "term", "lambda", "x", "bind", "variable", "appearing", "immediately", "term", "m", "thus", "lambda", "analogous", "universal", "existential", "quantifier", "forall", "exists", "firstorder", "logic", "one", "define", "analogously", "notion", "free", "bound", "variable", "expected", "way", "follows", "definition", "syntactic", "function", "mathbf", "fv", "mathbf", "bv", "free", "variable", "bound", "variable", "respectively", "defined", "set", "lambda", "terms", "structural", "induction", "thus", "every", "variable", "x", "term", "m", "term", "n", "begin", "array", "lll", "text", "free", "text", "bound", "1", "mathbf", "fv", "x", "x", "quad", "mathbf", "bv", "x", "varnothing", "2", "mathbf", "fv", "mn", "mathbf", "fv", "cup", "mathbf", "fv", "n", "mathbf", "bv", "mn", "mathbf", "bv", "cup", "mathbf", "bv", "n", "3", "mathbf", "fv", "lambda", "x", "mathbf", "fv", "x", "mathbf", "bv", "lambda", "x", "mathbf", "bv", "cup", "x", "end", "array", "mathbf", "fv", "varnothing", "m", "called", "combinator", "clause", "3", "two", "definition", "support", "intention", "lambda", "bind", "variable", "ensures", "free", "note", "difference", "mathbf", "bv", "mathbf", "fv", "variable", "typical", "subject", "concept", "appear", "firstorder", "logic", "one", "need", "careful", "issue", "casual", "attitude", "substitution", "lead", "syntactic", "difficulty", "1", "defend", "casual", "attitude", "adopting", "convention", "interested", "term", "certain", "equivalence", "class", "term", "define", "substitution", "lay", "convention", "allows", "u", "avoid", "difficulty", "definition", "substitution", "write", "x", "n", "denote", "substitution", "n", "free", "occurrence", "x", "m", "precise", "definition", "2", "recursion", "set", "lambda", "terms", "follows", "term", "a", "b", "m", "variable", "x", "y", "define", "x", "x", "equiv", "m", "x", "equiv", "y", "y", "distinct", "x", "ab", "x", "equiv", "x", "b", "x", "lambda", "x", "x", "equiv", "lambda", "x", "lambda", "x", "equiv", "lambda", "x", "y", "distinct", "x", "clause", "1", "definition", "simply", "say", "substitute", "m", "x", "dealing", "simply", "x", "result", "m", "clause", "2", "say", "nothing", "happens", "dealing", "variable", "different", "x", "substitute", "something", "x", "clause", "3", "tell", "u", "substitution", "unconditionally", "distributes", "application", "clause", "4", "5", "concern", "abstraction", "term", "parallel", "clause", "1", "2", "rather", "clause", "2", "1", "opposite", "order", "bound", "variable", "z", "abstraction", "term", "lambda", "z", "identical", "variable", "x", "substitution", "perform", "substitution", "substitution", "stop", "coheres", "intention", "x", "n", "supposed", "denote", "substitution", "n", "free", "occurrence", "x", "m", "m", "abstraction", "term", "lambda", "x", "whose", "bound", "variable", "x", "x", "occurr", "freely", "m", "nothing", "explains", "clause", "4", "clause", "5", "finally", "say", "bound", "variable", "abstraction", "term", "differs", "x", "least", "x", "chance", "occur", "freely", "abstraction", "term", "substitution", "continues", "body", "abstraction", "term", "definition", "change", "bound", "variable", "alpha", "convertibility", "term", "n", "obtained", "term", "m", "change", "bound", "variable", "roughly", "abstraction", "term", "lambda", "x", "inside", "m", "replaced", "lambda", "x", "let", "u", "say", "term", "m", "n", "alpha", "convertible", "sequence", "change", "bound", "variable", "starting", "m", "ending", "n", "axiom", "beta", "conversion", "stated", "nocapture", "proviso", "lambda", "x", "n", "rhd", "x", "n", "provided", "variable", "occurrs", "free", "n", "becomes", "bound", "substitution", "m", "roughly", "need", "adhere", "principle", "free", "variable", "ought", "remain", "free", "occurrence", "variable", "threatened", "become", "bound", "substitution", "simply", "perform", "enough", "alpha", "conversions", "sidestep", "problem", "keep", "mind", "work", "lambda", "calculus", "without", "worrying", "nettlesome", "syntactic", "difficulty", "example", "apply", "function", "lambda", "x", "lambda", "x", "y5", "argument", "2y", "upon", "substitution", "2y", "x", "y", "2y", "would", "captured", "variablebinding", "operator", "lambda", "y", "substitution", "would", "yield", "function", "different", "one", "intended", "however", "first", "transform", "lambda", "x", "lambda", "x", "y5", "lambda", "x", "lambda", "z", "x", "z5", "alpha", "conversion", "apply", "latter", "function", "argument", "2y", "whereas", "following", "valid", "use", "beta", "conversion", "lambda", "x", "lambda", "x", "y5", "2y", "rhd", "lambda", "2y", "y5", "validly", "use", "beta", "conversion", "conclude", "lambda", "x", "lambda", "z", "x", "z5", "2y", "rhd", "lambda", "z", "2y", "z5", "example", "help", "one", "see", "proviso", "beta", "conversion", "important", "proviso", "really", "different", "one", "used", "statement", "axiom", "predicate", "calculus", "namely", "forall", "xphi", "to", "phi", "tau", "_x", "provided", "variable", "free", "term", "tau", "substitution", "becomes", "bound", "substitution", "syntax", "lambda", "calculus", "quite", "flexible", "one", "form", "sort", "term", "even", "selfapplications", "xx", "term", "appear", "first", "blush", "suspicious", "one", "might", "suspect", "using", "term", "could", "lead", "inconsistency", "case", "one", "might", "find", "oneself", "reaching", "tool", "forbid", "term", "one", "view", "function", "set", "ordered", "pair", "certain", "kind", "x", "xx", "would", "function", "set", "ordered", "pair", "contains", "element", "pair", "x", "whose", "first", "element", "would", "x", "set", "contain", "way", "lest", "axiom", "foundation", "regularity", "violated", "thus", "set", "theoretical", "perspective", "term", "clearly", "dubious", "one", "find", "brief", "sketch", "one", "tool", "type", "theory", "fact", "term", "lead", "inconsistency", "serve", "useful", "purpose", "context", "lambda", "calculus", "moreover", "forbidding", "term", "type", "theory", "come", "free", "eg", "expressiveness", "untyped", "lambda", "calculus", "lost", "22", "combinators", "defined", "earlier", "combinator", "lambda", "term", "free", "variable", "one", "intuitively", "understand", "combinators", "completely", "specified", "operation", "since", "free", "variable", "handful", "combinators", "proven", "useful", "history", "lambda", "calculus", "next", "table", "highlight", "special", "combinators", "many", "could", "given", "obviously", "infinitely", "many", "combinators", "following", "concise", "definition", "proved", "utility", "table", "standard", "lambda", "terms", "combinators", "name", "definition", "comment", "bs", "lambda", "x", "lambda", "lambda", "z", "xz", "yz", "keep", "mind", "xz", "yz", "understood", "application", "xz", "yz", "xz", "yz", "bs", "thus", "understood", "substituteandapply", "operator", "z", "intervenes", "x", "y", "instead", "applying", "x", "y", "apply", "xz", "yz", "mathbf", "k", "lambda", "x", "lambda", "x", "value", "mathbf", "k", "m", "constant", "function", "whose", "value", "argument", "simply", "m", "mathbf", "lambda", "x", "x", "identity", "function", "mathbf", "b", "lambda", "x", "lambda", "lambda", "z", "x", "yz", "recall", "xyz", "understood", "xy", "z", "combinator", "trivial", "identity", "function", "mathbf", "c", "lambda", "x", "lambda", "lambda", "z", "xzy", "swap", "argument", "mathbf", "lambda", "x", "lambda", "x", "truth", "value", "true", "identical", "mathbf", "k", "shall", "see", "later", "representation", "truth", "value", "play", "role", "blending", "logic", "lambda", "calculus", "mathbf", "f", "lambda", "x", "lambda", "truth", "value", "false", "boldsymbol", "omega", "lambda", "x", "xx", "selfapplication", "combinator", "boldsymbol", "omega", "boldsymbol", "omega", "omega", "selfapplication", "selfapplication", "combinator", "reduces", "mathbf", "lambda", "f", "lambda", "x", "f", "xx", "lambda", "x", "f", "xx", "curry", "paradoxical", "combinator", "every", "lambda", "term", "x", "begin", "align", "mathbf", "x", "rhd", "lambda", "x", "x", "xx", "lambda", "x", "x", "xx", "rhd", "x", "lambda", "x", "x", "xx", "lambda", "x", "x", "xx", "end", "align", "first", "step", "reduction", "show", "mathbf", "x", "reduces", "application", "term", "lambda", "x", "x", "xx", "lambda", "x", "x", "xx", "recurring", "third", "step", "thus", "mathbf", "curious", "property", "mathbf", "x", "x", "mathbf", "x", "reduce", "common", "term", "boldsymbol", "theta", "lambda", "x", "lambda", "f", "f", "xxf", "lambda", "x", "lambda", "f", "f", "xxf", "turing", "fixedpoint", "combinator", "every", "lambda", "term", "x", "boldsymbol", "theta", "x", "reduces", "x", "boldsymbol", "theta", "x", "one", "confirm", "hand", "curry", "paradoxical", "combinator", "mathbf", "property", "table", "notational", "convention", "employed", "entry", "notation", "reading", "comment", "mn", "application", "function", "m", "argument", "n", "usually", "parenthesis", "used", "separate", "function", "argument", "like", "n", "however", "lambda", "calculus", "kindred", "subject", "parenthesis", "used", "grouping", "symbol", "thus", "safe", "write", "function", "argument", "adjacent", "one", "pqr", "application", "function", "pq", "which", "application", "function", "p", "argument", "q", "to", "r", "use", "parenthesis", "separate", "function", "argument", "disambiguate", "expression", "involve", "three", "term", "pqr", "recall", "convention", "understand", "officially", "illegal", "expression", "working", "left", "right", "always", "putting", "parenthesis", "around", "adjacent", "term", "thus", "pqr", "understood", "pq", "r", "pqrs", "pq", "r", "s", "expression", "pq", "r", "disambiguated", "convention", "identical", "pqr", "expression", "p", "qr", "also", "explicitly", "disambiguated", "distinct", "pqr", "application", "p", "argument", "qr", "application", "function", "q", "argument", "r", "lambda", "x", "lambda", "term", "bind", "variable", "x", "boldsymbol", "body", "term", "m", "official", "vocabulary", "lambda", "calculus", "consists", "symbol", "lambda", "left", "right", "parenthesis", "set", "variable", "assumed", "distinct", "three", "symbol", "lambda", "lest", "syntactic", "chaos", "alternative", "notation", "necessary", "include", "two", "kind", "grouping", "symbol", "parenthesis", "square", "bracket", "syntax", "parenthesis", "square", "bracket", "alone", "would", "obviously", "suffice", "two", "kind", "bracket", "employed", "entry", "sake", "readability", "given", "two", "kind", "grouping", "symbol", "could", "economize", "omit", "parenthesis", "abstraction", "term", "lambda", "x", "would", "written", "lambda", "x", "author", "write", "lambda", "xm", "lambda", "xcdot", "m", "full", "stop", "centered", "dot", "separating", "bound", "variable", "body", "abstraction", "term", "square", "bracket", "device", "intended", "assist", "reading", "lambda", "terms", "usually", "part", "official", "syntax", "one", "see", "device", "used", "earlier", "work", "logic", "principia", "mathematica", "function", "symbol", "expression", "forall", "x", "phi", "get", "u", "read", "whole", "formula", "phi", "scope", "forall", "x", "author", "write", "abstraction", "term", "without", "device", "separating", "bound", "variable", "body", "term", "crisply", "written", "eg", "lambda", "xx", "lambda", "yx", "practice", "without", "merit", "concise", "one", "ask", "permit", "even", "simpler", "official", "syntax", "lambda", "calculus", "practice", "flawless", "lambda", "xyz", "bound", "variable", "x", "xy", "usually", "name", "variable", "single", "letter", "theoretically", "clearly", "sufficient", "seems", "unduly", "restrictive", "forbid", "practice", "giving", "longer", "name", "variable", "indeed", "construction", "arise", "naturally", "computer", "programming", "language", "sake", "uniformity", "adopt", "square", "bracket", "notation", "entry", "incidentally", "notation", "used", "turing", "1937", "x", "lambda", "term", "obtained", "substituting", "lambda", "term", "free", "occurrence", "x", "inside", "m", "bewildering", "array", "notation", "represent", "substitution", "found", "literature", "lambda", "calculus", "kindred", "subject", "xa", "ax", "m_", "x", "a", "m_", "x", "xa", "ldots", "notation", "use", "substitution", "seems", "personal", "matter", "entry", "use", "linear", "notation", "eschewing", "superscript", "subscript", "practice", "representing", "substitution", "come", "computer", "science", "read", "programming", "language", "assigning", "value", "variable", "square", "bracket", "employed", "write", "abstraction", "term", "square", "bracket", "employed", "write", "substitution", "officially", "part", "syntax", "lambda", "calculus", "m", "term", "x", "variable", "x", "another", "term", "equiv", "n", "lambda", "terms", "m", "n", "identical", "understood", "sequence", "symbol", "m", "n", "length", "corresponding", "symbol", "sequence", "identical", "syntactic", "identity", "relation", "equiv", "part", "official", "syntax", "lambda", "calculus", "relation", "lambda", "terms", "belongs", "metatheory", "lambda", "calculus", "clearly", "rather", "strict", "notion", "equality", "lambda", "terms", "thus", "case", "x", "y", "distinct", "variable", "lambda", "x", "x", "equiv", "lambda", "even", "though", "two", "term", "clearly", "behave", "way", "sense", "expression", "identity", "operation", "x", "rightarrow", "x", "later", "develop", "formal", "theory", "equality", "lambda", "terms", "aim", "capturing", "intuitive", "equality", "lambda", "x", "x", "lambda", "3", "brief", "history", "lambda", "calculus", "lambda", "calculus", "arose", "study", "function", "rule", "already", "essential", "ingredient", "subject", "found", "frege", "pioneering", "work", "frege", "1893", "frege", "observed", "study", "function", "sufficient", "focus", "unary", "function", "ie", "function", "take", "exactly", "one", "argument", "procedure", "viewing", "multiplearity", "operation", "sequence", "abstraction", "yield", "equivalent", "unary", "operation", "called", "currying", "operation", "perhaps", "would", "historically", "accurate", "call", "operation", "fregeing", "often", "miscarriage", "justice", "appellation", "mathematical", "idea", "1920s", "mathematician", "moses", "sch\u00f6nfinkel", "took", "subject", "study", "socalled", "combinators", "common", "early", "day", "subject", "sch\u00f6nfinkel", "interested", "kind", "transformation", "one", "see", "formal", "logic", "combinators", "intended", "contribution", "foundation", "formal", "logic", "analogy", "reduction", "one", "see", "classical", "propositional", "logic", "sheffer", "stroke", "sch\u00f6finkel", "established", "astonishing", "result", "function", "sense", "transformation", "could", "given", "term", "combinators", "mathbf", "k", "bs", "later", "see", "definition", "combinators", "theorem", "every", "term", "m", "made", "mathbf", "k", "bs", "variable", "x", "exists", "term", "f", "built", "mathbf", "k", "bs", "derive", "fx", "m", "proof", "two", "suffice", "represent", "function", "beyond", "scope", "entry", "discussion", "see", "entry", "combinatory", "logic", "one", "prove", "theorem", "constructively", "algorithm", "given", "m", "produce", "required", "f", "church", "called", "f", "lambda", "x", "church", "1932", "3", "perspective", "beta", "rule", "justified", "lambda", "x", "function", "f", "satisfying", "fx", "m", "lambda", "x", "x", "transform", "m", "special", "case", "general", "principle", "n", "lambda", "x", "n", "transform", "x", "n", "although", "today", "clearly", "delimited", "system", "abstraction", "rewriting", "early", "day", "lambda", "calculus", "combinatory", "logic", "\u00e0", "la", "sch\u00f6nfinkel", "bound", "investigation", "foundation", "mathematics", "hand", "curry", "church", "kleene", "rosser", "pioneer", "subject", "focus", "defining", "mathematical", "object", "carrying", "logical", "reasoning", "inside", "new", "system", "turned", "early", "attempt", "socalled", "illative", "lambda", "calculus", "combinatory", "logic", "inconsistent", "curry", "isolated", "polished", "inconsistency", "result", "known", "curry", "paradox", "see", "entry", "curry", "paradox", "appendix", "b", "barendregt", "1985", "lambda", "calculus", "earns", "special", "place", "history", "logic", "source", "first", "undecidable", "problem", "problem", "given", "lambda", "terms", "m", "n", "determine", "whether", "n", "theory", "equational", "reasoning", "lambda", "terms", "yet", "defined", "definition", "come", "later", "problem", "shown", "undecidable", "another", "early", "problem", "lambda", "calculus", "whether", "consistent", "context", "inconsistency", "mean", "term", "equal", "one", "reduce", "lambda", "term", "m", "lambda", "term", "n", "case", "early", "result", "lambda", "calculus", "initially", "one", "result", "showing", "certain", "term", "interconvertible", "eg", "mathbf", "k", "bs", "later", "much", "powerful", "result", "socalled", "churchrosser", "theorem", "helped", "shed", "light", "beta", "conversion", "could", "used", "give", "quick", "proof", "noninterconvertibility", "whole", "class", "lambda", "terms", "see", "detailed", "discussion", "consistency", "lambda", "calculus", "somewhat", "obscure", "formalism", "1960s", "last", "mathematical", "semantics", "found", "relation", "programming", "language", "also", "clarified", "till", "model", "lambda", "calculus", "syntactic", "generated", "style", "henkin", "consisted", "equivalence", "class", "lambda", "terms", "suitable", "notion", "equivalence", "application", "semantics", "natural", "language", "thanks", "development", "montague", "linguist", "helped", "spread", "word", "subject", "since", "lambda", "calculus", "enjoys", "respectable", "place", "mathematical", "logic", "computer", "science", "linguistics", "see", "eg", "heim", "kratzer", "1998", "kindred", "field", "4", "reduction", "various", "notion", "reduction", "lambda", "terms", "available", "principal", "one", "beta", "reduction", "already", "seen", "earlier", "earlier", "used", "notation", "rhd", "precise", "section", "discus", "beta", "reduction", "extension", "definition", "onestep", "beta", "reduction", "rhd_", "beta", "1", "lambda", "terms", "a", "b", "say", "a", "beta", "reduces", "one", "step", "b", "written", "rhd_", "beta", "1", "b", "case", "exists", "occurrence", "subterm", "c", "a", "variable", "x", "lambda", "terms", "m", "n", "c", "equiv", "lambda", "x", "n", "b", "a", "except", "occurrence", "c", "a", "replaced", "x", "n", "example", "beta", "reduction", "variable", "x", "beta", "reduce", "anything", "right", "shape", "simply", "variable", "application", "term", "whose", "lefthand", "side", "abstraction", "term", "lambda", "x", "x", "rhd_", "beta", "1", "a", "x", "y", "distinct", "variable", "lambda", "x", "rhd_", "beta", "1", "y", "lambda", "term", "lambda", "x", "lambda", "xy", "b", "beta", "reduces", "one", "step", "two", "different", "lambda", "terms", "lambda", "x", "lambda", "xy", "b", "rhd_", "beta", "1", "lambda", "lambda", "x", "lambda", "xy", "b", "rhd_", "beta", "1", "lambda", "x", "xa", "b", "moreover", "one", "check", "two", "term", "beta", "reduce", "one", "step", "common", "term", "ba", "thus", "lambda", "a", "nearrow", "searrow", "lambda", "x", "lambda", "xy", "b", "ba", "searrow", "nearrow", "lambda", "x", "xa", "b", "binary", "relation", "one", "ask", "many", "question", "relation", "rhd_", "beta", "1", "holding", "lambda", "terms", "one", "define", "various", "derived", "notion", "term", "rhd_", "beta", "1", "definition", "beta", "reduction", "sequence", "lambda", "term", "a", "lambda", "term", "b", "finite", "sequence", "s_1", "ldots", "s_n", "lambda", "terms", "starting", "a", "ending", "b", "whose", "adjacent", "term", "s_k", "s_", "k1", "satisfy", "property", "s_k", "rhd_", "beta", "1", "s_", "k1", "generally", "sequence", "s", "finite", "infinitestarting", "lambda", "term", "a", "said", "beta", "reduction", "sequence", "commencing", "a", "provided", "adjacent", "term", "s_k", "s_", "k1", "s", "satisfy", "property", "s_k", "rhd_", "beta", "1", "s_", "k1", "continuing", "beta", "reduction", "example", "1", "beta", "reduction", "sequence", "commencing", "variable", "x", "continuing", "beta", "reduction", "example", "2", "twoterm", "sequence", "lambda", "x", "x", "beta", "reduction", "sequence", "lambda", "x", "x", "a", "a", "a", "variable", "beta", "reduction", "sequence", "prolonged", "beta", "reduction", "sequence", "commencing", "lambda", "x", "x", "a", "thus", "set", "beta", "reduction", "sequence", "commencing", "lambda", "x", "x", "a", "finite", "contains", "infinite", "sequence", "combinator", "boldsymbol", "omega", "curious", "property", "omega", "rhd_", "beta", "1", "omega", "every", "term", "every", "beta", "reduction", "sequence", "commencing", "boldsymbol", "omega", "finite", "infinite", "equal", "boldsymbol", "omega", "consider", "term", "mathbf", "k", "aboldsymbol", "omega", "infinitely", "many", "reduction", "sequence", "commencing", "term", "bk", "aboldsymbol", "omega", "rhd_", "beta", "1", "a", "bk", "aboldsymbol", "omega", "rhd_", "beta", "1", "bk", "aboldsymbol", "omega", "rhd_", "beta", "1", "a", "bk", "aboldsymbol", "omega", "rhd_", "beta", "1", "bk", "aboldsymbol", "omega", "rhd_", "beta", "1", "bk", "aboldsymbol", "omega", "rhd_", "beta", "1", "a", "bk", "aboldsymbol", "omega", "rhd_", "beta", "1", "bk", "aboldsymbol", "omega", "rhd_", "beta", "1", "bk", "aboldsymbol", "omega", "ldots", "a", "variable", "one", "see", "finite", "reduction", "sequence", "commencing", "bk", "aboldsymbol", "omega", "end", "a", "exactly", "one", "infinite", "reduction", "sequence", "definition", "beta", "redex", "lambda", "term", "m", "occurrence", "subterm", "m", "form", "lambda", "x", "p", "q", "redex", "come", "reducible", "expression", "beta", "redex", "simply", "candidate", "application", "beta", "reduction", "one", "contract", "beta", "redex", "term", "said", "beta", "normal", "form", "beta", "redexes", "term", "multiple", "beta", "normal", "form", "answer", "literally", "yes", "substantially", "answer", "m", "m", "beta", "normal", "form", "term", "m", "alpha", "convertible", "m", "thus", "beta", "normal", "form", "unique", "change", "bound", "variable", "far", "focused", "one", "step", "beta", "reduction", "one", "combine", "multiple", "beta", "reduction", "step", "one", "taking", "transitive", "closure", "relation", "rhd_", "beta", "1", "definition", "lambda", "terms", "a", "b", "one", "say", "a", "beta", "reduces", "b", "written", "rhd_", "beta", "b", "either", "equiv", "b", "exists", "finite", "beta", "reduction", "sequence", "a", "b", "definition", "term", "m", "beta", "normal", "form", "exists", "term", "n", "n", "beta", "normal", "form", "rhd_", "beta", "n", "reducibility", "defined", "oneway", "relation", "generally", "true", "rhd_", "beta", "b", "b", "rhd_", "beta", "a", "however", "depending", "one", "purpose", "one", "may", "wish", "treat", "a", "b", "equivalent", "either", "a", "reduces", "b", "b", "reduces", "a", "amount", "considering", "reflexive", "symmetric", "transitive", "closure", "relation", "rhd_", "beta", "1", "definition", "lambda", "terms", "a", "b", "say", "_", "beta", "b", "either", "equiv", "b", "exists", "sequence", "s_1", "ldots", "s_n", "starting", "a", "ending", "b", "whose", "adjacent", "term", "s_k", "s_", "k1", "either", "s_k", "rhd_", "beta", "1", "s_", "k1", "s_", "k1", "rhd_", "beta", "1", "s_k", "41", "notion", "reduction", "thus", "far", "developed", "theory", "beta", "reduction", "mean", "notion", "reduction", "available", "lambda", "calculus", "addition", "beta", "reduction", "standard", "relation", "lambda", "terms", "eta", "reduction", "definition", "onestep", "eta", "reduction", "lambda", "terms", "a", "b", "say", "a", "beta", "eta", "reduces", "one", "step", "b", "written", "rhd_", "beta", "eta", "1", "b", "case", "exists", "occurrence", "subterm", "c", "a", "variable", "x", "lambda", "terms", "m", "n", "either", "c", "equiv", "lambda", "x", "n", "b", "a", "except", "occurrence", "c", "a", "replaced", "x", "n", "c", "equiv", "lambda", "x", "mx", "b", "a", "except", "occurrence", "c", "a", "replaced", "m", "first", "clause", "definition", "rhd_", "beta", "eta", "1", "ensures", "relation", "extends", "relation", "onestep", "beta", "reduction", "relation", "onestep", "beta", "reduction", "replay", "development", "eta", "reduction", "thus", "one", "notion", "eta", "redex", "rhd_", "eta", "1", "one", "define", "relation", "rhd_", "eta", "lambda", "terms", "reflexive", "transitive", "closure", "rhd_", "eta", "1", "capture", "zeroormoresteps", "eta", "reduction", "one", "defines", "_", "eta", "symmetric", "transitive", "closure", "rhd_", "eta", "rhd_", "eta", "1", "b", "length", "b", "strictly", "smaller", "a", "thus", "infinite", "eta", "reductions", "case", "beta", "reduction", "saw", "beta", "reduction", "sequence", "example", "3", "4", "one", "combine", "notion", "reduction", "one", "useful", "combination", "blend", "beta", "eta", "reduction", "definition", "onestep", "beta", "eta", "reduction", "lambda", "x", "mx", "rhd_", "beta", "eta", "1", "m", "lambda", "x", "n", "rhd_", "beta", "eta", "1", "x", "n", "lambda", "term", "a", "beta", "eta", "reduces", "one", "step", "lambda", "term", "b", "case", "either", "a", "beta", "reduces", "b", "one", "step", "a", "eta", "reduces", "b", "one", "step", "one", "replay", "basic", "concept", "reduction", "beta", "reduction", "new", "notion", "reduction", "beta", "eta", "42", "reduction", "strategy", "recall", "term", "said", "beta", "normal", "form", "beta", "redexes", "subterms", "shape", "lambda", "x", "n", "term", "beta", "normal", "form", "reduced", "term", "beta", "normal", "form", "intuitively", "clear", "term", "beta", "normal", "form", "find", "one", "exhaustively", "contracting", "beta", "redexes", "term", "exhaustively", "contracting", "beta", "redexes", "resulting", "term", "forth", "say", "term", "beta", "normal", "form", "amount", "saying", "blind", "search", "one", "eventually", "terminate", "blind", "search", "beta", "normal", "form", "satisfactory", "addition", "aesthetically", "unpleasant", "quite", "inefficient", "may", "need", "exhaustively", "contract", "beta", "redexes", "wanted", "strategypreferably", "computable", "onefor", "finding", "beta", "normal", "form", "problem", "effectively", "decide", "multiple", "beta", "redexes", "term", "ought", "reduced", "definition", "beta", "reduction", "strategy", "function", "whose", "domain", "set", "lambda", "terms", "whose", "value", "term", "m", "beta", "normal", "form", "redex", "subterm", "m", "whose", "value", "term", "beta", "normal", "form", "simply", "m", "word", "beta", "reduction", "strategy", "selects", "whenever", "term", "multiple", "beta", "redexes", "one", "contracted", "term", "beta", "normal", "form", "nothing", "done", "require", "definition", "beta", "reduction", "strategy", "change", "term", "beta", "normal", "form", "one", "represent", "strategy", "s", "relation", "rhd_s", "lambda", "terms", "understanding", "rhd_s", "n", "provided", "n", "obtained", "m", "one", "step", "adhering", "strategy", "s", "viewed", "relation", "strategy", "constitute", "subrelation", "rhd_", "beta", "1", "beta", "reduction", "strategy", "may", "may", "property", "adhering", "strategy", "ensure", "eventually", "reach", "beta", "normal", "form", "one", "exists", "definition", "beta", "reduction", "strategy", "s", "normalizing", "lambda", "terms", "m", "m", "beta", "normal", "form", "n", "sequence", "ldots", "terminates", "n", "beta", "reduction", "strategy", "normalizing", "others", "rightmost", "strategy", "whereby", "always", "choose", "reduce", "rightmost", "beta", "redex", "beta", "redexes", "normalizing", "consider", "example", "term", "ki", "omega", "term", "two", "beta", "redexes", "omega", "recall", "term", "omegaomegaequiv", "lambda", "x", "xx", "lambda", "x", "xx", "working", "lefthand", "beta", "redexes", "beta", "reduce", "ki", "omega", "mathbf", "two", "step", "insist", "working", "rightmost", "beta", "redex", "omega", "reduce", "ki", "omega", "mathbf", "ki", "omega", "mathbf", "ki", "omega", "leftmost", "strategy", "whereby", "always", "choose", "reduce", "leftmost", "beta", "redex", "beta", "redexes", "normalizing", "proof", "fact", "beyond", "scope", "entry", "see", "barendregt", "1985", "section", "132", "detail", "defined", "reduction", "strategy", "natural", "ask", "whether", "one", "improve", "term", "beta", "normal", "form", "strategy", "discover", "normal", "form", "might", "shorter", "beta", "reduction", "sequence", "reach", "normal", "form", "term", "alpha", "convertible", "normal", "form", "question", "optimality", "defining", "optimal", "strategy", "showing", "optimal", "generally", "considerably", "difficult", "simply", "defining", "strategy", "discussion", "see", "barendregt", "1984", "chapter", "10", "sake", "concreteness", "discussed", "beta", "reduction", "strategy", "definition", "notion", "reduction", "beta", "one", "possibility", "notion", "r", "reduction", "associated", "theory", "r", "reduction", "strategy", "one", "replay", "problem", "normalizability", "optimality", "etc", "r", "5", "lambda", "theories", "discussed", "earlier", "lambda", "calculus", "nonextensional", "theory", "function", "nonextensional", "spirit", "understand", "lambda", "terms", "description", "treat", "equality", "lambda", "terms", "various", "approach", "available", "section", "let", "u", "treat", "equality", "relation", "primitive", "undefined", "relation", "holding", "two", "lambda", "terms", "try", "axiomatize", "property", "equality", "task", "identity", "axiom", "formulate", "suitable", "rule", "inference", "concerning", "equality", "lambda", "terms", "obvious", "property", "equality", "nothing", "lambda", "calculus", "follows", "tag", "reflexivity", "frac", "xx", "tag", "symmetry", "frac", "xy", "yx", "tag", "transitivity", "frac", "xy", "quad", "yz", "xz", "standard", "proof", "theory", "way", "read", "rule", "inference", "horizontal", "rule", "frac", "phantom", "xx", "premise", "rule", "equation", "equation", "horizontal", "rule", "conclusion", "rule", "inference", "case", "reflexivity", "rule", "nothing", "written", "horizontal", "rule", "understand", "case", "saying", "term", "x", "may", "infer", "equation", "x", "x", "premise", "51", "basic", "theory", "lambda", "three", "rule", "inference", "listed", "previous", "section", "governing", "equality", "nothing", "lambda", "calculus", "following", "list", "rule", "inference", "relate", "undefined", "notion", "equality", "two", "termbuilding", "operation", "lambda", "calculus", "application", "abstraction", "frac", "mn", "aman", "quad", "frac", "mn", "mana", "tag", "boldsymbol", "xi", "frac", "mn", "lambda", "x", "lambda", "x", "n", "together", "rule", "inference", "say", "congruence", "relation", "set", "lambda", "terms", "preserve", "application", "abstraction", "termbuilding", "operation", "final", "rule", "inference", "beta", "conversion", "important", "tag", "boldsymbol", "beta", "frac", "lambda", "x", "x", "reflexivity", "rule", "rule", "boldsymbol", "beta", "premise", "variable", "x", "term", "m", "a", "one", "infer", "equation", "lambda", "x", "x", "point", "formal", "derivation", "theory", "boldsymbol", "lambda", "52", "extending", "basic", "theory", "lambda", "number", "extension", "boldsymbol", "lambda", "available", "consider", "example", "rule", "boldsymbol", "eta", "express", "principle", "eta", "reduction", "rule", "inference", "tag", "boldsymbol", "eta", "frac", "lambda", "x", "mx", "text", "provided", "x", "notin", "mathbf", "fv", "rule", "boldsymbol", "eta", "tell", "u", "certain", "kind", "abstraction", "otiose", "safe", "identify", "m", "function", "given", "argument", "x", "applies", "m", "x", "rule", "also", "see", "term", "effectively", "function", "one", "intuitively", "justify", "rule", "using", "principle", "beta", "reduction", "tag", "mathbf", "ext", "frac", "mxnx", "mn", "text", "provided", "x", "notin", "mathbf", "fv", "cup", "mathbf", "fv", "n", "one", "view", "rule", "mathbf", "ext", "kind", "generalization", "principle", "derived", "mx", "nx", "x", "figure", "neither", "m", "n", "effectively", "shown", "m", "n", "alike", "compare", "principle", "principle", "universal", "generalization", "firstorder", "logic", "derived", "phi", "x", "set", "gamma", "hypothesis", "x", "free", "conclude", "gamma", "derives", "forall", "xphi", "another", "productive", "principle", "lambda", "calculus", "permit", "u", "identify", "term", "act", "tag", "boldsymbol", "omega", "frac", "text", "term", "x", "mxnx", "mn", "rule", "boldsymbol", "omega", "infinitely", "many", "hypothesis", "assumption", "mx", "nx", "matter", "x", "may", "conclude", "n", "boldsymbol", "omega", "rule", "analogue", "lambda", "calculus", "rule", "inference", "name", "formal", "number", "theory", "according", "one", "conclude", "universal", "formula", "forall", "xphi", "provided", "one", "proof", "phi", "x", "mathbf", "0", "phi", "x", "mathbf", "1", "ldots", "note", "unlike", "rule", "mathbf", "ext", "condition", "x", "occur", "freely", "m", "n", "arise", "6", "consistency", "lambda", "calculus", "lambda", "calculus", "consistent", "question", "might", "wellposed", "lambda", "calculus", "logic", "reasoning", "proposition", "apparent", "notion", "contradiction", "bot", "method", "forming", "absurd", "proposition", "eg", "p", "wedge", "neg", "p", "thus", "inconsistency", "lambda", "calculus", "mean", "bot", "formula", "tantamount", "bot", "derivable", "suitable", "notion", "consistent", "however", "available", "intuitively", "logic", "inconsistent", "permit", "u", "derive", "much", "theory", "lambda", "theory", "equation", "thus", "take", "inconsistency", "lambda", "mean", "equation", "derivable", "property", "true", "lambda", "would", "clearly", "show", "lambda", "little", "use", "formal", "theory", "early", "formulation", "idea", "lambda", "calculus", "a", "church", "indeed", "inconsistent", "see", "barendregt", "1985", "appendix", "2", "rosser", "1985", "discussion", "take", "concrete", "problem", "know", "equation", "bk", "mathbf", "theorem", "lambda", "two", "term", "obviously", "intuitively", "distinct", "bk", "function", "two", "argument", "whereas", "mathbf", "function", "one", "argument", "could", "show", "bk", "mathbf", "could", "show", "mathbf", "kk", "mathbf", "ik", "whence", "mathbf", "kk", "bk", "would", "theorem", "lambda", "along", "many", "equation", "strike", "u", "intuitively", "unacceptable", "investigating", "formal", "theory", "lambda", "intuitive", "unacceptability", "mean", "implies", "underivability", "missing", "deeper", "understanding", "beta", "reduction", "early", "result", "gave", "understanding", "known", "churchrosser", "theorem", "theorem", "churchrosser", "p", "rhd_", "beta", "q", "p", "rhd_", "beta", "r", "exists", "term", "s", "q", "rhd_", "beta", "s", "r", "rhd_", "beta", "s", "proof", "theorem", "quite", "nontrivial", "wellbeyond", "scope", "entry", "result", "deep", "fact", "beta", "reduction", "say", "matter", "diverge", "p", "beta", "reductions", "always", "converge", "common", "term", "churchrosser", "theorem", "give", "u", "among", "thing", "plain", "lambda", "calculusthat", "theory", "lambda", "equation", "lambda", "termsis", "consistent", "sense", "equation", "derivable", "illustration", "use", "churchrosser", "theorem", "solve", "earlier", "problem", "showing", "two", "term", "bk", "mathbf", "identified", "lambda", "two", "term", "beta", "normal", "form", "beta", "reduction", "sequence", "bk", "mathbf", "theorem", "lambda", "would", "term", "m", "beta", "reduction", "path", "mathbf", "bk", "churchrosser", "theorem", "implies", "two", "path", "diverging", "m", "merged", "impossible", "since", "bk", "mathbf", "distinct", "beta", "normal", "form", "churchrosser", "theorem", "implies", "existence", "beta", "reduction", "sequence", "commencing", "bk", "mathbf", "end", "common", "term", "beta", "reduction", "sequence", "commencing", "mathbf", "beta", "normal", "form", "likewise", "bk", "theorem", "lambda", "consistent", "sense", "every", "equation", "theorem", "prove", "theorem", "sufficient", "produce", "one", "underivable", "equation", "already", "worked", "example", "used", "churchrosser", "theorem", "show", "equation", "bk", "mathbf", "theorem", "lambda", "course", "nothing", "special", "two", "term", "significant", "generalization", "result", "available", "m", "n", "beta", "normal", "form", "m", "distinct", "n", "equation", "n", "theorem", "lambda", "simple", "condition", "underivability", "generally", "hold", "add", "additional", "rule", "inference", "lambda", "theory", "lambda", "eta", "lambda", "omega", "likewise", "consistent", "one", "prove", "consistency", "result", "along", "line", "consistency", "proof", "lambda", "extending", "churchrosser", "theorem", "wider", "sens", "derivability", "theory", "7", "semantics", "lambda", "calculus", "said", "outset", "lambda", "calculus", "heart", "function", "application", "surprisingly", "difficult", "cash", "idea", "semantic", "term", "natural", "approach", "would", "try", "associate", "every", "lambda", "term", "m", "function", "f_m", "domain", "d", "interpret", "application", "term", "mn", "using", "function", "application", "f_m", "f_n", "idea", "quickly", "run", "difficulty", "begin", "easy", "see", "context", "use", "standard", "settheoretic", "concept", "functionsassets", "see", "section", "12", "entry", "according", "concept", "remember", "function", "f", "set", "argumentvalue", "pair", "every", "argument", "get", "assigned", "unique", "value", "problem", "arises", "context", "selfapplications", "remember", "section", "21", "untyped", "lambda", "calculus", "allows", "lambda", "terms", "xx", "intuitively", "apply", "x", "semantic", "picture", "exploring", "obtain", "associated", "function", "f_", "xx", "term", "xx", "taking", "function", "f_x", "x", "applying", "f_", "xx", "f_x", "f_x", "following", "functionsassets", "would", "mean", "set", "f_x", "need", "contain", "argumentvalue", "pair", "f_x", "first", "component", "f_", "xx", "second", "f_", "x", "ldots", "f_", "x", "f_", "xx", "ldots", "would", "make", "f_x", "nonwellfounded", "object", "defining", "f_x", "would", "involve", "f_x", "fact", "set", "like", "excluded", "standard", "axiomatic", "set", "theory", "axiom", "foundation", "also", "known", "axiom", "regularity", "this", "semantic", "evidence", "concept", "function", "underlying", "lambda", "calculus", "extensional", "functionsassets", "concept", "problem", "run", "even", "deeper", "even", "use", "nonextensional", "notion", "function", "functionsasrules", "conception", "see", "section", "12", "run", "difficulty", "untyped", "lambda", "calculus", "everything", "function", "argument", "function", "correspondingly", "want", "domain", "d", "include", "sense", "function", "space", "dd", "contains", "function", "argument", "value", "d", "see", "every", "element", "d", "function", "applies", "element", "d", "returned", "argument", "element", "d", "every", "element", "d", "intuitively", "corresponds", "member", "dd", "turn", "take", "member", "dd", "ie", "function", "argument", "value", "d", "precisely", "kind", "thing", "want", "include", "domain", "d", "intuitively", "want", "every", "member", "dd", "correspond", "member", "d", "short", "want", "onetoone", "correspondence", "domain", "function", "space", "ie", "want", "satisfy", "equation", "xcong", "xx", "impossible", "since", "contradicts", "cantor", "theorem", "given", "difficulty", "question", "arises", "whether", "possible", "give", "settheoretic", "model", "lambda", "calculus", "first", "place", "turn", "d", "scott", "first", "describe", "model", "unpublished", "manuscript", "1969", "model", "d_infty", "solves", "aforementioned", "problem", "cantor", "theorem", "suitably", "restricting", "function", "space", "dd", "letting", "member", "dd", "correspond", "member", "d", "covering", "scott", "construction", "go", "beyond", "scope", "entry", "since", "involves", "advanced", "tool", "algebra", "topology", "see", "meyer", "1982", "barendregt", "1985", "chapter", "182", "hindley", "seldin", "2008", "chapter", "16", "detail", "instead", "discus", "general", "question", "model", "lambda", "calculus", "leaving", "aside", "moment", "question", "whether", "set", "function", "rule", "something", "altogether", "different", "ask", "kind", "mathematical", "structure", "model", "lambda", "calculus", "first", "place", "71", "lambda", "models", "turn", "multiple", "essentially", "equivalent", "way", "defining", "notion", "model", "lambda", "calculus", "see", "barendregt", "1985", "chapter", "5", "hindley", "seldin", "2008", "chapter", "15", "following", "discus", "consider", "palatable", "notion", "philosopher", "familiar", "standard", "semantics", "firstorder", "logic", "see", "eg", "entry", "classical", "logic", "socalled", "syntactical", "lambda", "models", "model", "first", "appear", "work", "hindley", "longo", "1980", "koymans", "1982", "meyer", "1982", "derive", "name", "fact", "clause", "closely", "correspond", "syntactic", "rule", "calculus", "boldsymbol", "lambda", "somewhat", "unsatisfactory", "motivates", "syntaxfree", "definition", "see", "time", "syntactical", "lambda", "models", "provide", "fairly", "transparent", "accessible", "route", "world", "lambda", "models", "addition", "despite", "conceptual", "shortcoming", "syntactical", "model", "proven", "technically", "useful", "tool", "semantical", "study", "lambda", "calculus", "order", "avoid", "settheoretic", "problem", "mentioned", "definition", "lambda", "models", "use", "socalled", "applicative", "structure", "idea", "treat", "denotation", "lambda", "terms", "settheoretic", "function", "unanalyzed", "firstorder", "functionobjects", "instead", "correspondingly", "treat", "function", "application", "unanalyzed", "binary", "operation", "functionobjects", "definition", "applicative", "structure", "pair", "cdot", "d", "set", "cdot", "binary", "operation", "d", "avoid", "trivial", "model", "usually", "assume", "d", "least", "two", "element", "applicative", "structure", "sense", "firstorder", "model", "function", "space", "satisfy", "problematic", "equation", "xcong", "xx", "lambda", "models", "turn", "defined", "definition", "lambda", "models", "work", "valuationsa", "concept", "familiar", "firstorder", "semantics", "valuation", "assign", "denotation", "variable", "used", "primarily", "semantic", "clause", "lambda", "operator", "additionally", "used", "express", "general", "claim", "domain", "way", "familiar", "semantics", "firstorder", "quantifier", "exists", "x", "forall", "x", "definition", "valuation", "applicative", "structure", "cdot", "function", "rho", "assigns", "element", "rho", "x", "in", "d", "every", "variable", "x", "useful", "piece", "notation", "rho", "valuation", "applicative", "structure", "cdot", "x", "variable", "din", "d", "object", "define", "valuation", "rho", "xmapsto", "saying", "rho", "xmapsto", "begin", "case", "text", "yx", "rho", "text", "otherwise", "end", "case", "rho", "xmapsto", "result", "changing", "value", "x", "d", "leaving", "value", "rho", "unchanged", "definition", "syntactical", "lambda", "model", "triple", "mathfrak", "cdot", "llbracket", "rrbracket", "cdot", "applicative", "structure", "llbracket", "rrbracket", "function", "assigns", "every", "lambda", "term", "valuation", "rho", "denotation", "llbracket", "mrrbracket_rhoin", "d", "subject", "following", "constraint", "llbracket", "xrrbracket_rhorho", "x", "llbracket", "mnrrbracket_rhollbracket", "mrrbracket_rhocdot", "llbracket", "nrrbracket_rho", "llbracket", "lambda", "xmrrbracket_rhocdot", "dllbracket", "mrrbracket_", "rho", "xmapsto", "din", "d", "llbracket", "lambda", "xmrrbracket_rho", "llbracket", "lambda", "xnrrbracket_rho", "whenever", "din", "d", "llbracket", "mrrbracket_", "rho", "xmapsto", "llbracket", "nrrbracket_", "rho", "xmapsto", "llbracket", "mrrbracket_rhollbracket", "mrrbracket_sigma", "whenever", "rho", "x", "sigma", "x", "xin", "mathbf", "fv", "intuitively", "model", "mathfrak", "llbracket", "mrrbracket_rho", "functionobject", "denoted", "lambda", "term", "m", "valuation", "rho", "straightforward", "define", "mean", "lambda", "model", "mathfrak", "satisfy", "equation", "mn", "symbolically", "mathfrak", "vdash", "mn", "definition", "satisfaction", "mathfrak", "vdash", "mntext", "iff", "rhotext", "llbracket", "mrrbracket_rhollbracket", "nrrbracket_rho", "word", "equation", "mn", "hold", "model", "mathfrak", "case", "lambda", "terms", "m", "n", "denotation", "every", "valuation", "underlying", "applicative", "structure", "note", "clause", "3", "4", "definition", "syntactical", "lambda", "model", "directly", "mirror", "boldsymbol", "lambda", "rules", "boldsymbol", "beta", "boldsymbol", "xi", "respectively", "see", "section", "51", "syntactic", "nature", "model", "might", "semantically", "unsatisfactory", "see", "make", "relatively", "straightforward", "prove", "soundness", "theorem", "semantics", "provided", "syntactical", "lambda", "models", "see", "barendregt", "1985", "theorem", "534", "hindley", "seldin", "2008", "theorem", "1512", "theorem", "term", "n", "mn", "derivable", "boldsymbol", "lambda", "syntactical", "lambda", "models", "mathfrak", "mathfrak", "vdash", "mn", "theorem", "provides", "first", "sanitycheck", "semantics", "note", "far", "shown", "exist", "syntactical", "lambda", "models", "worry", "addressed", "constructing", "socalled", "term", "model", "unlike", "wellknown", "henkin", "construction", "firstorder", "semantics", "order", "define", "model", "first", "need", "notion", "boldsymbol", "lambda", "equivalence", "class", "given", "lambda", "term", "m", "class", "contains", "precisely", "term", "boldsymbol", "lambda", "prof", "identical", "m", "_", "boldsymbol", "lambda", "n", "boldsymbol", "lambda", "text", "prof", "mn", "define", "term", "model", "boldsymbol", "lambda", "mathfrak", "setting", "d", "_boldsymbol", "lambda", "mtext", "lambdatext", "term", "_boldsymbol", "lambda", "cdot", "n", "_boldsymbol", "lambda", "mn", "_boldsymbol", "lambda", "llbracket", "mrrbracket_rho", "x_1", "n_1", "ldots", "x_n", "n_n", "_boldsymbol", "lambda", "mathbf", "fv", "x_1", "ldots", "x_n", "rho", "x_1", "n_1", "ldots", "rho", "x_n", "n_n", "easily", "seen", "indeed", "defines", "syntactical", "lambda", "model", "fact", "easily", "checked", "term", "model", "boldsymbol", "lambda", "mathfrak", "vdash", "mntext", "iff", "boldsymbol", "lambda", "text", "derives", "mn", "pave", "way", "simple", "completeness", "proof", "boldsymbol", "lambda", "respect", "class", "syntactical", "lambda", "models", "see", "meyer", "1982", "9899", "one", "explicit", "mention", "kind", "result", "literature", "theorem", "term", "n", "syntactical", "lambda", "models", "mathfrak", "mathfrak", "vdash", "mn", "mn", "derivable", "boldsymbol", "lambda", "proof", "simple", "proof", "contraposition", "us", "term", "model", "mathfrak", "countermodel", "nonderivable", "identity", "boldsymbol", "lambda", "reason", "dissatisfied", "syntactical", "lambda", "models", "semantics", "lambda", "calculus", "one", "virtue", "clause", "3", "4", "mirroring", "rule", "boldsymbol", "beta", "boldsymbol", "xi", "soundness", "result", "baked", "semantics", "unsatisfactory", "semantic", "perspective", "since", "mean", "via", "syntactical", "lambda", "models", "really", "learn", "anything", "directly", "condition", "applicative", "structure", "need", "satisfy", "order", "adequately", "model", "lambda", "calculus", "related", "worry", "clause", "3", "4", "recursive", "nature", "allow", "u", "compute", "denotation", "complex", "lambda", "term", "denotation", "part", "information", "syntactic", "operation", "used", "combine", "syntax", "see", "section", "2", "two", "way", "constructing", "complex", "lambda", "terms", "application", "term", "form", "mn", "abstraction", "term", "form", "lambda", "x", "clause", "1", "syntactical", "lambda", "models", "recursive", "clause", "syntactical", "application", "operation", "recursive", "clause", "syntactical", "operation", "lambda", "abstraction", "clause", "3", "4", "rather", "condition", "denotation", "function", "llbracket", "rrbracket", "recursive", "clause", "unsatisfactory", "since", "mean", "really", "given", "compositional", "semantics", "lambda", "operator", "syntactical", "lambda", "models", "worry", "taken", "care", "development", "syntaxfree", "lambda", "models", "comprehensive", "discussion", "syntaxfree", "model", "go", "beyond", "scope", "entry", "see", "barendregt", "1985", "chapter", "52", "hinley", "seldin", "2008", "chapter", "15b", "detail", "suffice", "say", "definition", "syntaxfree", "lambda", "models", "involves", "determining", "precisely", "condition", "applicative", "structure", "suitable", "interpreting", "lambda", "calculus", "resulting", "lambda", "models", "indeed", "provide", "something", "much", "closer", "recursive", "compositional", "semantics", "syntactical", "operation", "lambda", "abstraction", "interepreted", "corresponding", "semantic", "operation", "applicative", "structure", "worth", "noting", "however", "syntactical", "lambda", "models", "syntaxfree", "lambda", "models", "certain", "sense", "equivalent", "every", "syntactical", "lambda", "model", "defines", "syntaxfree", "lambda", "model", "vice", "versa", "see", "barendregt", "1985", "theorem", "536", "hinley", "seldin", "2008", "theorem", "1520", "detail", "technical", "perspective", "result", "allows", "u", "freely", "move", "different", "presentation", "lambda", "models", "use", "given", "context", "notion", "model", "expedient", "time", "may", "philosophical", "reason", "prefer", "one", "presentation", "semantic", "worry", "syntactical", "lambda", "models", "mentioned", "moving", "model", "construction", "let", "u", "briefly", "mention", "various", "way", "approaching", "lambda", "models", "one", "particularly", "interesting", "approach", "neglected", "far", "perspective", "category", "theory", "categorical", "logic", "wellknown", "model", "description", "using", "socalled", "cartesian", "closed", "category", "see", "koymans", "1982", "covering", "model", "description", "go", "beyond", "scope", "present", "entry", "since", "requires", "familiarity", "wide", "range", "concept", "category", "theory", "see", "entry", "category", "theory", "sense", "machinery", "involved", "detail", "model", "description", "instead", "barendregt", "1985", "section", "546", "recent", "year", "renewed", "interest", "categorical", "approach", "lambda", "calculus", "mainly", "focused", "typed", "version", "lambda", "calculus", "see", "section", "82", "912", "also", "include", "untyped", "lambda", "calculus", "discussed", "article", "see", "example", "hyland", "2017", "recent", "discussion", "72", "model", "construction", "term", "model", "seen", "section", "71", "rather", "trivial", "directly", "reflects", "syntactic", "structure", "lambda", "terms", "modeling", "precisely", "syntactic", "equality", "modulo", "boldsymbol", "lambda", "provable", "equality", "make", "term", "model", "mathematically", "philosophically", "rather", "uninteresting", "construction", "study", "interesting", "concrete", "lambda", "models", "one", "principal", "aim", "model", "theory", "lambda", "calculus", "already", "mentioned", "perhaps", "important", "definitely", "first", "nontrivial", "model", "lambda", "calculus", "scott", "d_infty", "also", "interesting", "model", "construction", "plotkin", "scott", "graph", "model", "p_omega", "first", "described", "plotkin", "1972", "scott", "1974", "model", "construction", "however", "usually", "rely", "fairly", "involved", "mathematical", "method", "definition", "verifying", "indeed", "lambda", "models", "consequently", "covering", "construction", "go", "beyond", "scope", "entry", "see", "hinley", "seldin", "2008", "chapter", "16f", "overview", "various", "model", "construction", "barendregt", "1985", "chapter", "18", "many", "formal", "detail", "one", "advantage", "different", "model", "one", "see", "different", "aspect", "equality", "lambda", "calculus", "different", "model", "take", "different", "view", "lambda", "terms", "get", "identified", "interesting", "question", "context", "lambda", "theory", "given", "class", "model", "context", "call", "class", "mathcal", "c", "lambda", "models", "complete", "case", "every", "consistent", "lambda", "theory", "satisfied", "model", "mathcal", "c", "see", "salibra", "2003", "overview", "various", "completeness", "incompleteness", "result", "interesting", "class", "lambda", "models", "8", "extension", "variation", "81", "combinatory", "logic", "sister", "formalism", "lambda", "calculus", "developed", "slightly", "earlier", "deal", "variablefree", "combination", "combinatory", "logic", "indeed", "even", "simpler", "lambda", "calculus", "since", "lack", "notion", "variable", "binding", "language", "combinatory", "logic", "built", "combinators", "variable", "flexibility", "precisely", "combinators", "chosen", "basic", "standard", "one", "mathbf", "bk", "bs", "mathbf", "b", "mathbf", "c", "name", "arbitrary", "lambda", "calculus", "combinatory", "logic", "one", "interested", "reducibility", "provability", "principal", "reduction", "relation", "combinator", "reduction", "axiom", "bi", "bi", "x", "x", "bk", "bk", "xy", "x", "bs", "bs", "xyz", "xz", "yz", "bb", "bb", "xyz", "x", "yz", "bc", "bc", "xyz", "xzy", "passage", "lambda", "calculus", "combinatory", "logic", "via", "translation", "turn", "although", "combinatory", "logic", "lack", "notion", "abstraction", "one", "define", "notion", "thereby", "simulate", "lambda", "calculus", "combinatory", "logic", "one", "translation", "defined", "recursively", "rule", "expression", "translation", "condition", "1", "x", "x", "unconditional", "2", "mn", "m", "n", "unconditional", "3", "lambda", "x", "bk", "x", "occur", "freely", "4", "lambda", "x", "x", "bi", "unconditional", "5", "lambda", "x", "mx", "x", "occur", "freely", "6", "lambda", "x", "mn", "bb", "lambda", "x", "n", "x", "occur", "freely", "7", "lambda", "x", "mn", "bc", "lambda", "x", "n", "x", "occur", "freely", "n", "8", "lambda", "x", "mn", "bs", "m", "n", "x", "occurs", "freely", "m", "n", "translation", "work", "insideout", "rather", "outsidein", "illustrate", "translation", "term", "lambda", "representative", "identity", "function", "mapped", "translation", "identity", "combinator", "bi", "rule", "4", "expected", "lambda", "term", "lambda", "x", "lambda", "x", "calling", "bk", "mapped", "translation", "begin", "align", "lambda", "x", "lambda", "x", "equiv", "lambda", "x", "bk", "x", "langle", "text", "rule", "1", "rangle", "equiv", "bk", "langle", "text", "rule", "3", "rangle", "end", "align", "lambda", "term", "lambda", "x", "lambda", "yx", "switch", "two", "argument", "mapped", "translation", "begin", "align", "lambda", "x", "lambda", "yx", "equiv", "lambda", "x", "bc", "lambda", "x", "langletext", "rule", "8", "rangle", "equiv", "lambda", "x", "bcbi", "x", "langlelambda", "equiv", "bi", "text", "rule", "4", "rangle", "equiv", "bbbcbi", "lambda", "x", "x", "langletext", "rule", "7", "rangle", "equiv", "bb", "bcbi", "bi", "langle", "lambda", "x", "x", "equiv", "bi", "text", "rule", "4", "rangle", "end", "align", "confirm", "lambda", "term", "lambda", "x", "lambda", "yx", "translated", "combinatory", "logic", "term", "bb", "bcbi", "bi", "analogous", "applicative", "behavior", "lambda", "terms", "p", "q", "lambda", "x", "lambda", "yx", "pq", "rhd", "lambda", "yp", "rhd", "qp", "likewise", "combinatory", "logic", "term", "p", "q", "bb", "bcbi", "bi", "pq", "rhd", "bcbi", "bi", "p", "q", "rhd", "bi", "q", "bi", "p", "rhd", "q", "bi", "p", "rhd", "qp", "give", "glimpse", "combinatory", "logic", "subject", "consult", "entry", "combinatory", "logic", "many", "issue", "discussed", "lambda", "calculus", "analogue", "combinatory", "logic", "vice", "versa", "82", "adding", "type", "many", "context", "reasoning", "computing", "natural", "distinguish", "different", "kind", "object", "way", "distinction", "introduced", "requiring", "certain", "formula", "function", "relation", "accept", "argument", "permit", "substitution", "kind", "object", "rather", "others", "might", "require", "example", "addition", "take", "number", "argument", "effect", "restriction", "forbid", "say", "addition", "5", "identity", "function", "lambda", "xx", "4", "regimenting", "object", "type", "also", "idea", "behind", "passage", "unsorted", "onesorted", "firstorder", "logic", "manysorted", "firstorder", "logic", "see", "enderton", "2001", "manzano", "2005", "manysorted", "firstorder", "logic", "stand", "lambda", "calculus", "support", "kind", "discrimination", "term", "applied", "term", "straightforward", "extend", "untyped", "lambda", "calculus", "discriminates", "different", "kind", "object", "entry", "limit", "typefree", "lambda", "calculus", "see", "entry", "type", "theory", "church", "type", "theory", "detailed", "discussion", "extension", "lambda", "calculus", "get", "add", "type", "see", "barendregt", "dekker", "statman", "2013", "book", "length", "treatment", "subject", "modeltheoretic", "perspective", "interesting", "add", "scott", "1980", "us", "semantic", "fact", "categorical", "model", "untyped", "lambda", "calculus", "see", "section", "71", "derive", "categorical", "model", "typed", "lambda", "calculus", "argue", "conceptual", "priority", "typed", "untyped", "calculus", "9", "application", "91", "logic", "\u00e0", "la", "lambda", "two", "sens", "lambda", "calculus", "connected", "logic", "911", "term", "logical", "constant", "table", "combinators", "defined", "combinators", "bt", "bf", "said", "serve", "representation", "lambda", "calculus", "truth", "value", "true", "false", "respectively", "term", "function", "truth", "value", "turn", "one", "treating", "lambda", "calculus", "kind", "programming", "language", "one", "write", "conditional", "statement", "p", "a", "else", "b", "simply", "pab", "course", "p", "a", "b", "understood", "lambda", "terms", "p", "rhd", "bt", "p", "true", "text", "if", "ptext", "then", "atext", "else", "b", "pab", "rhd", "bt", "ab", "rhd", "recall", "definition", "bt", "equiv", "bk", "p", "rhd", "bf", "p", "false", "text", "if", "ptext", "then", "atext", "else", "b", "pab", "rhd", "bf", "ab", "rhd", "b", "recall", "definition", "mathbf", "f", "equiv", "mathbf", "ki", "expect", "notion", "ifthenelse", "p", "reduces", "neither", "mathbf", "mathbf", "f", "general", "say", "text", "if", "ptext", "then", "atext", "else", "b", "encoding", "sketched", "familiar", "truth", "value", "logical", "connective", "classical", "truthtable", "logic", "show", "lambda", "calculus", "classical", "logic", "intimately", "related", "encoding", "show", "little", "embeddibility", "rule", "computation", "classical", "truthtable", "logic", "lambda", "calculus", "logic", "classical", "truthtable", "logic", "likewise", "represented", "lambda", "calculus", "one", "sufficient", "computable", "ingredient", "logic", "question", "eg", "logical", "consequence", "relation", "computable", "derivability", "relation", "computable", "etc", "computing", "lambda", "calculus", "see", "section", "92", "intrinsic", "relationship", "logic", "lambda", "calculus", "discussed", "next", "section", "912", "typed", "lambda", "calculus", "curryhowardde", "bruijn", "correspondence", "correspondence", "descried", "logic", "lambda", "calculus", "seen", "help", "apparatus", "known", "type", "section", "sketch", "beginning", "development", "subject", "known", "type", "theory", "interested", "developing", "type", "theory", "far", "make", "socalled", "curryhowardde", "bruijn", "correspondence", "visible", "detailed", "treatment", "found", "entry", "type", "theory", "see", "also", "hindley", "1997", "barendregt", "dekker", "statman", "2013", "type", "theory", "enriches", "untyped", "lambda", "calculus", "requiring", "term", "given", "type", "untyped", "lambda", "calculus", "application", "mn", "legal", "term", "regardless", "m", "n", "freedom", "permit", "one", "form", "suspicious", "term", "xx", "thence", "term", "paradoxical", "combinator", "mathbf", "one", "might", "wish", "exclude", "term", "like", "xx", "ground", "x", "serving", "function", "lefthand", "side", "application", "argument", "righthand", "side", "application", "type", "theory", "give", "u", "resource", "making", "intuitive", "argument", "precise", "assigning", "type", "term", "language", "type", "theory", "begin", "infinite", "set", "type", "variable", "assumed", "disjoint", "set", "variable", "lambda", "calculus", "symbol", "lambda", "set", "type", "made", "type", "variable", "operation", "sigma", "rightarrow", "tau", "variable", "type", "theory", "come", "type", "annotation", "unlike", "unadorned", "term", "variable", "untyped", "lambda", "calculus", "typed", "variable", "rendered", "x", "sigma", "intuitive", "reading", "variable", "x", "type", "sigma", "intuitive", "reading", "judgment", "sigma", "rightarrow", "tau", "term", "t", "function", "transforms", "argument", "type", "sigma", "argument", "type", "tau", "given", "assignment", "type", "term", "variable", "one", "typing", "rule", "sigma", "rightarrow", "tau", "n", "sigma", "tau", "lambda", "x", "sigma", "tau", "sigma", "rightarrow", "tau", "two", "rule", "define", "assignment", "type", "application", "abstraction", "term", "set", "term", "type", "theory", "set", "term", "built", "according", "formation", "rule", "definition", "set", "term", "type", "theory", "sufficient", "rule", "term", "xx", "course", "xx", "typed", "term", "simple", "reason", "type", "assigned", "meant", "type", "sigma", "could", "assigned", "x", "xx", "could", "annotated", "legal", "way", "make", "typed", "term", "assign", "x", "type", "variable", "type", "lefthand", "x", "would", "fail", "function", "type", "ie", "type", "shape", "sigma", "rightarrow", "tau", "moreover", "assign", "x", "function", "type", "sigma", "rightarrow", "tau", "sigma", "would", "equal", "sigma", "rightarrow", "tau", "impossible", "leading", "example", "consider", "type", "assigned", "combinators", "bi", "bk", "bs", "combinator", "type", "5", "bi", "rightarrow", "a", "bk", "rightarrow", "b", "rightarrow", "bs", "rightarrow", "b", "rightarrow", "c", "rightarrow", "rightarrow", "b", "rightarrow", "rightarrow", "c", "see", "hindley", "1997", "table", "principal", "type", "extensive", "listing", "read", "rightarrow", "implication", "type", "variable", "propositional", "variable", "recognize", "three", "familiar", "tautology", "righthand", "column", "table", "language", "used", "meager", "propositional", "variable", "implication", "connective", "table", "suggests", "interesting", "correspondence", "typed", "lambda", "calculus", "formal", "logic", "could", "really", "type", "assigned", "formula", "understood", "logical", "formula", "valid", "yes", "though", "validity", "need", "understood", "classical", "validity", "theorem", "tau", "type", "lambda", "term", "tau", "intuitionistically", "valid", "converse", "theorem", "hold", "well", "theorem", "phi", "intuitionistically", "valid", "logical", "formula", "whose", "connective", "implication", "rightarrow", "phi", "type", "lambda", "term", "correspondence", "seen", "one", "identifies", "intuitionistic", "validity", "derivability", "certain", "natural", "deduction", "formalism", "proof", "two", "theorem", "see", "hindley", "1997", "chapter", "6", "correspondence", "expressed", "previous", "two", "theorem", "intuitionistic", "validity", "typability", "known", "curryhowardde", "bruijn", "correspondence", "three", "logician", "noticed", "independently", "correspondence", "stated", "propositional", "intuitionistic", "logic", "restricted", "fragment", "containing", "implication", "connective", "rightarrow", "one", "extend", "correspondence", "connective", "quantifier", "crisp", "correspondence", "level", "implicationonly", "fragment", "detail", "see", "howard", "1980", "92", "computing", "one", "represent", "natural", "number", "simple", "way", "follows", "definition", "ordered", "tuples", "natural", "number", "ordered", "tuple", "langle", "a_0", "ldots", "a_nrangle", "lambda", "terms", "defined", "lambda", "x", "x", "a_0ldots", "a_n", "one", "defines", "lambda", "term", "ulcorner", "nurcorner", "corresponding", "natural", "number", "n", "ulcorner", "0urcorner", "mathbf", "every", "k", "ulcorner", "k", "1urcorner", "langle", "mathbf", "f", "ulcorner", "kurcornerrangle", "lambda", "term", "corresponding", "number", "1", "representation", "begin", "align", "ulcorner", "1", "urcorner", "equiv", "langlebf", "ulcorner", "0urcornerrangle", "equiv", "langlebf", "birangle", "equiv", "lambda", "x", "xmathbf", "fi", "end", "align", "lambda", "term", "corresponding", "number", "2", "representation", "begin", "align", "ulcorner", "2", "urcorner", "equiv", "langlebf", "ulcorner", "1urcornerrangle", "equiv", "lambda", "x", "xmathbf", "f", "lambda", "x", "xmathbf", "fi", "end", "align", "similarly", "ulcorner", "3urcorner", "lambda", "x", "xmathbf", "f", "lambda", "x", "xmathbf", "f", "lambda", "x", "xmathbf", "fi", "various", "representation", "natural", "number", "available", "representation", "one", "6", "using", "ingredient", "provided", "lambda", "calculus", "one", "represent", "recursive", "function", "show", "model", "exactly", "expressive", "model", "computing", "turing", "machine", "register", "machine", "detailed", "discussion", "relation", "different", "model", "computing", "see", "section", "comparing", "turing", "church", "approach", "entry", "churchturing", "thesis", "theorem", "every", "recursive", "function", "f", "arity", "n", "exists", "lambda", "term", "f", "natural", "number", "a_1", "ldots", "a_n", "f", "a_1", "ldots", "a_n", "y", "iff", "boldsymbol", "lambda", "vdash", "f", "langle", "bar", "_1", "ldots", "bar", "_nrangle", "bar", "proof", "see", "appendix", "since", "class", "recursive", "function", "adequate", "representation", "class", "computable", "numbertheoretic", "function", "thanks", "work", "find", "computable", "numbertheoretic", "function", "faithfully", "represented", "lambda", "calculus", "93", "relation", "motivation", "lambda", "calculus", "given", "beginning", "entry", "based", "reading", "lambda", "expressions", "description", "function", "thus", "understood", "lambda", "x", "function", "given", "x", "give", "m", "generally", "though", "necessarily", "involves", "x", "necessary", "read", "lambda", "terms", "function", "one", "could", "understand", "lambda", "terms", "denoting", "relation", "read", "abstraction", "term", "lambda", "x", "unary", "relation", "property", "r", "hold", "argument", "x", "case", "m", "see", "carnap", "1947", "p", "3", "relational", "reading", "understand", "application", "term", "mn", "form", "predication", "one", "make", "sense", "term", "using", "principle", "beta", "conversion", "lambda", "x", "x", "say", "abstraction", "relation", "lambda", "x", "predicated", "relation", "obtained", "plugging", "free", "occurrence", "x", "inside", "m", "concrete", "example", "kind", "approach", "lambda", "calculus", "consider", "extension", "firstorder", "logic", "one", "form", "new", "atomic", "formula", "using", "lambda", "terms", "following", "way", "syntax", "formula", "phi", "finite", "sequence", "x_1", "ldots", "x_n", "variable", "expression", "lambda", "x_1", "ldots", "x_n", "phi", "predicate", "symbol", "arity", "n", "extend", "notion", "free", "bound", "variable", "using", "function", "mathbf", "fv", "mathbf", "bv", "way", "mathbf", "fv", "lambda", "x_1", "ldots", "x_n", "phi", "mathbf", "fv", "phi", "x_1", "ldots", "x_n", "mathbf", "bv", "lambda", "x_1", "ldots", "x_n", "phi", "mathbf", "bv", "phi", "cup", "x_1", "ldots", "x_n", "deduction", "assume", "axiom", "universal", "closure", "equivalence", "lambda", "x_1", "ldots", "x_n", "phi", "t_1", "ldots", "t_n", "leftrightarrow", "phi", "x_1", "ldots", "x_n", "t_1", "ldots", "t_n", "phi", "x_1", "ldots", "x_n", "t_1", "ldots", "t_n", "denotes", "simultaneous", "substitution", "term", "t_k", "variable", "x_k", "1", "le", "k", "le", "n", "semantics", "firstorder", "structure", "a", "assignment", "s", "element", "a", "variable", "define", "begin", "align", "vdash", "lambda", "x_1", "ldots", "x_n", "phi", "t_1", "ldots", "t_n", "text", "iff", "vdash", "phi", "x_1", "ldots", "x_n", "t_1", "ldots", "t_n", "end", "align", "according", "approach", "one", "use", "lambda", "treat", "essentially", "formula", "even", "complex", "one", "atomic", "see", "principle", "beta", "reduction", "deductive", "semantic", "part", "approach", "adheres", "relational", "reading", "lambda", "term", "seen", "clearly", "semantics", "according", "standard", "tarskistyle", "semantics", "firstorder", "logic", "interpretation", "formula", "possibly", "free", "variable", "denotes", "set", "tuples", "element", "structure", "vary", "variable", "assignment", "assigns", "element", "structure", "variable", "one", "internalize", "functional", "approach", "done", "case", "various", "property", "theory", "formal", "theory", "reasoning", "property", "metaphysical", "object", "bealer", "1982", "zalta", "1983", "menzel", "1986", "1993", "turner", "1987", "kind", "theory", "employed", "certain", "metaphysical", "investigation", "property", "metaphysical", "entity", "investigated", "theory", "metaphysical", "relation", "among", "object", "interest", "add", "termbuilding", "symbol", "times", "formal", "theory", "arithmetic", "build", "number", "lambda", "used", "property", "theory", "build", "relation", "approach", "contrast", "approach", "lambda", "added", "grammar", "firstorder", "logic", "making", "recipe", "building", "atomic", "formula", "new", "formulabuilding", "operator", "like", "vee", "rightarrow", "connective", "case", "property", "theory", "lambda", "play", "role", "like", "times", "formal", "theory", "arithmetic", "used", "construct", "relation", "setting", "understood", "kind", "metaphysical", "object", "unlike", "times", "though", "lambda", "bind", "variable", "give", "illustration", "lambda", "used", "setting", "let", "u", "inspect", "grammar", "typical", "application", "mcmichael", "zalta", "1980", "one", "typically", "predication", "operator", "precisely", "family", "predication", "operator", "p_k", "k", "ge", "0", "language", "term", "mary", "john", "binary", "relation", "love", "formally", "express", "john", "love", "mary", "loves", "john", "mary", "property", "john", "love", "mary", "lambda", "loves", "john", "mary", "note", "lambda", "binding", "variable", "might", "call", "vacuous", "binding", "property", "understood", "proposition", "property", "object", "x", "john", "love", "lambda", "x", "loves", "john", "x", "property", "mary", "loved", "something", "lambda", "exists", "x", "loves", "x", "mary", "another", "instance", "vacuous", "binding", "viz", "proposition", "predication", "property", "x", "john", "love", "x", "mary", "p_1", "lambda", "x", "loves", "john", "x", "mary", "0ary", "predication", "property", "john", "love", "mary", "p_0", "lambda", "x", "loves", "john", "mary", "property", "object", "x", "y", "x", "love", "y", "lambda", "xy", "loves", "x", "property", "object", "x", "x", "love", "lambda", "x", "loves", "x", "x", "predication", "property", "object", "x", "y", "x", "love", "y", "john", "mary", "order", "p_2", "lambda", "xy", "loves", "x", "john", "mary", "reason", "lambda", "terms", "using", "beta", "conversion", "principle", "begin", "align", "p_n", "lambda", "x_1", "ldots", "x_n", "t_1", "ldots", "t_n", "leftrightarrow", "x_1", "ldots", "x_n", "t_1", "ldots", "t_n", "end", "align", "formally", "predication", "operator", "p", "_k", "k1", "ary", "predicate", "symbol", "first", "argument", "intended", "lambda", "term", "k", "argument", "rest", "argument", "intended", "argument", "body", "lambda", "term", "beta", "principle", "say", "predication", "n", "ary", "lambda", "term", "l", "n", "term", "hold", "precisely", "body", "l", "hold", "term", "turn", "theory", "may", "may", "able", "fully", "committed", "principle", "beta", "conversion", "indeed", "property", "theory", "full", "principle", "beta", "conversion", "lead", "paradox", "one", "replay", "russellstyle", "argument", "full", "principle", "beta", "conversion", "place", "setting", "one", "restricts", "formation", "lambda", "formulas", "requiring", "body", "lambda", "term", "contain", "lambda", "terms", "quantifier", "discussion", "see", "orilia", "2000", "one", "reason", "property", "theory", "formulated", "lambda", "calculus", "particular", "philosophical", "importance", "hyperintensional", "nature", "calculus", "see", "section", "12", "property", "concept", "may", "called", "hyperintensional", "identify", "necessarily", "coextensional", "property", "ie", "property", "instanciated", "exactly", "object", "every", "possible", "world", "property", "relation", "described", "theory", "bealer", "zalta", "menzel", "turner", "exactly", "characteristic", "word", "theory", "hyperintensional", "property", "theory", "recent", "year", "seen", "significant", "rise", "interest", "hyperintensional", "concept", "property", "metaphysics", "nolan", "2014", "correspondingly", "property", "theory", "formulated", "lambda", "calculus", "likely", "experience", "rise", "interest", "well", "context", "foundation", "mathematics", "zalta", "oppenheimer", "2011", "argue", "conceptual", "priority", "relational", "interpretation", "lambda", "terms", "functional", "one"]}