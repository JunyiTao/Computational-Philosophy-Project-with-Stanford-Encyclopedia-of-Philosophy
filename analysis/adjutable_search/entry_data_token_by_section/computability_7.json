{
    "main_text": "Primitive Recursive Functions || Recursive Functions\n3.1 Recursive Functions\n\n\nThe set of primitive recursive functions is a huge class of\ncomputable functions. In fact, they can be characterized as the set of\nfunctions computable in time that is some primitive recursive function\nof \\(n\\), where \\(n\\) is the length of the input. For\nexample, since \\(H(n,n)\\) is a primitive\nrecursive function, the primitive recursive functions include all of\nTIME[\\(H(n,n)\\)]. (See the next section for a\ndiscussion of computational complexity, including TIME.) Thus, the\nprimitive recursive functions include all functions that are feasibly\ncomputable by any conceivable measure of feasible, and much beyond\nthat.\n\n\nHowever, the primitive recursive functions do not include all\nfunctions computable in principle. To see this, we can again use\ndiagonalization. We can systematically encode all definitions of\nprimitive recursive functions of arity 1, calling them\n\\(p_{1}, p_{2}, p_{3}\\),\nand so on.\n\n\nWe can then build a Turing machine to compute the value of the\nfollowing diagonal function, \\(D(n) = p_{n}(n) + 1\\).\n\n\nNotice that \\(D\\) is a total, computable function from\n\\(\\mathbf{N}\\) to \\(\\mathbf{N}\\), but it is not primitive\nrecursive. Why? Suppose for the sake of a contradiction that \\(D\\)\nwere primitive recursive. Then \\(D\\) would be equal to\n\\(p_{d}\\) for some \\(d\\in \\mathbf{N}\\). But it would then follow that\n\n\\[\np_{d}(d) = p_{d}(d) +1,\n\\]\n\n\n\nwhich is a contradiction. Therefore, \\(D\\) is not primitive\nrecursive.\n\n\nAlas, the above diagonal argument works on any class of total\nfunctions that could be considered a candidate for the class of all\ncomputable functions. The only way around this, if we want all\nfunctions computable in principle, not just in practice, is to add some\nkind of unbounded search operation. This is what G\u00f6del did to\nextend the primitive recursive functions to the recursive\nfunctions.\n\n\nDefine the unbounded minimization operator, \\(\\mu\\), as follows. Let\n\\(f\\) be a perhaps partial function of arity \\(k+1\\). Then\n\\(\\mu[f\\)] is defined as the following function of arity k. On\ninput \\(x_{1}, \\ldots ,x_{k}\\) do the\nfollowing:\n\nFor \\(i = 0\\) to \\(\\infty\\) do \\(\\{\\)\nif \\(f(i,x_{1},\\ldots ,x_{k}) = 1\\), then output \\(i\\)\n\n\\(\\}\\)\n\n\n\nThus if \\(f(i,x_{1},\\ldots ,x_{k}) = 1\\), and for all \\(j \\lt i,\nf(j,x_{1},\\ldots ,x_{k})\\) is defined, but not equal to 1, then \\(\\mu\n[f](x_{1}, \\ldots ,x_{k}) = i\\). Otherwise \\(\\mu[f](x_{1}, \\ldots\n,x_{k})\\) is undefined.\n\n\nG\u00f6del defined the set of Recursive functions to be the\nclosure of the initial primitive recursive functions under composition,\nprimitive recursion, and \\(\\mu\\) . With this definition, the Recursive\nfunctions are exactly the same as the set of partial functions\ncomputable by the Lambda calculus, by Kleene Formal systems, by Markov\nalgorithms, by Post machines, and by Turing machines.\n",
    "section_title": "3.1 Recursive Functions",
    "entry_title": "Computability and Complexity",
    "hierarchy_title": "Computability and Complexity || Primitive Recursive Functions || Recursive Functions",
    "tokenized_text": [
        "primitive",
        "recursive",
        "function",
        "recursive",
        "function",
        "recursive",
        "function",
        "set",
        "primitive",
        "recursive",
        "function",
        "huge",
        "class",
        "computable",
        "function",
        "fact",
        "characterized",
        "set",
        "function",
        "computable",
        "time",
        "primitive",
        "recursive",
        "function",
        "n",
        "n",
        "length",
        "input",
        "example",
        "since",
        "h",
        "n",
        "n",
        "primitive",
        "recursive",
        "function",
        "primitive",
        "recursive",
        "function",
        "include",
        "time",
        "h",
        "n",
        "n",
        "see",
        "next",
        "section",
        "discussion",
        "computational",
        "complexity",
        "including",
        "time",
        "thus",
        "primitive",
        "recursive",
        "function",
        "include",
        "function",
        "feasibly",
        "computable",
        "conceivable",
        "measure",
        "feasible",
        "much",
        "beyond",
        "however",
        "primitive",
        "recursive",
        "function",
        "include",
        "function",
        "computable",
        "principle",
        "see",
        "use",
        "diagonalization",
        "systematically",
        "encode",
        "definition",
        "primitive",
        "recursive",
        "function",
        "arity",
        "calling",
        "p_",
        "p_",
        "p_",
        "build",
        "turing",
        "machine",
        "compute",
        "value",
        "following",
        "diagonal",
        "function",
        "n",
        "p_",
        "n",
        "n",
        "notice",
        "d",
        "total",
        "computable",
        "function",
        "mathbf",
        "n",
        "mathbf",
        "n",
        "primitive",
        "recursive",
        "suppose",
        "sake",
        "contradiction",
        "d",
        "primitive",
        "recursive",
        "d",
        "would",
        "equal",
        "p_",
        "din",
        "mathbf",
        "n",
        "would",
        "follow",
        "p_",
        "p_",
        "contradiction",
        "therefore",
        "d",
        "primitive",
        "recursive",
        "ala",
        "diagonal",
        "argument",
        "work",
        "class",
        "total",
        "function",
        "could",
        "considered",
        "candidate",
        "class",
        "computable",
        "function",
        "way",
        "around",
        "want",
        "function",
        "computable",
        "principle",
        "practice",
        "add",
        "kind",
        "unbounded",
        "search",
        "operation",
        "g\u00f6del",
        "extend",
        "primitive",
        "recursive",
        "function",
        "recursive",
        "function",
        "define",
        "unbounded",
        "minimization",
        "operator",
        "mu",
        "follows",
        "let",
        "f",
        "perhaps",
        "partial",
        "function",
        "arity",
        "k",
        "mu",
        "f",
        "defined",
        "following",
        "function",
        "arity",
        "k",
        "input",
        "x_",
        "ldots",
        "x_",
        "k",
        "following",
        "infty",
        "f",
        "x_",
        "ldots",
        "x_",
        "k",
        "output",
        "i",
        "thus",
        "f",
        "x_",
        "ldots",
        "x_",
        "k",
        "j",
        "lt",
        "f",
        "j",
        "x_",
        "ldots",
        "x_",
        "k",
        "defined",
        "equal",
        "mu",
        "f",
        "x_",
        "ldots",
        "x_",
        "k",
        "i",
        "otherwise",
        "mu",
        "f",
        "x_",
        "ldots",
        "x_",
        "k",
        "undefined",
        "g\u00f6del",
        "defined",
        "set",
        "recursive",
        "function",
        "closure",
        "initial",
        "primitive",
        "recursive",
        "function",
        "composition",
        "primitive",
        "recursion",
        "mu",
        "definition",
        "recursive",
        "function",
        "exactly",
        "set",
        "partial",
        "function",
        "computable",
        "lambda",
        "calculus",
        "kleene",
        "formal",
        "system",
        "markov",
        "algorithm",
        "post",
        "machine",
        "turing",
        "machine"
    ]
}