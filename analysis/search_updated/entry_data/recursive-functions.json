{
    "url": "recursive-functions",
    "title": "Recursive Functions",
    "authorship": {
        "year": "Copyright \u00a9 2020",
        "author_text": "Walter Dean\n<W.H.Dean@warwick.ac.uk>",
        "author_links": [
            {
                "http://go.warwick.ac.uk/whdean": "Walter Dean"
            },
            {
                "mailto:W%2eH%2eDean%40warwick%2eac%2euk": "W.H.Dean@warwick.ac.uk"
            }
        ],
        "raw_html": "<div id=\"article-copyright\">\n<p>\n<a href=\"../../info.html#c\">Copyright \u00a9 2020</a> by\n\n<br/>\n<a href=\"http://go.warwick.ac.uk/whdean\" target=\"other\">Walter Dean</a>\n&lt;<a href=\"mailto:W%2eH%2eDean%40warwick%2eac%2euk\"><em>W<abbr title=\" dot \">.</abbr>H<abbr title=\" dot \">.</abbr>Dean<abbr title=\" at \">@</abbr>warwick<abbr title=\" dot \">.</abbr>ac<abbr title=\" dot \">.</abbr>uk</em></a>&gt;\n    </p>\n</div>"
    },
    "pubinfo": [
        "First published Thu Apr 23, 2020"
    ],
    "preamble": "\n\nThe recursive functions are a class of functions on the\nnatural numbers studied in computability theory, a branch of\ncontemporary mathematical logic which was originally known as\nrecursive function theory. Such functions take their name\nfrom the process of recursion by which the value of a\nfunction is defined by the application of the same function applied to\nsmaller arguments.\n\nThis process may be illustrated by considering the familiar factorial\nfunction \\(x!\\)\u2014i.e., the function which returns the product \\(1\n\\times 2 \\times \\ldots \\times x\\) if \\(x > 0\\) and 1 otherwise. An\nalternative recursive definition of this function is as follows: \n\n\\[\\begin{align}\n\\label{defnfact}\n\\fact(0) & =  1 \\\\  \\nonumber\n\\fact(x+1) & =  (x+1) \\times \\fact(x) \\end{align}\\]\n\n\nSuch a definition might at first appear circular in virtue of the fact\nthat the value of \\(\\fact(x)\\) on the left hand side is defined in\nterms the same function on the righthand side. However a\ncharacteristic feature of recursive definitions is that they allow for\nthe values of functions which they describe to be calculated by\nsuccessively \u201cunwinding\u201d the clause for \\(x > 0\\) until\nthe clause for \\(x = 0\\) (the so-called base case) is\nreached. For instance the value of \\(fact(4)\\) may be calculated using\nthe preceding definition as follows: \n\\[\\begin{align} \\label{factcalc}\n\\fact(4) &= 4 \\times \\fact(3) \\\\\n& = 4 \\times (3 \\times \\fact(2))  \\nonumber \\\\\n& = 4 \\times (3 \\times (2 \\times \\fact(1)))  \\nonumber \\\\\n &=4 \\times (3 \\times (2 \\times 1 \\times (\\fact(0))))  \\nonumber \\\\\n& = 4 \\times (3 \\times (2 \\times (1 \\times 1)))  \\nonumber \\\\\n& = 24  \\nonumber \\\\\n\\end{align}\\]\n\n\nUnderstood in this way, the defining equations (\\ref{defnfact})\nprovide an algorithm for computing \\(\\fact(x)\\)\u2014i.e. an\neffective procedure for calculating its values which can be carried\nout by a human or mechanical computing device within a finite number\nof steps. It is for this reason that a class of recursive definitions\nsimilar to that exemplified by (\\ref{defnfact})\u2014 i.e. the\ngeneral recursive functions\u2014were first employed as the\nmathematical model of computation on which recursive function theory\nwas originally founded.\n\nSection 1 of this entry provides an overview of the foundational\ndevelopments in logic and mathematics which led to the founding of\nrecursive function theory in the 1930s. Section 2 surveys different\nforms of recursive definitions, inclusive of the primitive\nand partial recursive functions which are most central to the\nclassical development of this subject. Section 3 provides an overview\nof computability theory, inclusive of the so-called Recursion\nTheorem (Section 3.4)\u2014a result which highlights the\ncentrality of recursion to computation in general as well as its\nrelationship to self-reference. Subsequent updates to this entry will\nprovide an overview of subrecursive hierarchies employed in proof\ntheory and computer science as well as a more comprehensive treatment\nof contemporary computability theory. \n",
    "toc": [
        {
            "#HistBack": "1. Historical Background"
        },
        {
            "#EarlHistRecuDefi": "1.1 The Early History of Recursive Definitions"
        },
        {
            "#OrigPrimRecu": "1.2 The Origins of Primitive Recursion"
        },
        {
            "#AritReprGodeFirsIncoTheo": "1.3 Arithmetical Representability and G\u00f6del\u2019s First Incompleteness Theorem"
        },
        {
            "#AckePeteFunc": "1.4 The Ackermann-P\u00e9ter Function"
        },
        {
            "#GeneRecuFunc": "1.5 The General Recursive Functions"
        },
        {
            "#ChurThes": "1.6 Church\u2019s Thesis"
        },
        {
            "#EntsUnde": "1.7 The Entscheidungsproblem and Undecidability"
        },
        {
            "#OrigRecuFuncTheoCompTheo": "1.8 The Origins of Recursive Function Theory and Computability Theory"
        },
        {
            "#FormRecu": "2. Forms of Recursion"
        },
        {
            "#PrimRecuFuncPR": "2.1 The Primitive Recursive Functions (PR)"
        },
        {
            "#Defi": "2.1.1 Definitions"
        },
        {
            "#Exam": "2.1.2 Examples"
        },
        {
            "#AddiClosPropPrimRecuFunc": "2.1.3 Additional closure properties of the primitive recursive functions"
        },
        {
            "#PartRecuFuncPartRecuFuncREC": "2.2 The Partial Recursive Functions (PartREC) and the Recursive Functions (REC)"
        },
        {
            "#Defi_1": "2.2.1 Definitions"
        },
        {
            "#NormFormTheo": "2.2.2 The Normal Form Theorem"
        },
        {
            "#CompTheo": "3. Computability Theory"
        },
        {
            "#IndeSMNTheoUniv": "3.1 Indexation, the s-m-n Theorem, and Universality"
        },
        {
            "#NonCompFuncUndeProb": "3.2 Non-Computable Functions and Undecidable Problems"
        },
        {
            "#CompCompEnumSets": "3.3 Computable and Computably Enumerable Sets"
        },
        {
            "#RecuTheo": "3.4 The Recursion Theorem"
        },
        {
            "#ReduDegr": "3.5 Reducibilities and Degrees"
        },
        {
            "#ManyOneDegr": "3.5.1 The many-one degrees"
        },
        {
            "#TuriDegr": "3.5.2 The Turing degrees"
        },
        {
            "#AritAnalHier": "3.6 The Arithmetical and Analytical Hierarchies"
        },
        {
            "#AritHier": "3.6.1 The arithmetical hierarchy"
        },
        {
            "#AnalHier": "3.6.2 The analytical hierarchy"
        },
        {
            "#FurtRead": "4. Further Reading"
        },
        {
            "#Bib": "Bibliography"
        },
        {
            "#Aca": "Academic Tools"
        },
        {
            "#Oth": "Other Internet Resources"
        },
        {
            "#Rel": "Related Entries"
        }
    ],
    "main_text": "\n1. Historical Background\n\nNB: This section assumes familiarity with some of the terminology\nintroduced in\n Section 2\n and\n Section 3.\n Readers looking for a technical overview of recursive functions or\ncomputability theory are advised to start there.\n1.1 The Early History of Recursive Definitions\n\nExamples of recursive definitions can be found intermittently in the\nhistory of ancient and medieval mathematics. A familiar illustration\nis the sequence \\(F_i\\) of Fibonacci numbers\n\\(1,1,2,3,5,8,13, \\ldots\\) given by the recurrence \\(F_0 = 1, F_1 =\n1\\) and \\(F_{n} = F_{n-1} + F_{n-2}\\) (see\n Section 2.1.3).\n The definition of this sequence has traditionally been attributed to\nthe thirteenth century Italian mathematician Leonardo of Pisa (also\nknown as Fibonacci) who introduced it in his Liber Abaci in\nthe context of an example involving population genetics (see Fibonacci\n1202 [2003, 404\u2013405]). But descriptions of similar sequences can\nalso be found in Greek, Egyptian, and Sanskrit sources dating as early\nas 700 BCE (see, e.g., Singh 1985).\n\nGeneral interest in recursion as a mode of function definition\noriginated in the mid-nineteenth century as part of the broader\nprogram of arithmetizing analysis and the ensuing discussions of the\nfoundations of arithmetic itself. In this context, the formulation of\nrecursive definitions for number theoretic functions was closely tied\nto the isolation of mathematical induction as a mode of reasoning\nabout the natural numbers. It was in this setting in which Grassmann\n(1861) and Peirce (1881) first gave the familiar recursive definitions\nof addition and\n multiplication:[1]\n \n\\[\\begin{align} \\label{defnadd}\n\\text{i.}\\quad &&  x + 0 & = x \\\\ \\nonumber\n\\text{ii.}\\quad &&  x + (y+1) & = (x+y)+1\n\\end{align}\\]\n \n\\[\\begin{align} \\label{defnmult}\n\\text{i.}\\quad &&  x \\times 0 & = 0 \\\\ \\nonumber\n\\text{ii.}\\quad &&  x \\times (y+1) & = (x\\times y) + x\n\\end{align}\\]\n\n\nThey then used these definition to prove the associative, commutative,\nand distributive laws for these\n operations.[2]\n\n\nThe first person to employ the expression \u201cdefinition by\nrecursion\u201d appears to have been Dedekind in his essay Was\nsind und was sollen die Zahlen (1888). This work presents a set\ntheoretic foundation for arithmetic wherein Dedekind demonstrated that\nit was possible to state and prove the existence and uniqueness of\nfunctions defined by primitive recursion as mathematical theorems\n(\u00a7125\u2013126). He formulated recursive definitions of addition\n(\u00a7135), multiplication (\u00a7147), and exponentiation\n(\u00a7155) and then also formally proved by induction that the\nfunctions so defined satisfy the expected algebraic identities. The\nfirst two of these definitions would later be adopted by Peano (1889)\nas defining the symbols \\(+\\) and \\(\\times\\) in the direct\naxiomatization of arithmetic he based on Dedekind\u2019s\nmonograph.\n1.2 The Origins of Primitive Recursion\n\nThe first work devoted exclusively to recursive definability was\nSkolem\u2019s (1923) paper \n\n\nThe foundations of elementary arithmetic established by the recursive\nmode of thought, without the use of apparent variables ranging over\ninfinite domains. \n\n\nThis work is significant with respect to the subsequent development of\ncomputability theory for at least three reasons. First, it contains a\ninformal description of what we now call the primitive recursive\nfunctions. Second, it can be regarded as the first place where\nrecursive definability is linked to effective computability (see also\nSkolem 1946). And third, it demonstrates that a wide range of\nfunctions and relations are primitive recursive in a manner which\nanticipates G\u00f6del\u2019s (1931) use of primitive recursion for\nthe arithmetization of syntax. \n\nOne of Skolem\u2019s stated goals was to present a logical foundation\nfor number theory which avoids the use of unrestricted quantifiers. He\nwas inspired in this regard by the observation that it is possible to\ndevelop much of elementary arithmetic without the use of the\nexpressions \u201calways\u201d (i.e. for all) and\n\u201csometimes\u201d (i.e. there exists) which figure in\nthe formalization of number theory given by Russell and Whitehead in\nPrincipia Mathematica (1910\u20131913). This was to be\naccomplished by formulating arithmetical theorems as what he referred\nto as functional assertions. These took the form of\nidentities between terms defined by primitive recursive operations\nwhich Skolem referred to as descriptive functions. For\ninstance, the commutativity of addition is expressed in this form by\nan equation with free variables  \n\\[\\begin{equation}\\label{funassert}\nx + y = y + x\n\\end{equation}\\]\n\n\nIn cases where such statements are provable in the system Skolem\ndescribes, the intended interpretation is that the claim holds\nuniversally for all natural numbers\u2014e.g., \\(\\forall x \\forall y\n(x + y = y + x)\\). But in Skolem\u2019s system there is no means of\nnegating such a statement to express a bare existential assertion\nwithout producing a witness.\n\nStatements like (\\ref{funassert}) would later be referred to by\nHilbert & Bernays (1934) (who provided the first textbook\ntreatment of recursion) as verifiable in the sense that their\nindividual instances can be verified computationally by replacing\nvariables with concrete numerals. This is accomplished by what Skolem\nreferred to as the \u201crecursive mode of thought\u201d. The sense\nof this phrase is clarified by the following properties of the system\nhe describes: \n\n the natural numbers are taken as basic objects\ntogether with the successor function \\(x + 1\\); \n it is assumed that descriptive functions proven to\nbe equal may be substituted for one another in other expressions;\n\n all definitions of functions and relations on\nnatural numbers are given by recursion; \nfunctional assertions such as (\\ref{funassert}) must\nbe proven by induction. \n\n\nTaking these principles as a foundation, Skolem showed how to obtain\nrecursive definitions of the predecessor and\nsubtraction functions, the less than,\ndivisibility, and primality relations, greatest\ncommon divisors, least common multiples, and bounded\nsums and products which are similar to those given in\n  Section 2.1.2 \n below.\n\nOverall Skolem considered instances of what we would now refer to as\nprimitive recursion, course of values recursion, double recursion, and\nrecursion on functions of type \\(\\mathbb{N} \\rightarrow \\mathbb{N}\\).\nHe did not, however, introduce general schemas so as to systematically\ndistinguish these modes of definition. Nonetheless, properties\ni\u2013iv of Skolem\u2019s treatment provide a means of assimilating\ncalculations like (\\ref{factcalc}) to derivations in quantifier-free\nfirst-order logic. It is thus not difficult to discern in (Skolem\n1923) the kernel of the system we now know as Primitive Recursive\nArithmetic (as later formally introduced by Hilbert & Bernays\n1934, ch. 7).\n\nThe next important steps in the development of a general theory of\nrecursive function arose as a consequence of the interaction between\n Hilbert\u2019s Program\n and G\u00f6del\u2019s (1931) proof of the Incompleteness Theorems.\nHilbert (1900) had announced the goal of proving the consistency of\narithmetic\u2014and ultimately also analysis and set theory\u2014 in\nthe face of the set theoretic paradoxes. His initial plans for\ncarrying out such a proof are described in a series of lectures and\naddresses in the 1910s\u20131920s which provide a description of what\nwould come to be called the finitary standpoint\u2014i.e.,\nthe fragment of mathematical reasoning pertaining to finite\ncombinatorial objects which was intended to serve as the secure basis\nfor a consistency proof. The proof itself was to be carried out using\nthe methods of what Hilbert referred to as\nmetamathematics\u2014i.e., the formal study of axioms and\nderivations which would grow into the subject now known as\n proof theory.\n\nIn one of his initial descriptions of this program Hilbert (1905)\nsketched the basic form which a metamathematical proof of consistency\nmight take. Suppose, for instance, that \\(\\mathsf{T}\\) is a\nmathematical theory about which it is possible to prove the following\nconditional:\n\nIf \\(n\\) applications of rules of inference applied to the axioms\nof a system \\(\\mathsf{T}\\) do not lead to a contradiction, then\n\\(n+1\\) applications also do not lead to a contradiction.\n\n\nWere it possible to provide a mathematical demonstration of i), it\nmight seem possible to conclude\n\n\\(\\mathsf{T}\\) is consistent.\n\n\nHowever Poincar\u00e9 (1906) observed that Hilbert\u2019s approach\nrelies on mathematical induction in inferring ii from i. He objected\non the basis that this renders Hilbert\u2019s proposed method\ncircular in the case that the system \\(\\mathsf{T}\\) in question itself\nsubsumes principles intended to formalize\n induction.[3]\n\n\nTogether with his collaborators Ackermann and Bernays, Hilbert\ndeveloped metamathematics considerably during the 1910\u20131920s.\nThis served as the basis of Hilbert\u2019s (1922) lecture wherein he\nreplied to Poincar\u00e9 by making a systematic distinction between\n\u201cformal\u201c occurrences of mathematical induction in the\nobject language and the metatheoretic use of induction as a\n\u201ccontentual\u201c [inhaltliche] principle used in\norder to reason about proofs as finite combinatorial objects. It was\nalso in this context in which Hilbert connected the latter form of\ninduction to the \u201cconstruction and deconstruction of number\nsigns\u201d (1922, 1123). \n\nAs is made clear in subsequent presentations, Hilbert understood\n\u201cnumber signs\u201d to be unary numerals written in stroke\nnotation of the form  \n\\[\\nonumber\n|, ||, |||, \\ldots\\]\n\n\nSuch expressions can be operated on concretely by adjoining or\nremoving strokes in a manner which mirrors the arithmetical operations\nof successor and predecessor which figure in Skolem\u2019s\n\u201crecursive mode of thought\u201c. This observation in turn\ninformed Hilbert\u2019s explanation of the meaning of functional\nassertions like (\\ref{funassert}) in terms of their logical\nderivability from recursive definitions which also serve as procedures\nfor computing the values of functions they define (Hilbert 1920,\n54\u201357).\n\nHilbert first described a logical calculus for finitary number theory\nincluding \u201crecursion and intuitive induction for finite\ntotalities\u201d in (1923,\n 1139).[4]\n Although this presentation also included a discussion of definition\nby simultaneous recursion, a more extensive treatment of what we would\nnow recognize as recursion schemes is given in his well known\npaper \u201cOn the infinite\u201d (1926). This includes a discussion\nof what Hilbert calls ordinary recursion (which is similar to\nSkolem\u2019s description of primitive recursion), transfinite\nrecursion, as well as recursion at higher types. This treatment makes\nclear that Hilbert and his collaborators had taken substantial steps\ntowards developing a general theory of recursive definability.\nUltimately, however, the influence of Hilbert\u2019s presentations\nwas diminished in light of the more precise formulation of primitive\nrecursion which G\u00f6del would soon\n provide.[5]\n\n\nG\u00f6del\u2019s (1931, 157\u2013159) definition was as\nfollows:\n\n\nA number-theoretic function \\(\\phi(x_1,\\ldots,x_n)\\) is said to be\nrecursively defined in terms of the number-theoretic\nfunctions \\(\\psi(x_1,x_2,\\ldots,x_{n-1})\\) and \\(\\mu(x_1,x_2,\\ldots,\nx_{n+1})\\) if \n\\[\\begin{align} \\label{gprimrec}\n\\text{i.}\\quad & \\phi(0,x_2,\\ldots,x_n)  =  \\psi(x_2,\\ldots,x_n) \\\\ \\nonumber\n\\text{ii.}\\quad & \\phi(k+1,x_2,\\ldots,x_n)  =  \\mu(k,\\phi(k,x_2,\\ldots,x_n),x_2,\\ldots,x_n)\n\\end{align}\\]\n\n\nholds for all \\(x_2,\\ldots,x_n,k\\).\n\nA number-theoretic function \\(\\phi\\) is said to be recursive\nif there is a finite sequence of number-theoretic functions \\(\\phi_1 ,\n\\phi_2 , \\ldots \\phi_n\\) that ends with \\(\\phi\\) and has the property\nthat every function \\(\\phi_k\\) of the sequence is recursively defined\nin terms of two of the preceding functions, or results from any of the\npreceding functions by substitution, or, finally, is a constant or the\nsuccessor function \\(x + 1\\)\u2026. A relation \\(R(x_1, \\ldots ,\nx_n)\\) between natural numbers is said to be recursive if\nthere is a recursive function \\(\\phi(x_1 \\ldots , x_n)\\) such that,\nfor all \\(x_1, x_2, \\ldots, x_n\\)  \n\\[\\begin{equation}\\label{prch}\nR(x_1,\\ldots,x_n) \\leftrightarrow \\phi(x_1,\\ldots,x_n) = 0\n\\end{equation}\\]\n\n\n\nPutting aside G\u00f6del\u2019s use of the term\n\u201crecursive\u201d rather than \u201cprimitive recursive\u201d\n(which will be explained below), this exposition comes close to\ncoinciding with the contemporary definition of the primitive recursive\nfunctions given in\n Section 2.1.[6]\n G\u00f6del\u2019s definition also improved upon those of his\npredecessors by clearly defining the class of initial functions which\nare allowed in primitive recursive definitions and by stating that\neach primitive recursive function possesses a definition in terms of a\nsequence of functions showing how it is built up from initial\nfunctions. This makes clear that the primitive recursive functions\nconstitute a mathematically well-defined class of functions on the\nnatural numbers (which will be denoted here as \\(\\mathbf{PR}\\)).\nG\u00f6del additionally proved that the primitive recursive\nrelations\u2014defined as characteristic functions via\n(\\ref{prch})\u2014are closed under propositional operations and\nquantification bounded by a primitive recursive function (see\n Section 2.1.2).\n1.3 Arithmetical Representability and G\u00f6del\u2019s First Incompleteness Theorem\n\nThe foregoing definition appears in G\u00f6del\u2019s well-known\n(1931) paper \u201cOn formally undecidable propositions of\nPrincipia mathematica and related systems I\u201d. As he\nobserves immediately before presenting it, the definition of primitive\nrecursion is in fact a digression from the main focus of the\npaper\u2014i.e., proving the incompleteness of the axiomatic system\nof arithmetic he calls \\(\\mathsf{P}\\). In order to understand\nG\u00f6del\u2019s contribution to the initial development of\nrecursive function theory, it will be useful to attend both to some\nfeatures of this system and also to his proof of the First\nIncompleteness Theorem itself. (Additional details and context are\nprovided in the entry on\n G\u00f6del\u2019s incompleteness theorems.)\n\nSystem \\(\\mathsf{P}\\) is obtained from that of Whitehead and\nRussell\u2019s Principia Mathematica (1910\u20131913) by\nomitting the ramification of types, taking the natural numbers as the\nlowest type, and adding for them the second-order Peano axioms. It is\nhence a fixed formal system with finitely many non-logical axioms\nsufficient for the development of elementary number\n theory.[7]\n Recall also that an arithmetical system is said to be\n\\(\\omega\\)-consistent if it does not prove both \\(\\exists x\n\\varphi(x)\\) and \\(\\neg \\varphi(\\overline{n})\\) for each natural\nnumber \\(n \\in \\mathbb{N}\\) (where \\(\\overline{n} =_{\\mathrm{df}}\ns(s(\\ldots s(0)))\\) \\(n\\)-times) and that \\(\\omega\\)-consistency\nimplies simple consistency (i.e., the non-derivability of a\nformula and its negation). \n\nThe incompleteness theorem which G\u00f6del proved states that if\n\\(\\mathsf{P}\\) is \u03c9-consistent, then there exists a formula\n\\(G_{\\mathsf{P}}\\) which is undecidable in\n\\(\\mathsf{P}\\)\u2014i.e., neither provable nor refutable from its\naxioms. In order to obtain such a formula, G\u00f6del first\ndemonstrated how it is possible to express various syntactic and\nmetatheoretic properties of \\(\\mathsf{P}\\)-formulas and proofs as\nprimitive recursive relations via a technique which has come to be\nknown as the arithmetization of syntax (see the entry on\n G\u00f6del\u2019s incompleteness theorems).\n Second, he showed that for every primitive recursive relation\n\\(R(x_1,\\ldots,x_k)\\) there exists a \u201cclass sign\u201d (i.e.,\nformula) \\(\\varphi_R(x_1,\\ldots,x_n)\\) of \\(\\mathsf{P}\\) such that the\nfact that \\(R(x_1,\\ldots,x_n)\\) holds of (or does not hold of) a given\ntuple of numbers \\(n_1,\\ldots,n_k\\) is mirrored by the provability (or\nrefutability) in \\(\\mathsf{P}\\) of the corresponding instance of\n\\(\\varphi_R(x_1,\\ldots,x_n)\\) when the formal numeral \\(\\overline{n} =\ns(s(\\ldots s(0)))\\) (\\(n\\)-times) is substituted for\n\\(x_i\\)\u2014i.e., \n\\[\\begin{align} \\label{rep}\n\\text{i.}\\quad & \\text{if } R(n_1,\\ldots,n_k), \\text{ then } \\mathsf{P} \\vdash \\varphi_R(\\overline{n}_1,\\ldots,\\overline{n}_k) \\\\ \\nonumber\n\\text{ii.}\\quad & \\text{if } \\neg R(n_1,\\ldots,n_k), \\text{ then } \\mathsf{P} \\vdash \\neg \\varphi_R(\\overline{n}_1,\\ldots,\\overline{n}_k)\n\\end{align}\\]\n\n\nAccording to the terminology G\u00f6del would later introduce in\n(1934), in such a case \\(\\varphi_R(x_1,\\ldots,x_n)\\)\nrepresents \\(R(x_1,\\ldots,x_n)\\). In this presentation, he\nalso generalized his prior definition to say that a function\n\\(f(x_1,\\ldots,x_n)\\) is representable in \\(\\mathsf{P}\\) just in case\nthere exists a formula \\(\\varphi_f(x_1,\\ldots,x_k,y)\\) such that for\nall \\(n_1,\\ldots,x_k,m \\in \\mathbb{N}\\),  \n\\[\\begin{equation}\\label{repfun}\nf(n_1,\\ldots,n_k) = m  \\textrm{ if and only if } \\mathsf{P} \\vdash \\varphi_f(\\overline{n}_1,\\ldots,\\overline{n}_k,\\overline{m})\n\\end{equation}\\]\n\n\nG\u00f6del\u2019s arithmetization of syntax provides a means of\nassigning to each primitive symbol, term, formula, and proof\n\\(\\alpha\\) of \\(\\mathsf{P}\\) a unique G\u00f6del number\n\\(\\ulcorner \\alpha \\urcorner \\in \\mathbb{N}\\) according to its\nsyntactic structure. This technique takes advantage of the familiar\nobservation that a finite sequence of numbers \\(n_1,\\ldots,n_k\\) can\nbe encoded as a product of prime powers \\(2^{n_1} \\cdot 3^{n_2} \\cdot\n\\ldots p_k^{n_k}\\) so that various correlative operations on sequences\ncan be shown to be primitive recursive\u2014e.g., the operation which\ntakes two numbers \\(x\\) and \\(y\\) encoding sequences and returns the\ncode \\(x * y\\) of the result of concatenating \\(x\\) followed by \\(y\\).\nG\u00f6del proceeded on this basis to show that a sequence of notions\nabout the syntax and proof theory of \\(\\mathsf{P}\\) are primitive\nrecursive\u2014e.g., the function \\(\\textrm{Neg}(x)\\) which returns\nthe G\u00f6del number of the negation of the formula coded by \\(x\\)\ncan be defined as \\(\\ulcorner \\neg \\urcorner * x\\). The availability\nof the relevant recursive definitions thus falls out naturally since\nthe inductive definitions of syntactic notions like well-formed\nformula generalize the \u201cconstruction and deconstruction of\nnumber signs\u201d in the sense described by\n Hilbert.[8]\n\n\nThe penultimate definition in G\u00f6del\u2019s list is the relation\n\\(\\mathsf{Proof}_{\\mathsf{P}}(x,y)\\) which holds between the\nG\u00f6del number of a \\(\\mathsf{P}\\)-formula \\(\\varphi\\) and the\nG\u00f6del number of a finite sequence of \\(\\mathsf{P}\\)-formulas\n\\(\\psi_1,\\ldots, \\psi_n\\) just in case the latter is a correctly\nformed derivation of the former from the axioms of\n\\(\\mathsf{P}\\)\u2014i.e.,\n\n\\(\\mathsf{Proof}_{\\mathsf{P}}(\\ulcorner \\psi_1,\\ldots, \\psi_n\n\\urcorner, \\ulcorner \\varphi \\urcorner))\\) iff \\(\\mathsf{P} \\vdash\n\\varphi\\) via a derivation \\(\\psi_1,\\ldots,\\psi_n\\) in which each\n\\(\\psi_i\\) is either an axiom of \\(\\mathsf{P}\\) or follows from prior\nformulas via its rules of inference.  \n\nFrom (\\ref{rep}) it follows that there exists a formula\n\\(\\textrm{Proof}_{\\mathsf{P}}(x,y)\\) of \\(\\mathsf{P}\\) which\nrepresents \\(\\mathsf{Proof}_{\\mathsf{P}}(x,y)\\) and thus also a\nformula \n\\[\\textrm{Prov}_{\\mathsf{P}}(y) =_{\\textrm{df}} \\exists x \\textrm{Proof}_{\\mathsf{P}}(x,y).\\]\n\n\nG\u00f6del famously named the latter formula \\(\\sc{BEW}(x)\\) (for\nbeweisbar) as it can be understood to express that there\nexists a proof from the axioms of \\(\\mathsf{P}\\) of the formula with\nG\u00f6del number \\(y\\). But unlike the other formulas representing\nprimitive recursive relations which figure in its definition,\n\\(\\textrm{Prov}_{\\mathsf{P}}(x)\\) contains an unbounded existential\nquantifier. And thus as G\u00f6del is careful to observe, there is no\nreason to expect that it defines a primitive recursive relation.\n\nIt is, nonetheless, this formula which G\u00f6del uses to construct a\nsentence which is undecidable in \\(\\mathsf{P}\\). This can be\naccomplished by the application of the so-called Diagonal\nLemma (see\n G\u00f6del\u2019s incompleteness theorems)\n which states that for every formula \\(\\varphi(x)\\) of \\(\\mathsf{P}\\),\nthere exists a sentence \\(\\psi_{\\varphi}\\) such that  \n\\[\\mathsf{P} \\vdash \\psi_{\\varphi} \\leftrightarrow \\varphi(\\overline{\\ulcorner \\psi_{\\varphi} \\urcorner})\\]\n\n\nWhen applied to the formula \\(\\neg \\textrm{Prov}_{\\mathsf{P}}(x)\\),\nthe Diagonal Lemma yields a sentence \\(G_{\\mathsf{P}}\\)\u2014i.e.,\nthe so-called G\u00f6del sentence for\n\\(\\mathsf{P}\\)\u2014such that \\(\\mathsf{P} \\vdash G_P\n\\leftrightarrow \\neg \\textrm{Prov}_{\\mathsf{P}}(\\ulcorner\nG_{\\mathsf{P}} \\urcorner)\\). \\(G_{\\mathsf{P}}\\) is thus interpretable\nas \u201csaying of itself\u201d that it is unprovable in\n\\(\\mathsf{P}\\). G\u00f6del showed that this formula has the following\nproperties: \n\nif \\(\\mathsf{P}\\) is consistent, then \\(\\mathsf{P} \\not\\vdash\nG_{\\mathsf{P}}\\); \n if \\(\\mathsf{P}\\) is \u03c9-consistent, then \\(\\mathsf{P}\n\\not\\vdash \\neg G_{\\mathsf{P}}\\).\n\n\nThis constitutes what is now known as G\u00f6del\u2019s First\nIncompleteness Theorem.\n\nThe proof of this fact relies explicitly on the representability of\nthe relation \\(\\mathsf{Proof}_{\\mathsf{P}}(x,y)\\) in \\(\\mathsf{P}\\)\nwhich in turn derives from its primitive recursiveness. But the\ntechniques on which G\u00f6del\u2019s proof relies also contributed\nto the subsequent development of computability theory in several\nadditional ways. First, it follows from the possibility of G\u00f6del\nnumbering the formulas of \\(\\mathsf{P}\\) that we may also effectively\nenumerate them as \\(\\varphi_0(x), \\varphi_1(x), \\varphi_2(x),\n\\ldots\\)\u2014e.g., in increasing order of \\(\\ulcorner \\varphi_i\n\\urcorner\\). This provides a mechanism for referring to formulas via\ntheir indices which in turn served as an important precedent for\nKleene\u2019s (1936a) use of a similar indexation of general\nrecursive definitions in his proof of the Normal Form Theorem (see\n Section 2.2.2).\n Second, the proof of the Diagonal Lemma also demonstrates how it is\npossible to formalize the substitution of terms for free variables in\na manner which may be understood to yield an effective form of\nCantor\u2019s diagonal argument (see the entry on\n self-reference).\n This technique served as an important precedent for the use of\ndiagonalization in results such as the undecidability of the Halting\nProblem (Turing 1937, see\n Section 3.2),\n the Recursion Theorem (Kleene 1938, see\n Section 3.4),\n and the Hierarchy Theorem (Kleene 1943, see\n Section 3.6).\n \n\nAnother significant contribution of G\u00f6del\u2019s paper derives\nfrom the fact that after proving the incompleteness of \\(\\mathsf{P}\\),\nhe took several steps towards isolating features of axiomatic theories\nwhich are sufficient to ensure that they satisfy analogous\nundecidability results. In addition to being sufficiently strong to\nsatisfy (\\ref{rep}), the other requirement which he identifies is that\n\u201cthe class of axioms and the rules of inference \\(\\ldots\\) are\nrecursively definable\u201d (1931, 181). As he notes, these features\nhold both of Zermelo-Fraenkel set theory \\([\\mathsf{ZF}\\)] and a\nfirst-order arithmetical system similar to what we now call\nfirst-order Peano arithmetic \\([\\mathsf{PA]}\\), relative to an\nappropriate G\u00f6del numbering of their axioms. In particular, while\nneither of these systems is finitely axiomatizable, they may\nbe axiomatized by a finite number of schemes (e.g., of induction or\ncomprehension) such that the relation \\(\\ulcorner \\varphi\n\\urcorner\\) is the G\u00f6del number of an axiom of T\nis primitive recursive.\n\nThis observation set the stage for G\u00f6del\u2019s subsequent\nrevisiting of the incompleteness theorems in the lectures (1934)\nwherein he suggests a significant generalization of his original\n(1931) definition of recursiveness. G\u00f6del starts out by providing\nthe following informal characterization of the requirements of the\ntheories just described:\n\n\nWe require that the rules of inference, and the definitions of\nmeaningful formulas and axioms, be constructive; that is, for each\nrule of inference there shall be a finite procedure for determining\nwhether a given formula \\(B\\) is an immediate consequence (by that\nrule) of given formulas \\(A_1, \\ldots, A_n\\) and there shall be a\nfinite procedure for determining whether a given formula \\(A\\) is a\nmeaningful formula or an axiom. (G\u00f6del 1934, 346)\n\n\nHe also makes clear that what he calls \u201crecursiveness\u201d is\nto be initially regarded as an informal notion which he is\nattempting to make precise:\n\n\nRecursive functions have the important property that, for each given\nset of values of the arguments, the value of the function can be\ncomputed by a finite procedure. Similarly, recursive relations\n(classes) are decidable in the sense that, for each given \\(n\\)-tuple\nof natural numbers, it can be determined by a finite procedure whether\nthe relation holds or does not hold (the number belongs to the class\nor not), since the representing function is computable. (G\u00f6del\n1934, 348)\n\n\nOne of G\u00f6del\u2019s goals was thus to provide a mathematical\ndefinition of the term \u201crecursive\u201d which generalizes prior\nexamples of recursive definability in a manner but also captures to as\ngreat an extent as possible the class of functions computable by a\nfinite procedure. This led him to define the so-called general\nrecursive functions (see\n Section 1.5)\n whose isolation in turn played an important role in the formulation\nof Church\u2019s Thesis (see\n Section 1.6).\n However G\u00f6del\u2019s definition also took place against the\nbackdrop of other work which had been inspired by Hilbert\u2019s\noriginal consideration of different forms of recursive definitions. It\nwill now be useful to examine these developments.\n1.4 The Ackermann-P\u00e9ter Function\n\nAlready at the time of (1926), Hilbert had anticipated that it would\nbe possible to formulate definitions of functions whose values could\nbe computed in a recursive manner but which are not themselves\nprimitive recursive. In order to illustrate how such a definition\nmight be obtained, he presented a heuristic argument involving the\nfollowing sequence of functions: \n\\[\\begin{align}\n\\nonumber \\alpha_0(x,y) &= x + 1 &\\text{(successor)} \\\\ \n\\nonumber \\alpha_1(x,y) &= x + y &\\text{(addition)} \\\\ \n\\nonumber \\alpha_2(x,y) &= x \\times y &\\text{(multiplication)} \\\\ \n\\nonumber \\alpha_3(x,y) &= x^y &\\text{(exponentiation)} \\\\ \n\\nonumber \\alpha_4(x,y) &= \\underbrace{x^{x^{\\udots^x}}}_{y \\textrm{ times}} &\\text{(super-exponentiation)} \\\\ \n\\nonumber  &\\vdots\n\\end{align}\\]\n\n\nThe functions in this sequence are defined so that\n\\(\\alpha_{i+1}(x,y+1)\\) is obtained by primitive recursion as\n\\(\\alpha_i(\\alpha_{i+1}(x,y),x)\\), together with an appropriate base\ncase. It thus makes sense mathematically to consider the function \n\n\\[\\begin{equation}\\label{alphadef}\n\\alpha(i,x,y) = \\alpha_i(x,y)\n\\end{equation}\\]\n\n\nwherein the first argument \\(i\\) represents the position of the\nfunction \\(\\alpha_i(x,y)\\) in the prior list. For fixed \\(i,n,m \\in\n\\mathbb{N}\\) it is thus possible to effectively compute the value of\n\\(\\alpha(i,n,m)\\) by first constructing the definition of\n\\(\\alpha_i(x,y)\\) and then evaluating it at \\(n,m\\). But it is also\neasy to see that \\(\\alpha_{i+1}(x,x)\\) will eventually dominate\n\\(\\alpha_i(x,x)\\) for sufficiently large \\(x\\). This in turn suggests\nthat \\(\\alpha(i,x,y)\\) cannot be defined by a finite number of\napplications of the primitive recursion scheme and is thus not itself\nprimitive recursive.\n\nThe specification of \\(\\alpha(i,x,y)\\) just given does not itself have\nthe form of a recursive definition. But it is possible to define\nsimilar functions in a manner which generalizes the format of the\nscheme (\\ref{gprimrec}). One means of doing so is to first use\nrecursion on the type \\(\\mathbb{N} \\rightarrow \\mathbb{N}\\)\u2014a\nsimple form of recursion at higher types as envisioned by Skolem and\nHilbert\u2014to define an iteration functional as follows:\n \n\\[\\begin{aligned}\n\\mathcal{Iter}(\\phi,0) &= \\phi \\\\ \\nonumber\n\\mathcal{Iter}(\\phi,x+1) &= \\phi(\\mathcal{Iter}(\\phi,x)) \\end{aligned}\\]\n\n\n\\(\\mathcal{Iter}\\) takes as arguments a function \\(\\phi:\\mathbb{N}\n\\rightarrow \\mathbb{N}\\) as well as a number \\(x \\in \\mathbb{N}\\) and\nis defined so that \\(\\mathcal{Iter}(\\phi,n) =\n\\phi^{n+1}(x)\\)\u2014i.e., the function which is the \\(n\\)th iterate\nof \\(\\phi\\). We may now define a function \\(\\beta\\) of type\n\\(\\mathbb{N} \\rightarrow (\\mathbb{N} \\rightarrow \\mathbb{N})\\) as\nfollows:  \n\\[\\begin{aligned}\n\\beta(0) &= x+1 \\textrm{ (i.e., the successor function)} \\\\ \n\\beta(x+1) &= \\mathcal{Iter}(\\beta,x) \\nonumber\\end{aligned}\\]\n\n\nIt can then be verified that  \n\\[\\begin{align*}\n\\beta(0) & = x +1, \\\\\n\\beta(1) & = 2 + (x + 3) - 3 = x+2, \\\\\n\\beta(2) & = 2 \\times x - 3, \\\\\n\\beta(3) & = 2^{x+3} - 3, \\\\\n\\beta(4) &= \\underbrace{2^{2^{\\udots^2}}}_{x \\textrm{ times}} - 3,\\\\ \n  &\\vdots\n\\end{align*}\n\\]\n\n\nOn this basis, we may now define a variant of the so-called\nAckermann-P\u00e9ter function as \\(\\pi(i,x) =\n\\beta(i)(x)\\)\u2014i.e., the result of applying the function\n\\(\\beta(i)\\) to the argument \\(x\\). \\(\\pi(i,x)\\) has the same order of\ngrowth as \\(\\alpha_i(x,x)\\) and it is possible to prove via the\nargument sketched above that \\(\\pi(i,x)\\) is not primitive recursive\n(see, e.g., P\u00e9ter 1967, ch. 9). Based on earlier work of\nAckermann (1928), P\u00e9ter (1935) also showed that \\(\\pi(i,x)\\)\nmay also be defined by a so-called doubly recursive\ndefinition of the following form which takes only natural numbers as\n arguments:[9]\n \n\\[\\begin{align}\n\\label{pidef}\n\\pi(0,x) &= x + 1\\\\ \\nonumber\n\\pi(i+1,0) &= \\pi(i,1)\\\\ \\nonumber\n\\pi(i+1,x+1) &= \\pi(i,\\pi(i+1,x)) \n\\end{align}\\]\n\n\nThe third clause in this definition defines the value of \\(\\pi(i,x)\\)\nin terms of the value \\(\\pi(i,x-1)\\) rather than \\(\\pi(i-1,x-1)\\) in\nanalogy with the scheme (\\ref{gprimrec}). It may thus not be\nimmediately obvious that the definition (\\ref{pidef}) describes an\nalgorithm for computing the values of \\(\\pi(i,x)\\) which always\nterminates in the manner illustrated by the calculation\n(\\ref{factcalc}). Note, however, with each recursive application\neither \\(i\\) decreases, or \\(i\\) remains the same and \\(x\\) decreases.\nIt thus follows that each time \\(x\\) reaches 0, \\(i\\) will start to\ndecrease so that the base case is eventually reached. Thus although\nthe value of \\(\\pi(i,x)\\) grows very rapidly\u2014e.g., \\(\\pi(4,3) =\n2^{2^{65536}}-3\\)\u2014it is still reasonable to regard (\\ref{pidef})\nas satisfying G\u00f6del\u2019s\nrequirement that a recursively defined function is computable by a\nfinite procedure.\n\nSystematic consideration of such alternative recursion schemes\nexemplified by (\\ref{pidef}) was initiated by P\u00e9ter (1932). It\nwas also she who introduced the term \u201cprimitive recursive\u201d\nto describe the class of functions given by G\u00f6del\u2019s scheme\n(\\ref{gprimrec}), a choice which would become standard after its\nadoption by Kleene (1936a). P\u00e9ter additionally showed that\nHilbert\u2019s (1926) formulation of \u201cordinary recursion\u201d\nis equivalent to primitive recursion, and that the primitive recursive\nfunctions are closed under course of values recursion, as well as\nso-called nested recursions of one variable. Such studies led\nto her book (P\u00e9ter 1967), whose original German edition\nRekursive Funktionen (1951) was the first monograph devoted\nto recursive functions. Together with the later work of Grzegorczyk\n(1953), these developments also inspired the investigation of various\nsubrecursive hierarchies which would later play a role in proof theory\nand computer\n science.[10]\n\n1.5 The General Recursive Functions\n\nThe immediate source for G\u00f6del\u2019s discussion of recursion in\n1934 was not Ackermann or P\u00e9ter\u2019s work but rather a\nprivate communication with Herbrand, who in two previous papers (1930,\n1932) had proposed a related means of generalizing recursive\ndefinitions. G\u00f6del\u2019s informal description of\nHerbrand\u2019s suggestion was as\n follows:[11]\n\n\nIf \\(\\phi\\) denotes an unknown function, and \\(\\psi_1,\\ldots,\\psi_k\\)\nare known functions, and if the \\(\\psi\\)\u2019s and \\(\\phi\\) are\nsubstituted in one another in the most general fashions and certain\npairs of the resulting expressions are equated, then, if the resulting\nset of functional equations has one and only one solution for\n\\(\\phi\\), \\(\\phi\\) is a recursive function. (G\u00f6del 1934, 308)\n\n\nAs an illustration, consider the following set of equations: \n\n\\[\\begin{align} \\label{genrecex}\n\\phi(0) &= 0 \\\\ \\nonumber\n\\psi(x) &= \\phi(x) + 1\\\\ \\nonumber\n\\phi(x+1) &= \\psi(x) + 1\n\\end{align}\\]\n\n\nIn this case, the \u201cunknown\u201d function denoted by\n\\(\\phi(x)\\) is specified in terms of the auxiliary function\n\\(\\psi(x)\\) in such a way that \\(\\phi(x)\\) appears only once on the\nlefthand side of the equations (other than the base case).\nNonetheless, such a system of equations is unlike a primitive\nrecursive definition in that it does not specify a unique means for\ncomputing the values of \\(\\phi(n)\\) by \u201cdeconstructing\u201d\n\\(n\\) in the deterministic manner illustrated by calculations such as\n(\\ref{factcalc}).\n\nIn the general case there is indeed no guarantee that there will exist\na unique extensional function satisfying such a definition. But in the\ncase of this example it can be shown that \\(2 \\times x\\) is the unique\nfunction of type \\(\\mathbb{N} \\rightarrow \\mathbb{N}\\) satisfying\n\\(\\phi(x)\\) in the system of equations (\\ref{genrecex}). This may be\nillustrated by considering the following calculation of\n\\(\\phi(2)\\): \n\\[\\begin{align} \\label{genreccal}\n\\text{i.}\\quad   & \\phi(2) = \\psi(1) + 1 \\\\ \\nonumber\n\\text{ii.}\\quad  & \\psi(1) = \\phi(1) +1 \\\\ \\nonumber\n\\text{iii.}\\quad & \\phi(1) = \\psi(0) + 1 \\\\ \\nonumber\n\\text{iv.}\\quad  & \\psi(0) = \\phi(0) + 1 \\\\ \\nonumber\n\\text{v.}\\quad   & \\phi(0) = 0 \\\\ \\nonumber\n\\text{vi.}\\quad  & \\psi(0) = 0 + 1 \\\\ \\nonumber\n\\text{vii.}\\quad & \\phi(1) = (0 + 1) + 1 \\\\ \\nonumber\n\\text{viii.}\\quad& \\psi(1) = ((0 + 1) + 1) + 1 \\\\ \\nonumber\n\\text{ix.}\\quad  & \\phi(2) = (((0 + 1) + 1) + 1) + 1 \\ (= 4)\n\\end{align}\\]\n\n\nAs G\u00f6del notes, such a calculation may be understood as a\nderivation in quantifier-free first-order logic wherein the only rules\nwhich are allowed are the substitution of numerals for variables and\nthe replacement of a term on the righthand side of an equation by a\nnumeral for which the corresponding identity has already been\nderived.\n\nG\u00f6del introduced the term general recursive to describe\na function defined in this manner. Following the modernized\npresentation of Odifreddi (1989, ch. I.2) this class may be specified\non the basis of the following initial\n definitions:[12]\n\n\n\nDefinition 1.1\n\n\n\nThe class of numerals is the smallest set containing 0 and\nclosed under the successor function \\(x \\mapsto s(x)\\). We write\n\\(\\overline{n}\\) for the numeral \\(s(s(\\ldots s(0)))\\)\n\\(n\\)-times.\n\n\nThe class of terms is the smallest set containing the\nnumerals, variables \\(x_0,x_1, \\ldots\\) and closed under the\noperations \\(t \\mapsto s(t)\\) and \\(t_1,\\ldots,t_n \\mapsto\n\\psi^n_i(t_1,\\ldots,t_n)\\) where \\(t,t_1,\\ldots,t_n\\) are terms and\n\\(\\psi^n_i\\) is a primitive \\(n\\)-ary functional symbol.\n\n\nIf \\(t\\) and \\(u\\) are terms and \\(t\\) is of the form\n\\(\\psi^n_i(t_1,\\ldots,t_n)\\) where \\(t_1,\\ldots,t_n\\) do not contain\nany functional symbols other than \\(s\\), then \\(t = u\\) is an\nequation.\n\n\nA system of equations is a finite set of equations.\n\\(\\mathcal{E}(\\psi_1,\\ldots,\\psi_n,\\vec{x})\\) will be used to denote a\nsystem of equations containing primitive functional symbols\n\\(\\psi_1,\\ldots,\\psi_n\\) and variables among \\(\\vec{x} = x_1,\\ldots,\nx_k\\).\n\n\n\nHerbrand (1932) gave a semantic characterization of what it means for\na number theoretic function \\(f\\) to be defined by a system of\nequations \\(\\mathcal{E}(\\psi_1,\\ldots,\\psi_n,\\vec{x})\\) by requiring\nboth that there is a solution to the system and that \\(f\\) coincides\nwith the function determined as \\(\\psi_1\\) for every solution. He also\nsuggested that this fact should be proved intuitionistically, which\nmight in turn be thought to yield an effective procedure for computing\nthe values of\n \\(f\\).[13]\n He did not, however, specify a formal system in which such a proof\nshould be carried out. And thus G\u00f6del suggested (essentially) the\nfollowing syntactic replacement for Herbrand\u2019s definition:\n\n\nDefinition 1.2: A function \\(f:\\mathbb{N}^k\n\\rightarrow \\mathbb{N}\\) is general recursive if there is a\nsystem of equations \\(\\mathcal{E}(\\psi_1,\\ldots,\\psi_n,\\vec{x})\\) such\nthat if \\(\\psi^k_i\\) is the leftmost functional symbol in the last\nequation of \\(\\mathcal{E}\\) then for all \\(n_1,\\ldots,n_k, m \\in\n\\mathbb{N}\\) \n\\[f(n_1,\\ldots,n_k) = m\\]\n\n\nif and only if the equation \n\\[\\psi^k_i(\\overline{n}_1,\\ldots,\\overline{n}_k) = \\overline {m}\\]\n\n\nis derivable from the equations comprising \\(\\mathcal{E}\\) via the\nfollowing two rules:\n\nR1:\nSubstitution of a numeral for every occurrence of a particular\nvariable in an equation.\nR2:\nIf \\(\\psi^j_l(\\overline{n}_1,\\ldots,\\overline{n}_j) =\n\\overline{q}\\) has already been derived, then\n\\(\\psi^j_l(\\overline{n}_1,\\ldots,\\overline{n}_j)\\) may be replaced\nwith the numeral \\(\\overline{q}\\) on the righthand side of an\nequation. \n\n\nIn such a case we say that \\(\\mathcal{E}\\) defines \\(f\\) with\nrespect to \\(\\psi^k_i\\). \n\n\nIt can be verified that the system of equations (\\ref{genrecex}) and\nthe derivation (\\ref{genreccal}) exhibited above satisfy the foregoing\nrequirements, thus illustrating how it is possible to mechanically\ncalculate using a system of general recursive equations. However\ncertain systems\u2014e.g., \\(\\{\\phi(x) = 0, \\phi(x) =\ns(0)\\}\\)\u2014are inconsistent in the sense of not being satisfied by\nany function on the natural numbers, while others\u2014e.g.,\n\\(\\{\\phi(x) = \\phi(x)\\}\\)\u2014are not satisfied uniquely. One\nevident drawback of G\u00f6del\u2019s definition of general\nrecursiveness is thus that there is no apparent means of establishing\nwhether a given system of equations \\(\\mathcal{E}\\) determines a\nunique function (even if only partially defined). This is one of the\nreasons why G\u00f6del\u2019s characterization has been replaced by\nother extensionally equivalent definitions such as Kleene\u2019s\npartial recursive functions (see\n Section 2.2)\n in the subsequent development of computability theory.\n1.6 Church\u2019s Thesis\n\nBy formalizing his informal characterization of recursiveness via\n Definition 1.2,\n G\u00f6del succeeded in formulating a definition which subsumes the\nprimitive recursion scheme (\\ref{gprimrec}), the definition of the\nAckermann-P\u00e9ter function, as well as several other schemes\nconsidered by Hilbert. G\u00f6del\u2019s definition of general\nrecursiveness thus also defined a class \\(\\mathbf{GR}\\) of functions\nof type \\(\\mathbb{N}^k \\rightarrow \\mathbb{N}\\) which properly\nsubsumes the primitive recursive functions \\(\\mathbf{PR}\\). Moreover,\nwe now know that the class of functions representable in\n\\(\\mathsf{P}\\) (and in fact in far weaker arithmetical systems)\ncorresponds not to the primitive recursive functions, but rather to\nthe general recursive functions. Weakening the hypothesis that the set\nof (G\u00f6del numbers) of the axioms of a formal system to the\nrequirement that they be general recursive rather than primitive\nrecursive thus indeed provides a generalization of the First\nIncompleteness Theorem the manner in which G\u00f6del envisioned.\n\nThe definition of \\(\\mathbf{GR}\\) is also of historical importance\nbecause it was the first among several equivalent (and nearly\ncontemporaneous) definitions of what were originally called the\nrecursive functions but are now often referred to as the\ncomputable functions (see\n Section 2.2).\n These developments also contributed to one of the two final chapters\nin the study of recursive definability prior to the initiation of\ncomputability theory as an independent subject\u2014i.e., the\nisolation and eventual adoption of what is now known as\nChurch\u2019s Thesis.\n\nChurch\u2019s Thesis corresponds to the claim that the class of\nfunctions which are computable by a finite mechanical\nprocedure\u2014or, as it is traditionally said, are effectively\ncomputable\u2014coincides with the class of general recursive\nfunctions\u2014i.e.,\n\n(CT)\n\\(f:\\mathbb{N}^k \\rightarrow \\mathbb{N}\\) is\neffectively computable if and only if \\(f \\in \\mathbf{GR}\\).\n\n\nIt may appear that G\u00f6del already proposed a version of\nChurch\u2019s Thesis in 1934. However, he did not immediately endorse\nit upon its first explicit articulation by\n Church.[14]\n And since the surrounding history is complex it will be useful to\nrecord the following observations as a prelude to\n Sections 2 and 3.[15]\n (See also the entries on\n Church\u2019s Thesis\n and\n computational complexity theory.)\n\nG\u00f6del delivered the lectures (G\u00f6del 1934) while he was\nvisiting Princeton in the spring of 1934. Already at that time Church,\ntogether with his students Kleene and Rosser, had made substantial\nprogress in developing the formal system of function application and\nabstraction now known as the untyped lambda calculus. This\nsystem also provides a means of representing natural numbers as formal\nterms\u2014i.e., as so-called Church numerals. This leads to\na notion of a function being lambda-definable which is\nsimilar in form to (\\ref{repfun}). Church\u2019s definition thus also\ncharacterize a class \\(\\mathbf{L}\\) of lambda-definable functions\nwhich is similar in form to that of \\(\\mathbf{GR}\\). During this\nperiod, Kleene demonstrated that a wide range of number theoretic\nfunctions were included in \\(\\mathbf{L}\\), in part by showing how it\nis possible to implement primitive recursion in the lambda calculus.\nThis ultimately led Church to propose in early 1934 that the\nlambda-definable functions coincide with those possessing the property\nwhich he called \u201ceffective\n calculability\u201d.[16]\n\n\nA natural conjecture was thus that lambda-definability coincided\nextensionally with general recursiveness. Unlike (CT)\u2014which\nequates an informally characterized class of functions with one\npossessing a precise mathematical definition\u2014the statement\n\\(\\mathbf{GR} = \\mathbf{L}\\) potentially admits to formal\ndemonstration. Such a demonstration was given by Church (1936b; and in\ngreater detail by Kleene 1936b) providing the first of several\nextensional equivalence results which Kleene (1952, sec. 62) would\neventually cite as evidence of what he proposed to call\n\u201cChurch\u2019s Thesis\u201d.\n\nChurch\u2019s Thesis underlies contemporary computability theory in\nthe sense that it justifies the assumption that by studying\ncomputability relative to a single formalism (such as\n\\(\\mathbf{GR}\\) or \\(\\mathbf{L}\\)) we are thereby providing a\ngeneral account of which functions can and cannot be\neffectively computed in principle by an algorithm. In light of this,\nit will be useful to catalog some additional evidence for\nChurch\u2019s Thesis in the form of the equivalence of\n\\(\\mathbf{GR}\\) with several other computational formalisms presented\nin the Stanford Encyclopedia:\n\n\n\nLet \\(\\mathsf{T}\\) be a consistent, computably axiomatizable theory\nextending \\(\\mathsf{Q}\\) (i.e., Robinson arithmetic). Then the class\nof functions \\(\\mathbf{F}_{\\mathsf{T}}\\) which is representable in\n\\(\\mathsf{T}\\) in the sense of (\\ref{repfun}) above (with\n\\(\\mathsf{T}\\) replacing \\(\\mathsf{P}\\)) is such that\n\\(\\mathbf{F}_{\\mathsf{T}} = \\mathbf{GR}\\). (See\n representability in the entry on G\u00f6del\u2019s incompleteness theorems\n and Odifreddi (1989, ch. I.3).)\n\n\nThe class \\(\\mathbf{REC}\\) consisting of the total functions which are\nmembers of the class of partial recursive functions (formed\nby closing the class \\(\\mathbf{PR}\\) under the unbounded minimization\noperation) is such that \\(\\mathbf{REC} = \\mathbf{GR}\\). (See\n Section 2.2.1\n and Odifreddi (1989, ch. I.2).)\n\n\nThe class \\(\\mathbf{CL}\\) of functions representable in\n Combinatory Logic\n (a formal system related to the lambda calculus) is such that\n\\(\\mathbf{CL} = \\mathbf{GR}\\). (See\n computable functions and arithmetic in the entry on combinatory logic\n and Bimb\u00f3 (2012, ch. 5.3).)\n\n\nThe class \\(\\mathbf{T}\\) of functions computable by a\n Turing machine\n (under several variants of its definition) is such that \\(\\mathbf{T}\n= \\mathbf{GR}\\). (See\n alternative historical models of computability in the entry on Turing machines\n and Odifreddi (1989, ch. I.4).)\n\n\nThe class \\(\\mathbf{U}\\) of functions computable by Unlimited\nRegister Machines introduced by Shepherdson & Sturgis (1963)\nis such that \\(\\mathbf{U} = \\mathbf{GR}\\). (See Cutland (1980, ch.\n1\u20133) and Cooper (2004, ch. 2).)\n\n\nEquivalence results of these forms testify to the mathematical\nrobustness of the class \\(\\mathbf{GR}\\) and thereby also to that of\nthe informal notion of effective computability itself. As we have\nseen, G\u00f6del was originally led to the formulation of general\nrecursiveness by attempting to analyze the background notion of\nrecursive definition as a model of effective computation as inspired\nby the foundational developments of the late nineteenth and early\ntwentieth\n centuries.[17]\n Further discussion of how the work of Church, Turing, and Post can be\nseen as providing independently motivated analyses of computability\nwhich also support Church\u2019s Thesis can be found in Gandy (1980)\nand Sieg (1994, 1997, 2009).\n1.7 The Entscheidungsproblem and Undecidability\n\nIn addition to the goal of widening the scope of G\u00f6del\u2019s\nIncompleteness Theorems, another motivation for work on recursive\nfunctions during the 1930s was the study of so-called\nundecidable (or unsolvable) problems. The\noriginal example of such a problem was that of determining whether a\ngiven formula \\(\\varphi\\) of first-order logic is\nvalid\u2014i.e., true in all of its models. This was first\ndescribed as the Entscheidungsproblem (or decision\nproblem) for first-order logic by Hilbert & Ackermann in\ntheir textbook Grundz\u00fcge der theoretischen Logik\n (1928):[18]\n\n\n\nThe Entscheidungsproblem is solved if one knows a procedure,\nwhich permits the decision of the universality [i.e., validity] or\nsatisfiability of a given logical expression by finitely many\noperations. The solution of the problem of decision is of fundamental\nimportance to the theory of all domains whose propositions can be\nlogically described using finitely many axioms. (Hilbert &\nAckermann 1928,\n 73)[19]\n\n\n\nThis passage illustrates another sense in which the question of the\ndecidability of logical derivability is connected to the concerns\nwhich had initiated Hilbert\u2019s study of metamathematics. For note\nthat if \\(\\Gamma\\) is a finite set of axioms\n\\(\\{\\gamma_1,\\ldots,\\gamma_k\\}\\), then the question of whether\n\\(\\psi\\) is a logical consequence of \\(\\Gamma\\) is equivalent to\nwhether the sentence \\(\\varphi=_{\\textrm{df}} (\\gamma_1 \\wedge \\ldots\n\\wedge \\gamma_k) \\rightarrow \\psi\\) is logically valid. By\n G\u00f6del\u2019s Completeness Theorem (see the entry on G\u00f6del)\n for first-order logic, this is equivalent to the derivability of\n\\(\\varphi\\) from Hilbert & Ackermann\u2019s axiomatization of\nfirst-order logic. A positive answer to the\nEntscheidungsproblem could thus be interpreted as showing\nthat it is possible to mechanize the search for proofs in mathematics\nin the sense of allowing us to algorithmically determine if a formula\nexpressing an open question (e.g. the Riemann Hypothesis) is a logical\nconsequence of a suitably powerful finitely axiomatized theory (e.g.,\nG\u00f6del-Bernays set theory).\n\nIn addition to analyzing the notion of effective computability itself,\nthe mathematical goal of both Turing (1937) and Church (1936a,b) was\nto provide a mathematically precise negative answer to the\nEntscheidungsproblem. The answers which they provided can be\nunderstood as proceeding in three phases: \n\n Via the method of the arithmetization of syntax\ndescribed in\n Section 1.3\n Turing and Church showed how the Entscheidungsproblem could\nbe associated with a set of natural numbers \\(V\\). \n They then showed mathematically that \\(V\\) is not\ndecidable\u2014i.e., its characteristic function is not\ncomputable in the formal sense, respectively relative to the models\n\\(\\mathbf{T}\\) or \\(\\mathbf{L}\\). \n They finally offered further arguments to the effect that these\nmodels subsume all effective computable functions thus suggesting the\nfunction is not computable in the informal sense either.\n\n\nThe first of these steps can be undertaken by defining \n\n\\[\\begin{aligned}\nV & = \\{\\ulcorner \\varphi \\urcorner : \\varphi \\text{ is logically valid} \\} \\\\\n& =  \\{\\ulcorner \\varphi \\urcorner :  \\mathfrak{M} \\models \\varphi \\text{ for all } \\mathcal{L}_{\\varphi} \\text{-models } \\mathfrak{M}\\} \\end{aligned}\\]\n\n\nwhere \\(\\ulcorner \\cdot \\urcorner\\) is a G\u00f6del numbering of the\nlanguage of \\(\\varphi\\) as described in\n Section 1.3.\n The second step of Turing and Church\u2019s negative answer to the\nEntscheidungsproblem relied on their prior specification of\nsimilar decision problems for the models \\(\\mathbf{T}\\),\n\\(\\mathbf{L}\\), and \\(\\mathbf{GR}\\). Together with Kleene (1936a),\nthey showed the following:\n\n\nProposition 1.1: The characteristic functions of the\nfollowing sets are not computable with respect to the relevant\nmodel:\n\n\n\n\\(\\HP_T = \\{\\langle i,n \\rangle : \\text{the Turing machine $T_i$ halts\non input $n$}\\}\\)\n\n\n\\(\\HP_L = \\{\\ulcorner M \\urcorner : \\text{the untyped $\\lambda$-term\n$M$ has a normal form}\\}\\)\n\n\n\\(\\HP_{\\textit{GR}} = \\{\\ulcorner \\mathcal{E} \\urcorner :\\) the system\nof equations \\(\\mathcal{E}\\)-term determines a general recursive\nfunction\\(\\}\\)\n\n\n\nFor instance, Part i of\n Proposition 1.1\n shows that there is no Turing machine which outputs 1 if \\(T_i\\)\nhalts on \\(n\\) and 0 otherwise. This is thus a formulation of\nTuring\u2019s well-known\n unsolvability of the Halting Problem (see the entry on Turing machines).\n Part ii and iii would also now be described as expressing that the\nsets \\(\\HP_T,\\) \\(\\HP_L,\\) and \\(\\HP_{\\textit{GR}}\\) are all\nundecidable. By taking into account the equivalence results\nsummarized in\n Section 1.6,\n Proposition 1.1 thus shows that membership in these sets cannot be\ndecided relative to any of the models in question.\n\nOn this basis, Turing (for \\(\\mathbf{T}\\)) and Church (for\n\\(\\mathbf{L}\\) and \\(\\mathbf{GR}\\)) then proved the following:\n\n\nProposition 1.2: If \\(V\\) were decidable (with\nrespect to any of the models in question), then \\(\\HP_T, \\HP_L\\), and\n\\(\\HP_{GR}\\) would be as well.\n\n\nThe proofs which Turing and Church gave of these facts are\nconstructive in the sense that they show how to effectively transform\nan individual instance of one of the models into a first-order formula\nsuch that the formula is valid if and only if the instance possesses\nthe property in question\u2014e.g., given a Turing machine \\(T_i\\)\nand input \\(n \\in \\mathbb{N}\\), we construct a formula\n\\(\\varphi_{i,n}\\) such that the computation \\(T_i(n)\\) halts if and\nonly if \\(\\varphi_{i,n}\\) is valid. This method thus anticipates the\ndefinition of many-one reducibility given in\n Section 3.5.1\n below.\n\nIn conjunction with the other arguments which Church and Turing had\nalready offered in favor of Church\u2019s Thesis (see\n Section 1.6),\n Propositions\n 1.1\n and\n 1.2\n can thus be taken to show that the Entscheidungsproblem is\nindeed not decidable in the informal sense described by Hilbert &\nAckermann (1928)\u2014i.e., not decidable by a \u201cmechanical\nprocedure using finitely many operations\u201d. As we will see in\n Section 3,\n the desire to develop a general theory of such undecidability results\nand the relations which they bear to one another was an important\nmotivation for the further development of computability theory\nstarting in the 1940s.\n1.8 The Origins of Recursive Function Theory and Computability Theory\n\nThe developments just described form part of the prehistory of the\nsubfield of contemporary mathematical logic which was originally known\nas recursive function theory (or more simply as recursion\ntheory). This subject was initiated in earnest by Kleene, Turing,\nand Post starting in the late 1930s, directly on the basis of the\npapers containing the equivalence and undecidability results\nsummarized in\n Section 1.6\n and\n Section 1.7.\n Of particular importance are the papers (1936a, 1938, 1943,\n1955a,b,c) of Kleene. These respectively contain the definition of the\npartial recursive functions, the proof of their equivalence to\n\\(\\mathbf{GR}\\), the Normal Form Theorem, the Recursion Theorem, and\nthe definitions of the arithmetical and analytical hierarchies. Of\nequal importance are the papers (1937, 1939) of Turing (which\nrespectively contain the undecidability of the Halting Problem and the\ndefinition of Turing reducibility) and the paper (1944) of Post (which\nintroduced many-one and one-one reducibility and formulated what would\ncome to be known as Post\u2019s Problem).\n\nThese developments will be surveyed in\n Section 3.\n As we will see there, an important theme in the early stages of\ncomputability theory was the characterization of a notion of effective\ncomputability which is capable of supporting rigorous proofs grounded\nin intuitions about algorithmic calculability but which abstracts away\nfrom the details of the models mentioned in\n Section 1.6.\n To this end, G\u00f6del\u2019s original definition of the general\nrecursive equations was replaced in early textbook treatments (e.g.,\nShoenfield 1967, Rogers 1987) by Kleene\u2019s definition of the\npartial recursive functions in terms of the unbounded minimization\noperator introduced in\n Section 2.2.\n This characterization has in turn been replaced by machine-based\ncharacterizations such as those of Turing (1937) or Shepherdson &\nSturgis (1963) in later textbooks (e.g., Soare 1987, Cutland 1980)\nwhich are closer in form to informally described computer\nprograms.\n\nWhat is retained in these treatments is an understanding of\ncomputation as a means of operating in an effective manner on finite\ncombinatorial objects which can still be understood to fall under the\n\u201crecursive mode of thought\u201d as understood by early\ntheorists such as Skolem, Hilbert, G\u00f6del, and P\u00e9ter. But\nat the same time, many of the basic definitions and results in\nrecursive function theory are only indirectly related to recursive\ndefinability in the informal sense described in this section. In light\nof this, Soare (1996) proposed that recursive function theory should\nbe renamed computability theory and that we should\naccordingly refer to what were traditionally known as the\nrecursive functions as the computable functions.\n\nSuch a change in terminology has been largely adopted in contemporary\npractice and is reflected in recent textbooks such as Cooper (2004)\nand Soare (2016). Nonetheless, both sets of terminology are still\nwidely in use, particularly in philosophical and historical sources.\nReaders are thus advised to keep in mind the terminological discussion\nat the beginning of\n Section 3.\n2. Forms of Recursion\n\nNB: Readers looking for a mathematical overview of recursive functions\nare advised to start here. Discussion of the historical context for\nthe major definitions and results of this section can be found in\n Section 1.\n\nThis section presents definitions of the major classes of recursively\ndefined functions studied in computability theory. Of these the\nprimitive recursive functions \\(\\mathbf{PR}\\) and the\npartial recursive functions \\(\\mathbf{PartREC}\\) are the most\nfundamental. The former are based on a formalization of the process of\nrecursion described in the introduction to this entry and include\nvirtually all number theoretic functions studied in ordinary\nmathematics. The partial recursive functions are formed by closing the\nprimitive recursive functions under the operation of unbounded\nminimization\u2014i.e., that of searching for the smallest\nwitness to a decidable predicate. The class of  recursive\nfunctions  \\(\\mathbf{REC}\\)\u2014i.e., the partial recursive\nfunctions which are defined on all inputs\u2014has traditionally been\ntaken to correspond via Church\u2019s Thesis\n (Section 1.6)\n to those which can be effectively computed by an algorithm. \n\nThe following notional conventions will be employed in the remainder\nof this entry:\n\n\n\n\\(\\mathbb{N} =\\{0,1,2,\\ldots\\}\\) denotes the set of natural numbers,\n\\(\\mathbb{N}^k\\) denotes the cross product \\(\\mathbb{N} \\times \\ldots\n\\times \\mathbb{N}\\) \\(k\\)-times, and \\(\\vec{n}\\) denotes a vector of\nfixed numbers \\(n_0,\\ldots,n_{k-1}\\) (when the arity is clear from\ncontext).\n\n\nLowercase Roman letters \\(f,g,h,\\ldots\\) denote functions of type\n\\(\\mathbb{N}^k \\rightarrow \\mathbb{N}\\) (for some \\(k\\))\u2014i.e.,\nthe class of functions with domain \\(\\mathbb{N}^k\\) and range\n\\(\\mathbb{N}\\). For a fixed \\(j\\), \\(f:\\mathbb{N}^j \\rightarrow\n\\mathbb{N}\\) expresses that \\(f\\) is a \\(j\\)-ary function (or\nhas arity \\(j\\))\u2014i.e., \\(f\\) has domain\n\\(\\mathbb{N}^j\\) and range \\(\\mathbb{N}\\).\n\n\n\\(x_0,x_1,x_2, \\dots\\) are used as formal variables over\n\\(\\mathbb{N}\\) for the purpose of indicating the argument of\nfunctions. \\(x,y,z,\\ldots\\) will also be used informally for arbitrary\nvariables from this list. \\(\\vec{x}\\) will be used to abbreviate a\nvector of variables \\(x_0,\\ldots,x_{k-1}\\) (when the arity is clear\nfrom context).\n\n\nBoldface letters \\(\\mathbf{X}, \\mathbf{Y}, \\mathbf{Z},\\ldots\\) (or\nabbreviations like \\(\\mathbf{PR}\\)) will be used to denote classes of\nfunctions which are subsets of \\(\\bigcup_{k \\in \\mathbb{N}}(\n\\mathbb{N}^k \\rightarrow \\mathbb{N})\\).\n\n\nCalligraphic letters \\(\\mathcal{F},\\mathcal{G},\\mathcal{H},\\ldots\\)\n(or abbreviations like \\(\\mathcal{Comp}^j_k\\)) will be used to denote\nfunctionals on \\(\\mathbb{N}^k \\rightarrow\n\\mathbb{N}\\)\u2014i.e., operations which map one or more functions of\ntype \\(\\mathbb{N}^k \\rightarrow \\mathbb{N}\\) (possibly of different\narities) to other functions.\n\n\nUppercase letters \\(R,S,T, \\ldots\\) will be used to denote\nrelations\u2014i.e., subsets of \\(\\mathbb{N}^k\\)\u2014with\nthe range \\(A,B,C, \\ldots\\) reserved to denote unary\nrelations\u2014i.e., subsets of \\(\\mathbb{N}\\).\n\n\nThe characteristic function of a relation \\(R \\subseteq\n\\mathbb{N}^k\\) is denoted by\n\\(\\chi_R(x_0,\\ldots,x_{k-1})\\)\u2014i.e.,  \n\\[\\chi_R(x_0,\\ldots,x_{k-1}) = \\begin{cases} 1 & \\text{ if } R(x_0,\\ldots,x_{k-1}) \\\\  0 & \\text{ if } \\neg R(x_0,\\ldots,x_{k-1})\n\\end{cases}\\]\n \n\n2.1 The Primitive Recursive Functions (PR)\n2.1.1 Definitions\n\nA class \\(\\mathbf{X}\\) of recursively defined functions may be\nspecified by giving a class of initial functions \\(I_{\\mathbf{X}}\\)\nwhich is then closed under one or more functionals from a class\n\\(Op_{\\mathbf{X}}\\). It is in general possible to define a class in\nthis manner on an arbitrary set of initial functions. However, all of\nthe function classes considered in this entry will determine functions\nof type \\(\\mathbb{N}^k \\rightarrow \\mathbb{N}\\)\u2014i.e., they will\ntake \\(k\\)-tuples of natural numbers as inputs and (if defined) return\na single natural number as output.\n\nIn the case of the primitive recursive functions \\(\\mathbf{PR}\\), the\ninitial functions include the nullary zero function\n\\(\\mathbf{0}\\) which returns the value 0 for all inputs (and can thus\nbe treated as a constant symbol), \\(s(x)\\) denotes the unary\nsuccessor function \\(x \\mapsto x + 1\\), and \\(\\pi^k_i\\)\ndenotes the \\(k\\)-ary projection function on to the \\(i\\)th\nargument (where \\(0 \\leq i < k\\))\u2014i.e.,  \n\\[\\pi^k_i(x_0,\\ldots,x_i, \\ldots x_{k-1}) = x_i\\]\n\n\nThis class of functions will be denoted by \\(I_{\\mathbf{PR}} =\n\\{\\mathbf{0}, s, \\pi^k_i\\}\\). Note that since \\(\\pi^k_i\\) is a\ndistinct function for each \\(i,k \\in \\mathbb{N}\\), \\(I_{\\mathbf{PR}}\\)\nalready contains infinitely many functions.\n\nThe functionals of \\(\\mathbf{PR}\\) are those of composition\nand primitive recursion. Composition takes \\(j\\) functions\n\\(g_0, \\ldots, g_{j-1}\\) of arity \\(k\\) and a single function \\(f\\) of\narity \\(j\\) and returns their composition\u2014i.e., the\nfunction  \n\\[h(x_0,\\ldots,x_{k-1}) =  f(g_0(x_0,\\ldots,x_{k-1}),\\ldots,g_{j-1}(x_0,\\ldots,x_{k-1}))\\]\n\n\nof type \\(\\mathbb{N}^k \\rightarrow \\mathbb{N}\\). As an example,\nsuppose that \\(f\\) is the multiplication function\n\\(\\textit{mult}(x,y)\\), \\(g_0\\) is the constant 3 function (which we\nmay think of as implicitly taking a single argument), and \\(g_1(x)\\)\nis the successor function \\(s(x)\\). Then the composition of \\(f\\) with\n\\(g_0\\) and \\(g_1\\) is the unary function \\(h(x) = f(g_0(x),g_1(x)) =\nmult(3, s(x))\\) which we would conventionally denote by \\(3 \\times\n(x+1)\\).\n\nThe operation of composition may be understood as a class of\nfunctionals which for each \\(j,k \\in \\mathbb{N}\\) takes as inputs\n\\(j\\) functions \\(g_0, \\ldots, g_{j-1}\\) of arity \\(k\\) and a single\nfunction \\(f\\) of arity \\(j\\) and returns as output the \\(k\\)-ary\nfunction \\(h\\) which composes these functions in the manner just\nillustrated. This is described by the following scheme:\n\n\nDefinition 2.1: Suppose that \\(f:\\mathbb{N}^j\n\\rightarrow \\mathbb{N}\\) and \\(g_0, \\ldots, g_{j-1} : \\mathbb{N}^k\n\\rightarrow \\mathbb{N}\\). Then the term\n\\(\\mathcal{Comp}^j_k[f,g_0,\\ldots,g_{j-1}]\\) denotes the function\n\n\\[f(g_0(x_0,\\ldots,x_{k-1}),\\ldots,g_{j-1}(x_0,\\ldots,x_{k-1}))\\]\n\n\nof type \\(\\mathbb{N}^k \\rightarrow \\mathbb{N}.\\)\n\n\nPrimitive recursion is also a functional operation. In the simplest\ncase, it operates by taking a single unary function \\(g(x)\\) and a\nnatural number \\(n \\in \\mathbb{N}\\) and returns the unary function\ndefined by  \n\\[\\begin{align}\nh(0) & =  n \\label{prex1}\\\\ \\nonumber\nh(x+1) & =  g(h(x))\n\\end{align}\\]\n\n\nIn such a definition, the first clause (known as the base\ncase) determines the value of \\(h\\) at 0, while the second clause\ndetermines how its value at \\(x+1\\) depends on its value at \\(x\\). In\nthis case it is easy to see that the value of \\(x\\) determines how\nmany times the function \\(g\\) is iterated (i.e., applied to\nitself) in determining the value of \\(h\\). For instance, if \\(n = 3\\)\nand \\(g(x) = mult(x,x)\\), then \\(h(x) = 3^{x+1}\\)\u2014i.e., the\n\\(x+1\\)st iterate of the map \\(x \\mapsto 3 \\times x\\).\n\nThe full primitive recursion scheme generalizes (\\ref{prex1}) in two\nways. First, it allows the value of the function \\(h\\) at \\(x+1\\) to\ndepend not just on its own value at \\(x\\), but also on the value of\nthe variable \\(x\\) itself. This leads to the scheme  \n\\[\\begin{align} \\label{prex2}\nh(0) & =  n  \\\\ \\nonumber\nh(x+1) & =  g(x,h(x))\n\\end{align}\\]\n\n\nFor instance, the definition of the factorial function \\(\\fact(x)\\)\ndefined in the introduction to this entry can be obtained via\n(\\ref{prex2}) with \\(n = 1\\) and \\(g(x_0,x_0) =\ntimes(s(x_0),x_0)\\).\n\nA second possible generalization to (\\ref{prex1}) results from\nallowing the value of \\(h\\) to depend on a finite sequence of\nauxiliary variables known as parameters which may also be\narguments to the base case. In the case of a single parameter \\(x\\),\nthis leads to the scheme  \n\\[\\begin{align}  \\label{prex3}\nh(x,0) & =  f(x) \\\\ \\nonumber\nh(x,y+1) & =  g(x,h(x,y)) \n\\end{align}\\]\n\n\nThe addition function \\(\\textit{add}(x,y)\\) may, for instance, be\ndefined in this way by taking \\(f(x_0) = x_0\\) and \\(g(x_0,x_1) =\ns(x_1)\\). This definition can also be thought of as specifying that\nthe sum \\(x+y\\) is the value obtained by iterating the application of\nthe successor function \\(y\\) times starting from the initial value\n\\(x\\) in the manner of (\\ref{prex1}). Similarly,\n\\(\\textit{mult}(x,y)\\) may be defined by taking \\(f(x_0) = 0\\) and\n\\(g(x_0,x_1) = add(x_0,x_1)\\). This defines the product \\(x \\times y\\)\nas the value obtained by iterating the function which adds \\(x\\) to\nits argument \\(y\\) times starting from the initial value 0.\n\nSuch definitions may thus be understood to provide algorithms for\ncomputing the values of the functions so\n defined.[20]\n For observe that each natural number \\(n\\) is either equal to 0 or is\nof the form \\(m+1\\) for some \\(m \\in \\mathbb{N}\\). If we now introduce\nthe abbreviation \\(\\overline{n} = s(s(s \\ldots (s(\\mathbf{0}))))\\)\n\\(n\\)-times, the result of applying the successor function \\(s\\) to a\nnumber denoted by \\(\\overline{n}\\) thus yields the number denoted by\n\\(\\overline{n+1}\\). We may thus compute the value of \\(x + y\\) using\nthe prior recursive definition of addition as follows:\n\n\\[\\begin{align}\\label{prcalc2}\n\\textit{add}(\\overline{2},\\overline{3}) & = s(\\textit{add}(\\overline{2},\\overline{2})) \\\\\n& = s(s(add(\\overline{2},\\overline{1}))) \\nonumber\\\\\n& = s(s(s(\\textit{add}(\\overline{2},\\overline{0})))) \\nonumber\\\\\n& = s(s(s(\\overline{2}))) \\nonumber\\\\\n& = s(s(s(s(s(\\mathbf{0}))))) \\nonumber\\\\\n& = \\overline{5}\\nonumber\\\\\n\\end{align}\\]\n \n\nThe full definition of the primitive recursion operation combines both\ngeneralizations of (\\ref{prex1}) into a single scheme which takes as\narguments a \\(k\\)-ary function \\(f\\), a \\(k+2\\)-ary function \\(g\\),\nand returns a \\(k+1\\)-ary function \\(h\\) defined as follows \n\n\\[\\begin{align}  \\label{prscheme}\nh(x_0,\\ldots,x_{k-1},0) & = f(x_0,\\ldots,x_{k-1}) \\\\   \\nonumber\nh(x_0,\\ldots,x_{k-1},y+1) & = g(x_0,\\ldots,x_{k-1},y,h(x_0,\\ldots,x_{k-1},y))\n\\end{align}\\]\n\n\nHere the first \\(k\\) arguments \\(x_0,\\ldots,x_{k-1}\\) to \\(g\\) are the\nparameters, the \\(k+1\\)st argument \\(y\\) is the recursion\nvariable, and the \\(k+2\\)nd argument \\(h(x_0,\\ldots,x_{k-1},y)\\)\ngives the prior value of \\(h\\). An elementary set theoretic argument\nshows that for each \\(k \\in \\mathbb{N}\\), if \\(f\\) is \\(k\\)-ary and\n\\(g\\) is \\(k+2\\)-ary, then a there is a unique \\(k+1\\)-ary function\n\\(h\\) satisfying (\\ref{prscheme})\u2014see, e.g., (Moschovakis 1994,\nch. 5).\n\nIt will again be useful to introduce a formal scheme for referring to\nfunctions defined in this manner:\n\n\nDefinition 2.2: Suppose that \\(f:\\mathbb{N}^k\n\\rightarrow \\mathbb{N}\\) and \\(g: \\mathbb{N}^{k+2} \\rightarrow\n\\mathbb{N}\\). Then the term \\(\\mathcal{PrimRec}_k[f,g]\\) denotes the\nunique function of type \\(\\mathbb{N}^{k+1} \\rightarrow \\mathbb{N}\\)\nsatisfying (\\ref{prscheme}). \n\n\nWe may now formally define the class \\(\\mathbf{PR}\\) of primitive\nrecursive functions as follows:\n\n\nDefinition 2.3: The class of primitive recursive\nfunctions \\(\\mathbf{PR}\\) is the smallest class of functions\ncontaining the initial functions \\(I_{\\mathbf{PR}} = \\{\\mathbf{0}, s,\n\\pi^k_i\\}\\) and closed under the functionals \n\\[Op_{\\mathbf{PR}} = \\{\\mathcal{Comp}^i_j,\n \\mathcal{PrimRec}_k\\}.\\]\n\n\n\nWith the definition of \\(\\mathbf{PR}\\) in place, we may also define\nwhat it means for a relation \\(R \\subseteq \\mathbb{N}^k\\) to be\nprimitive recursive:\n\n\nDefinition 2.4: \\(R \\subseteq \\mathbb{N}^k\\) is a\nprimitive recursive relation just in case its characteristic\nfunction  \n\\[\\chi_R(x_0,\\ldots,x_{k-1}) = \\begin{cases} 1 & \\text{ if } R(x_0,\\ldots,x_{k-1}) \\\\  0 & \\text{ if } \\neg R(x_0,\\ldots,x_{k-1})\n\\end{cases}\n\\]\n\n\nis a primitive recursive function. \n\n\nDefinition 2.4\n thus conventionalizes the characterization of a primitive recursive\nrelation \\(R \\subseteq \\mathbb{N}^k\\) as one for which there exists an\nalgorithm similar to that illustrated above which returns the output 1\non input \\(\\vec{n}\\) if \\(R\\) holds of \\(\\vec{n}\\) and the output 0 if\n\\(R\\) does not hold of \\(\\vec{n}\\). As will become clear below, most\nsets and relations on the natural numbers which are considered in\neveryday mathematics\u2014e.g., the set PRIMES of prime\nnumbers or the relation \n\\[\\textit{DIV} = \\{\\langle n, m \\rangle : n\n\\textit{ divides } m \\textit{ without remainder}\\}\\]\n \u2014are primitive\nrecursive.\n\nThe foregoing definition specifies \\(\\mathbf{PR}\\) as the minimal\nclosure of \\(I_{\\mathbf{PR}}\\) under the functions in\n\\(Op_{\\mathbf{PR}}\\). In other words, \\(\\mathbf{PR}\\) may be\nequivalently defined as the subclass of \\(\\bigcup_{k \\in\n\\mathbb{N}}(\\mathbb{N}^k \\rightarrow \\mathbb{N})\\) satisfying the\nfollowing properties: \n\\[\\label{prmc}\\begin{equation}\n\\end{equation}\\]\n\n\n\n\n\ni.\n\\(I_{\\mathbf{PR}} \\subseteq \\mathbf{PR}\\)\nii.\n For all \\(j,k \\in \\mathbb{N}\\) and \\(f,g_0,\\ldots,g_{k-1} \\in\n\\mathbf{PR}\\), if \\(f\\) is \\(j\\)-ary and \\(g_i\\) is \\(k\\)-ary (for \\(1\n\\leq i \\leq n\\)) then \\(\\mathcal{Comp}^j_k[f,g_0,\\ldots,g_{j-1}] \\in\n\\mathbf{PR}\\).\niii.\n For all \\(k \\in \\mathbb{N}\\) and \\(f,g \\in \\mathbf{PR}\\), if\n\\(f\\) is \\(k\\)-ary and \\(g\\) is \\(k+2\\)-ary then\n\\(\\mathcal{PrimRec}_k[f,g] \\in \\mathbf{PR}\\).\niv.\n No functions are members of \\(\\mathbf{PR}\\) unless they can be\ndefined by i\u2013iii.\n \n\n\nAnother consequence of\n Definition 2.3\n is thus that each function \\(f \\in \\mathbf{PR}\\) possesses a\nspecification which shows how it may be defined from the initial\nfunctions \\(I_{\\mathbf{PR}}\\) in terms of a finite number of\napplications of composition and primitive recursion. This process may\nbe illustrated by further considering the definitions of the functions\n\\(\\textit{add}(x,y)\\) and \\(\\textit{mult}(x,y)\\) given above.\n\nNote first that although the familiar recursive definitions of\naddition (\\ref{defnadd}) and multiplication (\\ref{defnmult}) fit the\nformat of (\\ref{prex3}), they do not fit the format of\n(\\ref{prscheme}) which in this case requires that the argument \\(g\\)\nto the primitive recursion scheme be a \\(3\\)-ary function. It is,\nhowever, possible to provide a definition of \\(\\textit{add}(x,y)\\) in\nthe official form by taking \\(f(x_0) = \\pi^1_0(x_0)\\)\u2014i.e., the\nidentity function\u2014and \\(g(x_0,x_1,x_2) =\n\\mathcal{Comp}^1_3[s,\\pi^3_1]\\)\u2014i.e., the function which results\nfrom composing the successor function with the \\(3\\)-ary projection\nfunction on to its second argument. The expression\n\\(\\mathcal{PrimRec}_1[\\pi^1_0,\\mathcal{Comp}^1_3[s,\\pi^3_1]]\\) may\nthen be understood as a term which encodes the definition we have\nprovided for addition. Multiplication can then be defined via\n(\\ref{prscheme}) with \\(f = \\mathbf{0}\\) and \\(g(x_0,x_1,x_2) =\n\\mathcal{Comp}^2_3[add,\\pi^3_0,\\pi^3_2]\\). Thus \n\\[\\mathcal{PrimRec}_1[\\mathbf{0},\\mathcal{Comp}^2_3[add,\\pi^3_0,\\pi^3_2]]\\]\n \u2014or\nin explicit form \n\\[\\mathcal{PrimRec}_1[\\mathbf{0},\\mathcal{Comp}^2_3[\\mathcal{PrimRec}_1[\\pi^1_0,\\mathcal{Comp}^1_3[s,\\pi^3_1]],\\pi^3_0,\\pi^3_2]]\\]\n \u2014can be taken as a similar term\nencoding the definition of multiplication we have abbreviated by\n\\(\\textit{mult}(x,y)\\).\n\nThese examples illustrate that the simpler recursion schemes which are\nemployed in many informal recursive definitions may be assimilated to\n Definition 2.3\u2014e.g.,\n the function \\(h(x,y)\\) defined in (\\ref{prex3}) maybe obtained as\n\\(\\mathcal{PrimRec}_1[f,\\mathcal{Comp}^2_3[g,\\pi^3_1,\\pi^3_2]]\\).\nRepeated use of this and similar observations will be made (generally\nwithout comment) in the examples provided in\n Section 2.1.2.\n\nAnother consequence of the fact that every \\(f \\in\n\\mathbf{PR}\\) is defined by a term given in this manner by\n(\\ref{prmc}) is the following:\n\n\nProposition 2.1: The class of functions\n\\(\\mathbf{PR}\\) is countable.\n\n\nThis can be demonstrated by showing that it is possible to enumerate\n\\(\\mathbf{PR}\\) as \\(f_0,f_1,f_2,\\ldots\\) by introducing a G\u00f6del\nnumbering of terms formed from the expressions \\(\\mathbf{0},s,\\pi^k_i,\n\\mathcal{Comp}^j_k\\) and \\(\\mathcal{PrimRec}_k\\) in the manner\ndescribed in\n Section 1.3.\n Since there are uncountably many functions of type \\(\\mathbb{N}^k\n\\rightarrow \\mathbb{N}\\) for all \\(k > 0\\), this observation also\nprovides a non-constructive demonstration that there exist number\ntheoretic functions which are not primitive recursive.\n2.1.2 Examples\n\nAlmost all number theoretic functions and relations encountered in\nordinary mathematics can be shown to be primitive recursive. In order\nto illustrate the extent of this class, we will present here a\nstandard sequence of definitions which can be traced historically to\nSkolem (1923). This can be used to show that the sequence coding\n\\(\\langle \\ldots \\rangle\\) and decoding \\((\\cdot)_i\\) operations\ndefined below are primitive recursive. This is in turn required for\nG\u00f6del\u2019s arithmetization of syntax (see\n Section 1.3)\n as well as results like the Normal Form Theorem\n (2.3)\n which will be discussed below.\nConstant functions\n\nFor each \\(k \\in \\mathbb{N}\\) the constant \\(k\\)-function defined as\n\\(\\const_k(x) = k\\) is primitive recursive. This is because we can\ninductively define  \n\\[\\begin{aligned}\n \\const_0(x) & = \\mathbf{0}\\\\\n \\text{ and  }\\\\\n \\const_{k+1}(x) & = \\mathcal{Comp}^1_1[s,\\const_k] \\\\\n& =  s(s(s \\ldots (s(\\mathbf{0})))) \\\\\n& =_{\\textrm{df}} \\overline{k+1} \\end{aligned}\\]\n\nExponentiation, super-exponentiation, \u2026\n\nWe have already seen that the addition function \\(\\textit{add}(x,y)\\)\ncan be defined by primitive recursion in terms of repeated application\nof successor and that the multiplication function\n\\(\\mathit{mult}(x,y)\\) can be defined by primitive recursion in terms\nof repeated application of addition. We can continue this sequence by\nobserving that the exponentiation function \\(x^y\\) can be defined by\nprimitive recursion in terms of repeated multiplication as follows:\n \n\\[\\begin{align}  \\label{exp}\n\\textit{exp}(x,0) & =  \\overline{1}\\\\ \\nonumber\n\\textit{exp}(x+1,y) & =  \\textit{mult}(x,\\textit{exp}(x,y)) \n\\end{align}\\]\n\n\nThe super-exponentiation function \n\\[x \\uarrow y = \\underbrace{x^{x^{\\udots^x}}}_{y \\textrm{ times}}\\]\n\n\ncan be defined by primitive recursion in terms of repeated\nexponentiation as as follows:  \n\\[\\begin{align}  \\label{superexp}\n\\textit{supexp}(x,0) & =  \\overline{1}\\\\ \\nonumber\n\\textit{supexp}(x+1,y) & =  \\textit{exp}(x,\\textit{supexp}(x,y)) \n\\end{align}\\]\n\n\nThe sequence of functions \n\\[\\begin{aligned}\n\\alpha_0(x,y) & = x + y, \\\\\n\\alpha_1(x,y) & = x \\times y, \\\\\n\\alpha_2(x,y) & = x^y, \\\\\n\\alpha_3(x,y) & = x \\uarrow y, \\\\\n &\\vdots\\\\\n\\end{aligned}\\]\n\n\nwhose \\(i+1\\)st member is defined in terms of primitive recursion of\nthe \\(i\\)th member form a hierarchy of functions whose values grow\nincreasingly quickly in proportion to their inputs. While each\nfunction in this sequence is primitive recursive, we can also consider\nthe function \\(\\alpha(x,y)\\) defined as \\(\\alpha_x(y,y)\\)\u2014a\nversion of the so-called Ackermann-P\u00e9ter function\ndefined in\n Section 1.4\u2014whose\n values are not bounded by any fixed function \\(\\alpha_i\\). As it can\nbe shown that the values of \\(\\alpha(x,y)\\) are not bounded by any of\nthe functions \\(\\alpha_i(x,y)\\), this shows that \\(\\alpha(x,y)\\)\ncannot be defined by any finite number of applications of the scheme\n\\(\\mathcal{PrimRec}_1\\). This provides a constructive proof that there\nexist functions of type \\(\\mathbb{N}^2 \\rightarrow \\mathbb{N}\\) which\nare not primitive recursive.\nPredecessor and proper subtraction\n\nThe proper predecessor function is given by  \n\\[\\textit{pred}(y) = \\begin{cases}\n0 & \\text{ if } y = 0 \\\\\n y - 1 & \\text{otherwise} \n\\end{cases}\\]\n\n\nThis function is primitive recursive since it may be defined as \n\n\\[\\begin{align}  \\label{pred}\n\\textit{pred}(y) & = 0\\\\ \\nonumber\n\\textit{pred}(y+1) & = y\n\\end{align}\\]\n\n\nNote that the second clause of (\\ref{pred}) does not depend on the\nprior value of \\(\\textit{pred}(y)\\). But this definition can still be\nconformed to the scheme (\\ref{prscheme}) by taking \\(f(x_0) =\n\\mathbf{0}\\) and \\(g(x_0,x_1,x_2) = \\pi^3_1\\).\n\nThe proper subtraction function is given by  \n\\[x \\dotminus y = \\begin{cases}\nx - y & \\text{ if } y \\leq x \\\\\n 0 & \\text{otherwise} \n\\end{cases}\\]\n\n\nThis function is also primitive recursive since it may be defined as\n \n\\[\\begin{align} \\label{dotminus}\nx \\dotminus 0 & = x \\\\ \\nonumber\nx \\dotminus (y+1) & = \\textit{pred}(x \\dotminus y)\n\\end{align}\\]\n\nAbsolute difference, signum, minimum, and maximum\n\nThe absolute difference function is defined as  \n\\[|x - y| = \\begin{cases}\nx - y & \\text{ if } y \\leq x \\\\\n y - x & \\text{otherwise} \n\\end{cases}\\]\n\n\n\\(|x - y|\\) may be defined by composition as \\((x \\dotminus y) + (y\n\\dotminus x)\\) and is hence primitive recursive since \\(\\dotminus\\)\nis.\n\nThe signum function is defined as  \n\\[\\textit{sg}(x) = \\begin{cases}\n1 & \\text{ if } x \\neq 0 \\\\\n 0 & \\text{otherwise} \n\\end{cases}\\]\n\n\nThis function may be defined by composition as \\(\\textit{sg}(x) = 1\n\\dotminus (1 \\dotminus x)\\) and is hence primitive recursive as is the\ninverted signum function defined by\n\\(\\overline{\\textit{sg}}(x) = 1 \\dotminus \\textit{sg}(y)\\) which\nreturns 1 if \\(x = 0\\) and 1 otherwise.\n\nThe minimum and maximum functions may be similarly defined by\ncomposition from functions previously seen to be primitive recursive\nas follows:  \n\\[\\begin{aligned}\n\\min(x,y) & = \\overline{\\textit{sg}}(x \\dotminus y) \\times x + \\overline{\\textit{sg}}(y \\dotminus x) \\times y\\\\\n\\max(x,y) & = \\textit{sg}(x \\dotminus y) \\times x + \\textit{sg}(y \\dotminus x) \\times y\\end{aligned}\\]\n\nOrder and identity\n\nThe characteristic functions of the less than relation\n(\\(<\\)) and equality relation (\\(=\\)) on the natural\nnumbers are definable as follows:  \n\\[\\begin{aligned}\n\\chi_<(x,y) & = \\textit{sg}(y \\dotminus x) \\\\ \\nonumber\n\\chi_=(x,y) & =  1 \\dotminus (\\textit{sg}(x \\dotminus y) + \\textit{sg}(y \\dotminus x))\\end{aligned}\\]\n\n\nThese relations are hence primitive recursive.\n\nAs the less than or equal to relation (\\(\\leq\\)) is logically\nequivalent to \\(x < y \\vee x = y\\) it will follow from the next set\nof observations that this relation is also primitive recursive. The is\nadditionally true of \\(x > y\\), \\(x \\geq y\\) and \\(x \\neq y\\).\nClosure under propositional operations\n\nThe set of primitive recursive relations is closed under boolean\noperations. In other words, if \\(P(\\vec{x})\\) and \\(Q(\\vec{x})\\)\nare primitive recursive, then so are \\(\\neg P(\\vec{x})\\), \\(P(\\vec{x})\n\\wedge Q(\\vec{x})\\), \\(P(\\vec{x}) \\vee Q(\\vec{x})\\), \\(P(\\vec{x})\n\\rightarrow Q(\\vec{x}),\\) and \\(P(\\vec{x}) \\leftrightarrow\nQ(\\vec{x})\\).\n\nGiven the interdefinability of the classical connectives, this follows\nupon noting the following:  \n\\[\\begin{align*}\n\\chi_{\\neg P}(\\vec{x}) & = 1 \\dotminus \\chi_{P}(\\vec{x}) \\\\ \n\\chi_{P \\wedge Q}(\\vec{x}) & = \\chi_{P}(\\vec{x}) \\times \\chi_{Q}(\\vec{x})\n\\end{align*}\\]\n\nBounded sums and products\n\nSuppose that \\(f(\\vec{x},z)\\) is primitive recursive. Then the\nbounded sum \\(g(\\vec{x},y) = \\Sigma_{i=0}^y f(\\vec{x},i)\\)\nand the bounded product \\(h(\\vec{x},y) = \\Pi_{i=0}^y\nf(\\vec{x},i)\\) are both primitive recursive as they may be\nrespectively defined as follows:  \n\\[\\begin{aligned}\ng(\\vec{x},0) & =  f(\\vec{x},0) \\\\ \\nonumber\ng(\\vec{x},y+1) & = g(\\vec{x},y) + f(\\vec{x},y+1) \\\\  \\nonumber\nh(\\vec{x},0) & =  f(\\vec{x},0) \\\\ \\nonumber \nh(\\vec{x},y+1) & = g(\\vec{x},y) \\times f(\\vec{x},y+1) \\end{aligned}\\]\n\nClosure under bounded quantification\n\nThe set of primitive recursive relations is also closed under\nbounded quantification\u2014i.e., if \\(R(\\vec{x},z)\\) is a\nprimitive recursive relation, then so are the relations \\(\\forall z\n\\leq y R(\\vec{x},z)\\) and \\(\\exists z \\leq y R(\\vec{x},z)\\). These may\nbe respectively defined as follows as follows:  \n\\[\\begin{aligned}\nu_R(\\vec{x},y) & =_{\\textrm{df}} \\chi_{\\forall z \\leq y R(\\vec{x},z)}(\\vec{x}) = \\Pi_{i=0}^y \\chi_R(\\vec{x},i) \\\\ \\nonumber\ne_R(\\vec{x},y)  & =_{\\textrm{df}} \\chi_{\\exists z \\leq R(\\vec{x},z)}(\\vec{x}) = sg\\left(\\Sigma_{i=0}^y \\chi_R(\\vec{x},i)\\right)\\end{aligned}\\]\n\nClosure under bounded minimization\n\nThe set of primitive recursive relations is also closed under\nbounded minimization. This is to say that if \\(R(\\vec{x},z)\\)\nis a primitive recursive relation, then so is the function\n\\(m_R(\\vec{x},y)\\) which returns the least \\(z\\) less than or equal to\n\\(y\\) such that \\(R(\\vec{x},z)\\) holds if such a \\(z\\) exists and\n\\(y+1\\) otherwise\u2014i.e.,  \n\\[\\begin{align} \\label{boundedmin}\n m_R(\\vec{x},y) = \n\\begin{cases}\n\\text{the least $z \\leq y$ such that $R(\\vec{x},z)$} & \\text{ if such a $z$ exists} \\\\\ny + 1 & \\text{ otherwise}\n\\end{cases}\\end{align}\\]\n\n\nTo see this, observe that if \\(R(\\vec{x},z)\\) is primitive recursive,\nthen so is \\(\\forall z \\leq y \\neg R(\\vec{x},z)\\). It is then not\ndifficult to verify that  \n\\[m_R(\\vec{x},y) = \\Sigma_{i=0}^y \\chi_{\\forall z \\leq y \\neg R(\\vec{x},z)}(\\vec{x},i).\\]\n\nDivisibility and primality\n\nA natural number \\(y\\) is said to be divisible by \\(x\\) just\nin case there exists a \\(z\\) such that \\(x \\times z = y\\)\u2014i.e.,\n\\(x\\) divides \\(y\\) without remainder. In this case we write \\(x\n\\divides y\\). Note that if \\(x \\divides y\\) holds, then this must be\nwitnessed by a divisor \\(z \\leq y\\) such that \\(x \\times z = y\\). We\nmay thus define \\(x \\divides y\\) in the following manner which shows\nthat it is primitive recursive:  \n\\[x \\divides y \\Longleftrightarrow \\exists z \\leq y(x \\times z = y)\\]\n\n\nWe may also define the non-divisibility relations \\(x\n\\notdivides y\\) as \\(\\neg(x \\divides y)\\) which shows that it too is\nprimitive recursive.\n\nNext recall that a natural number \\(x\\) is prime just in case\nit is greater than 1 and is divisible by only 1 and itself. We may\nthus define the relation \\(\\textit{Prime}(x)\\) in the following manner\nwhich shows that it is primitive recursive:  \n\\[\\begin{aligned}\n\\textit{Prime}(x) \\Longleftrightarrow \\overline{1} < x \\wedge \\forall z \\leq x(z \\divides x \\rightarrow (z = \\overline{1} \\vee z = x))\\end{aligned}\\]\n\n\nThe primes form a familiar infinite sequence \\(p_0 = 2,\\) \\(p_1 = 3,\\)\n\\(p_2 = 5,\\) \\(p_3 = 7,\\) \\(p_4 = 11,\\)\u2026. Let \\(p(x) =\np_x\\)\u2014i.e., the function which returns the \\(x\\)th prime number.\n\\(p(x)\\) can be defined by primitive recursion relative to the\nfunction \\(\\nextPrime(x)\\) which returns the least \\(y > x\\) such\nthat \\(y\\) is prime as follows:  \n\\[\\begin{aligned}\np(0) & = \\overline{2} \\\\ \\nonumber\np(x+1) & = \\nextPrime(p(x))\\end{aligned}\\]\n\n\nRecall that Euclid\u2019s Theorem states that there is always a prime\nnumber between \\(x\\) and \\(x! + 1\\) and also that \\(x! = \\fact(x)\\) is\nprimitive recursive. It thus follows that \\(\\nextPrime(x)\\) can be\ndefined via bounded minimization as follows:  \n\\[\\begin{aligned}\n\\nextPrime(x) = m_{x < z \\ \\wedge \\ \\textit{Prime}(z)}(x,\\fact(x)+1)\\end{aligned}\\]\n\n\nIt thus follows that \\(p(x)\\) is primitive recursive.\nSequences and coding\n\nThe foregoing sequence of definitions provides some evidence for the\nrobustness of the class of primitive recursive relations and\nfunctions. Further evidence is provided by the fact that it is\npossible to develop the machinery for coding and decoding finite\nsequences of natural numbers and for performing various combinatorial\noperations on sequences\u2014e.g., adjunction of an element,\nconcatenation, extracting a subsequence, substituting one element for\nanother, etc. The primitive recursiveness of these operations\nunderpins G\u00f6del\u2019s arithmetization of syntax as described in\n Section 1.3.\n We present here only the basic definitions required to demonstrate\nthe primitive recursiveness of the \\(k\\)-tupling and projection\nfunctions which are required for results in computability theory such\nas the Normal Form Theorem\n (2.3)\n discussed below.\n\nGiven a finite sequence of natural numbers \\(n_0,n_1,\\ldots,n_{k-1}\\)\nwe define its code to be the number  \n\\[\\begin{align}\n \\label{primecode}\np_0^{n_0 + 1} \\times p_1^{n_1 + 1} \\times p_2^{n_2 + 1} \\times \\ldots \\times p_{k-1}^{n_{k-1}+1}\n\\end{align}\\]\n\n\nwhere \\(p_i\\) is the \\(i\\)th prime number as defined above. In other\nwords, the code of \\(n_0,n_1,\\ldots,n_{k-1}\\) is the natural number\nresulting from taking the product of the numbers \\(p_i^{n_i + 1}\\) for\n\\(0 \\leq i \\leq k-1\\). This will be denote by \\(\\langle\nn_0,n_1,\\ldots,n_{k-1} \\rangle\\)\u2014e.g.,  \n\\[\\begin{aligned}\n\\langle 3,1,4,1,5 \\rangle & = 2^{4} \\times 3^{2} \\times 5^{5} \\times 7^{2} \\times 11^{6} \\\\\n& = 39062920050000.\\\\\n\\end{aligned}\n\\]\n\n\n(Note that 1 is added to each exponent so that, e.g., 3, 1, 4, 1, 5\nhas a distinct code from that of 3, 1, 4, 1, 5, 0, etc.\u2014i.e., so\nthat the coding operation is injective.)\n\nThe operation which takes a sequence of arbitrary length to its code\ndoes not have a fixed arity and hence is not given by a single\nprimitive recursive function. But it is not hard to see that if we\nrestrict attention to sequences of given length \\(k\\), then \\(\\langle\nn_0,n_1,\\ldots,n_{k-1} \\rangle : \\mathbb{N}^k \\rightarrow \\mathbb{N}\\)\nis primitive recursive as it is simply the bounded product given by\n(\\ref{primecode}). Consider next the function \\(\\textit{element}(s,i)\n= n_i\\) where \\(s = \\langle n_0,n_1,\\ldots,n_{k-1} \\rangle\\) and \\(0\n\\leq i \\leq k-1\\) and which returns 0 when \\(i\\) is not in this range\nor \\(s = 0\\) or 1 (and thus not a code of a sequence). In order to see\nthat \\(\\textit{element}(s,i)\\) is also primitive recursive, first\nobserve that it is possible to recover \\(\\textit{len}(s)\\)\u2014i.e.,\nthe length of the sequence coded by \\(s\\)\u2014by searching\nfor the least \\(i < s\\) such that \\(p_i \\divides s\\) and \\(p_{i+1}\n\\notdivides s\\). Since \\(s\\) also bounds all the primes \\(p_i\\) which\ndivide it we may define  \n\\[\\begin{aligned}\nlen(s) = \\begin{cases} 0 & \\text{ if $s = 0$ or $s = 1$} \\\\\n1 + m_{p_z \\divides s \\wedge p_{z+1} \\notdivides s}(s,s) & \\text{ otherwise} \\end{cases}\\end{aligned}\\]\n\n\nIt is straightforward to see that a function defined by cases with\nprimitive recursive conditions is primitive recursive. So\n\\(\\textit{len}(s)\\) is primitive recursive as well.\n\nFinally observe that \\(\\textit{element}(s,i)\\) is equal to the\nsmallest exponent \\(n\\) such that \\(p_i^{n+1} \\divides s\\) but\n\\(p_i^{n+2} \\notdivides s\\) and that such an exponent is also bounded\nby \\(s\\). We may thus provide a primitive recursive definition of\n\\(\\textit{element}(s,i)\\) as follows:  \n\\[\\begin{aligned}\n\\textit{element}(s,i) = \\begin{cases} 0 & \\text{ if  $len(s) \\leq i$ or $s = 0$ or $s = 1$}\\\\\nm_{p_i^{z+1} \\divides s \\wedge p_i^{z+2} \\notdivides s}(s,s) \\dotminus 1 & \\text{ otherwise} \\end{cases}\\end{aligned}\\]\n\n\nThe conventional abbreviation \\((s)_i = \\textit{element}(s,i)\\) will\nbe employed for this function below.\n2.1.3 Additional closure properties of the primitive recursive functions\n\nThe primitive recursive functions and relations encompass a broad\nclass including virtually all those encountered in ordinary\nmathematics outside of logic or computability theory. This is\nillustrated in part by the fact that \\(\\mathbf{PR}\\) contains\nfunctions such as \\(supexp(x,y)\\) which grow far faster than those\nwhose values we can feasibly compute in practice in the sense studied\nin\n computational complexity theory.\n But the robustness of the class \\(\\mathbf{PR}\\) is also attested to\nby the fact that its definition is invariant with respect to a variety\nof modifications\u2014e.g., with respect to the classes of initial\nfunctions \\(I_{\\mathbf{PR}}\\) and functionals \\(Op_{\\mathbf{PR}}\\) on\nwhich its definition is based.\n\nAs an initial illustration, consider the following scheme of so-called\npure iteration:  \n\\[\\begin{align} \\label{pureiter}\nh(0,y) & =  y \\\\ \\nonumber\nh(x+1,y) & = g(h(x,y))\n\\end{align}\\]\n\n\nIt is easy to see that the function \\(h\\) defined by (\\ref{pureiter})\nfrom \\(g\\) in this manner is the \\(x^{\\mathrm{th}}\\)\u2013iterate of\n\\(g\\)\u2014 i.e., \\(g^{x}(y)=_{\\mathrm{df}} g(g(\\ldots g(y)))\\)\n\\(x\\)\u2013times with the convention that \\(g^0(y) = y\\). We will\ndenote this functional by \\(\\mathcal{Iter}[g,x]\\). The scheme\n(\\ref{pureiter}) thus generalizes (\\ref{prex1}) by making the value of\nbase case an argument to \\(h\\). But it is an apparent restriction of\n(\\ref{prscheme}) in the sense that \\(h\\) cannot depend on either the\nrecursion variable or additional parameters.\n\nSuppose we now consider an alternative class of initial functions\n\\(In_{\\mathbf{IT}}\\) containing \\(s,\\pi^k_i\\), the binary coding\nfunction \\(\\langle x,y \\rangle\\), and the decoding functions \\((x)_0\\)\nand \\((x)_1\\) defined at the end of\n Section 2.1.2.\n (Note that these operate analogously to the first and second\nproduction functions \\(\\pi^2_0\\) and \\(\\pi^2_1\\) operating on\ncodes of ordered pairs.) Now define \\(\\mathbf{IT}\\) to be the\nsmallest class of functions containing \\(In_{\\mathbf{IT}}\\) and closed\nunder the functionals \\(Op_{\\mathbf{IT}} =\n\\{\\mathcal{Comp}^i_j,\\mathcal{Iter}\\}\\).\n\n\nTheorem 2.1 (Robinson 1947): The class\n\\(\\mathbf{IT}\\) is equal to the class \\(\\mathbf{PR}\\) of primitive\nrecursive functions.\n\n\nThis illustrates that if we slightly enlarge the class of initial\nfunctions, it is still possible to obtain the entire class\n\\(\\mathbf{PR}\\) via a scheme of functional iteration which at first\nappears less general than primitive recursion. See Odifreddi (1989,\nch. I.5) for an account of further improvements which can be obtained\nin this direction.\n\nOther results show that the class \\(\\mathbf{PR}\\) also remains stable\nif primitive recursion is replaced with other schemes which may\ninitially appear more general. The most familiar of these is the\nscheme of course of values recursion which is traditionally\nillustrated using the so-called Fibonacci function\n\\(\\fib(x)\\) which was briefly discussed at the beginning of\n Section 1.\n This may be defined as follows:  \n\\[\\begin{align} \\label{fibdefn}\nfib(0) & = 0\\\\ \\nonumber\nfib(1) & = 1\\\\ \\nonumber\nfib(y+1) & = fib(y) + fib(y-1)\n\\end{align}\\]\n\n\nThis definition can readily be used to calculate the values of\n\\(\\fib(x)\\) in a recursive manner\u2014e.g.,  \n\\[\\begin{aligned} \n\\fib(4) &= \\fib(3) + \\fib(2) \\\\ \n  &= (\\fib(2) + \\fib(1)) + (\\fib(1)+\\fib(0))  \\\\ \n  &= ((\\fib(1) + \\fib(0)) + 1) + (1 + 1) \\\\ \n  &= ((1 + 1) + 1) + (1 + 1) \\\\ \n& = 5\n\\end{aligned}\\]\n\n\nThis gives rises to the familiar sequence 0, 1, 1, 2, 5, 8, 13, 21,\n34, 55, 89, 144,\u2026 wherein \\(F_0 =0,\\) \\(F_1 = 1,\\) and\n\\(F_{i+2} = F_{i+1} + F_i.\\) Note, however, the definition\n(\\ref{fibdefn}) cannot be directly assimilated to the primitive\nrecursion scheme (\\ref{prscheme}) since the third clause defines the\nvalue of \\(\\fib(y+1)\\) in terms of both \\(\\fib(y)\\) and\n\\(\\fib(y-1)\\). It is, however, still possible to show that \\(\\fib \\in\n\\mathbf{PR}\\). One means of doing this is to again make use of the\nbinary coding and projection functions to first define an auxiliary\nfunction \\(g(0) = \\langle 0,1 \\rangle\\) and \n\\[g(y+1) = \\langle (g(y))_1,(g(y))_0 + (g(y))_1 \\rangle\\]\n\n\nwhich enumerates the pairs \\(\\langle F_0,F_1 \\rangle\\), \\(\\langle F_1,\nF_2 \\rangle, \\ldots\\) It is then easy to see that \\(\\fib(y) =\n(g(y))_0\\).\n\n(\\ref{fibdefn}) is thus an instance where the value of the function\n\\(h\\) at \\(y\\) depends on the values \\(h(y-1)\\) and \\(h(y-2)\\) of its\ngraph (for \\(y \\geq 2\\)). It is, of course, also possible to consider\ncases where \\(h(y)\\) depends on an arbitrary number of its preceding\nvalues \\(h(0), \\ldots, h(y-1)\\). To this end, suppose we are given\n\\(h(\\vec{x},y)\\) and then define  \n\\[\\begin{align*}\n\\widetilde{h}(\\vec{x},y) &= \\Pi_{i = 0}^y p_i^{h(\\vec{x},i)+1} \\\\\n& = \\langle h(\\vec{x},0), \\ldots, h(\\vec{x},y) \\rangle.\\\\\n\\end{align*}\n\\]\n\n\nWe then say that \\(h(\\vec{x},y)\\) is defined by course of values\nrecursion from \\(f(\\vec{x})\\) and \\(g(\\vec{x},y,z)\\) if \n\n\\[\\begin{aligned}\nh(\\vec{x},0) & = f(\\vec{x}) \\\\ \\nonumber\nh(\\vec{x},y + 1) & = g(\\vec{x},y,\\widetilde{h}(\\vec{x},y))\\end{aligned}\\]\n\n\nSuppose that we now let \\(\\mathcal{CV}_k[f,g]\\) denote the\ncorresponding functional operation and let \\(\\mathbf{CV}\\) be the\nsmallest class of functions containing \\(In_{\\mathbf{PR}}\\) and closed\nunder \\(\\mathcal{Comp}^j_k\\) and \\(\\mathcal{CV}_k\\). Then since it is\neasy to see that \\(\\widetilde{h}(\\vec{x},y)\\) is primitive recursive\nif \\(h(\\vec{x},y)\\) is, we also have the following:\n\n\nTheorem 2.2 (P\u00e9ter 1935): The class\n\\(\\mathbf{CV}\\) is equal to the class \\(\\mathbf{PR}\\) of primitive\nrecursive functions.\n\n\nSince course of values recursion is occasionally used in mathematical\npractice, it is significant that it does not lead outside the class of\nprimitive recursive functions. There are, however, a number of other\npossible ways in which the scheme (\\ref{prscheme}) might also be\ngeneralized, including what are known as double recursion and\nnested recursion. The definition of the\nAckermann-P\u00e9ter function \\(\\pi(x,y)\\) in\n Section 1.4\n exhibits the former since its value at \\(x,y\\) depends on its value\nat both \\(x-1\\) and \\(y-1\\) and also the latter since the\noccurrence of the defined function \\(\\pi(x,y)\\) is\n\u201cnested\u201d within itself (rather than an auxiliary function)\non the righthand side of the third clause. Although such definitions\narise less often in practice, they are important historically due to\ntheir occurrence in Hilbert\u2019s original discussion of recursion\n(see\n Section 1.3).\n Such schemes were considered systematically by P\u00e9ter (1967)\nwho showed that unnested double recursion on its own also does not\nlead outside the class of primitive recursive functions.\n2.2 The Partial Recursive Functions (PartREC) and the Recursive Functions (REC)\n\nWe have now seen two ways of showing that there exist number theoretic\nfunctions which are not primitive recursive\u2014i.e., by observing\nthat while there are only countably many primitive recursive functions\nthere are uncountably many functions of type \\(\\mathbb{N}^k\n\\rightarrow \\mathbb{N}\\) (\\(k > 0\\)) and also by constructing a\nfunction such as \\(\\alpha(x,y) = \\alpha_x(y,y)\\) which grows faster\nthan any primitive recursive function. A third proof\u2014originally\ndue to Hilbert & Bernays (1934, ch. 7)\u2014is based on the\nobservation that it is possible to enumerate the class \\(\\mathbf{PR}\\)\nas \\(g_0(x),g_1(x),g_2(x), \\ldots\\)\u2014e.g., by G\u00f6del\nnumbering the sorts of definitions considered at the end of\n Section 2.1.1.\n If we then consider the modified diagonal function  \n\\[\\begin{aligned}\n\\delta(x) = g_x(x) + 1\\end{aligned}\\]\n\n\nit is easy to see that this function also cannot be primitive\nrecursive. For if \\(\\delta(x)\\) coincided with some function\n\\(g_j(x)\\) in the enumeration, then we would have \\(g_j(j) = \\delta(j)\n= g_j(j) + 1\\), a contradiction. Note that this also shows that\nrelative to such an enumeration the universal function\n\\(u_1(i,x) = g_i(\\vec{x})\\) for unary primitive recursive functions\ncannot itself be primitive recursive as we could otherwise define\n\\(\\delta(x)\\) as \\(u_1(x,x) + 1\\). Hilbert & Bernays (1939, ch. 5)\nwould later discuss this observation in regard to what has become\nknown as their denotational paradox\u2014see, e.g., (Priest\n1997).\n\nOn the other hand, there are intuitively effective procedures for\ncomputing each of these functions. For instance, in the case of\n\\(\\delta(x)\\) we can proceed as follows: \n\nuse \\(x\\) to construct the definition of \\(g_x(y)\\); \n compute the value of \\(g_x(x)\\) by performing the corresponding\nprimitive recursive calculation; \n add 1 and halt. \n\n\nThis illustrates that although \\(\\alpha(x,y)\\), \\(\\delta(x)\\), and\n\\(u_1(i,x)\\) are not primitive recursive, they are still\neffectively computable in the sense discussed in\n Section 1.6.\n There is thus a natural motivation for seeking to expand the\ndefinition of the class \\(\\mathbf{PR}\\) so as to encompass such\nintuitively computable functions.\n\nOne means by which this can be accomplished builds on the observation\nthat the bounded minimization operation \\(m_R(\\vec{x},y)\\) admits to a\nstraightforward algorithmic characterization\u2014i.e., to compute\nthe value of \\(m_R(\\vec{x},y)\\) successively check \\(R(\\vec{x},0),\\)\n\\(R(\\vec{x},1),\\) \u2026, \\(R(\\vec{x},z),\\)\u2026 giving output\n\\(z\\) and halting as soon as \\(R(\\vec{x},z)\\) holds and \\(y+1\\) if no\npositive instance is found before \\(z = y\\). This can be generalized\nto the so-called unbounded search operation. In particular,\ngiven a relation \\(R(\\vec{x},y)\\) we can define the operation\n\\(\\mu_R(\\vec{x},z)\\) which returns the least \\(z\\) such that\n\\(R(\\vec{x},z)\\) if such a \\(z\\) exists and is undefined otherwise.\nNote that if \\(R(\\vec{x},y)\\) is primitive recursive, then it is still\npossible to effectively search for the value of \\(\\mu_R(\\vec{x},y)\\)\nby successively checking \\(R(\\vec{x},0),\\) \\(R(\\vec{x},1),\\)\u2026.\nBut since no upper bound is specified in advance, we are not\nguaranteed that this procedure will always terminate. In particular,\nif there is no \\(z \\in \\mathbb{N}\\) such that \\(R(\\vec{x},z)\\) holds,\nthen the procedure will continue indefinitely. In this case, we\nstipulate that \\(\\mu_R(\\vec{x},y)\\) is undefined, from which\nit follows that \\(\\mu_R(\\vec{x},y)\\) will correspond to what is known\nas a partial function\u2014a notion which is made precise by\nthe following sequence of definitions.\n2.2.1 Definitions\n\nThe class of so-called partial recursive functions is\nobtained from our prior definition of \\(\\mathbf{PR}\\) by closing under\nan operation similar to \\(\\mu_R(\\vec{x},z)\\) which is applied to\nfunctions rather than relations. In order to define this class, we\nfirst introduce the following conventions regarding partial\nfunctions which extends those given at the beginning of\n Section 2:\n\n\n\nA function \\(f:\\mathbb{N}^k \\rightarrow \\mathbb{N}\\) is called\ntotal if \\(f(\\vec{n})\\) is defined for all \\(\\vec{n} \\in\n\\mathbb{N}^k\\). Otherwise \\(f(\\vec{x})\\) is called\npartial.\n\n\nWe write \\(f(\\vec{n})\\darrow\\) to express that \\(f(\\vec{x})\\) is\ndefined at \\(\\vec{n}\\) and additionally \\(f(\\vec{n})\\darrow = m\\) if\n\\(f(\\vec{n})\\) is defined at \\(\\vec{n}\\) and equal to \\(m\\). Otherwise\nwe write \\(f(\\vec{n})\\uarrow\\) to express that \\(f(\\vec{x})\\) is\nundefined at \\(\\vec{n}.\\)\n\n\nThe domain of \\(f(\\vec{n})\\) is the set \\(\\textrm{dom}(f) =\n\\{\\vec{n} \\in \\mathbb{N}^k : f(\\vec{n}) \\darrow\\}\\).\n\n\nWe write \\(f(\\vec{x}) \\simeq g(\\vec{x})\\) just in case for all\n\\(\\vec{n} \\in \\mathbb{N}\\), either \\(f(\\vec{n})\\) and \\(g(\\vec{n})\\)\nare both undefined or are both defined and equal.\n\n\nSuppose we are given a partial function \\(f(x_0,\\ldots,x_{k-1},y)\\).\nWe now introduce terms of the form \\(\\mu y f(x_0,\\ldots,x_{k-1},y)\\)\ndefined as follows:  \n\\[\\begin{align} \\label{murec}\n\\mu y f(x_0,\\ldots,x_{k-1},y) \n  = \\begin{cases} z & \\text{if } z \\text{ is such that } \\\\\n    &\\:\\: f(x_0,\\ldots,x_{k-1},z) = 0 \\text{ and } \\\\\n    &\\:\\: \\forall w < z(f(x_0,\\ldots,x_1,w)\\darrow \\neq 0) \\\\\n\\uarrow & \\text{otherwise}\n\\end{cases}\\end{align}\\]\n\n\nIn other words, \\(\\mu y f(\\vec{n},y)\\) is equal to the least \\(m\\)\nsuch that \\(f(\\vec{n},m) = 0\\) provided that such an \\(m\\) exists and\nalso that \\(f(\\vec{n},i)\\) is defined but not equal to 0 for all \\(0\n\\leq i < m\\). On the other hand, \\(\\mu y f(\\vec{n},y)\\) is\nundefined just in case either there is no \\(m\\) such that\n\\(f(\\vec{n},m) = 0\\) or there is such a \\(m\\) but \\(f(\\vec{n},i)\\) is\nundefined for some \\(i < m\\).\n\nSince this definition determines \\(\\mu yf(\\vec{x},y)\\) uniquely,\n(\\ref{murec}) can also be regarded as defining a functional\n\\(\\mathcal{Min}_k\\) which maps \\(k+1\\)-ary partial functions into\n\\(k\\)-ary partial functions. We now define the classes of functions\n\\(\\mathbf{PartREC}\\) and \\(\\mathbf{REC}\\) as follow:\n\n\nDefinition 2.5: The class of partial recursive\nfunctions \\(\\mathbf{PartREC}\\) (also known as the\n\\(\\mu\\)-recursive functions) is the smallest class of partial\nfunctions of type \\(\\mathbb{N}^k \\rightarrow \\mathbb{N}\\) containing\nthe initial functions \\(I_{\\mathbf{PR}} = \\{\\mathbf{0},s,\\pi^i_k\\}\\)\nand closed under the functionals \n\\[Op_{\\mathbf{PartREC}} = \\{\\mathcal{Comp}^i_j,\\mathcal{PrimRec}_k,\\mathcal{Min}_k\\}.\\]\n\n\nWe say that a function \\(f:\\mathbb{N}^k \\rightarrow \\mathbb{N}\\) is\npartial recursive if \\(f \\in \\mathbf{PartREC}\\). Additionally\nwe say that \\(f\\) is recursive if \\(f \\in \\mathbf{PartREC}\\)\nand \\(f\\) is total. The set of recursive functions will be denoted by\n\\(\\mathbf{REC}\\). \n\n\nNote that despite its name, the class of partial recursive\nfunctions contains total functions. In particular, a\nrecursive function is, by definition, one which is\npartial recursive while also being total. We will see in\n Section 3.2,\n there also exist partial recursive functions which are genuinely\npartial and total functions which are not recursive.\n\nNote finally that if \\(f(\\vec{x})\\) is recursive it may be defined via\nsome finite number of applications of composition, primitive\nrecursion, and unbounded minimization in a manner which preserves the\ntotality of intermediate functions in its definition. Thus although\nthe specification of \\(f(\\vec{x})\\) may involve one or more\napplications of unbounded search, each search required to compute its\nvalue is guaranteed to terminate in a finite number of steps. It thus\nfollows that all of functions in \\(\\mathbf{REC}\\) are computable by an\nalgorithm (despite the fact that we will soon see that this class\ncontains functions which are not primitive recursive). This\nconstitutes part of the evidence for Church\u2019s\nThesis\u2014i.e., the claim that \\(\\mathbf{REC}\\) coincides with\nthe class of effectively computable functions\u2014which was surveyed\nin\n Section 1.6.\n2.2.2 The Normal Form Theorem\n\nA question which naturally arises at this stage is whether more than\none application of unbounded minimization is required to obtain all\npartial recursive functions. The fact that a single application is\nsufficient is a consequence of the Kleene Normal Form\nTheorem. In order to formulate this result, it is convenient to\nofficially extend the application of the \\(\\mu\\)-operator to relations\nin the manner discussed at the beginning of this section\u2014i.e.,\n \n\\[\\begin{align} \\label{unboundedminrel}\n\\mu y R(\\vec{x},y) = \n\\begin{cases}\n\\text{the least $y$ such that $R(\\vec{x},y)$} & \\text{ if such a $y$ exists} \\\\\n\\uarrow & \\text{ otherwise}\n\\end{cases}\\end{align}\\]\n\n\n\nTheorem 2.3: For all \\(k \\in \\mathbb{N}\\) there\nexists a \\(k\\)+2-ary primitive recursive relation\n\\(T_k(e,\\vec{x},s)\\)\u2014the so-called Kleene\n\\(T\\)-predicate\u2014and a primitive recursive function \\(u(x)\\)\n(not depending on \\(k\\)) satisfying the following condition: for all\n\\(k\\)-ary partial recursive functions \\(f(\\vec{x})\\) there exists \\(e\n\\in \\mathbb{N}\\) such that for all \\(\\vec{n} \\in \\mathbb{N}^k\\) \n\n\\[f(\\vec{n}) \\simeq u(\\mu s T_k(e,\\vec{n},s))\\]\n\n\n\nSince \\(\\mu y R(\\vec{x},y) \\simeq \\mu y \\chi_{\\neg R}(\\vec{x},y)\\), it\nis easy to see that the class \\(\\mathbf{PartREC}\\) can also be\nobtained by closing the primitive recursive functions under the\noperation defined by (\\ref{unboundedminrel}). One consequence of\n Theorem 2.3\n is thus that it is indeed possible to define any \\(k\\)-ary partial\nrecursive function \\(f(\\vec{x})\\) by a single application of unbounded\nsearch applied to the relation \\(T_k(e,\\vec{x},s)\\) for an appropriate\nchoice of \\(e\\). More generally, the Normal Form Theorem illustrates\nhow any such function may be defined from a single relation\n\\(T_k(e,\\vec{x},s)\\) wherein the value of \\(e\\) serves as a\ndescription of the manner in which \\(f(\\vec{x})\\) is defined in terms\nof the basis functions \\(I_{\\mathbf{PR}}\\) and the operations\n\\(Op_{\\mathbf{PartRec}}\\). Such an \\(e\\) is known as an index\nfor \\(f(\\vec{x})\\). As we will see in\n Section 3,\n the availability of such indices is one of the central features of\nthe partial recursive functions which allows them to provide the basis\nfor a general theory of computability and non-computability.\n\nThe complete details of the proof of\n Theorem 2.3\n are involved. But the basic idea may be summarized as follows:\n\n\n\nEvery partial recursive function \\(f(\\vec{x})\\) is defined by a term\n\\(\\tau\\) over the language  \n\\[\\mathbf{0},s,\\pi^i_j,\\mathcal{Comp}^j_k,\\mathcal{PrimRec}_k,\\mathcal{Min}_k\\]\n\n\nin the manner which extends the notation scheme for partial recursive\nfunction introduced at the end of\n Section 2.1.1.\n By associating the atomic expressions of this language with natural\nnumbers in the manner of G\u00f6del numbering \\(\\ulcorner \\cdot\n\\urcorner\\) described in\n Section 1.3\n and then employing the coding machinery described at the end of\n Section 2.1.2,\n it is then possible to associate \\(\\tau\\) with a natural number\n\\(\\ulcorner \\tau \\urcorner = e\\) which can serve as an index for\n\\(f(\\vec{x})\\).\n\n\nThe definition of \\(T_k(e,\\vec{n},s)\\) can now be constructed by\nformalizing the following decision algorithm: \n\n on input \\(e,\\vec{n},s\\) construct a term \\(\\tau\\) defining\n\\(f(\\vec{x})\\) from \\(e\\); \n understanding \\(s\\) as a potential code for a sequence of\nintermediate computational steps similar to that exemplified by the\ncalculation (\\ref{prcalc2}), check whether the result of carrying out\nthe computation described by \\(\\tau\\) on input \\(\\vec{n}\\) for\n\\(\\textit{len}(s)\\) steps corresponds to \\(s\\); \n if so, accept\u2014i.e., \\(T_k(e,\\vec{n},s)\\) holds\u2014and if\nnot reject\u2014i.e., \\(\\neg T_k(e,\\vec{n},s)\\) holds. \n \n\n\nBy performing an unbounded search over codes of computation sequences\nin this manner, we achieve the dual purposes of both determining if\nthe computation described by \\(\\tau\\) on input \\(\\vec{n}\\) halts after\na finite number of steps and, if so, also finding a code \\(s\\) of a\ncomputation sequence which witnesses this fact. The function \\(u(s)\\)\ncan then be defined by formalizing the operation which extracts the\noutput of the computation from the last step\n\\((s)_{\\textit{len}(s)-1}\\) of the sequence encoded by \\(s\\). In the\ncase that \\(T_k(e,\\vec{n},s)\\) holds, \\(u(s)\\) will thus correspond to\nthe value \\(f(\\vec{n})\\). Since the foregoing steps require only\nperforming bounded search and checking the local combinatorial\nproperties of finite sequences, it can additionally be shown that\n\\(T_k(e,\\vec{n},s)\\) and \\(u(x)\\) are primitive recursive.\n\n\nThe techniques used in this proof can also be used to show that\n\\(\\alpha(x,y)\\), the universal \\(k\\)-ary primitive recursive\nevaluation function \\(u_k(i,\\vec{x})\\), and the modified diagonal\nfunction \\(\\delta(x)\\) are all recursive (despite the fact that we\nhave seen above that they are not primitive recursive). For\ninstance note that the coding of definitions of \\(k\\)-ary partial\nrecursive functions described above also allows us to uniformly\nenumerate all primitive recursive functions\n\\(g_0(\\vec{x}),g_1(\\vec{x}),\\ldots\\) by considering the codes of terms\nnot containing \\(\\mathcal{Min}_k\\). We can define in this manner a\nprimitive recursive function \\(r(i)\\) enumerating the indices for\nthese functions such that we can obtain the universal function for\n\\(k\\)-ary primitive recursive function as \\(u_k(i,\\vec{x}) = u(\\mu s\nT_1(r(i),\\vec{x},s)) = g_i(\\vec{x})\\). But note that since\n\\(g_i(\\vec{x})\\) is always defined, \\(u_1(i,\\vec{x})\\) is not only\npartial recursive but also total, and hence recursive.\n\nTaking into account the equivalences between models of computation\nsummarized in\n Section 1.6,\n it is also possible to formulate a version of\n Theorem 2.3\n for each of the models of computation mentioned there. For instance,\nin the case of the Turing Machine model \\(\\mathbf{T}\\), the analogous\nversion of the Normal Form Theorem can be used to show that there is a\nsingle\n universal Turing machine (see entry on Turing machines)\n \\(U\\) such that every partial recursive function \\(f(\\vec{x})\\)\ncorresponds to that computed by \\(U(e,\\vec{x})\\) for some \\(e \\in\n\\mathbb{N}\\). Complete proofs of this sort were given by Turing (1937,\nsec. 6) for \\(\\mathbf{T}\\), by Kleene (1936a, sec. 2) for the general\nrecursive functions \\(\\mathbf{GR}\\) (see also Kleene 1952, sec. 58),\nby Shoenfield (1967, ch. 7.4) for the class\n\\(\\mathbf{F}_{\\mathsf{PA}}\\) of functions representable in Peano\nArithmetic, and by Cutland (1980, ch. 5) for the Unlimited Register\nMachine model \\(\\mathbf{U}\\).\n3. Computability Theory\n\nComputability Theory is a subfield of contemporary mathematical logic\ndevoted to the classification of functions and sets of natural numbers\nin terms of their absolute and relative computability and\ndefinability-theoretic properties. This subject is closely related in\nboth origin and content to the study of recursive functions. This is\nreflected by the fact that computability theory was known as\nrecursive function theory (or simply recursion\ntheory) from the time of its inception in the 1930s until the\nlate 1990s. It is also reflected in the formulation and proof of the\nso-called Recursion Theorem which provides a fundamental link\nbetween recursive definability and the sort of self-referential\nconstructions which are at the core of many methods in computability\ntheory (see\n Section 3.4).\n\nFor reasons discussed in\n Section 1.7,\n contemporary expositions of computability theory are often presented\nin an abstract manner which seeks to minimize reference to the\nspecific features of a model of computation such as the partial\nrecursive functions. It is thus useful to stress the following\nmodifications to the traditional terminology which has been employed\nin\n Sections 1 and 2\n and the more contemporary terminology which will be employed in this\nsection:\n\n\n\nThe expressions computable function and\npartial computable function will be used\ninstead of the traditional terms recursive\nfunction and partial recursive\nfunction as defined in\n Section 2.2.1.\n\n\nThe expression computable set will be used\ninstead of the traditional term recursive\nset. Similarly, computably\nenumerable (or c.e.) set will\nbe used instead of the traditional term recursively\nenumerable (or r.e.) set (see\n Section 3.3).\n\n\nThe other notational conventions introduced at the beginnings of\n Section 2.1\n and\n Section 2.2\n will be retained in this section.\n3.1 Indexation, the s-m-n Theorem, and Universality\n\nThe first significant result in computability theory was\nKleene\u2019s (1936a) proof of the Normal Form Theorem which was\npresented in\n Section 2.2.2.\n As discussed there, the Normal Form Theorem can be understood as\nillustrating how it is possible to associate each \\(k\\)-ary partial\ncomputable function \\(f(\\vec{x})\\) with a natural number \\(e\\) known\nas its index such that \\(f(\\vec{x}) \\simeq \\mu\ns(T_k(e,\\vec{x},s))\\). Such an \\(e\\) can be thought of as a name for a\ncomputer program built up from the basis functions, composition,\nprimitive recursion, and minimization by which the values\n\\(f(\\vec{x})\\) can be computed. This also leads to what is known as an\nindexation of \\(k\\)-ary partial computable functions \n\n\\[\\phi^k_0(\\vec{x}), \\phi^k_1(\\vec{x}), \\phi^k_2(\\vec{x}), \\ldots, \\phi^k_i(\\vec{x}), \\ldots\\]\n\n\nwhere \\(\\phi^k_i(\\vec{x}) \\simeq \\mu s T_k(i,\\vec{x},s)\\). Such an\nenumeration provides a uniform means of listing off all partial\ncomputable functions in the order of their indices. It should be\nnoted, however, that each partial computable function has infinitely\nmany indices. For instance, given a function \\(f:\\mathbb{N}^k\n\\rightarrow \\mathbb{N}\\) computed by \\(\\phi_e(\\vec{x})\\), it is\npossible to define infinitely many extensionally coincident functions\nwith distinct indices \\(\\phi_{e'}(\\vec{x}), \\phi_{e''}(\\vec{x}),\n\\ldots\\)\u2014e.g., by \u201cpadding\u201d the definition encoded\nby \\(e\\) with terms that successively add and then subtract \\(m\\) for\neach \\(m \\in \\mathbb{N}\\). As this yields a definition of an\nextensionally equivalent function, it thus follows that infinitely\nmany of the \\(\\phi^k_i(\\vec{x})\\) will correspond to the same function\nin extension.\n\nA result closely related to the Normal Form Theorem is the following\nwhich is conventionally known as the s-m-n Theorem:\n\n\nTheorem 3.1: For all \\(n,m \\in \\mathbb{N}\\), there is\na primitive recursive function \\(s^m_n(i,x_0,\\ldots,x_{m-1})\\) such\nthat  \n\\[\\phi^n_{s^m_n(i,x_0,\\ldots,x_{m-1})}(y_0,\\ldots,y_{n-1}) \\simeq \\phi^{n+m}_i(x_0,\\ldots,x_{m-1},y_0,\\ldots,y_{n-1})\\]\n\n\n\nHere the function \\(s^m_n(i,\\vec{x})\\) should be thought of as acting\non an index \\(i\\) for an \\(n+m\\)-ary partial computable function\ntogether with values \\(\\vec{x}\\) for the first \\(m\\) of its arguments.\nThis function returns an index for another partial computable function\nwhich computes the \\(n\\)-ary function determined by carrying out\n\\(\\phi^{n+m}_i\\) with the first \\(m\\) of its arguments \\(\\vec{x}\\)\nfixed but retaining the next \\(n\\) variables \\(\\vec{y}\\) as inputs.\nAlthough the formulation of the s-m-n Theorem may at first\nappear technical, its use will be illustrated in the proof of\n Rice\u2019s Theorem (3.4)\n and the\n Recursion Theorem (3.5)\n below.\n\nAnother consequence of the Normal Form Theorem is the following:\n\n\nTheorem 3.2: For every \\(k \\in \\mathbb{N}\\), there is\na \\(k+1\\)-ary partial computable function \\(\\upsilon^k\\) which is\nuniversal in the sense that for all \\(k\\)-ary partial computable\nfunctions \\(f(\\vec{x})\\), there is an \\(i \\in \\mathbb{N}\\) such that\n\\(\\upsilon_k(i,\\vec{x}) \\simeq f(\\vec{x})\\).\n\n\nThis follows immediately from\n Theorem 2.3\n by taking \\(\\upsilon_k(i,\\vec{x}) = u(\\mu s T_k(i,\\vec{x},s))\\) where\n\\(i\\) is such that \\(f(\\vec{x}) \\simeq \\phi^k_i(\\vec{x})\\) in the\nenumeration of \\(k\\)-ary partial computable functions. As\n\\(\\upsilon^k(i,\\vec{x})\\) can be used to compute the values of all\n\\(k\\)-ary partial computable functions uniformly in their index, it is\nconventionally referred to as the \\(k\\)-ary universal partial\ncomputable function.\n\nIt is useful to observe that while we have just defined such a\nfunction for each \\(k\\), it is also possible to define a binary\nfunction \\(\\upsilon(i,x)\\) which treats its second argument as a code\nfor a finite sequence \\(x_0,\\ldots,x_{k-1}\\) and then computes in the\nsame manner as the \\(k\\)-ary universal function so that we have\n\\(\\upsilon(i,\\langle x_0,\\ldots, x_{k-1} \\rangle) \\simeq\n\\upsilon^k(i,x_0,\\ldots,k_{k-1})\\). This provides a means of replacing\nthe prior enumerations of \\(k\\)-ary partial computable functions with\na single enumeration of unary functions  \n\\[\\phi_0(x), \\phi_1(x), \\phi_2(x), \\ldots, \\phi_i(x), \\ldots\\]\n\n\nwhere \\(\\phi_i(\\langle x_0,\\ldots, x_{k-1} \\rangle) \\simeq\n\\upsilon(i,\\langle x_0,\\ldots, x_{k-1} \\rangle) \\simeq\n\\phi^k_i(x_0,\\ldots, x_{k-1})\\).\n\nTogether with\n Theorem 2.3,\n Theorem 3.1 and\n Theorem 3.2\n codify the basic properties of a model of computation which make it\nsuitable for the development of a general theory of computability. In\n Section 2\n such a model has been defined in the form of the partial recursive\nfunctions. But as was discussed briefly at the end of\n Section 2.2.2,\n versions of these results may also be obtained for the other models\nof computation discussed in\n Section 1.6.\n This licenses the freer usage of computer-based analogies and other\nappeals to Church\u2019s Thesis employed in most contemporary\ntreatments of computability theory which will also be judiciously\nemployed in the remainder of this entry.\n3.2 Non-Computable Functions and Undecidable Problems\n\nHaving just seen that there is a universal partial computable function\n\\(\\upsilon(i,x)\\), a natural question is whether this function is also\ncomputable (i.e., total). A negative answer is provided\nimmediately by observing that by using \\(\\upsilon(i,x)\\) we may define\nanother modified diagonal function \\(d(x) = \\upsilon(x,x) + 1\\) which\nis partial computable (since \\(\\upsilon(i,x)\\) is). This in turn\nimplies that \\(d(x) \\simeq \\phi_j(x)\\) for some \\(j\\). But now note\nthat if \\(\\upsilon(i,x)\\) were total, then \\(d(j)\\) would be defined\nand we would then have  \n\\[\\begin{align*}\nd(j) & = \\phi_j(j) \\\\\n& = \\upsilon(j,j) + 1 \\\\\n& = \\phi_j(j) + 1,\n\\end{align*}\\]\n\n\na contradiction. Comparing this situation with that described at the\nbeginning of\n Section 2.2\n we can see that the partial computable functions differ from the\nprimitive recursive functions in admitting a universal function within\nthe same class but at the same time giving up the requirement that the\nfunctions in the class must be total. In other words, while\n\\(\\upsilon(i,x) \\in \\mathbf{PartREC}\\), the discussion in\n Section 2.2.2\n shows that \\(u_1(i,\\vec{x}) \\in \\mathbf{REC} - \\mathbf{PR}\\). \n\nSince it is easy to see how the minimization operation can be used to\ndefine partial functions, the foregoing observations is expected. What\nis more surprising is that there are mathematically well-defined\ntotal functions which are not computable. Building on the\ndiscussion of the Entscheidungsproblem in\n Section 1.7,\n the most famous example of such a function derives from the so-called\n Halting Problem (see entry on Turing machines)\n for the Turing Machine model. This was originally formulated by\nTuring (1937) as follows:\n\n\nGiven an indexation of \\(T_0, T_1, \\ldots\\) of Turing machines, does\nmachine \\(T_i\\) halt on the input \\(n\\)?\n\n\nAn equivalent question can also be formulated in terms of the partial\nrecursive functions:\n\n\nIs the partial computable function \\(\\phi_i(x)\\) defined for input\n\\(n\\)?\n\n\nThe pairs of natural numbers \\(\\langle i,n \\rangle\\) corresponding to\npositive answers to this question determine a subset of \\(\\mathbb{N}\n\\times \\mathbb{N}\\) as follows:  \n\\[\\begin{aligned}\n \\HP = \\{\\langle i,n \\rangle : \\phi_i(n) \\darrow\\} \\end{aligned}\\]\n\n\nA set (or problem) is said to be undecidable just in\ncase its characteristic function is not computable. For instance let\n\\(h(x,y) = \\chi_{\\HP}(x,y)\\) and observe that this, by definition, is\na total function. The so-called undecidability of the\nHalting Problem may now be formulated as follows:\n\n\nTheorem 3.3: \\(h(x,y)\\) is not a computable\nfunction.\n\n\n\nProof: Suppose for a contradiction that \\(h(x,y)\\) were\ncomputable. Consider the function \\(g(x)\\) defined as \n\n\\[\\begin{aligned}\ng(x) = \\begin{cases} \n0 & \\text{if } h(x,x) \\darrow = 0 \\\\\n\\uarrow & \\text{otherwise}\n\\end{cases}\\end{aligned}\\]\n\n\nOn the assumption that \\(h(x,y)\\) is computable, \\(g(x)\\) is partial\ncomputable since, e.g., it may be computed by a program which on input\n\\(x\\) computes \\(h(x,x)\\) and returns 0 just in case \\(h(x,x) = 0\\)\nand otherwise goes into an infinite loop. It hence follows that \\(g(x)\n\\simeq \\phi_j(x)\\) for some \\(j \\in \\mathbb{N}\\). But now observe that\none of the following two alternatives must hold: i) \\(g(j) \\darrow\\);\nor ii) \\(g(j)\\uarrow\\). We may thus reason by cases as follows:\n\n\n\nSuppose that \\(g(j) \\darrow\\). Then \\(h(j,j) = 0\\) by definition of\n\\(g(x)\\). Since \\(h(i,x)\\) is the characteristic function of \\(\\HP\\),\nthis means \\(\\phi_j(j) \\uarrow\\). But then since \\(g(x) \\simeq\n\\phi_j(x)\\), \\(g(j) \\uarrow\\), a contradiction.\n\n\nSuppose that \\(g(j) \\uarrow\\). Then \\(h(j,j) \\neq 0\\) by definition of\n\\(g(x)\\). Since \\(h(x,y)\\) is the characteristic function of \\(\\HP\\)\n(and hence total), the only other possibility is that \\(h(j,j) = 1\\)\nwhich in turn implies that \\(\\phi_j(j) \\darrow\\). But then since\n\\(g(x) \\simeq \\phi_j(x)\\), \\(g(j) \\darrow\\), a contradiction. \u25a1\n\n\n\n\n\\(h(x,y)\\) thus provides an initial example of a mathematically\nwell-defined total function which is not computable. Other\nnon-computable functions can be defined by considering decision\nproblems similar to \\(\\HP\\). Some well-known examples are as follows:\n \n\\[\\begin{align} \\label{undecexs}\nK & = \\{i : \\phi_i(i) \\darrow\\} \\\\ \n Z &= \\{i : \\phi_i(n)\\darrow = 0 \\text{ for all $n \\in \\mathbb{N}$}\\} \\nonumber \\\\\n \\TOT & = \\{i : \\phi_i(n) \\darrow \\text{ for all $n \\in \\mathbb{N}$}\\}  \\nonumber \\\\\n\\textit{FIN}  & = \\{i : \\phi_i(n)\\darrow \\text{ for at most\nfinitely many distinct} \\text{$n \\in \\mathbb{N}$}\\}\\nonumber\\\\\n&  = \\{i : W_i \\text{ is finite} \\}   \\nonumber \n\\end{align}\\]\n\n\nSuppose we let \\(k(x), z(x), \\textit{tot}(x)\\), and\n\\(\\textit{fin}(x)\\) be the characteristic functions of these sets. By\nmaking suitable modifications to the proof of\n Theorem 3.3\n it is possible to directly show the following:\n\n\nProposition 3.1: None of the functions \\(k(x), z(x),\n\\textit{tot}(x)\\), and \\(\\textit{fin}(x)\\) are computable. \n\n\nFor instance in the case of \\(k(x)\\), we may argue as follows:\n\n define a function \\(g(x)\\) which returns 0 if \\(k(x) = 0\\) and\nwhich is undefined otherwise; \n as before, if \\(k(x)\\) is assumed to be computable, then \\(g(x)\\)\nis partial computable and there is hence an index \\(j\\) such that\n\\(g(x) \\simeq \\phi_j(x)\\); \n but now observe that \\(k(j) = 1\\) iff \\(g(j) \\uarrow\\) iff\n\\(\\phi_j(j) \\uarrow\\) iff \\(k(j) = 0\\). \n\n\nAs this is again a contradictory situation, we may conclude that\n\\(k(x)\\) is not computable.\n\nNote that each of the sets \\(I\\) defined in (\\ref{undecexs}) has the\nfollowing property: if \\(j \\in I\\) and \\(\\phi_j(x) \\simeq \\phi_k(x)\\),\nthen \\(k \\in I\\) as well. Sets with this property are known as\nindex sets as they collect together the indices of all\npartial computable functions which share a common\n\u201csemantic\u201d property\u2014i.e., one which is completely\ndetermined by their graphs such as being coincident with the constant\n0 function in the case of \\(Z\\) or being defined on all inputs in the\ncase of \\(\\TOT\\). An index set \\(I\\) is called non-trivial if\n\\(I \\neq \\emptyset\\) or \\(I \\neq \\mathbb{N}\\)\u2014i.e., it fails to\neither include or exclude all indices. It is easy to see that all of\nthe sets defined in (\\ref{undecexs}) are non-trivial index sets. The\nundecidability of these sets thus follows from the following more\ngeneral result:\n\n\nTheorem 3.4 (Rice 1953): If \\(I\\) is a non-trivial\nindex set, then \\(I\\) is undecidable.\n\n\n\nProof: Let \\(I\\) be a non-trivial index set and suppose for a\ncontradiction that \\(\\chi_I(x)\\) is computable. Consider the\neverywhere undefined unary function \\(u(x)\\)\u2014i.e., \\(u(n)\n\\uarrow\\) for all \\(n \\in \\mathbb{N}\\). Since \\(u(x)\\) is partial\ncomputable, there is an index \\(b\\) such that \\(\\phi_b(x) \\simeq\nu(x)\\). We may suppose without loss of generality that \\(b \\not\\in\nI\\). (If it is the case that \\(b \\in I \\neq \\mathbb{N}\\), then we can\nswitch the role of \\(I\\) with its complement \\(\\overline{I}\\) in the\nfollowing argument and obtain the same result). Since \\(I \\neq\n\\emptyset\\), we can also choose an index \\(a \\in I\\) and define a\nfunction as follows:  \n\\[\\begin{aligned}\n f(x,y) = \\begin{cases} \n\\phi_a(y) & \\text{if } k(x) = 1 \\ \\ \\ \\text{(i.e., if $\\phi_x(x) \\darrow$)} \\\\\n\\uarrow & \\text{if } k(x) = 0 \\ \\ \\ \\text{(i.e., if $\\phi_x(x) \\uarrow$)} \n\\end{cases} \\nonumber\\end{aligned}\\]\n\n\nNote that \\(f(x,y)\\) is partial computable since it is defined by\ncases in terms of \\(\\phi_a(x)\\) based on the value of \\(\\phi_x(x)\\).\nThere is thus an index \\(c\\) such that \\(f(x,y) \\simeq \\phi_c(x,y)\\).\nBy applying the\n s-m-n Theorem (3.1),\n we thus have that \\(\\phi_c(x,y) \\simeq \\phi_{s^2_1(c,x)}(y)\\). But\nnote that we now have the following sequences of implications:\n\n\n\\[\\begin{align*}\nk(x) = 1 & \\Rightarrow f(x,y)  \\simeq \\phi_a(y) \\\\\n& \\Rightarrow \\phi_{s^2_1(c,x)}(y)  \\simeq \\phi_a(y)\\\\\n&  \\Rightarrow s^2_1(c,x) \\in I  \n\\end{align*}\n\\]\n\n\n(by our choice of \\(a \\in I\\)) \n\\[\\begin{align*}\nk(x) = 0 & \\Rightarrow f(x,y) \\simeq \\phi_b(y) \\\\\n& \\Rightarrow \\phi_{s^2_1(c,x)}(y) \\simeq \\phi_b(y) \\\\\n& \\Rightarrow s^2_1(c,x) \\not\\in I\n\\end{align*}\\]\n\n\n(by our assumptions that \\(b\\) is an index for \\(u(x)\\)\u2014the\neverywhere undefined function\u2014and that \\(b \\not\\in I\\)). \n\n\nIt hence follows that the value of \\(k(x)\\) may be computed by\napplying the following algorithm: \n\n on input \\(x\\), calculate the value of \\(s^2_1(c,x)\\) (whose\ncomputability follows from the s-m-n Theorem); \n calculate the value of \\(\\chi_I(s^2_1(c,x))\\) (which may be\naccomplished since we have assumed that \\(\\chi_I(x)\\) is computable).\n\n\n\nEither by invoking Church\u2019s Thesis or by formalizing the prior\nalgorithm as a partial recursive definition, it follows that \\(k(x)\\)\nis computable. But this contradicts\n Proposition 3.1\n which shows that \\(k(x)\\) is not computable. \u25a1\n\n\nRice\u2019s Theorem (3.4)\n provides a means of showing that many decision problems of practical\nimport are undecidable\u2014e.g., of determining whether a program\nalways returns an output or whether it correctly computes a given\nfunction (e.g., addition or multiplication). Its proof also shows that\nif \\(I\\) is a non-trivial index set, the problem of deciding \\(x \\in\nK\\) can be \u201creduced\u201d to that of deciding \\(x \\in I\\) it\nthe following sense: if we could effectively decide the\nlatter, then we could also effectively decide the former by\nfirst calculating \\(s^2_1(c,x)\\) and then checking if this value is in\n\\(I\\). This method of showing undecidability will be formalized by the\nnotion of a many-one reduction described in\n Section 3.5\n below.\n3.3 Computable and Computably Enumerable Sets\n\nA set \\(A \\subseteq \\mathbb{N}\\) is said to be computable (or\nrecursive according to the older terminology of\n Section 2)\n just in case its characteristic function is. More generally we have\nthe following:\n\n\nDefinition 3.1: A relation \\(R \\subseteq\n\\mathbb{N}^k\\) is computable just in case \\(\\chi_R(\\vec{x})\\)\nis computable.\n\n\nThis definition extends the definition of a primitive recursive\nrelation given in\n Section 2.1\u2014e.g.,\n since sets like PRIMES and DIV are primitive\nrecursive they are ipso facto computable. Via Church\u2019s\nThesis, the notion of a computable set thus also generalizes the\naccompanying heuristic about effective decidability\u2014i.e., \\(R\\)\nis computable just in case there is an algorithm for deciding if\n\\(R(\\vec{n})\\) holds which always returns an answer after a finite\n(although potentially unbounded) number of steps. On the other hand,\nit follows from the observations recorded in\n Section 3.2\n that none of HP, K, Z, TOT, or\nFIN are computable sets.\n\nA related definition is that of a computably enumerable (or\nc.e.) set\u2014i.e., one whose members can be\nenumerated by an effective procedure. (In the older terminology of\n Section 2\n such a set is said to be recursively enumerable which is\ntraditionally abbreviated r.e.) Officially we have the\nfollowing:\n\n\nDefinition 3.2: \\(A \\subseteq \\mathbb{N}\\) is\ncomputably enumerable (or c.e.) if \\(A = \\emptyset\\) or \\(A\\)\nis the range of a computable function\u2014i.e., \n\\[A = \\{m : \\phi_e(n)\\darrow = m \\text{ for some } n \\in \\mathbb{N}\\}\\]\n\n\nfor some index \\(e\\) of a total computable function.\n\n\nThis definition can be extended to relations by viewing \\(m\\) as a\ncode for a finite sequence in the obvious way\u2014i.e., \\(R\n\\subseteq \\mathbb{N}^k\\) is c.e.\u00a0just in case there is a\ncomputable function \\(\\phi_e(x)\\) such that \\(R(n_0, \\ldots, n_k)\\) if\nand only if \\(\\phi_e(n) = \\langle n_0, \\ldots, n_k \\rangle\\) for some\n\\(n \\in \\mathbb{N}\\).\n\nIf \\(A\\) is computably enumerable, its members may thus be listed off\nas  \n\\[A = \\{\\phi_e(0), \\phi_e(1), \\phi_e(2), \\ldots \\}\\]\n\n\npossibly with repetitions\u2014e.g., the constant function\n\\(\\const_{17}(x)\\) enumerates the singleton set \\(\\{17\\}\\), which is\nthereby c.e. It is easy to see that a computable set \\(A\\) is\ncomputably enumerable. For if \\(A = \\emptyset\\), then \\(A\\) is\nc.e.\u00a0by definition. And if \\(A \\neq \\emptyset\\), we may choose\n\\(a \\in A\\) and then define  \n\\[\\begin{align} \\label{cefromc}\nf(x) = \\begin{cases} \n     x & \\text{if } \\chi_A(x) = 1 \\\\ \n     a & \\text{otherwise} \\end{cases}\n\\end{align}\\]\n\n\nIn this case \\(f(x)\\) is computable and has \\(A\\) as its range.\n\nIn proving facts about computably enumerable sets, it is often\nconvenient to employ one of several equivalent definitions:\n\n\nProposition 3.2: Suppose \\(A \\subseteq \\mathbb{N}\\).\nThen the following are equivalent:\n\n\n\n\\(A\\) is computably enumerable.\n\n\n\\(A = \\emptyset\\) or \\(A\\) is the range of a primitive recursive\nfunction.\n\n\n\\(A = \\{n \\in \\mathbb{N}: \\exists y R(n,y)\\}\\) for a computable\nrelation \\(R\\).\n\n\n\\(A\\) is the domain of a partial computable function.\n\n\n\nThe proof of\n Proposition 3.2\n is largely a matter of unpacking definitions. For instance, to see\nthat iv implies i, suppose that \\(A =\n\\textrm{dom}(\\phi_e)\\)\u2014i.e., \\(A = \\{n \\in \\mathbb{N} :\n\\phi_e(n) \\darrow\\}\\). If \\(A = \\emptyset\\) it is automatically c.e.\nOtherwise, there is an element \\(a \\in A\\). We may now define \n\n\\[\\begin{aligned}\nf(x) = \\begin{cases} (x)_0 & \\text{if } T_1(e,(x)_0,(x)_1) \\\\ a & \\text{otherwise} \\end{cases}\\end{aligned}\\]\n\n\n\\(f(x)\\) thus treats its input as a pair \\(\\langle n,s \\rangle\\)\nconsisting of an input \\(n\\) to \\(\\phi_e(x)\\) and a computation\nsequence \\(s\\) as defined in the proof of the Normal Form Theorem\n (2.3).\n As \\(x\\) varies over \\(\\mathbb{N}\\), it thus steps through all\npossible inputs \\((x)_0\\) to \\(\\phi_e\\) and also all possible\nwitnesses \\((x)_1\\) to the fact that the computation of \\(\\phi_e\\) on\n\\((x)_0\\) halts. It then returns \\((x)_0\\) if \\((x)_1\\) is such a\nwitness to a halting computation and \\(a\\) otherwise. Thus the range\nof \\(f(x)\\) will correspond to that of \\(\\phi_e(x)\\). And as\n\\(T_1(e,x,s)\\) is computable (and in fact primitive recursive)\nrelation, it is easy to see that \\(f(x)\\) is a computable function\nwith range \\(A\\). This shows that \\(A\\) is c.e.\u00a0as desired.\n\nPart iv of\n Proposition 3.2\n also provides a convenient uniform notation for computably enumerable\nsets\u2014i.e., if \\(A = \\textrm{dom}(\\phi_e)\\) we denote \\(A\\) by\n\\(W_e = \\{n : \\phi_e(n) \\darrow\\}\\). The sequence \\(W_0,W_1, W_2,\n\\ldots\\) thus provides a uniform enumeration of c.e.\u00a0sets\nrelative to our prior enumeration of unary partial computable\nfunctions. This notation also aids the formulation of the\nfollowing:\n\n\nProposition 3.3:\n\n\n\nThe computably enumerable sets are effectively closed under union,\nintersection, and cross product\u2014i.e., there are computable\nfunctions \\(\\textit{un}(x,y),\\) \\(\\textit{int}(x,y)\\) and\n\\(\\textit{cr}(x,y)\\) such that if \\(A = W_i\\) and \\(B = W_j\\) then\n\n\\[A \\cup B = W_{\\textit{un}(i,j)}, A \\cap B = W_{\\textit{int}(i,j)}\\]\n\n\nand \n\\[\\{\\langle x,y \\rangle : x \\in A \\ \\& \\ y \\in B\\} = W_{\\textit{cr}(i,j)}.\\]\n\n\n\nThe computable sets are additionally closed under complementation and\nrelative complementation\u2014i.e., if \\(A\\) and \\(B\\) are recursive,\nthen so are \\(\\overline{A}\\) and \\(A - B\\).\n\n\n\nThe proofs of these facts are also straightforward upon appeal to\nChurch\u2019s Thesis. For instance, if \\(\\textrm{dom}(\\phi_i) = A\\)\nand \\(\\textrm{dom}(\\phi_j) = B\\) then \\(\\textit{un}(i,j)\\) can be\ntaken to be an index for a program which simulates the computation of\n\\(\\phi_i(n)\\) and \\(\\phi_j(n)\\) in alternate stages and halts just in\ncase one of these subcomputations halt. Note also that if \\(A = W_i\\)\nis computable, then \\(\\chi_{\\overline{A}}(x) = 1 \\dotminus \\chi_A(x)\\)\nis also computable, from which it follows that \\(\\overline{A}\\) is\n computable.[21]\n\n\nA related observation is the following:\n\n\nProposition 3.4 (Post 1944): \\(A\\) is computable if\nand only if \\(A\\) and \\(\\overline{A}\\) are both computably\nenumerable.\n\n\nThe left-to-right direction is subsumed under\n Proposition 3.3.\n For the right-to-left direction, suppose that \\(A =\n\\textrm{dom}(\\phi_i)\\) and \\(\\overline{A} = \\textrm{dom}(\\phi_j)\\).\nThen to decide \\(n \\in A\\) we can perform an unbounded search for a\ncomputation sequence \\(s\\) such that either \\(T_1(i,n,s)\\) or\n\\(T_1(j,n,s)\\), accepting in the first case and rejecting in the\nsecond. Since \\(A \\cup \\overline{A} = \\mathbb{N}\\), the search must\nalways terminate and since \\(A \\cap \\overline{A} = \\emptyset\\), the\nconditions are exclusive. Thus by again appealing to Church\u2019s\nThesis, \\(A\\) is computable.\n\nWe have seen that the computable sets are contained in the computably\nenumerable sets. Two questions which arise at this stage are as\nfollows:\n\n are there examples of sets which are computably enumerable but\nnot computable? \nare there are examples of sets which are not computably\nenumerable? \n\n\nA positive answer to both is provided by the following:\n\n\nCorollary 3.1: Recall the set \\(K = \\{i : \\phi_i(i)\n\\darrow\\}\\)\u2014i.e., the so called Diagonal Halting\nProblem. \\(K\\) is computably enumerable but not computable while\n\\(\\overline{K}\\) is not computably enumerable.\n\n\n\\(K\\) is clearly c.e.\u00a0as it is the domain of \\(\\mu s\nT_1(x,x,s)\\). On the other hand, we have seen that the characteristic\nfunction of \\(K\\)\u2014i.e., the function \\(\\chi_K(x) = k(x)\\) as\ndefined in\n Section 3.2\u2014is\n not computable. Thus \\(K\\) is indeed a computably enumerable set\nwhich is not computable. To see that \\(\\overline{K}\\) is not c.e.,\nobserve that if it were, then \\(K\\) would be computable by\n Proposition 3.4.\n This in turn suggests a sense in which it is \u201charder\u201d to\ndecide membership in \\(K\\) than in any computable set. The hierarchies\nintroduced in\n Sections 3.5\n and\n Section 3.6\n will provide a means of making such observations precise.\n3.4 The Recursion Theorem\n\nThe result which is now most often referred to as Kleene\u2019s\nRecursion Theorem can be used to unify a number of effective\ndiagonal arguments similar to that underlying\n Theorem 3.3\n and has a wide range of applications both in computability theory and\nother areas of mathematical logic and computer\n science.[22]\n Although its statement is straightforward, both its significance and\nthe following proof become clearer upon considering subsequent\napplications.\n\n\nTheorem 3.5 (Kleene 1938): Suppose that \\(f(x)\\) is a\ntotal computable function. Then there is a number \\(n \\in \\mathbb{N}\\)\nsuch that \\(\\phi_n(y) \\simeq \\phi_{f(n)}(y)\\).\n\n\n\nProof: Consider the function \\(g(x,y)\\) defined as follows:\n \n\\[\\begin{aligned}\ng(x,y) = \\begin{cases} \\phi_{\\phi_x(x)}(y) & \\text{if } \\phi_x(x) \\darrow \\\\ \\uarrow & \\text{otherwise} \\end{cases} \\end{aligned}\\]\n\n\nAs it is evident that \\(g(x,y)\\) is partial computable, \\(g(x,y)\n\\simeq \\phi_e(x,y)\\) for some \\(e\\). It thus follows by the\n s-m-n Theorem (3.1)\n that \\(\\phi_e(x,y) \\simeq \\phi_{s^2_1(e,x)}(y)\\). Let \\(b(x) =\ns^2_1(e,x)\\) and note that we then have \\(\\phi_{b(x)}(y)\\) is the same\nfunction as \\(\\phi_{\\phi_x(x)}(y)\\) provided that \\(\\phi_x(x)\\) is\ndefined. Note that \\(b(x)\\) is a total computable function and is\ndefined independently of the given function \\(f(x)\\).\n\nNext let \\(k\\) be an index for the composition of \\(f(x)\\) with\n\\(b(x)\\)\u2014i.e., \\(\\phi_k(x) \\simeq f(b(x))\\). We now claim that\n\\(n = b(k)\\) is the number called for in the statement of the theorem.\nFor first note that since \\(b(x)\\) and \\(f(x)\\) are both total,\n\\(\\phi_k(x)\\) is also total and thus \\(\\phi_k(k)\\) is defined. From\nthis it follows that \\(\\phi_{b(k)}(y) \\simeq \\phi_{\\phi_k(k)}(y)\\). We\nnow have the following sequence of functional identities: \n\n\\[\\phi_n(y) \\simeq \\phi_{b(k)}(y) \\simeq  \\phi_{\\phi_k(k)}(y) \\simeq \\phi_{f(b(k))}(y) \\simeq \\phi_{f(n)}(y)\\]\n\n\n\u25a1\n\n\nThe Recursion Theorem is sometimes also referred to as the Fixed\nPoint Theorem. Note, however, that\n Theorem 3.5\n does not guarantee the existence of an extensional fixed point for\nthe given function \\(f(x)\\)\u2014i.e., a number \\(n\\) such that\n\\(f(n) = n\\). (In fact it is evident that there are computable\nfunctions for which no such value exists\u2014e.g., \\(f(x) = x+1\\).)\nBut suppose we view \\(f(x)\\) instead as a mapping on indices to\npartial computable functions or, more figuratively, as a means of\ntransforming a program for computing a partial computable\nfunction into another program. On this interpretation, the theorem\nexpresses that for every such computable transformation there is some\nprogram \\(n\\) such that the function \\(\\phi_n(y)\\) which it computes\nis the same as the function \\(\\phi_{f(n)}(y)\\) computed by its image\n\\(f(n)\\) under the transformation.\n\nAs it may at first appear such an \\(n\\) is defined in a circular\nmanner, it is also prima facie unclear why such a program\nmust exist. Indeed Soare (2016, 28\u201329) remarks that the\nforegoing proof of the Recursion Theorem is \u201cvery short but\nmysterious\u201d and is \u201cbest visualized as a diagonal argument\nthat fails\u201d. In order to clarify both this comment and the\nproof, consider the matrix depicted in Figure 1 whose rows \\(R_i\\)\nenumerate not the values of partial computable functions but rather\nthe functions themselves\u2014i.e., the row \\(R_i\\) will contain the\nfunctions \\(\\phi_{\\phi_i(0)}, \\phi_{\\phi_i(1)}, \\ldots\\) with the\nunderstanding that if \\(\\phi_i(j) \\uarrow\\), then \\(\\phi_{\\phi_i(j)}\\)\ndenotes the totally undefined function. (Such a depiction is\noriginally due to Owings 1973.)\n\n\n\n\\[\\begin{matrix}\n\\phi_{\\phi_{0}(0)} & \\phi_{\\phi_{0}(1)} &  \\ldots &  \\phi_{\\phi_{0}(i)} & \\ldots& \\phi_{\\phi_{0}(d)} & \\ldots& \\phi_{\\phi_{0}(h_{f}(i))}& \\ldots\\\\\n\\phi_{\\phi_{1}(0)} & \\phi_{\\phi_{1}(1)} & \\ldots & \\phi_{\\phi_{1}(i)} &  \\ldots& \\phi_{\\phi_{1}(d)} & \\ldots& \\phi_{\\phi_{1}(h_{f}(i))}& \\ldots\\\\\n\u22ee&& \u22f1 &&&&&\u22ee\\\\\n \\phi_{\\phi_{i}(0)} & \\ldots & \\ldots & \\phi_{\\phi_{i}(i)} & \\ldots &  \\phi_{\\phi_{i}(d)} & \\ldots&  \\phi_{\\phi_{i}(h_{f}(i))} & \\ldots \\\\\n\u22ee& & & & \u22f1 & &&\u22ee\\\\\n \\phi_{\\phi_{d}(0)} & \\ldots&  \\ldots& \\phi_{\\phi_{d}(i)} & \\ldots&  \\phi_{\\phi_{d}(d)} & \\ldots&  \\phi_{\\phi_{d}(h_{f}(i))}& \\ldots& \\phi_{\\phi_{d}(h_{f}(d))} \\ldots\\\\\n\u22ee& & & & & & \u22f1 & &&\\uarrow\\\\\n \\phi_{\\phi_{h_{f}(i)}(0)}& \\ldots & \\ldots&  \\phi_{\\phi_{h_{f}(i)}(i)}& \\ldots& \\phi_{\\phi_{h_{f}(i)}(d)}&  \\ldots& \\phi_{\\phi_{h_{f}(i)}(h_{f}(i))}& \\ldots &= \\\\\n\u22ee& & & & & && & \u22f1 &\\darrow\\\\\n\\phi_{\\phi_{h_{f}(d)}(0)}& \\ldots& \\ldots& \\phi_{\\phi_{h_{f}(d)}(i)}& \\ldots& \\phi_{\\phi_{h_{f}(d)}(d)}& \\ldots& \\phi_{\\phi_{h_{f}(d)}(h_{f}(i))}&\n    \\ldots&   \\phi_{\\phi_{h_{f}(d)}(h_{f}(d))} \\ldots\\\\\n \u22ee\\\\\n\\end{matrix}\\]\n\n\n\nFigure 1: The matrix of partial\ncomputable functions employed in the proof of the\n  Recursion Theorem (3.5)\n\n\n\nWe may think of the function \\(f(x)\\) given in\n Theorem 3.5\n as inducing a transformation on the rows so that \\(R_i\\) is mapped to\n\\(R_{f(i)}\\). To this end, let \\(h_f(x)\\) be an index to the total\ncomputable function which composes \\(f\\) with \\(\\phi_x\\) so that we\nhave  \n\\[\\begin{aligned}\n\\phi_{h_f(x)}(y) \\simeq f(\\phi_x(y))\\end{aligned}\\]\n\n\nNext consider the diagonal of this matrix\u2014i.e., \\(D =\n\\phi_{\\phi_0(0)}, \\phi_{\\phi_1(1)}, \\ldots\\) Since the indices to the\nfunctions which comprise \\(D\\) are given effectively, it must be the\ncase that \\(D\\) itself corresponds to some row \\(R_d\\)\u2014i.e.,\n \n\\[\\begin{align} \\label{dr} \n\\phi_{\\phi_d(i)}(y) \\simeq \\phi_{\\phi_i(i)}(y) \\text{ for all } i \\in \\mathbb{N}\n\\end{align}\\]\n\n\nBut now consider the image of \\(R_d\\) under \\(f\\)\u2014i.e., the row\n\\(R_{h_f(d)} = \\phi_{\\phi_{h_f(d)}(0)}, \\phi_{\\phi_{h_f(d)}(1)},\n\\ldots\\) It follows from (\\ref{dr}) that we must have \n\n\\[\\begin{equation} \\label{lastrecthm1}\n\\phi_{\\phi_d(h_f(d))}(y) \\simeq  \\phi_{\\phi_{h_f(d)}(h_f(d))}(y)\n\\end{equation}\\]\n\n\nBut note that by the definition of \\(h_f\\), \\(\\phi_{h_f(d)}(h_f(d)) =\nf(\\phi_d(h_f(d))\\) and thus also from (\\ref{lastrecthm1}) \n\n\\[\\begin{equation} \\label{lastrecthm2}\n\\phi_{\\phi_d(h_f(d))}(y) \\simeq  \\phi_{f(\\phi_d(h_f(d))}(y)\n\\end{equation}\\]\n\n\nBut now note that since \\(f,\\phi_d\\) and \\(h_f\\) are all total, the\nvalue \\(\\phi_d(h_f(d))\\) is defined. Thus setting \\(n =\n\\phi_d(h_f(d))\\) it follows from (\\ref{lastrecthm2}) that \\(\\phi_n(y)\n\\simeq \\phi_{f(n)}(y)\\) as desired.\n\nAs mentioned above, the Recursion Theorem may often be used to present\ncompact proofs of results which would traditionally be described as\ninvolving self-reference. For instance, an immediate\nconsequence is that for every \\(f(x)\\) there is an \\(n\\) such that\n\\(W_n = W_{f(n)}\\). To see this note that\n Theorem 3.5\n entails the existence of such an \\(n\\) such that \\(\\phi_n(x) \\simeq\n\\phi_{f(n)}\\) for every computable \\(f(x)\\). But since the domains of\nthe functions must then coincide, it follows that \\(W_n =\nW_{f(n)}\\).\n\nIt is useful to record the following alternative form of the Recursion\nTheorem:\n\n\nCorollary 3.2: For every partial computable function\n\\(f(x,y)\\), there is an index \\(n\\) such that \\(\\phi_n(y) \\simeq\nf(n,y)\\).\n\n\n\nProof: By the\n s-m-n Theorem (3.1),\n \\(f(x,y) \\simeq \\phi_{s^2_1(i,x)}(y)\\) for some \\(i\\). But then the\nexistence of the required \\(n\\) follows by applying\n Theorem 3.5\n to \\(s^2_1(i,x)\\). \u25a1\n\n\nHere are some easy consequences in the spirit described above which\nmake use of this formulation:\n\n\n\nThere is a number \\(n\\) such that \\(\\phi_n(x) = x + n\\). (This follows\nby taking \\(f(x,y) = x + n\\) in\n Corollary 3.2.\n Analogous observations yield the existence of \\(n\\) such that\n\\(\\phi_n(x) = x \\times n, \\phi_n(x) = x^n\\), etc.)\n\n\nThere is a number \\(n\\) such that \\(W_n = \\{n\\}\\). (Take \n\n\\[f(x,y) = \\begin{cases}\n0 & \\text{if } x = y \\\\\n \\uarrow & \\text{otherwise} \n\\end{cases}\\]\n\n\nin\n Corollary 3.2.)\n\n\nConsider a term \\(\\tau\\) corresponding to a \u201cprogram\u201d\nwhich determines the partial computable program with index \\(\\ulcorner\n\\tau \\urcorner\\) (as described in\n Section 2.2.2).\n We say that such a program is self-reproducing if for all\ninputs \\(x\\), the computation of \\(\\tau\\) on \\(x\\) outputs \\(\\ulcorner\n\\tau \\urcorner\\). Since in order to construct \\(\\tau\\) it would seem\nthat we need to know \\(\\ulcorner \\tau \\urcorner\\) in advance, it might\nappear that self-reproducing programs need not exist. Note, however,\nthat transposed back into our official terminology, the existence of\nsuch a program is equivalent to the existence of a number \\(n\\) such\nthat \\(\\phi_n(x) = n\\). And this is guaranteed by applying\n Corollary 3.2\n to the function \\(f(x,y) = x\\).\n\n\nFor further discussions of the Recursion Theorem in regard to\nself-reference and more advanced applications in computability theory\nsee, e.g., Cutland (1980, ch. 11), Rogers (1987, ch. 11), Odifreddi\n(1989, ch. II.2), and Y. Moschovakis (2010).\n\nBefore leaving the Recursion Theorem, it will finally be useful to\nreflect on how it bears on the general concept of recursive\ndefinability as discussed in\n Sections 1 and 2.\n Consider, for instance, a simple definition such as \n\n\\[\\begin{align} \\label{recex}\nh(0) & = k \\\\ \\nonumber\nh(y+1) & = g(h(y))\n\\end{align}\\]\n\n\nIn the case that \\(f(y)\\) and \\(g(y)\\) are primitive recursive, we\nhave remarked that it is possible to show that there exists a unique\nfunction \\(h(y)\\) satisfying (\\ref{recex}) by an external\nset-theoretic argument. But we may also consider the case in which\n\\(g(y)\\) is assumed to be computable relative to a model of\ncomputation \\(\\mathbf{M}\\) which differs from the partial recursive\nfunctions in that it does not natively support recursion as a mode of\ncomputation\u2014e.g., the Turing Machine model \\(\\mathbf{T}\\) or\nUnlimited Register Machine model \\(\\mathbf{U}\\). If we simply set down\n(\\ref{recex}) as a definition in this case, we would have no a\npriori assurance that \\(h(y)\\) is computable relative to\n\\(\\mathbf{M}\\) even if \\(g(x)\\) is.\n\nUpon examination, however, it is clear that the only features of a\nmodel of computation on which the proof of\n Theorem 3.5\n relies are the existence of an indexation for which a version of the\n s-m-n Theorem (3.1)\n is available. If \\(\\mathbf{M}\\) satisfies these conditions, the claim\nthat \\(h(y)\\) is computable relative to \\(\\mathbf{M}\\) is equivalent\nto \\(h(y) \\simeq \\phi_n(y)\\) where \\(n\\) is an index drawn from some\nsuitable indexation of the \\(\\mathbf{M}\\)-computable functions. But\nsince the s-m-n Theorem for \\(\\mathbf{M}\\) allows us to treat\nan index as a variable, we can also consider the function defined by\n \n\\[\\begin{aligned}\nf(x,0) & = k \\\\ \\nonumber\nf(x,y+1) & = g(\\phi_x(y))\\end{aligned}\\]\n\n\nNow note that the existence of an \\(n\\) such that \\(f(n,y) \\simeq\n\\phi_n(y)\\) is again guaranteed by\n Corollary 3.2.\n This in turn yields  \n\\[\\begin{aligned}\n\\phi_n(0) & = k \\\\ \\nonumber\n\\phi_n(y+1) & = g(\\phi_n(y))\\end{aligned}\\]\n\n\nThis illustrates how the existence of a computable function satisfying\na recursive definition such as (\\ref{recex}) follows from the\nRecursion Theorem even if we have not started out by characterizing a\n\u201ccomputable function\u201d as one defined\n\u201crecursively\u201d in the informal sense discussed in\n Section 1.\n And this in turn helps to explain why\n Theorem 3.5\n has come to be known as the Recursion Theorem.\n3.5 Reducibilities and Degrees\n\nA central topic in contemporary computability theory is the study of\nrelative computability\u2014i.e., if we assume that\nwe are able to decide membership in a given set or compute a given\nfunction, which other sets or functions would we be able to decide or\ncompute? This question may be studied using the notion of a\nreduction of one set \\(A\\) to another \\(B\\) which was\nintroduced informally by Kolmogorov (1932) as a means of transforming\na \u201csolution\u201d of \\(A\\) into a \u201csolution\u201d of\n \\(B\\).[23]\n Turing (1939) provided the first formal definition of a computational\nreduction in his study of ordinal logics. However, it was Post who\nfirst proposed to systematically study reducibility notions and their\nassociated degree structures in his highly influential paper\n\u201cRecursively enumerable sets of positive integers and their\ndecision problems\u201d (1944).\n\nTherein Post explains the basic idea of a reduction and its\nsignificance as follows:\n\n\nRelated to the question of solvability or unsolvability of problems is\nthat of the reducibility or non-reducibility of one problem to\nanother. Thus, if problem \\(P_1\\) has been reduced to problem \\(P_2\\),\na solution of \\(P_2\\) immediately yields a solution of \\(P_1\\), while\nif \\(P_1\\) is proved to be unsolvable, \\(P_2\\) must also be\nunsolvable. For unsolvable problems the concept of reducibility leads\nto the concept of degree of unsolvability, two unsolvable problems\nbeing of the same degree of unsolvability if each is\nreducible to the other, one of lower degree of unsolvability than\nanother if it is reducible to the other, but that other is not\nreducible to it, of incomparable degrees of unsolvability if neither\nis reducible to the other. A primary problem in the theory of\nrecursively enumerable sets is the problem of determining the degrees\nof unsolvability of the unsolvable decision problems thereof. We shall\nearly see that for such problems there is certainly a highest degree\nof unsolvability. Our whole development largely centers on the single\nquestion of whether there is, among these problems, a lower degree of\nunsolvability than that, or whether they are all of the same degree of\nunsolvability. (Post 1944, 289)\n\n\nIn order to appreciate this passage, it is again useful to think of a\nset \\(A \\subseteq \\mathbb{N}\\) as being associated with the\nproblem of deciding membership in \\(A\\)\u2014e.g., given a\nnatural number \\(n\\), is \\(n\\) prime? (i.e., \\(n \\in\n\\textit{PRIMES}\\)?) or is the \\(n\\)th partial computable function with\ninput \\(n\\) defined? (i.e., \\(n \\in K\\)?). But even given this\ncorrespondence, the assertion that a solution to a problem \\(B\\)\n\u201cimmediately yields\u201d a solution to \\(A\\) may still be\nanalyzed in a number of different ways. Two of the most important\npossibilities are as follows:\n\n\n\nAssuming that there is an algorithm for deciding questions of the form\n\\(n \\in B\\), then it is possible to specify an algorithm for deciding\nquestions of the form \\(n \\in A\\).\n\n\nAssuming that we had access to an \u201coracle\u201d\ncapable of answering arbitrary questions of the form \\(n \\in B\\) in a\nsingle step, then it is possible to specify an algorithm employing the\noracle for deciding \\(n \\in A\\).\n\n\nThe formalization of these relations between problems leads to the\nnotions of many-one reducibility and Turing\nreducibility which provide distinct but complementary analyses of\nthe notions \\(A\\) is no harder to solve than \\(B\\) and also\nthe degree of unsolvability (or difficulty) of\n\\(A\\) is equal to that of\n \\(B\\).[24]\n The latter notion came first historically and was introduced by\nTuring (1939) and in an equivalent form by Kleene (1943). However it\nwas Post (1944) who both introduced the former notion and also\ninitiated the general study of Turing reducibility. In fact the final\nsentence of the passage quoted above describes an important technical\nquestion about the Turing degrees which would shape the early\ndevelopment of computability theory (i.e., \u201cPost\u2019s\nproblem\u201d given as\n Question 3.1\n below).\n3.5.1 The many-one degrees\n\nWe have already seen an example of many-one reducibility in the proof\nof\n Rice\u2019s Theorem (3.4).\n In particular, the proof showed that the problem of deciding\nmembership in \\(K\\) can be reduced to that of deciding membership in\nany non-trivial index set \\(I\\) in the following sense: for all \\(n\\),\nif \\(n \\in K\\) then \\(s^2_1(c,n) \\in I\\). Thus if there were an\nalgorithm for deciding membership in \\(I\\), we would be able to decide\nwhether \\(n \\in K\\) by using it to test whether \\(s^2_1(c,n) \\in I\\).\nThe function \\(s^2_1(c,x)\\) (whose computability is given by the\ns-m-n Theorem) is thus a so-called many-one reduction\nof \\(K\\) to \\(I\\).\n\nThe formal definition generalizes this example as follows:\n\n\nDefinition 3.3: Given sets \\(A, B \\subseteq\n\\mathbb{N}\\), \\(A\\) is said to be many-one (or \\(m\\)-one)\nreducible to \\(B\\) if there is a computable function \\(f(x)\\)\nsuch that for all \\(n \\in \\mathbb{N}\\),  \n\\[n \\in A \\text{ in and only if } f(n) \\in B\\]\n\n\nIn this case we write \\(A \\leq_m B\\).\n\n\nUsing this notation, the foregoing example thus shows that \\(K \\leq_m\nI\\). These observations can generalized as follows:\n\n\nProposition 3.5: Suppose that \\(A \\leq_m B\\).\n\n\n\nIf \\(B\\) is computable, then so is \\(A\\).\n\n\nIf \\(B\\) is computably enumerable, then so is \\(A\\).\n\n\n\nBy contraposing\n Proposition 3.5\n it thus follows that in order to show that a set \\(B\\) is\nnon-computable (or non-c.e.) it suffices to show that a known\nnon-computable (or non-c.e.) set can be reduced to it. As an initial\nexample, observe that the Diagonal Halting Problem \\(K = \\{i :\n\\phi_i(i) \\darrow\\}\\) is reducible to the Halting Problem \\(\\HP =\n\\{\\langle i,n \\rangle : \\phi_i(n) \\darrow\\}\\) by the reduction \\(f(x)\n= \\langle x,x \\rangle\\)\u2014i.e., the computable pairing function of\n\\(x\\) with itself is a many-one reduction showing \\(K \\leq_m \\HP\\).\nThus since \\(\\HP\\) is known to be non-computable, this gives another\nproof that \\(K\\) also is not computable.\n\nReducibility notions also typically come with an associated notion of\nwhat it means for a designated set to be complete relative to\na class of sets\u2014i.e., a set to which every set in the class may\nbe reduced and which is itself a member of the class. As an initial\nexample we have the following:\n\n\nDefinition 3.4: A set \\(B\\) is said to be\nmany-one (or \\(m\\)-) complete for the computably\nenumerable sets just in case the following conditions hold:\n\n\n\n\\(B\\) is computable enumerable;\n\n\nFor all computably enumerable sets \\(A\\), \\(A \\leq_m B\\).\n\n\n\nAn obvious example of a complete c.e. set is \\(\\HP\\). For since \\(\\HP\n= \\{\\langle i,n \\rangle : \\exists s T_1(i,n,s)\\}\\) and \\(T_1(x,y,z)\\)\nis a computable relation, it follows from\n Proposition 3.2\n that \\(\\HP\\) is c.e. And on the other hand, if \\(A = W_i\\), then \\(n\n\\in A\\) if and only if \\(\\langle i,n \\rangle \\in \\HP\\) thus showing\nthat \\(W_i \\leq_m \\HP\\).\n\nIt is, nonetheless, standard to take \\(K\\) rather than \\(\\HP\\) as the\ncanonical complete c.e. Although it might at first seem that \\(K\\)\ncontains \u201cless computational information\u201d than \\(\\HP\\), it\nis not hard to see that \\(K\\) is also such that every c.e. set is\n\\(m\\)-reducible to it. For supposing that \\(A = W_i\\), we may define a\nfunction  \n\\[\\begin{aligned} \\label{redK}\nf(x,y) = \\begin{cases} 1 & \\text{ if } \\phi_i(x) \\darrow \\text{ (i.e., $x \\in A$)} \\\\\n\\uarrow & \\text{otherwise}\n\\end{cases}\\end{aligned}\\]\n\n\nAs \\(f(x,y)\\) is clearly partial computable, the\n s-m-n Theorem (3.1)\n gives a total recursive function \\(s^2_1(i,x)\\) such that \\(f(x,y)\n\\simeq \\phi_{s^2_1(i,x)}(y)\\). We then have  \n\\[n \\in A \\ \\Leftrightarrow \\ \\phi_i(n) \\darrow \\ \\Leftrightarrow \\ \\phi_{s^2_1(i,n)}(s^2_1(i,n)) \\darrow \\  \\Leftrightarrow \\ s^2_1(i,n) \\in K\\]\n\n\nThese biconditionals hold because \\(\\phi_i(n) \\darrow\\) just in case\n\\(\\phi_{s^2_1(i,n)}(y)\\) is \\(\\const_1(x)\\) (i.e., the constant\n1-function) as opposed to the everywhere undefined function just in\ncase \\(\\phi_{s^2_1(i,n)}(s^2_1(i,n)) \\darrow\\). But as the later\ncondition is equivalent to \\(s^2_1(i,n) \\in K\\), \\(s^2_1(i,x)\\) is a\nmany-one reduction showing \\(A \\leq_m K\\).\n\nThis illustrates a sense in which deciding membership in \\(K\\) can\nalso be understood as universal for computably enumerable sets or,\nalternatively, that there is no c.e. set which is any\n\u201charder\u201d to solve than \\(K\\). Nonetheless, there are\nproblems that are harder to solve than \\(K\\) in the sense that they\ncould not be solved even if we possessed a decision algorithm for\n\\(K\\). For instance, it will follow from results given below that\nwhile \\(K\\) is \\(m\\)-reducible to \\(\\TOT\\), \\(\\TOT\\) is not\n\\(m\\)-reducible to \\(K\\). This illustrates how \\(m\\)-reducibility can\nbe used to study the relative difficulty of solving\ncomputational problems.\n\nThese considerations lead naturally to the notion of a degree of\ndifficulty\u2014another concept which can be made precise with\nrespect to different reducibility notions. The version for many-one\nreducibility is given by the following definition:\n\n\nDefinition 3.5: If \\(A\\) and \\(B\\) are many-one\nreducible to each other\u2014i.e., \\(A \\leq_m B\\) and \\(B \\leq_m\nA\\)\u2014then we say that \\(A\\) and \\(B\\) are many-one\nequivalent and we write \\(A \\equiv_m B\\).\n\n\nIt follows immediately from\n Definition 3.3\n that \\(\\leq_m\\) is reflexive. It is also clearly transitive. (For if\n\\(f(x)\\) and \\(g(x)\\) are computable functions which respectively\nserve as many-one reductions showing \\(A \\leq_m B\\) and \\(B \\leq_m\nC\\), then their composition \\(f(g(x))\\) is a many-one reduction\nshowing \\(A \\leq_m C\\).) As it thus follows that \\(\\equiv_m\\) is an\nequivalence relation, it also makes sense to define the following:\n\n\nDefinition 3.6: \\(\\textrm{deg}_m(A)\\)\u2014the\nmany-one (or \\(m\\)-) degree of \\(A\\)\u2014is the\nequivalence class of \\(A\\) with respect to \\(\\equiv_m\\)\u2014i.e.,\n\\(\\textrm{deg}_m(A) = \\{B \\subseteq \\mathbb{N} : B \\equiv_m A\\}\\). We\ncall an \\(m\\)-degree computable if it contains a computable\nset and c.e.\u00a0if it contains a computably enumerable set.\n\n\n\nThe \\(m\\)-degree \\(\\textrm{deg}(A)\\) of \\(A\\) collects together all\nsets which are many-one equivalent to it. It can thus be thought of as\nan abstract representation of the relative difficulty of deciding\nmembership in \\(A\\) when this latter notion is in turn explicated in\nterms of \\(m\\)-reducibility. For instance, since our prior\nobservations show that \\(\\textrm{deg}_m(\\HP) = \\textrm{deg}_m(K)\\),\nthey are thus \u201cequally difficult\u201d c.e.\u00a0degrees.\n\nIt is traditional to use boldface lower case Roman letters\n\\(\\mathbf{a},\\mathbf{b}, \\ldots\\) to denote degrees (although it\nshould be kept in mind that these are sets of sets of natural\nnumbers). We next define an ordering on \\(m\\)-degrees as\nfollows:\n\n\nDefinition 3.7: Let \\(\\mathbf{a}\\) and \\(\\mathbf{b}\\)\nbe \\(m\\)-degrees. We then define\n\n\n\n\\(\\mathbf{a} \\leq_m \\mathbf{b}\\) just in case there is a set \\(A \\in\n\\mathbf{a}\\) and a set \\(B \\in \\mathbf{b}\\) such that \\(A \\leq_m\nB\\).\n\n\n\\(\\mathbf{a} <_m \\mathbf{b}\\) just in case \\(\\mathbf{a} \\leq_m\n\\mathbf{b}\\) and \\(\\mathbf{a} \\neq \\mathbf{b}\\).\n\n\n\nIt is easy to see that \\(<_m\\) is a partial order on\n\\(m\\)-degrees\u2014i.e., irreflexive, antisymmetric, and transitive.\nWe accordingly introduce the structure \\(\\mathcal{D}_m = \\langle\n\\{\\textrm{deg}_m(A) : A \\subseteq \\mathbb{N}\\}, <_m\\rangle\\) which\nis traditionally known as the many-one (or m-)\ndegrees.\n\nTogether with the similar study of the Turing degrees (which will be\ndefined in\n Section 3.5.2),\n investigating the structure of \\(\\mathcal{D}_m\\) has been a major\nfocus of research in computability theory since the time of\nPost\u2019s (1944) introduction of the many-one degrees. Some\nproperties of this structure are as follows:\n\n\nProposition 3.6:\n\n\n\nThe \\(m\\)-degrees are not closed under complementation\u2014i.e.,\nthere exist sets \\(A\\) such that \\(A \\not\\equiv_m \\overline{A}\\) and\nthus \\(\\overline{A} \\not\\in \\textrm{deg}(A)\\).\n\n\n\\(\\mathbf{0} =_{\\textrm{df}} \\textrm{deg}_m(\\emptyset) =\n\\{\\emptyset\\}\\) and \\(\\mathbf{n} =_{\\textrm{df}}\n\\textrm{deg}_m(\\mathbb{N}) = \\{\\mathbb{N}\\}\\) are distinct\n\\(m\\)-degrees both of which are (trivially) computable.\n\n\nThere is exactly one computable \\(m\\)-degree \\(\\mathbf{0}_m\\) other\nthan \\(\\mathbf{0}\\) and \\(\\mathbf{n}\\)\u2014i.e., \\(\\mathbf{0}_m =\n\\textrm{deg}(A)\\) for any computable set \\(A \\neq \\emptyset, A\\neq\n\\mathbb{N}\\). Additionally, \\(\\mathbf{0}_m\\) is minimal in\n\\(\\mathcal{D}_m\\) in the sense that \\(\\mathbf{0}_m \\leq_m \\mathbf{a}\\)\nfor all degrees \\(\\mathbf{a}\\) other than \\(\\mathbf{0}\\) and\n\\(\\mathbf{n}\\).\n\n\nIf \\(\\mathbf{b}\\) is a c.e.\u00a0degree and \\(\\mathbf{a} \\leq_m\n\\mathbf{b}\\), then \\(\\mathbf{a}\\) is also a c.e.\u00a0degree.\n\n\nThere is a maximum c.e.\u00a0\\(m\\)-degree\u2014i.e.,\n\\(\\textrm{deg}_m(K) =_{\\textrm{df}} \\mathbf{0}'_m\\)\u2014in the sense\nthat \\(\\mathbf{a} \\leq \\mathbf{0}'_m\\) for all c.e.\u00a0degrees\n\\(\\mathbf{a}\\).\n\n\nAny pair of \\(m\\)-degrees \\(\\mathbf{a},\\mathbf{b}\\) have a least\nupper bound \\(\\mathbf{c}\\)\u2014i.e., \\(\\mathbf{a} \\leq_m\n\\mathbf{c}\\) and \\(\\mathbf{b} \\leq_m \\mathbf{c}\\) and \\(\\mathbf{c}\\)\nis \\(\\leq_m\\)-less than any other upper bound of \\(\\mathbf{a}\\) and\n\\(\\mathbf{b}\\). Since we have seen that \\(\\leq_m\\) is also a partial\norder, this implies that \\(\\mathcal{D}_m\\) is additionally an\nupper semi-lattice.\n\n\nThere exists a c.e.\u00a0degree \\(\\mathbf{a}\\) properly between\n\\(\\mathbf{0}_m\\) and \\(\\mathbf{a} < \\mathbf{0}'_m\\)\u2014i.e.,\n\\(\\mathbf{0}_m < \\mathbf{a} < \\mathbf{0}'_m\\).\n\n\n\nPost (1944) demonstrated part vii by showing that there exist\nso-called simple sets\u2014i.e., sets \\(A\\) which are\nc.e.\u00a0and such that \\(\\overline{A}\\) is infinite but does not\ncontain an infinite c.e.\u00a0subset. It is easy to see that a simple\nset cannot be computable. But on the other hand, Post also showed that\na simple set cannot be \\(m\\)-complete. And it thus follows that if\n\\(A\\) is simple \\(\\mathbf{a} =_{\\textrm{df}} \\textrm{deg}_m(A) \\neq\n\\mathbf{0}_m\\) but \\(A \\not\\equiv_m K\\) and thus \\(\\mathbf{a} <\n\\mathbf{0}'_m\\). Suppose we now understand \u201cdegrees of\nunsolvability\u201d in the passage quoted at the beginning of this\nsection as corresponding to the c.e.\u00a0\\(m\\)-degrees. It thus\nfollows from part v of\n Proposition 3.6\n that \\(\\mathbf{0}'_m\\) is indeed a \u201chighest\u201d such degree\nand also from part vii that there is a lower but still\n\u201cunsolvable\u201d (i.e., non-computable) degree.\n\nAlthough the other parts of\n Proposition 3.6\n have straightforward proofs, they provide some insight into the fact\nthat \\(\\mathcal{D}_m\\) is itself a highly complex structure (see,\ne.g., Odifreddi 1999b, 1). Nonetheless the first two parts of this\ntheorem are often taken to illustrate awkward features of the many-one\ndegrees as an abstract representation of computational\ndifficulty\u2014i.e., the exceptional behavior of\n\\(\\textrm{deg}_m(\\emptyset)\\) and \\(\\textrm{deg}_m(\\mathbb{N})\\) and\nthe fact a set and its complement may inhabit different degrees (as is\neasy to see is exemplified by \\(K\\) and \\(\\overline{K}\\)). It is\npartly in light of these features that the Turing degrees\n\\(\\mathcal{D}_T\\) are the structure which are now most widely studied\nin computability theory. But as Post also alludes, it is relative to\n\\(\\mathcal{D}_T\\) for which he was originally unable to demonstrate\nthe existence of a c.e.\u00a0set of an intermediate degree of\nunsolvability.\n3.5.2 The Turing degrees\n\nThe notion of relative computability mentioned at the\nbeginning of this section is now standardly analyzed in terms of\ncomputability in a set \\(A \\subseteq \\mathbb{N}\\).\nInformally, we say that a function \\(f(\\vec{x})\\) is computable in\n\\(A\\) just in case there exists an algorithm which is effective in the\ntraditional sense with the exception of the fact its computation may\nrely on computing one or more values \\(\\chi_A(y)\\). These values are\nin turn assumed to be available to the algorithm in a single step even\nthough \\(\\chi_A(y)\\) may not itself be computable\u2014e.g., if \\(A =\nK\\).\n\nThis notion was originally introduced by Turing (1939) who described\nwhat he referred to as an oracle (or o-)\nmachine variant of the standard Turing Machine model\n\\(\\mathbf{T}\\). An o-machine is otherwise like a normal Turing machine\nbut also possesses a read-only oracle tape (and corresponding\nread-only head) on which the characteristic function of a set \\(A\\) is\nassumed to be written at the beginning of its computation. The\ntransitions of an o-machine are determined by its internal state\ntogether with the currently scanned symbols on both its read-write\ntape and the oracle tape, thus formalizing the idea that the machine\nmay \u201cconsult the oracle\u201d about the characteristic function\nof \\(A\\) one or more times during the course of its\n computation.[25]\n\n\nKleene (1943) described an analogous idea for the general\nrecursive functions as follows:\n\n\nA function \\(\\phi\\) which can be defined from given functions\n\\(\\psi_1, \\ldots, \\psi_k\\) by a series of applications of general\nrecursive schemata we call general recursive in the given\nfunctions; and in particular, a function definable ab initio\nby these means we call general recursive. (Kleene 1943:\n44)\n\n\nThe former part of this characterization differs from the definition\nof general recursiveness given in\n Section 1.5\n in allowing that in addition to the initial functions \\(\\mathbf{0}\\)\nand \\(s(x)\\), the functions \\(\\psi_1, \\ldots, \\psi_k\\) can also enter\ninto systems of equations which define the function \\(\\phi\\). This\ncorresponds to the assumption that the values of \\(\\psi_1, \\ldots,\n\\psi_k\\) are available in the course of a computation without the need\nfor further calculation.\n\nIt is also possible to modify the definition of the partial\nrecursive functions given in\n Section 2.2.1\n to allow such relativization to an additional class of initial\nfunctions. Since relativization to a finite set of functions can be\naccomplished by successive relativization to a single function and the\ngraph of a function can also be coded into a set, this is now\nstandardly achieved as follows:\n\n\nDefinition 3.8: Given a set \\(A \\subseteq\n\\mathbb{N}\\), we define the class of \\(A\\)-partial recursive\nfunctions \\(\\mathbf{PartREC}^A\\) to be the smallest class of\npartial functions containing the initial functions \\(I_A =\n\\{\\mathbf{0},s,\\pi^i_k,\\chi_A(x)\\}\\) and closed under the\nfunctionals \n\\[Op_{\\mathbf{PartREC}} = \\{\\mathcal{Comp}^i_j,\\mathcal{PrimRec}_k,\\mathcal{Min}_k\\}.\\]\n\n\n\nThere are, of course, uncountably many subsets of the natural numbers.\nBut for each such \\(A \\subseteq \\mathbb{N}\\), we may still understand\n\\(\\chi_A(x)\\) as a new primitive functional symbol which can be\nemployed in constructing one of countably many \\(A\\)-partial recursive\ndefinitions in the manner discussed in\n Section 2.1.1.\n It is thus also possible to list off all of the unary \\(A\\)-partial\nrecursive functions relative to the codes of their definitions to\nobtain a uniform enumeration  \n\\[\\begin{aligned}\n\\phi_0^{A}(x), \\phi_1^{A}(x), \\phi^{A}_2(x), \\ldots\\end{aligned}\\]\n\n\nand similarly for other arities. It is thus not difficult to see that\nwe can thereby also obtain relativized versions of results like the\n s-m-n Theorem (3.1)\n and the Universality Theorem\n (3.2)\n as exemplified by the following:\n\n\nTheorem 3.6: For all \\(A \\subseteq \\mathbb{N}\\),\nthere is an \\(A\\)-partial computable function \\(\\upsilon\\) which is\nuniversal in the sense that for all unary \\(A\\)-partial\ncomputable functions \\(f(\\vec{x})\\), there is an \\(i \\in \\mathbb{N}\\)\nsuch that \\(\\upsilon^{A}(i,x) \\simeq f(x)\\).\n\n\nThese observations in turn license the use of the expression\ncomputable in \\(A\\) to describe both a function\n\\(f(\\vec{x})\\) which is \\(A\\)-partial recursive and total and also a\nset \\(B\\) such that \\(\\chi_B(x)\\) is computable in \\(A\\). We also use\nthe expression computably enumerable (c.e.) in \\(A\\)\nto describe a set \\(B\\) which is the range of an \\(A\\)-partial\nrecursive function and the notation \\(W^A_e\\) to denote the domain of\n\\(\\phi^{A}_e(x)\\). It is then straightforward to see that many of our\nprior proofs about non-computability also carry over to the\nrelativized setting\u2014e.g., \\(K^A = \\{i : \\phi^{A}_i(i)\\darrow\\}\\)\nis an example of a set which is computably enumerable in \\(A\\) but not\ncomputable in \\(A\\).\n\nWe may now state the definition of Turing reducibility as\nfollows:\n\n\nDefinition 3.9: Given sets \\(A, B \\subseteq\n\\mathbb{N}\\), \\(A\\) is said to be Turing (or \\(T\\)-)\nreducible to \\(B\\) just in case \\(A\\) is computable in \\(B\\).\nIn this case we write \\(A \\leq_T B\\).\n\n\nIt is a consequence of this definition that \\(A \\leq_T B\\) just in\ncase \\(\\chi_A(x)\\) coincides with the (total) \\(B\\)-computable\nfunction given by \\(\\phi^{B}_e(x)\\) for some index \\(e\\). For instance\nif we adopt Turing\u2019s characterization of relative computability,\nwe may think of \\(e\\) as describing a program for a machine which can\nconsult \\(B\\) as an oracle. In this case, \\(A \\leq_T B\\) means that it\nis possible to decide if \\(n \\in A\\) by carrying out the program\ndescribed by \\(e\\) on the input \\(n\\) which may in turn require\nperforming queries to the oracle \\(B\\) during the course of its\ncomputation.\n\nWe may also define a notion of completeness with respect to \\(\\leq_T\\)\nas follows:\n\n\nDefinition 3.10: We say that \\(B\\) is Turing\ncomplete if \\(B\\) is c.e.\u00a0and all c.e.\u00a0sets \\(A\\) are\nsuch that \\(A \\leq_T B\\).\n\n\nIt is easy to see that \\(A \\leq_m B\\) implies \\(A \\leq_T B\\). (For if\n\\(f(x)\\) is a \\(m\\)-reduction of \\(A\\) to \\(B\\), then consider the\nprogram which first computes \\(f(n)\\) and then, using \\(B\\) an as\noracle, checks if \\(f(n) \\in B\\), outputting 1 if so and 0 if not.) It\nthus follows that \\(K\\) is also Turing complete\u2014i.e., it\nembodies the maximum \u201cdegree of unsolvability\u201d among the\nthe c.e.\u00a0sets when this notion is understood in terms of Turing\nreducibility as well as many-one reducibility.\n\nSuch observations can be made precise by first defining the notion of\nTuring equivalence:\n\n\nDefinition 3.11: If \\(A\\) and \\(B\\) are Turing\nreducible to each other\u2014i.e., \\(A \\leq_T B\\) and \\(B \\leq_T\nA\\)\u2014then we say that \\(A\\) and \\(B\\) are Turing\nequivalent and we write \\(A \\equiv_T B\\).\n\n\nAs it is again easy to see that \\(\\equiv_T\\) is an equivalence\nrelation, we may also define the notion of Turing degree as\nfollows:\n\n\nDefinition 3.12: \\(\\textrm{deg}_T(A)\\)\u2014the\nTuring degree of \\(A\\)\u2014is the equivalence class of\n\\(A\\) with respect to \\(\\equiv_T\\)\u2014i.e., \\(\\textrm{deg}_T(A) =\n\\{B \\subseteq \\mathbb{N} : B \\equiv_T A\\}\\).\n\n\nWe can now define an ordering on Turing degrees as follows:\n\n\nDefinition 3.13: Let \\(\\mathbf{a}\\) and\n\\(\\mathbf{b}\\) be Turing degrees. We then define\n\n\n\n\\(\\mathbf{a} \\leq_T \\mathbf{b}\\) just in case there is a set \\(A \\in\n\\mathbf{a}\\) and a set \\(B \\in \\mathbf{b}\\) such that \\(A \\leq_T\nB\\).\n\n\n\\(\\mathbf{a} <_T \\mathbf{b}\\) just in case \\(\\mathbf{a} \\leq_T\n\\mathbf{b}\\) and \\(\\mathbf{a} \\neq \\mathbf{b}\\).\n\n\n\nAs with the \\(m\\)-degrees, we say that \\(\\mathbf{a}\\) is a\ncomputable Turing degree if it contains a computable set and\na computably enumerable (c.e.) degree if it contains\na c.e.\u00a0set. If we consider the structure \n\\[\\mathcal{D}_T = \\langle \\{\\textrm{deg}_T(A) : A \\subseteq \\mathbb{N}\\},\\leq_T\\rangle\n\\]\n\n\n\u2014which is known as the Turing degrees\u2014it is again\neasy to see that \\(\\leq_T\\) is a partial order. Some observations\nwhich illustrate the relationship between \\(\\mathcal{D}_T\\) and the\nmany-one degrees \\(\\mathcal{D}_m\\) are as follows:\n\n\nTheorem 3.7:\n\n\n\nThere is exactly one computable Turing degree denoted by\n\\(\\mathbf{0}_T = \\textrm{deg}_T(\\emptyset)\\) (which is often written\n\\(\\mathbf{0}\\) when there is no possibility of ambiguity with the\n\\(m\\)-degrees). \\(\\mathbf{0}_T\\) consists of all of the computable\nsets and is the unique minimum Turing degree.\n\n\nFor all sets \\(A\\), and \\(A \\equiv_T \\overline{A}\\) and thus also\n\\(\\textrm{deg}_T(A) = \\textrm{deg}_T(\\overline{A})\\).\n\n\n\\(\\textrm{deg}_T(K)\\) is the maximum amongst all c.e.\u00a0Turing\ndegrees.\n\n\nFor any sets \\(A,B\\), \\(\\textrm{deg}_m(A) \\subseteq\n\\textrm{deg}_T(A)\\) and if  \n\\[\\textrm{deg}_m(A) \\leq_m \\textrm{deg}_m(B),\\]\n\n\nthen \n\\[\\textrm{deg}_T(A) \\leq_T \\textrm{deg}_T(B).\\]\n\n\n\n\nSince \\(\\emptyset\\) and \\(\\mathbb{N}\\) are both (trivially) computable\nsets, by part i) we have \\(\\textrm{deg}_T(\\emptyset) =\n\\textrm{deg}_T(\\mathbb{N}) = \\mathbf{0}_T\\), unlike the \\(m\\)-degrees.\nAnd also unlike the \\(m\\)-degrees we have by part ii that\n\\(\\textrm{deg}_T(A) = \\textrm{deg}_T(\\overline{A})\\). (For if we can\ndecide \\(B\\) via an algorithm which uses \\(A\\) an as oracle, then we\ncan also decide it using \\(\\overline{A}\\) as an oracle by simply\nswapping the responses obtained in our former algorithm.)\n\nThe structures of both \\(\\mathcal{D}_T\\) and the c.e.\u00a0degrees\n\n\\[\\mathcal{E}_T = \\langle \\{\\textrm{deg}_T(A) : A \\text{ is c.e.}\\}, \\leq_T\\rangle\\]\n\n\nhave been extensively investigated since the 1950s. One of their most\nbasic properties may be considered by first defining the operation of\nsets  \n\\[A \\oplus B = \\{2n : n \\in A\\} \\cup \\{2n+1 : n \\in B\\}.\\]\n\n\n\\(A \\oplus B\\) is called the effective join of \\(A\\) and\n\\(B\\) as it encodes the \u201cinformation\u201d contained in \\(A\\)\non the even members of \\(A \\oplus B\\) and that contained \\(B\\) on its\nodd members. \\(A \\oplus B\\) is c.e.\u00a0if both \\(A\\) and \\(B\\) are.\nSuppose we also define the operation  \n\\[\\textrm{deg}_T(A) \\vee \\textrm{deg}_T(B) =_{\\textrm{df}} \\textrm{deg}(A \\oplus B)\\]\n\n\non the degrees \\(\\mathbf{a} = \\textrm{deg}_T(A)\\) and \\(\\mathbf{b} =\n\\textrm{deg}_T(B)\\). Then it is not difficult to see that \\(\\mathbf{a}\n\\vee \\mathbf{b}\\) is the least upper bound of \\(\\mathbf{a}\\)\nand \\(\\mathbf{b}\\) with respect to the structure \\(\\mathcal{D}_T\\).\nLike the \\(m\\)-degrees, \\(\\mathcal{D}_T\\) and \\(\\mathcal{E}_T\\) both\nform an upper semi-lattice\u2014i.e., a partial order in\nwhich least upper bounds always\n exist.[26]\n\n\nGiven \\(A \\subseteq \\mathbb{N}\\), we may also consider \\(K^A =\\{n :\n\\phi^{A}_n(n) \\darrow\\}\\)\u2014i.e., the set considered above which\ncorresponds to the Diagonal Halting Problem relativized to the oracle\n\\(A\\). \\(K^A\\) is referred to as the jump of \\(A\\) for which\nwe also write \\(A'\\). This notation is also used to denote an\noperation on Turing degrees by setting \\(\\mathbf{a}' =\n\\textrm{deg}_T(A')\\) for some representative \\(A \\in \\mathbf{a}\\). The\nfollowing collects together several facts about the jump operation on\nboth sets and degrees:\n\n\nProposition 3.7: For any set \\(A, B \\subseteq\n\\mathbb{N}\\) with \\(\\textrm{deg}_T(A) = \\mathbf{a}\\) and\n\\(\\textrm{deg}_T(B) = \\mathbf{b}\\):\n\n\n\nIf \\(A\\) is computable, then \\(K^A \\equiv_T K\\).\n\n\n\\(A'\\) is c.e.\u00a0in \\(A\\) but not computable in \\(A\\).\n\n\nIf \\(A \\leq_T B\\), then \\(A' \\leq_T B'\\) and if \\(A \\equiv_T B\\), then\n\\(A' \\equiv_T B'\\).\n\n\n\\(\\mathbf{a} <_T \\mathbf{a}'\\)\n\n\nIf \\(\\mathbf{a} \\leq_T \\mathbf{b}\\), then \\(\\mathbf{a}' \\leq_T\n\\mathbf{b}'\\).\n\n\n\\(\\mathbf{0}' \\leq_T \\mathbf{a}'\\)\n\n\nIf \\(B\\) is c.e.\u00a0in \\(A\\), then \\(\\mathbf{b} \\leq_T\n\\mathbf{a}'\\).\n\n\n\nPart ii of\n Proposition 3.7\n records the fact that the basic result that \\(K\\) is c.e.\u00a0but\nnot computable holds for computability relativized to any set \\(A\\).\nFrom this it follows that \\(A <_T A'\\) and thus also that the\nresult of iterating the jump operation on any set \\(A\\) yields a\nsequence  \n\\[\\begin{aligned}\nA^{(0)} & = A, \\\\\nA^{(1)} & = \\left(A^{(0)}\\right)' = A', \\\\\nA^{(2)} & = \\left(A^{(1)}\\right)' = A'', \\\\\n\\vdots \\\\\nA^{(i+1)} &= \\left(A^{(i)}\\right)', \\\\\n\\vdots\n\\end{aligned}\\]\n\n\nfor which \\(A^{(0)} <_T A^{(1)} <_T A^{(2)} <_T \\ldots\\). As\nbenchmarks in the Turing degrees we also define the sets\n\n\\[\\begin{aligned}\n\\emptyset^0 & = \\emptyset, \\\\\n\\emptyset' & = K, \\\\\n\\emptyset'' & = K', \\\\\n\\vdots \\\\\n\\emptyset^{(i+1)} & = K^{(i)'}, \\\\\n\\vdots\n\\end{aligned}\\]\n\n\nand the degrees \\(\\mathbf{0}^{(n)} =\n\\textrm{deg}_T(\\emptyset^{(n)})\\). Note that the latter correspond to\na linearly ordered sequence  \n\\[\n\\mathbf{0} <_T \\mathbf{0}' < _T\\mathbf{0}'' <_T \\ldots <_T \\mathbf{0}^{(n)} <_T \\ldots\n\\]\n\n\n\n\n\nFigure 2: The Turing degrees\n\\(\\mathcal{D}_T\\). [A\n extended text-based description of figure 2\n is in the supplement.]\n\n\nAs depicted in Figure 2, it is possible to use this sequence to\nclassify many of the problems defined in\n Section 3.2:\n\n\n\n\\(\\mathbf{0} = \\textrm{deg}_T(\\emptyset) = \\{A : A \\text{ is\ncomputable}\\}\\)\n\n\n\\(\\mathbf{0}' = \\textrm{deg}_T(K) = \\textrm{deg}_T(\\HP)\\)\n\n\n\\(\\mathbf{0}'' = \\textrm{deg}_T(\\TOT) =\n\\textrm{deg}_T(\\textit{FIN})\\)\n\n\nSuch classifications illustrate how the position of a set within\n\\(\\mathcal{D}_T\\) can be understood as a measure of how far away it is\nfrom being computable\u2014i.e., of its degree of\nunsolvability or difficulty. However unlike other\nconventional measurement scales, the structure of \\(\\mathcal{D}_T\\) is\nneither simple nor is it always straightforward to discern. Some\nevidence to this effect was provided by the fact that the answer to\nthe following question was posed but left unanswered by Post\n (1944):[27]\n\n\n\nQuestion 3.1 (Post\u2019s Problem): Is\nthere a c.e.\u00a0degree \\(\\mathbf{a}\\) such that \\(\\mathbf{0} <_T\n\\mathbf{a} <_T \\mathbf{0}'\\)?\n\n\nPost\u2019s problem was eventually answered in the positive\nindependently by Friedberg (1957) and Muchnik (1956) who showed the\nfollowing:\n\n\nTheorem 3.8: There are c.e.\u00a0sets \\(A\\) and \\(B\\)\nsuch that \\(A \\nleq_T B\\) and \\(B \\nleq_T A\\). Thus if \\(\\mathbf{a} =\n\\textrm{deg}_T(A)\\) and \\(\\mathbf{b} = \\textrm{deg}_T(B)\\), then\n\\(\\mathbf{a} \\nleq_T \\mathbf{b}\\) and \\(\\mathbf{b} \\nleq_T\n\\mathbf{a}\\) and hence also \\(\\mathbf{0} <_T \\mathbf{a} <_T\n\\mathbf{0}'\\) and \\(\\mathbf{0} <_T \\mathbf{b} <\n_T\\mathbf{0}'\\).\n\n\nThe proof of\n Friedberg-Muchnik Theorem (3.8)\n required the development of a new technique known as the priority\nmethod (or also as the injury method) which has become a\ncentral tool in the subsequent development of computability theory.\nThe method provides a means of constructing a c.e.\u00a0set \\(A\\) with\na certain property \\(P\\) which may be described as follows: \n\n the desired properties of \\(A\\) are divided into an infinite list\nof requirements \\(R_0, R_1, R_2, \\ldots\\) such that if all of\nthe \\(R_i\\) are satisfied, then \\(A\\) will satisfy \\(P\\); \n the requirements are then associated with priorities\ncorresponding to an ordering in which their satisfaction is to be\npreserved by the construction\u2014e.g., \\(R_0\\) might have the\nhighest (or \u201cmost important\u201d) priority, \\(R_1\\) the second\nhighest priority, \\(\\ldots\\); \n \\(A\\) is then constructed in stages \\(A_0,A_1,A_2, \\ldots, A_s,\n\\ldots\\) with each stage \\(s\\) attempting to satisfy the highest\npriority requirement \\(R_j\\) which is currently unsatisfied, either by\nadding numbers to the current approximation \\(A_s\\) of \\(A\\) or by\nprohibiting other numbers from entering \\(A_t\\) at a later stage \\(t\n> s\\); \n it may happen that by satisfying some requirement \\(R_i\\) at\nstage \\(s\\) the process causes another requirement \\(R_j\\) to become\nunsatisfied (i.e., stage \\(s\\) injures \\(R_j\\)); \n in this case, the priority ordering is consulted in order to\ndetermine what action to take. \n\n\nIn the case of\n Theorem 3.8,\n this technique is used to simultaneously construct the two\nc.e.\u00a0sets \\(A\\) and \\(B\\) of degree intermediate between\n\\(\\mathbf{0}\\) and \\(\\mathbf{0}'\\) by alternating between the\nrequirements \\(R_{2i}\\) which entail that \\(A \\neq \\{n : \\phi^{B}_i(n)\n\\darrow = 1\\}\\) at even stages to ensure \\(A \\nleq_T B\\) and\nrequirements \\(R_{2i+1}\\) which entail that \\(B \\neq \\{n :\n\\phi^{A}_i(n) \\darrow = 1\\}\\) at odd stages so as to ensure \\(B\n\\nleq_T A\\).\n\nSophisticated application of the priority method have been employed in\ncomputability theory from the 1960s onward to investigate the\nstructure of \\(\\mathcal{D}_T\\) and\n \\(\\mathcal{E}_T\\).[28]\n Some illustrative results which can be obtained either in this manner\nor more elementary techniques are as follows:\n\n\n\nThere are continuum (i.e., \\(2^{\\aleph_0}\\)) many distinct Turing\ndegrees. In particular, although for a given degree \\(\\mathbf{a}\\) the\nset of \\(\\mathbf{b}\\) such that \\(\\mathbf{b} \\leq_T \\mathbf{a}\\) is\ncountable, the set of \\(\\mathbf{b}\\) such that \\(\\mathbf{a} <_T\n\\mathbf{b}\\) is uncountable (Kleene & Post 1954).\n\n\nFor every degree \\(\\mathbf{a} \\not\\equiv_T \\mathbf{0}\\), there exists\na degree \\(\\mathbf{b}\\) which is incomparable to\n\\(\\mathbf{a}\\)\u2014i.e., \\(\\mathbf{b} \\nleq_T \\mathbf{a}\\) and\n\\(\\mathbf{a} \\nleq_T \\mathbf{b}\\). Moreover, there is a set of\n\\(2^{\\aleph_0}\\) pairwise incompatible degrees (Kleene & Post\n1954).\n\n\nThere are minimal degrees \\(\\mathbf{m}\\)\u2014i.e., degrees\nfor which there is no \\(\\mathbf{a}\\) such that \\(\\mathbf{0} <_T\n\\mathbf{a} <_T \\mathbf{m}\\) (Sacks 1963b). Thus in general\n\\(<_T\\) is not a dense order. (But by fact vii below,\nthere are not minimal c.e.\u00a0degrees.)\n\n\nThere are pairs of degrees \\(\\mathbf{a}\\) and \\(\\mathbf{b}\\) which do\nnot possess a greatest lower bound. Thus although \\(\\mathcal{D}_T\\) is\nan upper semi-lattice, it is not a lattice (Kleene & Post 1954).\nThe same is true of \\(\\mathcal{E}_T\\) (Lachlan 1966).\n\n\nEvery countable partially ordered set can be embedded into\n\\(\\mathcal{D}_T\\) (Thomason 1971). However this is not true\nof \\(\\mathcal{E}_T\\) into which there are finite non-distributive\nlattices which cannot be embedded (Lachlan & Soare 1980).\n\n\nThere is a non-c.e.\u00a0degree \\(\\mathbf{a} <_T \\mathbf{0}'\\)\n(Shoenfield 1960).\n\n\nFor any c.e.\u00a0degrees \\(\\mathbf{a} <_T \\mathbf{b}\\), there is a\nc.e.\u00a0degree \\(\\mathbf{c}\\) such that \\(\\mathbf{a} <_T\n\\mathbf{c} <_T \\mathbf{b}\\) (Sacks 1964). Thus unlike the Turing\ndegrees in general, the c.e.\u00a0degrees are densely\nordered.\n\n\nFor any c.e.\u00a0degree \\(\\mathbf{a} >_T \\mathbf{0}\\), there are\nincomparable c.e.\u00a0degrees \\(\\mathbf{b},\\mathbf{c} <_T\n\\mathbf{a}\\) such that \\(\\mathbf{a} = \\mathbf{b} \\cup \\mathbf{c}\\)\n(Sacks 1963b).\n\n\nLet \\(\\textrm{Th}({\\mathcal{D}_T})\\) be the first-order theory of the\nstructure \\(\\mathcal{D}_T\\) in the language with the with \\(\\equiv_T\\)\nand \\(\\leq_T\\). Not only is \\(\\textrm{Th}({\\mathcal{D}_T})\\)\nundecidable (Lachlan 1968), it is fact many-one equivalent to true\nsecond-order arithmetic (Simpson 1977).\n\n\nAs is easily shown to be true of the join operation \\(\\mathbf{a} \\vee\n\\mathbf{b}\\), the jump operation \\(\\mathbf{a}' = \\mathbf{b}\\) is\ndefinable in \\(\\mathcal{D}_T\\) in the language with \\(\\equiv_T\\) and\n\\(\\leq_T\\) (Shore & Slaman 1999).\n\n\nThese properties attest to the complexity of \\(\\mathcal{D}_T\\) as a\nmathematical structure. A related question is whether\n\\(\\mathcal{D}_T\\) is rigid in the following sense:\n\n\nQuestion 3.2: Does there exist a non-trivial\nautomorphism of \\(\\mathcal{D}_T\\)\u2014i.e., a mapping \\(\\pi:\n\\mathcal{D}_T \\rightarrow \\mathcal{D}_T\\) which preserves \\(\\leq_T\\)\nand is not the identity?\n\n\nA negative answer to this question would show that the relation of\n\\(\\textrm{deg}_T(A)\\) to other degrees uniquely determines the degree\nof unsolvability of \\(A\\) relative to \\(\\mathcal{D}_T\\). Recent work\nhas pointed in this direction (see, e.g., Slaman 2008). Nonetheless,\nat the time of the 2020 update to this entry,\n Question 3.2\n remains a significant open problem in computability theory whose\norigins can be traced back to the original foundational work of\nTuring, Post, and Kleene surveyed above.\n3.6 The Arithmetical and Analytical Hierarchies\n\nThe many-one degrees \\(\\mathcal{D}_m\\) and the Turing degrees\n\\(\\mathcal{D}_T\\) are sometimes referred to as hierarchies in\nthe sense that they determine an ordering on\n\\(\\mathcal{P}(\\mathbb{N})\\)\u2014i.e., the set of subsets of the\nnatural numbers\u2014in terms of relative computability. In a series\nof papers from the 1940s and 1950s, Kleene (initiating in 1943) and\nMostowski (initiating in 1947) realized that it was also possible to\nimpose another sort of ordering on \\(\\mathcal{P}(\\mathbb{N})\\) in\nterms of the logical complexity of the simplest predicate which\ndefines a set \\(A \\subseteq \\mathbb{N}\\) in the languages of first- or\nsecond-order arithmetic. This idea leads to what are known as the\narithmetical and analytical hierarchies, both of\nwhich can be understood as classifying sets in terms of their\ndefinitional (or descriptive) complexity. As we will\nsee, the resulting classifications are related to those determined\nrelative to \\(\\mathcal{D}_T\\) in terms of relative computability. They\nare also similar in form to other definability hierarchies studied in\n computational complexity theory\n (e.g., the polynomial hierarchy) and\n descriptive set theory\n (e.g., the Borel and projective hierarchies).\n3.6.1 The arithmetical hierarchy\n\nRecall that according to the definitions given in\n Section 3.3,\n a relation \\(R \\subseteq \\mathbb{N}^k\\) is said to be\ncomputable just in case its characteristic function\n\\(\\chi_R(\\vec{x})\\) is a computable function and computably\nenumerable just in case it is the range of a computable function.\nIn order to introduce the arithmetical hierarchy, it is useful to\nemploy an alternative characterization of computable and computably\nenumerable relations in the form of a semantic analog to the\nproof-theoretic notion of arithmetical representability\ndiscussed in\n Section 1.3.\n\nRecall that the language of first-order arithmetic\n\\(\\mathcal{L}_a\\) contains the primitive symbols\n\\(\\{<,',+,\\times,0\\}\\) respectively intended to denote the less\nthan relation, successor, addition, and multiplication functions on\nthe natural numbers as well as the first natural number 0. A\nfirst-order arithmetical formula is one built up from these\nexpressions using variables, propositional connectives, and the\nfirst-order quantifiers \\(\\forall x, \\exists x\\) where the variables\nare intended to range over the natural numbers \\(\\mathbb{N}\\). Recall\nalso that the standard model of first-order arithmetic is the\nstructure \\(\\mathfrak{N} = \\langle \\mathbb{N},0,<,s,+,\\times\n\\rangle\\) in which the symbols of \\(\\mathcal{L}_a\\) receive their\nintended interpretations. Finally we say that an\n\\(\\mathcal{L}_a\\)-formula \\(\\varphi(\\vec{x})\\) defines a\nrelation \\(R \\subseteq \\mathbb{N}^k\\) just in case \\(R = \\{\\langle\nn_1,\\ldots,n_k \\rangle : \\mathfrak{N} \\models\n \\varphi(n_1,\\ldots,n_k)\\}\\).[29]\n For instance \\(x < y \\vee x = y\\) defines the less-than-or-equal\nrelation \\(\\leq\\), \\(\\exists y(y + y = x)\\) defines the even numbers,\nand  \n\\[\\forall y \\forall z(y \\times z = x \\rightarrow y = s(0) \\vee y = x)\\]\n\n\ndefines the prime numbers.\n\n\nDefinition 3.14: A formula \\(\\varphi(\\vec{x})\\) of\n\\(\\mathcal{L}_a\\) is said to be in the class \\(\\Delta^0_0\\) if it\ncontains only bounded first-order quantifiers\u2014i.e.,\nthose of the form \\(\\exists x(x < t \\wedge \\ldots)\\) and \\(\\forall\nx(x < t \\rightarrow \\ldots)\\) for \\(t\\) an \\(\\mathcal{L}_a\\)-term\nnot containing \\(x\\). A formula is said to be in the class\n\\(\\Sigma^0_1\\) if it is of the form \\(\\exists \\vec{y}\n\\varphi(\\vec{x},\\vec{y})\\) for \\(\\varphi(\\vec{x},\\vec{y}) \\in\n\\Delta^0_0\\) and to be in the class \\(\\Pi^0_1\\) if it is of the form\n\\(\\forall \\vec{y} \\varphi(\\vec{x},\\vec{y})\\) for\n\\(\\varphi(\\vec{x},\\vec{y}) \\in \\Delta^0_0\\). Finally, a formula\n\\(\\varphi(\\vec{x})\\) is said to be in the class \\(\\Delta^0_1\\) if it\nis semantically equivalent to both a \\(\\Sigma^0_1\\)-formula\n\\(\\psi(\\vec{x})\\) and a \\(\\Pi^0_1\\)-formula\n\\(\\chi(\\vec{x})\\)\u2014i.e., \\(\\mathfrak{N} \\models\n\\varphi(\\vec{n})\\) iff \\(\\mathfrak{N} \\models \\psi(\\vec{n})\\) iff\n\\(\\mathfrak{N} \\models \\chi(\\vec{n})\\) for all \\(\\vec{n} \\in\n\\mathbb{N}^k\\).\n\n\nIt is standard to extend this syntactic classification of formulas in\nterms of quantifier complexity to sets and relations on the natural\nnumbers which can be defined by a formula in a given class. Thus, for\ninstance, \\(x < y \\vee x = y\\) is a \\(\\Delta^0_0\\)-formula and the\nrelation \\(\\leq\\) on \\(\\mathbb{N} \\times \\mathbb{N}\\) is accordingly\nsaid to be \\(\\Delta^0_0\\). On the other hand, while \\(\\exists y(y + y\n= x)\\) is a \\(\\Sigma^0_1\\)-formula, the set of even numbers is also\ndefined by \\(\\exists y < x(x = 0 \\vee y + y = x)\\). Thus this set\nis also classified as \\(\\Delta^0_0\\) in virtue of the existence of\nthis latter definition which is simpler in the sense measured by the\narithmetical hierarchy.\n\nThe first step in relating such classifications to\ncomputability-theoretic notions is provided by the following:\n\n\nProposition 3.8:\n\n\n\nA relation \\(R \\subseteq \\mathbb{N}^k\\) is computably enumerable if\nand only if there is a \\(\\Sigma^0_1\\)-formula which defines\n\\(R(\\vec{x})\\).\n\n\nA relation \\(R \\subseteq \\mathbb{N}^k\\) is computable if and only if\nthere is a \\(\\Delta^0_1\\)-formula which defines\n\\(R(\\vec{x})\\).\n\n\n\nProposition 3.8\n may be proved by directly showing that for each partial recursive\nfunction \\(\\phi_e(\\vec{x})\\) it is possible to construct a\ncorresponding \\(\\mathcal{L}_a\\)-formula \\(\\varphi(\\vec{x})\\) whose\nlogical structure mimics the steps in the definition of the former.\nThis can be achieved by formalizing primitive recursion using an\narithmetically definable coding of finite sequences and expressing\nminimization using an unbounded existential quantifier (see, e.g.,\nKaye 1991, ch. 3). But it is also possible to obtain\n Proposition 3.8\n in a uniform manner by showing that there is a so-called\nuniversal formula for \\(\\Sigma^0_1\\). In order specify such a\nformula, first note that it is possible to effectively enumerate all\n\\(\\Delta^0_0\\)-formulas with \\(k+1\\) free variables as\n\\(\\psi^{k+1}_0(x,\\vec{y}), \\psi^{k+1}_1(x,\\vec{y}), \\ldots\\) and then\ndefine a corresponding enumeration of \\(\\Sigma^0_1\\)-formulas as\n\\(\\varphi^k_0(\\vec{y}) = \\exists x \\psi_0(x,\\vec{y}),\\)\n\\(\\varphi^k_1(\\vec{y}) = \\exists x \\psi_1(x,\\vec{y}),\\)\u2026. We\nthen have the following:\n\n\nTheorem 3.9 (Kleene 1943): For all \\(k\\), there\nexists a \\(\\Sigma^0_1\\)-formula \\(\\sigma_{k,1}(x,\\vec{y})\\) such that\nfor all \\(\\Sigma^0_1\\)-formulas with \\(k\\)-free variables\n\\(\\varphi^k_e(\\vec{y})\\), the following biconditional \n\n\\[\\sigma_{k,1}(e,\\vec{m}) \\leftrightarrow \\varphi^k_e(\\vec{m})\\]\n\n\nholds in the standard model \\(\\mathfrak{N}\\) for all \\(\\vec{m} \\in\n\\mathbb{N}^k\\).\n\n\nTheorem 3.9\n can be demonstrated by first observing that the truth of a\n\\(\\Sigma^0_1\\)-formula \\(\\varphi^k_e(\\vec{x})\\) is equivalent to\n\\(\\mathfrak{N} \\models \\psi^k_e(n,\\vec{m})\\) for some \\(n \\in\n\\mathbb{N}\\). Next note that the sequence of observations recorded in\n Section 2.1.2\n suffices to show that all \\(\\Delta^0_0\\)-definable relations are\nprimitive recursive. We may thus consider an algorithm which on input\n\\(e,\\vec{m}\\) uses \\(e\\) to construct \\(\\psi^k_e(x,\\vec{y})\\) and then\nperforms an unbounded search for an \\(n\\) such that\n\\(\\psi^k_e(n,\\vec{m})\\) holds. By an appeal to Church\u2019s Thesis\n(which can, of course, be replaced by an explicit construction) there\nis a computable function \\(f(e)\\) for which we have the following:\n \n\\[\\mathfrak{N} \\models \\varphi^k_e(\\vec{m}) \\text{ if and only if } \\mu s(T_k(f(e),\\vec{m},s)) \\darrow\\]\n\n\nIn order to construct the formula \\(\\sigma_{k,1}(e,\\vec{y})\\) promised\nby\n Theorem 3.9,\n observe that standard techniques from the arithmetization of syntax\nallow us to obtain a \\(\\Delta^0_1\\)-formula \\(\\tau_k(x,\\vec{y},z)\\)\nwhich defines the Kleene \\(T\\)-predicate \\(T_k(x,\\vec{y},z)\\)\nintroduced in\n Section 2.2.2.\n We may finally define \\(\\sigma_{k,1}(e,\\vec{y}) = \\exists z\n\\tau_k(f(e),\\vec{y},z)\\). The first part of\n Proposition 3.8\n now follows by letting \\(e\\) be such that\n\\(\\textrm{dom}(\\phi^k_e(\\vec{x})) = R\\) and then taking\n\\(\\sigma_{k,1}(e_0,\\vec{x}) \\in \\Sigma^0_1\\) where \\(e_0\\) is such\nthat \\(f(e_0) = e\\). This is often formulated as what is known as the\nEnumeration Theorem which can be compared to\n Theorem 3.2:\n\n\nProposition 3.9: A relation \\(R \\subseteq\n\\mathbb{N}^k\\) is computable enumerable if and only if there is a\nnumber \\(e\\) (known as a c.e.\u00a0index for \\(R\\)) such that\n\\(R\\) is defined by \\(\\exists z \\tau_k(e,\\vec{y},z)\\).\n\n\nThe second part of\n Proposition 3.8\n follows by observing that if \\(R\\) is recursive then both \\(R\\) and\n\\(\\overline{R}\\) are c.e. Thus if \\(e\\) is a c.e.\u00a0index for\n\\(R\\), then \\(\\overline{R}\\) is defined by \\(\\neg \\exists z\n\\tau_k(e,\\vec{x},z)\\) which is equivalent to a \\(\\Pi^0_1\\)-formula\nsince \\(\\tau_k(x,\\vec{y},z) \\in \\Delta^0_1\\).\n\nThe formula classes \\(\\Delta^0_1\\) and \\(\\Sigma^0_1\\) thus provide an\nalternative arithmetical characterization of the computable and\ncomputably enumerable sets. These classes also define the lowest\nlevels of the arithmetical hierarchy which in full generality\nis defined as follows:\n\n\nDefinition 3.15: In order to simplify notation, the\nclasses \\(\\Sigma^0_0\\) and \\(\\Pi^0_0\\) are both used as alternative\nnames for the class \\(\\Delta^0_0\\). A formula is said to be in the\nclass \\(\\Sigma^0_{n+1}\\) if it is of the form \\(\\exists \\vec{y}\n\\varphi(\\vec{x},\\vec{y})\\) for \\(\\varphi(\\vec{x},\\vec{y}) \\in\n\\Pi^0_n\\) and to be in the class \\(\\Pi_{n+1}\\) if it is of the form\n\\(\\forall \\vec{y} \\varphi(\\vec{x},\\vec{y})\\) for\n\\(\\varphi(\\vec{x},\\vec{y}) \\in \\Sigma^0_n\\). A formula\n\\(\\varphi(\\vec{x})\\) is \\(\\Delta^0_{n+1}\\) if it is semantically\nequivalent to both a \\(\\Sigma^0_{n+1}\\)-formula \\(\\psi(\\vec{x})\\) and\na \\(\\Pi^0_{n+1}\\)-formula \\(\\chi(\\vec{x})\\).\n\n\nIt thus follows that a formula is \\(\\Sigma^0_{n}\\) just in case it is\nof the form  \n\\[\\exists \\vec{x}_1 \\forall \\vec{x}_2 \\exists \\vec{x}_3 \\ldots \\mathsf{Q} \\vec{x}_n \\varphi(\\vec{x}_1,\\vec{x}_2,\\vec{x}_3,\\ldots,\\vec{x}_n)\\]\n\n\n(where there are \\(n\\) alternations of quantifier types and\n\\(\\mathsf{Q}\\) is \\(\\forall\\) if \\(n\\) is even and \\(\\exists\\) if\n\\(n\\) is odd). Similarly a \\(\\Pi^0_n\\)-formula is of the form \n\n\\[\\forall \\vec{x}_1 \\exists \\vec{x}_2 \\forall \\vec{x}_3 \\ldots \\mathsf{Q} \\vec{x}_n \\varphi(\\vec{x}_1,\\vec{x}_2,\\vec{x}_3,\\ldots,\\vec{x}_n).\\]\n\n\nThe notations \\(\\Sigma^0_n\\), \\(\\Pi^0_n\\), and \\(\\Delta^0_n\\) are also\nstandardly used to denote the classes of sets and relations which are\ndefinable by a formula in the corresponding syntactic class. For\ninstance it follows from the second part of\n Proposition 3.8\n that \\(\\textit{PRIMES}\\) is \\(\\Delta^0_1\\) (since it is computable)\nand from the first part that \\(\\HP\\) and \\(K\\) are \\(\\Sigma^0_1\\)\n(since they are c.e.). It thus follows that their complements\n\\(\\overline{HP}\\) and \\(\\overline{K}\\) are both \\(\\Pi^0_1\\). It is\nalso not hard to see that \\(\\TOT\\) is \\(\\Pi^0_2\\) as the fact that\n\\(\\phi_x(y)\\) is total may be expressed as \\(\\forall y \\exists z\n\\tau_1(x,y,z)\\) by using the arithmetized formulation of the\n\\(T\\)-predicate introduced above. Similarly, \\(\\textit{FIN}\\) is\n\\(\\Sigma^0_2\\)-definable since the fact that \\(\\phi_x(y)\\) is defined\nfor only finitely many arguments is expressible as \\(\\exists u \\forall\ny\\forall z(u < y \\rightarrow \\neg \\tau_1(x,y,z))\\).\n\nIt is a consequence of the Prenex Normal Form Theorem for first-order\nlogic that every \\(\\mathcal{L}_a\\)-formula \\(\\varphi(\\vec{y})\\) is\nprovably equivalent to one of the form \\(\\mathsf{Q}_1 x_1 \\mathsf{Q}_2\nx_2 \\ldots \\mathsf{Q}_{n} \\varphi(\\vec{x},\\vec{y})\\) for\n\\(\\mathsf{Q}_i \\equiv \\exists\\) or \\(\\forall\\) (e.g., Boolos, Jeffrey,\n& Burgess 2007, ch. 19.1). It thus follows that up to provable\nequivalence, every such formula is \\(\\Sigma^0_n\\) or \\(\\Pi^0_n\\) for\nsome \\(n \\in \\mathbb{N}\\). Since it is conventional to allow that\nblocks of quantifiers may be empty in the\n Definition 3.15,\n it follows that \n\\[\\Sigma^0_n \\subseteq \\Delta^0_{n+1} \\subseteq \\Sigma^0_{n+1}\\]\n\n\nand \n\\[\\Pi^0_n \\subseteq \\Delta^0_{n+1} \\subseteq \\Pi^0_{n+1}.\\]\n\n\nThe fact that these inclusions are strict is a consequence of the\nso-called Hierarchy Theorem, a simple form of which may be\nstated as follows:\n\n\nTheorem 3.10 (Kleene 1943): For all \\(n \\geq 1\\),\nthere exists a set \\(A \\subseteq \\mathbb{N}\\) which is\n\\(\\Pi^0_n\\)-definable but not \\(\\Sigma^0_n\\)-definable and hence also\nneither \\(\\Sigma^0_m\\)- nor \\(\\Pi^0_m\\)-definable for any \\(m <\nn\\). It thus follows that \\(\\overline{A}\\) is \\(\\Sigma^0_n\\)-definable\nbut not \\(\\Pi^0_n\\)-definable and hence also neither \\(\\Sigma^0_m\\)-\nnor \\(\\Pi^0_m\\)-definable for any \\(m < n\\).\n\n\nIt is again possible to prove\n Theorem 3.10\n by a direct syntactic construction. For instance, building on the\ndefinition of the universal \\(\\Sigma^0_1\\)-predicate\n\\(\\sigma_{k,1}(\\vec{y})\\), it may be shown that for every level\n\\(\\Sigma^0_n\\) of the arithmetical hierarchy, there is a\n\\(\\Sigma^0_n\\)-formula \\(\\sigma_{k,n}(x,\\vec{y})\\) which defines\n\\(\\Sigma^0_n\\)-satisfaction in the standard model in the\nsense that  \n\\[\\begin{aligned}\n\\mathfrak{N} \\models \\sigma_{k,n}(\\ulcorner \\varphi(y) \\urcorner,\\vec{m}) \\leftrightarrow \\varphi(\\vec{m}) \\end{aligned}\\]\n\n\nfor all \\(\\varphi(\\vec{x}) \\in \\Sigma^0_n\\) and \\(\\vec{m} \\in\n\\mathbb{N}^k\\) (and where we have also defined our G\u00f6del\nnumbering to agree with the indexation of \\(\\Sigma^0_n\\)-formulas\nintroduced above). Now consider the \\(\\Pi^0_n\\)-formula \\(\\lambda(x) =\n\\neg \\sigma_{2,n}(x,x) \\in \\Pi^0_n\\) and let \\(A\\) be the set defined\nby \\(\\lambda(x)\\). A standard diagonal argument shows that \\(A\\)\ncannot be \\(\\Sigma^0_n\\)-definable and also that if \\(\\ulcorner\n\\sigma_{2,n}(x,x) \\urcorner = l\\) in the enumeration of\n\\(\\Sigma^0_n\\)-formulas then \\(\\neg \\sigma_{2,n}(l,l)\\) is a\n\\(\\Pi^0_n\\)-formula which cannot be provably equivalent to a\n\\(\\Sigma^0_k\\)-formula (see, e.g., Kaye 1991: ch. 9.3). Thus as Kleene\n(1943, 64) observed, part of the significance of the Hierarchy Theorem\nis that it illustrates how the\n Liar Paradox\n may be formalized to yield a stratified form of Tarski\u2019s\nTheorem on the undefinability of truth (see the entry on\n self-reference).\n\nWe may also define a notion of completeness with respect to the levels\nof the arithmetical hierarchy as follows: \\(A\\) is\n\\(\\Sigma^0_n\\)-complete if \\(A\\) is \\(\\Sigma^0_n\\)-definable\nand for all \\(\\Sigma^0_n\\)-definable \\(B\\), we have \\(B \\leq_m A\\)\n(and similarly for \\(\\Pi^0_n\\)-complete). It is not hard to\nshow that in addition to being many-one complete, \\(K\\) is also\n\\(\\Sigma^0_1\\)-complete. Similarly \\(\\overline{K}\\) is\n\\(\\Pi^0_1\\)-complete, \\(INF\\) is \\(\\Sigma^0_2\\)-complete, and \\(TOT\\)\nis \\(\\Pi^0_2\\)-complete. These observations can be subsumed under a\nmore general result which relates the arithmetical hierarchy to the\nTuring degrees and from which\n Theorem 3.10\n can also be obtained as a corollary.\n\n\nTheorem 3.11 (Post 1944):\n\n\n\n\\(A\\) is \\(\\Sigma^0_{n+1}\\)-definable iff \\(A\\) is computably\nenumerable in some \\(\\Pi^0_n\\)-definable set iff \\(A\\) is computably\nenumerable in some \\(\\Sigma_n\\)-definable set.\n\n\n\\(\\emptyset^{(n)}\\) is \\(\\Sigma^0_n\\)-complete for all \\(n >\n0\\).\n\n\n\\(B\\) is \\(\\Sigma^0_{n+1}\\)-definable if and only if \\(B\\) is\ncomputably enumerable in \\(\\emptyset^{(n)}\\).\n\n\n\\(B\\) is \\(\\Delta^0_{n+1}\\)-definable if and only if \\(B \\leq_T\n\\emptyset^{(n)}\\).\n\n\n\nThe various parts of\n Theorem 3.11\n follow from prior definitions together with Propositions\n 3.2\n and\n 3.7.\n Note in particular that it follows from parts ii and iv of\n Theorem 3.11\n together with part vii of\n Proposition 3.7\n that \\(\\emptyset^{(n)}\\) is an example of a set in the class\n\\(\\Sigma^0_n - \\Pi^0_n\\) from which it also follows that\n\\(\\overline{\\emptyset^{(n)}} \\in \\Pi^0_n - \\Sigma^0_n\\). This\nobservation in turn strengthens the Hierarchy Theorem\n (3.10)\n by showing that \\(\\Delta^0_n \\subsetneq \\Sigma^0_n\\) and \\(\\Delta^0_n\n\\subsetneq \\Pi^0_n\\) as depicted in Figure 3.\n\n\n\nFigure 3: The Arithmetical Hierarchy. [A\n extended text-based description of figure 3\n is in the supplement.]\n\n\nPart iv of\n Theorem 3.11\n can also be understood as generalizing\n Proposition 3.4\n (i.e., Post\u2019s Theorem). In particular, it characterizes the\n\\(\\Delta^0_{n+1}\\)-definable sets as those sets \\(B\\) such that both\n\\(B\\) and \\(\\overline{B}\\) are computably enumerable in some\n\\(\\Sigma^0_n\\)-complete set such as \\(\\emptyset^{(n)}\\). Restricting\nto the case \\(n = 1\\), this observation can also be used to provide an\nindependent computational characterization of the\n\\(\\Delta^0_2\\)-definable sets, extending those given for the\n\\(\\Sigma^0_1\\)-definable and \\(\\Delta^0_1\\)-definable sets by\n Proposition 3.8.\n\n\nDefinition 3.16: A set \\(A\\) is said to be limit\ncomputable if there is a computable sequence of finite sets\n\\(\\{A^s : s \\in \\mathbb{N}\\}\\) such that  \n\\[n \\in A \\text{ if and only if } \\textrm{lim}_s A^s(n) = 1\\]\n\n\nwhere \\(\\lim_s A^s(n) = 1\\) means that \\(\\lim_s \\chi_{A_s}(n)\\) exists\nand is equal to 1.\n\n\nIf \\(A\\) is c.e., then it is clear that \\(A\\) is limit computable. For\nif \\(A\\) is the range of a computable function \\(\\phi_e(x)\\), then we\nmay take \\(A^s\\) to be \\(\\{\\phi_e(0), \\ldots, \\phi_e(s)\\}\\) in which\ncase \\(A^0 \\subseteq A^1 \\subseteq A^2 \\subseteq \\ldots\\) In the\ngeneral case of limit computability, the sequence of sets \\(\\{A^s : s\n\\in \\mathbb{N}\\}\\) may be thought of as an approximation of \\(A\\)\nwhich need not grow monotonically in this way but can rather both grow\nand shrink as long as there is always a stage \\(s\\) such that for all\n\\(s \\leq t\\), \\(n \\in A^t\\) if \\(n \\in A\\) and \\(n \\not\\in A^t\\) if\n\\(n \\not\\in A\\). Following Putnam (1965), a limit computable set can\nalso thus also be described as a so-called trial-and-error\npredicate\u2014i.e., one for which membership can be determined\nby following a guessing procedure which eventually converges to the\ncorrect answer to the questions of the form \\(n \\in A\\)?\n\nThe following is traditionally referred to as The Limit\nLemma:\n\n\nTheorem 3.12 (Shoenfield 1959): The following are\nequivalent:\n\n\n\n\\(A\\) is limit computable.\n\n\n\\(A \\leq_T \\emptyset'\\)\n\n\n\nWe have seen that part iv of\n Proposition 3.11\n characterizes the sets Turing reducible to \\(\\emptyset'\\) as the\n\\(\\Delta^0_2\\)-definable sets.\n Theorem 3.12\n thus extends the characterizations of the computable (i.e.,\n\\(\\Delta^0_1\\)-definable) and computably enumerable (i.e.,\n\\(\\Sigma^0_1\\)-definable) sets given in\n Proposition 3.8\n by demonstrating the coincidence of the \\(\\Delta^0_2\\)-definable sets\nand those which are limit computable.\n3.6.2 The analytical hierarchy\n\nKleene introduced what is now known as the analytical\nhierarchy in a series of papers (1955a,b,c) which built directly\non his introduction of the arithmetical hierarchy in (1943). His\nproximal motivation was to provide a definability-theoretic\ncharacterization of the so-called hyperarithmetical\nsets\u2014i.e., those which are computable from transfinite\niterates of the Turing jump through the constructive ordinals. On the\nother hand, Mostowski (1947) had already noticed similarities between\nthe arithmetical hierarchy of sets of natural numbers and results\nabout hierarchies of point sets studied in descriptive set\ntheory\u2014i.e., sets of elements of Polish spaces\n(complete, separable metrizable spaces such as the real numbers,\nCantor space, or Baire space)\u2014which have their origins in the\nwork of Borel, Lebesgue, Lusin, and Suslin in the early twentieth\ncentury. Beginning in his PhD thesis under Kleene, Addison (1954)\nrefined Mostowski\u2019s comparisons by showing that Kleene\u2019s\ninitial work could also be used to provide effective versions of\nseveral classical results in this tradition. We present here the\nfundamental definitions regarding the analytical hierarchy together\nwith some of some results illustrating how it is connected it to these\nother developments.\n\n\nDefinition 3.17: The language \\(\\mathcal{L}^2_a\\)\nof second-order arithmetic extends the language \\(\\mathcal{L}_a\\)\nof first-order arithmetic with the binary relation symbol \\(\\in\\),\ntogether with set variables \\(X,Y,Z, \\ldots\\) and set\nquantifiers \\(\\exists X\\) and \\(\\forall Y\\). The standard model of\n\\(\\mathcal{L}^2_a\\) is the structure \\(\\langle\n\\mathbb{N},\\mathcal{P}(\\mathbb{N}),0,<,s,+,\\times,\\in \\rangle\\).\nThe intended range of the set quantifiers is thus\n\\(\\mathcal{P}(\\mathbb{N})\\) (i.e.\u00a0the power set of\n\\(\\mathbb{N}\\)) while the intended interpretation of \\(x \\in X\\) is\nthat the number \\(x \\in \\mathbb{N}\\) is a member of the set \\(X\\)\nwhere \\(X \\in \\mathcal{P}(\\mathbb{N})\\).\n\n\nNote that in the general case a formula\n\\(\\varphi(x_1,\\ldots,x_j,X_1,\\ldots, X_k)\\) of \\(\\mathcal{L}^2_a\\) may\nhave both free number variables \\(x_1,\\ldots, x_j\\) and free set\nvariables \\(X_1,\\ldots,X_k\\). If \\(R \\subseteq \\mathbb{N}^j \\times\n\\mathcal{P}(\\mathbb{N})^k\\) is defined by such a formula, then it is\nsaid to be analytical. Kleene (1955a) proved a normal form\ntheorem for analytical relations which shows that if \\(R\\) is\nanalytical then it is definable by an \\(\\mathcal{L}^2_a\\)-formula of\nthe form  \n\\[\\forall X_1 \\exists X_2 \\forall X_3 \\ldots \\mathsf{Q} X_n \\psi(X_1,X_2,X_3,\\ldots,X_n)\\]\n\n\nor \n\\[\\exists X_1 \\forall X_2 \\exists X_3 \\ldots \\mathsf{Q} X_n \\psi(X_1,X_2,X_3,\\ldots,X_n)\\]\n\n\nwhere \\(\\psi(\\vec{X})\\) contains only number quantifiers and\n\\(\\mathsf{Q}\\) is \\(\\forall\\) or \\(\\exists\\) depending on where \\(n\\)\nis even or odd. It thus possible to classify both\n\\(\\mathcal{L}^2_a\\)-formulas and the sets they define into classes as\nfollows:\n\n\nDefinition 3.18:\n\nWe denote by both \\(\\Sigma^1_0\\) and \\(\\Pi^1_0\\) the class of\n\\(\\mathcal{L}^2_a\\)-formulas containing no set quantifiers (i.e., a\nso-called arithmetical formulas). An \\(\\mathcal{L}^2_a\\)\nformula is in the class \\(\\Sigma^1_{n+1}\\) if it is of the form\n\\(\\exists X \\psi(X)\\) where \\(\\psi \\in \\Pi^1_n\\) and a relation is\n\\(\\Sigma^1_{n+1}\\)-definable if it is defined by a\n\\(\\Sigma^1_{n+1}\\)-formula. Similarly an \\(\\mathcal{L}^2_a\\)-formula\nis in the class \\(\\Pi^1_{n+1}\\) if it is of the form \\(\\forall X\n\\psi(X)\\) where \\(\\psi \\in \\Sigma^1_n\\) and a relation is\n\\(\\Pi^1_{n+1}\\)-definable if is defined by a\n\\(\\Pi^1_{n+1}\\)-formula. A relation is\n\\(\\Delta^1_n\\)-definable just in case it is definable by both\na \\(\\Sigma^1_n\\)- and a \\(\\Pi^1_n\\)-formula.\n\n\nIt hence follows that, as in the case of the arithmetical hierarchy,\nwe have \n\\[\\Sigma^1_n \\subseteq \\Delta^1_{n+1} \\subseteq \\Sigma^1_{n+1}\\]\n\n\nand \n\\[\\Pi^1_n \\subseteq \\Delta^1_{n+1} \\subseteq \\Pi^1_{n+1}.\\]\n\n\nIn addition, a version of the Enumeration Theorem for arithmetical\nsets can also be proven which can be used to obtain the following\ngeneralization of the Hierarchy Theorem:\n\n\nTheorem 3.13 (Kleene 1955a): For all \\(n \\geq 1\\),\nthere exists a set \\(A \\subseteq \\mathbb{N}\\) which is\n\\(\\Pi^1_n\\)-definable but not \\(\\Sigma^1_n\\)-definable and hence also\nneither \\(\\Sigma^1_m\\)- nor \\(\\Pi^1_m\\)-definable for any \\(m <\nn\\). It thus follows that \\(\\overline{A}\\) is \\(\\Sigma^1_n\\)-definable\nbut not \\(\\Pi^1_n\\)-definable and also neither \\(\\Sigma^1_m\\)- nor\n\\(\\Pi^1_m\\)-definable for any \\(m < n\\).\n\n\nIn order to provide some illustrations of the levels of the analytical\nhierarchy, it is useful to record the following:\n\n\nDefinition 3.19: A set \\(A \\subseteq \\mathbb{N}\\) is\nimplicitly definable in \\(\\mathcal{L}^2_a\\) just in case\nthere is an arithmetical formula \\(\\varphi(X)\\) with \\(X\\) as its sole\nfree set variable and no free number variables such that \\(A\\) is the\nunique set satisfying \\(\\varphi(X)\\) in the standard model of\n\\(\\mathcal{L}^2_a\\).\n\n\nTrue Arithmetic (\\(\\textrm{TA}\\)) corresponds to the set of\nG\u00f6del numbers of first-order arithmetical sentences true in the\nstandard model of \\(\\mathcal{L}_a\\)\u2014i.e., \\(\\textrm{TA} =\n\\{\\ulcorner \\varphi \\urcorner : \\varphi \\in \\mathcal{L}_a \\ \\wedge \\\n\\mathfrak{N} \\models \\varphi\\}\\). Prior to the definition of the\nanalytical hierarchy itself, Hilbert & Bernays had already showed\nthe following:\n\n\nTheorem 3.14 (Hilbert and Bernays 1939, \u00a75.2e):\n\\(\\textrm{TA}\\) is implicitly definable in \\(\\mathcal{L}^2_a\\).\n\n\nIt is then not difficult to show the following:\n\n\nProposition 3.10 (Spector 1955): If \\(A\\) is\nimplicitly definable, then \\(A\\) is \\(\\Delta^1_1\\)-definable in\n\\(\\mathcal{L}^2_a\\).\n\n\nIt thus follows that \\(\\textrm{TA}\\) is \\(\\Delta^1_1\\)-definable. On\nthe other hand, it follows from Tarski\u2019s Theorem on the\nundefinability of truth that \\(\\textrm{TA}\\) is not arithmetically\ndefinable\u2014 i.e. \\(\\textrm{TA} \\not\\in \\Sigma^0_n \\cup \\Pi^0_n\\)\nfor any \\(n \\in \\mathbb{N}\\). This in turn shows that the analytical\nsets properly extend the arithmetical ones.\n\nThe class of \\(\\Delta^1_1\\)-definable subsets of \\(\\mathbb{N}\\) is\nalso related to Kleene\u2019s original study of the class of\nhyperarithmetical sets, customarily denoted \\(\\textrm{HYP}\\). The\ndefinition of \\(\\textrm{HYP}\\) depends on that of a system of\nconstructive ordinal notations known as \\(\\mathcal{O} = \\langle O,\n<_O \\rangle\\) which Kleene had introduced in (1938). (It was also\nin the context of defining \\(\\mathcal{O}\\) in which he proved the\n Recursion Theorem 3.5\u2014see\n Rogers 1987, ch. 11.7 and Y. Moschovakis 2010.) \\(\\textrm{HYP}\\) can\nbe informally characterized as the class of sets of natural numbers\n\\(A\\) such that \\(A \\leq_T \\emptyset^{(\\alpha)}\\) where \\(\\alpha\\) is\nan ordinal which receives a notation \\(e \\in O\\)\u2014i.e., \\(A \\in\n\\textrm{HYP}\\) just in case it is computable from a transfinite\niteration the of Turing jump up to the first non-recursive ordinal\n \\(\\omega^{ck}_1\\).[30]\n Kleene\u2019s original result was as\n follows:[31]\n\n\n\nTheorem 3.15 (Kleene 1955b): A set \\(A \\subseteq\n\\mathbb{N}\\) is \\(\\Delta^1_1\\)-definable if and only if \\(A \\in\n\\textrm{HYP}\\).\n\n\nThe next step up the analytical hierarchy involves the\ncharacterization of the \\(\\Pi^1_1\\)-definable sets. S. Kleene (1955a)\noriginally established his normal form theorem for\n\\(\\mathcal{L}^2_a\\)-formulas using a variant of the language of\nsecond-order arithmetic which contains function quantifiers\n\\(f,g,h,\\ldots\\) which are intended to range over \\(\\mathbb{N}\n\\rightarrow \\mathbb{N}\\) instead of set quantifiers intended to range\nover \\(\\mathcal{P}(\\mathbb{N})\\) (Rogers 1987, ch. 16.2). In this\nsetting, it is possible to show the following:\n\n\nProposition 3.11: \\(A \\in \\Pi^1_1\\) if and only if\nthere is a computable (i.e., \\(\\Delta^0_1\\)-definable) relation\n\\(R(x,f)\\) such that  \n\\[x \\in A \\text{ if and only if } \\forall f \\exists yR(x,\\overline{f}(y))\\]\n\n\nwhere \\(\\overline{f}(y)\\) denotes \\(\\langle\nf(0),\\ldots,f(y-1)\\rangle\\).\n\n\nFor each such relation, we may also define a computable tree\n\\(\\textit{Tr}_x\\) consisting of the finite sequences \\(\\sigma \\in\n\\mathbb{N}^{< \\mathbb{N}}\\) such that for all proper initial\nsubsequences \\(\\tau \\subset \\sigma\\), \\(\\neg R(x,\\tau)\\) holds. A leaf\nnode in this tree thus corresponds to the first place for which \\(R\\)\nholds. An infinite path in \\(\\textit{Tr}_x\\) thus corresponds to a\nfunction \\(f\\) such that \\(\\forall y \\neg R(x,\\overline{f}(y))\\),\nwhich is in turn a witness to \\(x \\not\\in A\\). It thus follows that\n\\(x \\in A\\) if and only if \\(\\textit{Tr}_x\\) is well-founded. Since it\nis straightforward to effectively enumerate computable trees, it is\nalso not difficult to show the following:\n\n\nProposition 3.12: The set \\(T\\) of indices to\nwell-founded computable trees is \\(m\\)-complete for the\n\\(\\Pi^1_1\\)-definable sets\u2014i.e., \\(T \\in \\Pi^1_1\\) and for all\n\\(A \\in \\Pi^1_1\\), \\(A \\leq_m T\\).\n\n\nRecalling that \\(O\\) denotes the set of natural numbers which are\nnotations for ordinals in Kleene\u2019s \\(\\mathcal{O}\\), a related\nresult is the following:\n\n\nProposition 3.13: \\(O\\) is \\(\\Pi^1_1\\)-complete.\n\n\nIt can then be shown using the\n Hierarchy Theorem 3.13\n that neither \\(T\\) nor \\(O\\) is \\(\\Sigma^1_1\\)-definable. These\nresults provide the basis for an inductive analysis of the structure\nof \\(\\Delta^1_1\\)- and \\(\\Pi^1_1\\)-definable sets in terms of\nconstructive ordinals which builds on\n Theorem 3.15\n (see Rogers 1987, ch. 16.4).\n\nThe foregoing results all pertain to the use of\n\\(\\mathcal{L}^2_a\\)-formulas to describe sets of natural numbers. The\ninitial steps connecting the analytical hierarchy to classical\ndescriptive set theory are mediated by considering formulas\n\\(\\varphi(X)\\) which define subclasses \\(\\mathcal{X} \\subseteq\n\\mathcal{P}(\\mathbb{N})\\). In this case, \\(A \\in \\mathcal{X}\\) may be\nidentified with the graph of its characteristic function\n\\(\\chi_A(x)\\)\u2014i.e., as an infinite sequence whose \\(n\\)th\nelement is 1 if \\(n \\in A\\) and 0 if \\(n \\not\\in A\\). In this way a\nformula \\(\\psi(X)\\) with a single free set variable may be understood\nas defining a subset of the Cantor space \\(\\mathcal{C} =\n2^{\\mathbb{N}}\\) consisting of all infinite 0-1 sequences and a\nformula \\(\\psi(\\vec{X})\\) with \\(X_1,\\ldots,X_k\\) free as defining a\nsubclass of \\(2^{\\mathbb{N}} \\times \\ldots \\times\n2^{\\mathbb{N}}\\).\n\nIn descriptive set theory, a parallel sequence of topological\ndefinitions of subclasses of \\(\\mathcal{C}\\) is given in the context\nof defining the Borel sets and projective sets. First recall that one\nmeans of defining a topology on \\(\\mathcal{C}\\) is to take as basic\nopen sets all sets of functions \\(f: \\mathbb{N} \\rightarrow \\{0,1\\}\\)\nsuch that \\(\\overline{f}(k) = \\sigma\\) for some \\(\\sigma \\in 2^{<\n\\mathbb{N}}\\) and \\(k \\in \\mathbb{N}\\). The boldface Borel\nHierarchy on \\(\\mathcal{C}\\) is now given by defining\n\\(\\mathbf{\\Sigma^0_1}\\) to be the collection of all open sets of\n\\(\\mathcal{C}\\), \\(\\mathbf{\\Pi^0_{n}}\\) (for \\(n \\geq 1\\)) to be the\nset of all complements \\(\\overline{A}\\) of sets \\(A \\in\n\\mathbf{\\Sigma^0_1}\\), and \\(\\mathbf{\\Sigma^0_{n+1}}\\) to be the set\nof all countable unions \\(\\bigcup_{i \\in \\mathbb{N}} A_i\\) where \\(A_i\n\\in \\mathbf{\\Pi^0_n}\\). (Thus \\(\\mathbf{\\Pi^0_1}\\) denotes the set of\nclosed sets, \\(\\mathbf{\\Sigma^0_2}\\) denotes the so-called\n\\(F_{\\sigma}\\) sets, \\(\\mathbf{\\Pi^0_2}\\) the \\(G_{\\delta}\\) sets,\netc.) The union of these classes corresponds to the boldface Borel\nsets \\(\\mathbf{B}\\) which may also be characterized as the\nsmallest class of sets containing the open sets of \\(\\mathcal{C}\\)\nwhich is closed under countable unions and complementation. The\nso-called analytic sets are defined to be the continuous\nimages of the Borel sets and are denoted by \\(\\mathbf{\\Sigma^1_1}\\)\nwhile the co-analytic sets are defined to be the complements\nof analytic sets and are denoted by \\(\\mathbf{\\Pi^1_1}\\). Finally,\n\\(\\mathbf{\\Delta^1_1}\\) is used to denote the intersection of the\nanalytic and co-analytic sets.\n\nAddison observed (1958, 1959) that these classical definitions can be\neffectivized by restricting to computable unions in the definition of\nthe \\(\\mathbf{\\Sigma^0_n}\\) sets. This leads to the so-called\nlightface version of the Borel hierarchy\u2014customarily\ndenoted using the same notations \\(\\Sigma^0_n\\) and \\(\\Pi^0_n\\) used\nfor the levels of arithmetical hierarchy\u2014and corresponding\ndefinitions of \\(\\Sigma^1_1\\) (i.e., lightface analytic), \\(\\Pi^1_1\\)\n(i.e., lightface co-analytic), and \\(\\Delta^1_1\\) sets. In particular,\nthis sequence of definitions suggests an analogy between\n Theorem 3.15\n and the following classical result of Suslin:\n\n\nTheorem 3.16 (Suslin 1917): The class of\n\\(\\mathbf{\\Delta}^1_1\\) sets is equal to the class of Borel sets\n\\(\\mathbf{B}\\).\n\n\nAn effective form of\n Theorem 3.16\n relating the \\(\\Delta^1_1\\) subsets of \\(\\mathcal{C}\\) to the\nlightface Borel sets representable by computable codes can be obtained\nfrom Kleene\u2019s original proof of\n Theorem 3.15\n (see, e.g., Y. Moschovakis 2009, ch. 7B). Addison also showed that it\nis similarly possible to obtain an effective version of Lusin\u2019s\nTheorem (1927)\u2014i.e., \u201cany two disjoint analytic sets can\nbe separated by a Borel set\u201d\u2014and Kond\u00f4\u2019s\ntheorem (1939)\u2014i.e., \u201cevery \\(\\mathbf{\\Pi^1_1}\\)-relation\ncan be uniformized by a \\(\\mathbf{\\Pi^1_1}\\)-relation\u201d. See Y.\nMoschovakis (2009, ch. 2E,4E) and also Simpson (2009, ch.\nV.3,VI.2)\n4. Further Reading\n\nHistorical surveys of the early development of recursive functions and\ncomputability theory are provided by Sieg (2009), Adams (2011), and\nSoare (2016, part V). Many of the original sources discussed in\n \u00a71\n are anthologized in Davis (1965), Heijenoort (1967), and Ewald\n(1996). Textbook presentation of computability theory at an elementary\nand intermediate level include Hopcroft & Ulman (1979), Cutland\n(1980), Davis, Sigal, & Weyuker (1994), and Murawski (1999). The\noriginal textbook expositions of the material presented in\n \u00a72\n and\n \u00a73\n (up to the formulation of Post\u2019s problem) include Kleene\n(1952), Shoenfield (1967), and Rogers (1987; first edition 1967). The\nstructure of the many-one and Turing Degrees is presented in more\nadvanced textbooks such as Sacks (1963a), Shoenfield (1971), Hinman\n(1978), Soare (1987), Cooper (2004), and Soare (2016). In addition to\nShoenfield (1967, ch. 7) and Rogers (1987, ch. 16), the classic\ntreatment of the hyperarithmetical and analytical hierarchies is Sacks\n(1990). Classical and effective descriptive set theory are developed\nin Y. Moschovakis (2009, first edition 1980) and Kechris (1995).\nSimpson (2009) develops connections between computability theory and\nReverse Mathematics\u2014i.e., the axiomatic study of\nsubsystems of second-order arithmetic whose \u03c9-models may often\nbe characterized using computability theoretic methods. Treatment of\nsub-recursive hierarchies and connections to proof theory and\ntheoretical computer science are provided by P\u00e9ter (1967), Rose\n(1984), Clote (2002, ch. 6\u20137), and Schwichtenberg & Wainer\n(2011). Many of the historical and mathematical topics surveyed in\nthis entry are also presented in greater detail in the two volumes of\nOdifreddi\u2019s Classical Recursion Theory (1989, 1999a),\nwhich contain many additional historical references.\n",
    "bibliography": {
        "categories": [],
        "cat_ref_text": {
            "ref_list": [
                "<li id=\"ref-Ackermann1928\">Ackermann, Wilhelm, 1928, \u201c\u00dcber\ndie Erf\u00fcllbarkeit gewisser Z\u00e4hlausdr\u00fccke\u201d,\n<em>Mathematische Annalen</em>, 100: 638\u2013649.\ndoi:10.1007/BF01448869",
                "<li id=\"ref-Adams2011\">Adams, Rod, 2011, <em>An Early History of\nRecursive Functions and Computability: From G\u00f6del to Turing</em>,\nBoston: Docent Press.",
                "<li id=\"ref-Addison1954\">Addison, J.W., 1954, <em>On Some Points of\nthe Theory of Recursive Functions</em>, PhD thesis, University of\nWisconsin.",
                "<li id=\"ref-Addison1958\">\u2013\u2013\u2013, 1958,\n\u201cSeparation Principles in the Hierarchies of Classical and\nEffective Descriptive Set Theory\u201d, <em>Fundamenta\nMathematicae</em>, 46(2): 123\u2013135.\ndoi:10.4064/fm-46-2-123-135",
                "<li id=\"ref-Addison1959\">\u2013\u2013\u2013, 1959, \u201cSome\nConsequences of the Axiom of Constructibility\u201d, <em>Fundamenta\nMathematicae</em>, 46(3): 337\u2013357.\ndoi:10.4064/fm-46-3-337-357",
                "<li id=\"ref-Basu2016\">Basu, Sankha S. and Stephen G. Simpson, 2016,\n\u201cMass Problems and Intuitionistic Higher-Order Logic\u201d,\n<em>Computability</em>, 5(1): 29\u201347. doi:10.3233/COM-150041",
                "<li id=\"ref-Bimbo2010\">Bimb\u00f3, Katalin, 2012, <em>Combinatory\nLogic: Pure, Applied and Typed</em>, Boca Raton, FL: Chapman &amp;\nHall.",
                "<li id=\"ref-Boolos2007\">Boolos, George S., John P. Burgess, and\nRichard C. Jeffrey, 2007, <em>Computability and Logic</em>, fifth\nedition, Cambridge: Cambridge University Press.\ndoi:10.1017/CBO9780511804076",
                "<li id=\"ref-Calude1979\">Calude, Cristian, Solomon Marcus, and Ionel\nTevy, 1979, \u201cThe First Example of a Recursive Function Which Is\nNot Primitive Recursive\u201d, <em>Historia Mathematica</em>, 6(4):\n380\u2013384. doi:10.1016/0315-0860(79)90024-7",
                "<li id=\"ref-Church1936a\">Church, Alonzo, 1936a, \u201cA Note on the\n<em>Entscheidungsproblem</em>\u201d, <em>Journal of Symbolic\nLogic</em>, 1(1): 40\u201341. doi:10.2307/2269326",
                "<li id=\"ref-Church1936\">\u2013\u2013\u2013, 1936b, \u201cAn\nUnsolvable Problem of Elementary Number Theory\u201d, <em>American\nJournal of Mathematics</em>, 58(2): 345\u2013363.\ndoi:10.2307/2371045",
                "<li id=\"ref-Clote2002\">Clote, Peter and Evangelos Kranakis, 2002,\n<em>Boolean Functions and Computation Models</em>, (Texts in\nTheoretical Computer Science. An EATCS Series), Berlin, Heidelberg:\nSpringer Berlin Heidelberg. doi:10.1007/978-3-662-04943-3",
                "<li id=\"ref-Cooper2004\">Cooper, S. Barry, 2004, <em>Computability\nTheory</em>, Boca Raton, FL: Chapman &amp; Hall.",
                "<li id=\"ref-Cutland1980\">Cutland, Nigel, 1980, <em>Computability: An\nIntroduction to Recursive Function Theory</em>, Cambridge: Cambridge\nUniversity Press. doi:10.1017/CBO9781139171496",
                "<li id=\"ref-Davis1965\">Davis, Martin (ed.), 1965, <em>The Undecidable:\nBasic Papers on Undecidable Propositions, Unsolvable Problems and\nComputable Functions</em>, New York: Raven Press.",
                "<li id=\"ref-Davis1982a\">\u2013\u2013\u2013, 1982, \u201cWhy\nG\u00f6del Didn\u2019t Have Church\u2019s Thesis\u201d,\n<em>Information and Control</em>, 54(1\u20132): 3\u201324.\ndoi:10.1016/S0019-9958(82)91226-8",
                "<li id=\"ref-Davis1994\">Davis, Martin, Ron Sigal, and Elaine J.\nWeyuker, 1994, <em>Computability, Complexity, and Languages:\nFundamentals of Theoretical Computer Science</em>, second edition,\n(Computer Science and Scientific Computing), Boston: Academic Press,\nHarcourt, Brace.",
                "<li id=\"ref-Dean2019a\">Dean, W., forthcoming, \u201cIncompleteness\nvia Paradox and Completeness\u201d, <em>The Review of Symbolic\nLogic</em>, first online: 23 May 2019.\ndoi:10.1017/S1755020319000212",
                "<li id=\"ref-Dedekind1888\">Dedekind, Richard, 1888, <em>Was Sind Und\nWas Sollen Die Zahlen?</em>, Braunschweig: Vieweg.",
                "<li id=\"ref-Enderton2010\">Enderton, Herbert B., 2010,\n<em>Computability Theory: An Introduction to Recursion Theory</em>,\nBurlington, MA: Academic Press.",
                "<li id=\"ref-Epstein1989\">Epstein, Richard and Walter A. Carnielli,\n2008, <em>Computability: Computable Functions, Logic, and the\nFoundations of Mathematics</em>, Socorro, NM: Advance Reasoing\nForum.",
                "<li id=\"ref-Ewald1996\">Ewald, William Bragg (ed.), 1996, <em>From Kant\nto Hilbert: A Source Book in the Foundations of Mathematics.</em>, New\nYork: Oxford University Press.",
                "<li id=\"ref-Feferman1995a\">Feferman, Solomon, 1995, \u201cTuring in\nthe land of \\(O(z)\\)\u201d, in <em>The Universal Turing Machine a\nHalf-Century Survey</em>, Rolf Herken (ed.), Berlin: Springer, pp.\n103\u2013134.",
                "<li id=\"ref-Sigler2003\">Fibonacci, 1202 [2003], <em>Fibonacci\u2019s\nLiber Abaci: A Translation into Modern English of Leonardo\nPisano\u2019s Book of Calculation</em>, L. E. Sigler (ed.), Berlin:\nSpringer.",
                "<li id=\"ref-Friedberg1957\">Friedberg, R. M., 1957, \u201cTwo\nRecursively Enumerable Sets of Incomparable Degrees of Unsolvability\n(Solution of Post\u2019s Problem, 1944)\u201d, <em>Proceedings of\nthe National Academy of Sciences</em>, 43(2): 236\u2013238.\ndoi:10.1073/pnas.43.2.236",
                "<li id=\"ref-Gandy1980\">Gandy, Robin, 1980, \u201cChurch\u2019s\nThesis and Principles for Mechanisms\u201d, in <em>The Kleene\nSymposium</em>, Jon Barwise, H. Jerome Keisler, and Kenneth Kunen\n(eds.), (Studies in Logic and the Foundations of Mathematics 101),\nAmsterdam: Elsevier, 123\u2013148.\ndoi:10.1016/S0049-237X(08)71257-6",
                "<li id=\"ref-Godel1931a\">G\u00f6del, Kurt, 1931, \u201c\u00dcber\nformal unentscheidbare S\u00e4tze der Principia Mathematica und\nverwandter Systeme, I\u201d (On Formally Undecidable Propositions of\n<em>Principia Mathematica</em> and Related Systems\u00a0I),\n<em>Monatshefte f\u00fcr Mathematik und Physik</em>, 38:\n173\u2013198. Reprinted in G\u00f6del 1986: 144\u2013195.",
                "<li id=\"ref-Godel1934a\">\u2013\u2013\u2013, 1934, \u201cOn\nUndecidable Propositions of Formal Mathematical Systems\u201d,\nPrinceton lectures. Reprinted in Godel 1986: 338-371.",
                "<li id=\"ref-Godel1986\">\u2013\u2013\u2013, 1986, <em>Collected\nWorks. I: Publications 1929\u20131936</em>, Solomon Feferman, John W.\nDawson, Jr, Stephen C. Kleene, Gregory H. Moore, Robert M. Solovay,\nand Jean van Heijenoort (eds.), Oxford: Oxford University Press.",
                "<li id=\"ref-Godel2003\">\u2013\u2013\u2013, 2003, <em>Collected\nWorks. V: Correspondence H\u2013Z</em>, Solomon Feferman, John W.\nDawson, Jr, Warren Goldfrab, Charles Parsons, and Wilfried Sieg\n(eds.), Oxford: Oxford University Press.",
                "<li id=\"ref-Grassmann1861\">Grassmann, Hermann, 1861, <em>Lehrbuch Der\nArithmetik F\u00fcr H\u00f6here Lehranstalten</em>, Berin: Th. Chr.\nFr. Enslin.",
                "<li id=\"ref-Greibach1975\">Greibach, Sheila A., 1975, <em>Theory of\nProgram Structures: Schemes, Semantics, Verification</em>, (Lecture\nNotes in Computer Science 36), Berlin/Heidelberg: Springer-Verlag.\ndoi:10.1007/BFb0023017",
                "<li id=\"ref-Grzegorczyk1953\">Grzegorczyk, Andrzej, 1953, \u201cSome\nClasses of Recursive Functions\u201d, <em>Rozprawy Matematyczne</em>,\n4: 3\u201345.",
                "<li id=\"ref-Grzegorczyk1958\">Grzegorczyk, A., A. Mostowski, and C.\nRyll-Nardzewski, 1958, \u201cThe Classical and the \u03c9-Complete\nArithmetic\u201d, <em>The Journal of Symbolic Logic</em>, 23(2):\n188\u2013206. doi:10.2307/2964398",
                "<li id=\"ref-Heijenoort1967\">Heijenoort, Jean van (ed.), 1967, <em>From\nFrege to G\u00f6del : A Source Book in Mathematical Logic,\n1879\u20131931</em>, Cambridge, MA: Harvard University Press.",
                "<li id=\"ref-Herbrand1930\">Herbrand, Jacques, 1930, \u201cLes Bases de\nla Logique Hilbertienne\u201d, <em>Revue de Metaphysique et de\nMorale</em>, 37(2): 243\u2013255.",
                "<li id=\"ref-Herbrand1931\">\u2013\u2013\u2013, 1932, \u201cSur La\nNon-Contradiction de l\u2019Arithm\u00e9tique.\u201d, <em>Journal\nF\u00fcr Die Reine Und Angewandte Mathematik (Crelles Journal)</em>,\n166: 1\u20138. doi:10.1515/crll.1932.166.1",
                "<li id=\"ref-Hilbert1900\">Hilbert, David, 1900, \u201cMathematische\nProbleme. Vortrag, Gehalten Auf Dem Internationalen\nMathematiker-Congress Zu Paris 1900\u201d, <em>Nachrichten von Der\nGesellschaft Der Wissenschaften Zu G\u00f6ttingen,\nMathematisch-Physikalische Klasse</em>, 253\u2013297. English\ntranslation as \u201cMathematical Problems\u201d in Ewald, 1996,\n1096\u20131105.",
                "<li id=\"ref-Hilbert1905\">\u2013\u2013\u2013, 1905, \u201c\u00dcber\nDie Grundlagen Der Logik Und Der Arithmetik\u201d, in\n<em>Verhandlungen Des 3. Internationalen Mathematiker-Kongresses : In\nHeidelberg Vom 8. Bis 13. August 1904</em>, Leipzig: Teubner, pp.\n174\u2013185. English translation as \u201cOn the foundations of\nlogic and and arithmetic\u201d in van Heijenoort, 1967.",
                "<li id=\"ref-Hilbert1920\">\u2013\u2013\u2013, 1920, \u201cLectures\non Logic \u2018Logic-Kalk\u00fcl\u2019 (1920)\u201d, reprinted in\nHilbert 2013: 298\u2013377.",
                "<li id=\"ref-Hilbert1922\">\u2013\u2013\u2013, 1922,\n\u201cNeubegr\u00fcndung der Mathematik. Erste Mitteilung\u201d,\n<em>Abhandlungen aus dem Mathematischen Seminar der Universit\u00e4t\nHamburg</em>, 1(1): 157\u2013177. English translation as \u201cThe\nnew grounding of mathematics: First report\u201d in Ewald 1996,\n1115\u20131134. doi:10.1007/BF02940589",
                "<li id=\"ref-Hilbert1923\">\u2013\u2013\u2013, 1923, \u201cDie\nlogischen Grundlagen der Mathematik\u201d, <em>Mathematische\nAnnalen</em>, 88(1\u20132): 151\u2013165. English translation as\n\u201cThe logical foundations of mathematics\u201d in Ewald 1996,\n1134\u20131148. doi:10.1007/BF01448445",
                "<li id=\"ref-Hilbert1926\">\u2013\u2013\u2013, 1926, \u201c\u00dcber\ndas Unendliche\u201d, <em>Mathematische Annalen</em>, 95:\n161\u2013190. English translation as \u201cOn the infinite\u201d in\nvan Heijenoort 1967, 367\u2013292. doi:10.1007/BF01206605 ",
                "<li id=\"ref-Hilbert1929\">\u2013\u2013\u2013, 1930, \u201cProbleme\nder Grundlegung der Mathematik\u201d, <em>Mathematische Annalen</em>,\n102: 1\u20139. English translation as \u201cProblems of the\nGrounding of Mathematics\u201d in Mancosu 1998, 223\u2013233.\ndoi:10.1007/BF01782335",
                "<li id=\"ref-Hilbert2013\">Hilbert, David, 2013, <em>David\nHilbert\u2019s Lectures on the Foundations of Arithmetic and Logic\n1917\u20131933</em>, William Ewald and Wilfried Sieg (eds.), Berlin,\nHeidelberg: Springer Berlin Heidelberg.\ndoi:10.1007/978-3-540-69444-1",
                "<li id=\"ref-Hilbert1928\">Hilbert, David and Wilhelm Ackermann, 1928,\n<em>Grundz\u00fcge der theoretischen Logik</em>, first edition,\nBerlin: J. Springer.",
                "<li id=\"ref-Hilbert1934\">Hilbert, David and Paul Bernays, 1934,\n<em>Grundlagen der Mathematik</em>, Vol. I, Berlin: Springer.",
                "<li id=\"ref-Hilbert1939\">\u2013\u2013\u2013, 1939, <em>Grundlagen\nder Mathematik</em>, Vol. II, Berlin: Springer.",
                "<li id=\"ref-Hinman1978\">Hinman, Peter G., 1978,\n<em>Recursion-Theoretic Hierarchies</em>, Berlin: Springer.",
                "<li id=\"ref-Hopcroft1979\">Hopcroft, John and Jeffrey Ulman, 1979,\n<em>Introduction to Automata Theory, Languages, and Computation</em>,\nReading, MA: Addison-Wesley.",
                "<li id=\"ref-Kaye1991\">Kaye, Richard, 1991, <em>Models of Peano\nArithmetic</em>, (Oxford Logic Guides, 15), Oxford: Clarendon\nPress.",
                "<li id=\"ref-Kechris1995\">Kechris, Alexander S., 1995, <em>Classical\nDescriptive Set Theory</em>, Berlin: Springer.\ndoi:10.1007/978-1-4612-4190-4",
                "<li id=\"ref-Kleene1936\">Kleene, S. C., 1936a, \u201cGeneral Recursive\nFunctions of Natural Numbers\u201d, <em>Mathematische Annalen</em>,\n112(1): 727\u2013742. doi:10.1007/BF01565439",
                "<li id=\"ref-Kleene1936b\">\u2013\u2013\u2013, 1936b,\n\u201c\u03bb-Definability and Recursiveness\u201d, <em>Duke\nMathematical Journal</em>, 2(2): 340\u2013353.\ndoi:10.1215/S0012-7094-36-00227-2",
                "<li id=\"ref-Kleene1938\">\u2013\u2013\u2013, 1938, \u201cOn\nNotation for Ordinal Numbers\u201d, <em>Journal of Symbolic\nLogic</em>, 3(4): 150\u2013155. doi:10.2307/2267778",
                "<li id=\"ref-Kleene1943\">\u2013\u2013\u2013, 1943, \u201cRecursive\nPredicates and Quantifiers\u201d, <em>Transactions of the American\nMathematical Society</em>, 53(1): 41\u201341.\ndoi:10.1090/S0002-9947-1943-0007371-8",
                "<li id=\"ref-Kleene1952\">\u2013\u2013\u2013, 1952, <em>Introduction\nto Metamathematics</em>, Amsterdam: North-Holland.",
                "<li id=\"ref-Kleene1955a\">\u2013\u2013\u2013, 1955a,\n\u201cArithmetical Predicates and Function Quantifiers\u201d,\n<em>Transactions of the American Mathematical Society</em>, 79(2):\n312\u2013312. doi:10.1090/S0002-9947-1955-0070594-4",
                "<li id=\"ref-Kleene1955b\">\u2013\u2013\u2013, 1955b,\n\u201cHierarchies of Number-Theoretic Predicates\u201d, <em>Bulletin\nof the American Mathematical Society</em>, 61(3): 193\u2013214.\ndoi:10.1090/S0002-9904-1955-09896-3",
                "<li id=\"ref-Kleene1955c\">\u2013\u2013\u2013, 1955c, \u201cOn the\nForms of the Predicates in the Theory of Constructive Ordinals (Second\nPaper)\u201d, <em>American Journal of Mathematics</em>, 77(3):\n405\u2013428. doi:10.2307/2372632",
                "<li id=\"ref-Kleene1954\">Kleene, S. C. and Emil L. Post, 1954,\n\u201cThe Upper Semi-Lattice of Degrees of Recursive\nUnsolvability\u201d, <em>The Annals of Mathematics</em>, 59(3):\n379\u2013407. doi:10.2307/1969708",
                "<li id=\"ref-Kolmogorov1932\">Kolmogorov, Andrei, 1932, \u201cZur\nDeutung der intuitionistischen Logik\u201d, <em>Mathematische\nZeitschrift</em>, 35(1): 58\u201365. doi:10.1007/BF01186549",
                "<li id=\"ref-Kondo1939\">Kond\u00f4, Motokiti, 1939, \u201cSur\nl\u2019uniformisation des Compl\u00e9mentaires Analytiques et les\nEnsembles Projectifs de la Seconde Classe\u201d, <em>Japanese Journal\nof Mathematics\u202f:Transactions and Abstracts</em>, 15:\n197\u2013230. doi:10.4099/jjm1924.15.0_197",
                "<li id=\"ref-Kreisel1960\">Kreisel, George, 1960, \u201cLa\nPr\u00e9dicativit\u00e9\u201d, <em>Bulletin de La\nSoci\u00e9t\u00e9 Math\u00e9matique de France</em>, 79:\n371\u2013391. doi:10.24033/bsmf.1554",
                "<li id=\"ref-Kreisel1965\">Kreisel, George and Gerald E. Sacks, 1965,\n\u201cMetarecursive Sets\u201d, <em>Journal of Symbolic Logic</em>,\n30(3): 318\u2013338. doi:10.2307/2269621",
                "<li id=\"ref-Lachlan1966\">Lachlan, A. H., 1966, \u201cLower Bounds for\nPairs of Recursively Enumerable Degrees\u201d, <em>Proceedings of the\nLondon Mathematical Society</em>, s3-16(1): 537\u2013569.\ndoi:10.1112/plms/s3-16.1.537",
                "<li id=\"ref-Lachlan1968\">\u2013\u2013\u2013, 1968,\n\u201cDistributive Initial Segments of the Degrees of\nUnsolvability\u201d, <em>Zeitschrift f\u00fcr Mathematische Logik und\nGrundlagen der Mathematik/Mathematical Logic Quarterly</em>, 14(30):\n457\u2013472. doi:10.1002/malq.19680143002",
                "<li id=\"ref-Lachlan1980\">Lachlan, A.H and R.I Soare, 1980, \u201cNot\nEvery Finite Lattice Is Embeddable in the Recursively Enumerable\nDegrees\u201d, <em>Advances in Mathematics</em>, 37(1): 74\u201382.\ndoi:10.1016/0001-8708(80)90027-4",
                "<li id=\"ref-Lusin1927\">Lusin, Nicolas, 1927, \u201cSur Les Ensembles\nAnalytiques\u201d, <em>Fundamenta Mathematicae</em>, 10: 1\u201395.\ndoi:10.4064/fm-10-1-1-95",
                "<li id=\"ref-Mancosu1998\">Mancosu, Paolo, (ed.), 1998, <em>From Brouwer\nto Hilbert: The Debate on the Foundations of Mathematics in the\n1920s</em>, Oxford: Oxford University Press.",
                "<li id=\"ref-McCarthy1963\">McCarthy, John, 1961, \u201cA Basis for a\nMathematical Theory of Computation, Preliminary Report\u201d, in\n<em>Papers Presented at the May 9-11, 1961, Western Joint IRE-AIEE-ACM\nComputer Conference on - IRE-AIEE-ACM \u201961 (Western)</em>, Los\nAngeles, California: ACM Press, 225\u2013238.\ndoi:10.1145/1460690.1460715",
                "<li id=\"ref-Medvedev1955\">M\u00e9dv\u00e9d\u00e9v, \u00da. T.,\n1955, \u201cSt\u00e9p\u00e9ni trudnosti massovyh\nprobl\u00e9m\u201d (Degrees of Difficulty of Mass Problems),\n<em>Doklady Akad\u00e9mii Nauk SSSR</em>, 104: 501\u2013504.",
                "<li id=\"ref-Moschovakis1989\">Moschovakis, Yiannis N., 1989, \u201cThe\nFormal Language of Recursion\u201d, <em>The Journal of Symbolic\nLogic</em>, 54(4): 1216\u20131252. doi:10.2307/2274814",
                "<li id=\"ref-Moschovakis1994\">\u2013\u2013\u2013, 1994, <em>Notes on\nSet Theory</em>, (Undergraduate Texts in Mathematics), New York, NY:\nSpringer New York. doi:10.1007/978-1-4757-4153-7",
                "<li id=\"ref-Moschovakis2009a\">\u2013\u2013\u2013, 2009,\n<em>Descriptive Set Theory</em>, second edition, Providence, RI:\nAmerican Mathematical Society.",
                "<li id=\"ref-Moschovakis2009\">\u2013\u2013\u2013, 2010,\n\u201cKleene\u2019s Amazing Second Recursion Theorem\u201d, <em>The\nBulletin of Symbolic Logic</em>, 16(2): 189\u2013239.\ndoi:10.2178/bsl/1286889124",
                "<li id=\"ref-Mostowski1946\">Mostowski, Andrzej, 1947, \u201cOn\nDefinable Sets of Positive Integers\u201d, <em>Fundamenta\nMathematicae</em>, 34: 81\u2013112. doi:10.4064/fm-34-1-81-112",
                "<li id=\"ref-Muchnik1956\">Muchnik, A. A., 1956, \u201cOn the\nUnsolvability of the Problem of Reducibility in the Theory of\nAlgorithms\u201d, <em>Doklady Akad\u00e9mii Nauk SSSR</em>, 108:\n194\u2013197.",
                "<li id=\"ref-Murawski1999\">Murawski, Roman, 1999, <em>Recursive\nFunctions and Metamathematics: Problems of Completeness and\nDecidability, Goedel\u2019s Theorems</em>, Dordrecht, Boston:\nKluwer.",
                "<li id=\"ref-Myhill1955\">Myhill, John, 1955, \u201cCreative\nsets\u201d, <em>Zeitschrift f\u00fcr Mathematische Logik und\nGrundlagen der Mathematik/Mathematical Logic Quarterly</em>, 1(2):\n97\u2013108. doi:10.1002/malq.19550010205",
                "<li id=\"ref-Odifreddi1989\">Odifreddi, Piergiogio, 1989, <em>Classical\nRecursion Theory. volume 1: The Theory of Functions and Sets of\nNatural Numbers</em>, (Studies in Logic and the Foundations of\nMathematics 125), Amsterdam: North-Holland",
                "<li id=\"ref-Odifreddi1999\">\u2013\u2013\u2013, 1999a, <em>Classical\nRecursion Theory. volume 2</em>, (Studies in Logic and the Foundations\nof Mathematics 143), Amsterdam: North-Holland.",
                "<li id=\"ref-Odifreddi1999a\">\u2013\u2013\u2013, 1999b,\n\u201cReducibilities\u201d, in <em>Handbook of Computability\nTheory</em>, Edward R. Griffor (ed.), (Studies in Logic and the\nFoundations of Mathematics 140), Amsterdam: Elsevier, 89\u2013119.\ndoi:10.1016/S0049-237X(99)80019-6",
                "<li id=\"ref-Owings1973\">Owings, James C., 1973, \u201cDiagonalization\nand the Recursion Theorem.\u201d, <em>Notre Dame Journal of Formal\nLogic</em>, 14(1): 95\u201399. doi:10.1305/ndjfl/1093890812",
                "<li id=\"ref-Peano1889\">Peano, Giuseppe, 1889, <em>Arithmetices\nPrincipia, Nova Methodo Exposita</em>, Turin: Bocca.",
                "<li id=\"ref-Peirce1881\">Peirce, C. S., 1881, \u201cOn the Logic of\nNumber\u201d, <em>American Journal of Mathematics</em>, 4(1/4):\n85\u201395. doi:10.2307/2369151",
                "<li id=\"ref-Peter1932\">P\u00e9ter, R\u00f3zsa, 1932,\n\u201cRekursive Funktionen\u201d, in <em>Verhandlungen Des\nInternationalen Mathematiker- Kongresses Z\u00fcrich</em>, Vol. 2, pp.\n336\u2013337.",
                "<li id=\"ref-Peter1935\">\u2013\u2013\u2013, 1935,\n\u201cKonstruktion nichtrekursiver Funktionen\u201d,\n<em>Mathematische Annalen</em>, 111(1): 42\u201360.\ndoi:10.1007/BF01472200",
                "<li id=\"ref-Peter1959\">\u2013\u2013\u2013, 1959,\n\u201cRekursivit\u00e4t und Konstruktivit\u00e4t\u201d, in\n<em>Constructivity in Mathematics</em>, Arend Heyting (ed.),\nNorth-Holland, Amsterdam, pp. 226\u2013233.",
                "<li id=\"ref-Peter1967\">\u2013\u2013\u2013, 1967, <em>Recursive\nFunctions</em>, Istv\u00e1n F\u00f6ldes (trans.), New York: Academic\nPress.",
                "<li id=\"ref-Poincare1906\">Poincar\u00e9, Henri, 1906, \u201cLes\nMath\u00e9matiques et La Logique\u201d, <em>Revue de\nM\u00e9taphysique et de Morale</em>, 14(3): 294\u2013317.",
                "<li id=\"ref-Post1944\">Post, Emil L., 1944, \u201cRecursively\nEnumerable Sets of Positive Integers and Their Decision\nProblems\u201d, <em>Bulletin of the American Mathematical\nSociety</em>, 50(5): 284\u2013317.\ndoi:10.1090/S0002-9904-1944-08111-1",
                "<li id=\"ref-Post1965\">\u2013\u2013\u2013, 1965, \u201cAbsolutely\nunsolvable problems and relatively undecidable propositions: Account\nof an anticipation\u201d (1941) in <em>The undecidable</em> M. Davis,\ned., New York: Raven Press, 338\u2013433.",
                "<li id=\"ref-Priest1997\">Priest, Graham, 1997, \u201cOn a Paradox of\nHilbert and Bernays\u201d, <em>Journal of Philosophical Logic</em>,\n26(1): 45\u201356. doi:10.1023/A:1017900703234",
                "<li id=\"ref-Putnam1965\">Putnam, Hilary, 1965, \u201cTrial and Error\nPredicates and the Solution to a Problem of Mostowski\u201d,\n<em>Journal of Symbolic Logic</em>, 30(1): 49\u201357.\ndoi:10.2307/2270581",
                "Rice, H. G., 1953, \u201cClasses of Recursively Enumerable Sets\nand Their Decision Problems\u201d, <em>Transactions of the American\nMathematical Society</em>, 74(2): 358\u2013358.\ndoi:10.1090/S0002-9947-1953-0053041-6",
                "<li id=\"ref-Robinson1947\">Robinson, Raphael, 1947, \u201cPrimitive\nRecursive Functions\u201d, <em>Bulletin of the American Mathematical\nSociety</em>, 53(10): 925\u2013942.\ndoi:10.1090/S0002-9904-1947-08911-4",
                "<li id=\"ref-Rogers1987\">Rogers, Hartley, 1987, <em>Theory of Recursive\nFunctions and Effective Computability</em>, Cambridge, MA: MIT\nPress.",
                "<li id=\"ref-Rose1984\">Rose, H. E., 1984, <em>Subrecursion: Functions\nand Hierarchies</em>, (Oxford Logic Guides, 9), Oxford: Clarendon\nPress.",
                "<li id=\"ref-Sacks1963\">Sacks, Gerald E., 1963a, <em>Degrees of\nUnsolvability</em>, Princeton, NJ: Princeton University Press.",
                "<li id=\"ref-Sacks1963b\">\u2013\u2013\u2013, 1963b, \u201cOn the\nDegrees Less than 0\u2032\u201d, <em>The Annals of Mathematics</em>,\n77(2): 211\u2013231. doi:10.2307/1970214",
                "<li id=\"ref-Sacks1964\">\u2013\u2013\u2013, 1964, \u201cThe\nRecursively Enumerable Degrees Are Dense\u201d, <em>The Annals of\nMathematics</em>, 80(2): 300\u2013312. doi:10.2307/1970393",
                "<li id=\"ref-Sacks1990\">\u2013\u2013\u2013, 1990, <em>Higher\nRecursion Theory</em>, Berlin: Springer.",
                "<li id=\"ref-Schwichtenberg2011\">Schwichtenberg, Helmut and Stanley S.\nWainer, 2011, <em>Proofs and Computations</em>, Cambridge: Cambridge\nUniversity Press. doi:10.1017/CBO9781139031905",
                "<li id=\"ref-Shepherdson1963\">Shepherdson, J. C. and H. E. Sturgis,\n1963, \u201cComputability of Recursive Functions\u201d, <em>Journal\nof the ACM</em>, 10(2): 217\u2013255. doi:10.1145/321160.321170",
                "Shoenfield, Joseph R., 1959, \u201cOn Degrees of\nUnsolvability\u201d, <em>The Annals of Mathematics</em>, 69(3):\n644\u2013653. doi:10.2307/1970028",
                "<li id=\"ref-Shoenfield1960\">\u2013\u2013\u2013, 1960,\n\u201cDegrees of Models\u201d, <em>Journal of Symbolic Logic</em>,\n25(3): 233\u2013237. doi:10.2307/2964680",
                "<li id=\"ref-Shoenfield1967\">\u2013\u2013\u2013, 1967,\n<em>Mathematical Logic</em>, (Addison-Wesley serices in logic),\nReading, MA: Addison-Wesley.",
                "<li id=\"ref-Shoenfield1971\">\u2013\u2013\u2013, 1971, <em>Degrees\nof Unsolvability</em>, Amsterdam: North-Holland.",
                "<li id=\"ref-Shore1999\">Shore, Richard A. and Theodore A. Slaman, 1999,\n\u201cDefining the Turing Jump\u201d, <em>Mathematical Research\nLetters</em>, 6(6): 711\u2013722. doi:10.4310/MRL.1999.v6.n6.a10",
                "<li id=\"ref-Sieg1994\">Sieg, Wilfried, 1994, \u201cMechanical\nProcedures and Mathematical Experiences\u201d, in <em>Mathematics and\nMind</em>, Alexander George (ed.), Oxford: Oxford University Press,\npp. 71\u2013117.",
                "<li id=\"ref-Sieg1997\">\u2013\u2013\u2013, 1997, \u201cStep by\nRecursive Step: Church\u2019s Analysis of Effective\nCalculability\u201d, <em>Bulletin of Symbolic Logic</em>, 3(2):\n154\u2013180. doi:10.2307/421012",
                "<li id=\"ref-Sieg2005\">\u2013\u2013\u2013, 2005, \u201cOnly two\nletters: The correspondence between Herbrand and G\u00f6del\u201d,\n<em>Bulletin of Symbolic Logic</em>, 11(2): 172\u2013184.\ndoi:10.2178/bsl/1120231628",
                "<li id=\"ref-Sieg2009\">\u2013\u2013\u2013, 2009, \u201cOn\nComputability\u201d, in <em>Philosophy of Mathematics</em>, Andrew D.\nIrvine (ed.), (Handbook of the Philosophy of Science), Amsterdam:\nElsevier, 535\u2013630. doi:10.1016/B978-0-444-51555-1.50017-1",
                "<li id=\"ref-Simpson1977\">Simpson, Stephen G., 1977, \u201cFirst-Order\nTheory of the Degrees of Recursive Unsolvability\u201d, <em>The\nAnnals of Mathematics</em>, 105(1): 121\u2013139.\ndoi:10.2307/1971028",
                "<li id=\"ref-Simpson2009\">\u2013\u2013\u2013, 2009, <em>Subsystems\nof Second Order Arithmetic</em>, second edition, (Perspectives in\nLogic), Cambridge: Cambridge University Press.\ndoi:10.1017/CBO9780511581007",
                "<li id=\"ref-Singh1985\">Singh, Parmanand, 1985, \u201cThe So-Called\nFibonacci Numbers in Ancient and Medieval India\u201d, <em>Historia\nMathematica</em>, 12(3): 229\u2013244.\ndoi:10.1016/0315-0860(85)90021-7",
                "<li id=\"ref-Skolem1923a\">Skolem, Thoralf, 1923, \u201cBegr\u00fcndung\nDer Elementaren Arithmetik Durch Die Rekurrierende Denkweise Ohne\nAnwendung Scheinbarer Veranderlichen Mit Unendlichem\nAusdehnungsbereich\u201d, <em>Videnskapsselskapets Skrifter, I.\nMatematisk-Naturvidenskabelig Klasse</em>, 6: 1\u201338.",
                "<li id=\"ref-Skolem1946\">\u2013\u2013\u2013, 1946, \u201cThe\ndevelopment of recursive arithmetic\u201d In <em> Dix\u00edeme\nCongr\u00e9s des Mathimaticiens Scandinaves</em>, Copenhagen,\n1\u201316. Reprinted in Skolem 1970, pp. 499\u2013415. ",
                "<li id=\"ref-Skolem1970\"> \u2013\u2013\u2013, 1970, <em>Selected\nWorks in Logic</em> Olso: Universitetsforlaget. Edited by J.E.\nFenstad.",
                "<li id=\"ref-Slaman2008\">Slaman, Theodore A., 2008, \u201cGlobal\nProperties of the Turing Degrees and the Turing Jump\u201d, in\n<em>Computational Prospects of Infinity</em>, by Chitat Chong, Qi\nFeng, Theodore A Slaman, W Hugh Woodin, and Yue Yang, (Lecture Notes\nSeries, Institute for Mathematical Sciences, National University of\nSingapore 14), Singapore: World Scientific, 83\u2013101.\ndoi:10.1142/9789812794055_0002",
                "<li id=\"ref-Soare1987\">Soare, Robert I., 1987, <em>Recursively\nEnumerable Sets and Degrees: A Study of Computable Functions and\nComputably Generated Sets</em>, Berlin: Springer.",
                "<li id=\"ref-Soare1996\">\u2013\u2013\u2013, 1996,\n\u201cComputability and Recursion\u201d, <em>Bulletin of Symbolic\nLogic</em>, 2(3): 284\u2013321. doi:10.2307/420992",
                "<li id=\"ref-Soare2016\">\u2013\u2013\u2013, 2016, <em>Turing\nComputability: Theory and Applications</em>, Berlin: Springer.\ndoi:10.1007/978-3-642-31933-4",
                "<li id=\"ref-Spector1955\">Spector, Clifford, 1955, \u201cRecursive\nWell-Orderings\u201d, <em>Journal of Symbolic Logic</em>, 20(2):\n151\u2013163. doi:10.2307/2266902",
                "<li id=\"ref-Sudan1927\">Sudan, G., 1927, \u201cSur Le Nombre\nTransfinite \\(\\omega^{\\omega}\\)\u201d, <em>Bulletin\nMath\u00e9matique de La Soci\u00e9t\u00e9 Roumaine Des\nSciences</em>, 30(1): 11\u201330.",
                "Suslin, Michel, 1917, \u201cSur Une D\u00e9finition Des\nEnsembles Mesurables sans Nombres Transfinis\u201d, <em>Comptes\nRendus de l\u2019Acad\u00e9mie Des Sciences</em>, 164(2):\n88\u201391.",
                "<li id=\"ref-Tait1981\">Tait, W. W., 1981, \u201cFinitism\u201d,\n<em>The Journal of Philosophy</em>, 78(9): 524\u2013546.\ndoi:10.2307/2026089",
                "<li id=\"ref-Tarski1935\">Tarski, Alfred, 1935, \u201cDer\nWahrheitsbegriff in den formalisierten Sprachen\u201d, <em>Studia\nPhilosophica</em>, 1: 261\u2013405.",
                "<li id=\"ref-Tarski1953\">Tarski, Alfred, Andrzej Mostowski, and Raphael\nM. Robinson, 1953, <em>Undecidable Theories</em>, (Studies in Logic\nand the Foundations of Mathematics), Amsterdam: North-Holland.",
                "<li id=\"ref-Thomason1971\">Thomason, S. K., 1971, \u201cSublattices of\nthe Recursively Enumerable Degrees\u201d, <em>Zeitschrift f\u00fcr\nMathematische Logik und Grundlagen der Mathematik/Mathematical Logic\nQuarterly</em>, 17(1): 273\u2013280.\ndoi:10.1002/malq.19710170131",
                "<li id=\"ref-Turing1936\">Turing, Alan M., 1937, \u201cOn Computable\nNumbers, with an Application to the Entscheidungsproblem\u201d,\n<em>Proceedings of the London Mathematical Society</em>, s2-42(1):\n230\u2013265. doi:10.1112/plms/s2-42.1.230",
                "<li id=\"ref-Turing1939\">\u2013\u2013\u2013, 1939, \u201cSystems of\nLogic Based on Ordinals\u201d, <em>Proceedings of the London\nMathematical Society</em>, s2-45(1): 161\u2013228.\ndoi:10.1112/plms/s2-45.1.161",
                "<li id=\"ref-Wang1957\">Wang, Hao, 1957, \u201cThe Axiomatization of\nArithmetic\u201d, <em>Journal of Symbolic Logic</em>, 22(2):\n145\u2013158. doi:10.2307/2964176",
                "<li id=\"ref-Whitehead1910\">Whitehead, Alfred North and Bertrand\nRussell, 1910\u20131913, <em>Principia Mathematica</em>, first\nedition, Cambridge: Cambridge University Press."
            ]
        },
        "raw_text": "<div id=\"bibliography\">\n<h2 id=\"Bib\">Bibliography</h2>\n<p>\nNote: In cases where an English translation is available, page\nreferences in the main text and notes are to the indicated\ntranslations of the sources cited below.</p>\n<ul class=\"hanging\">\n<li id=\"ref-Ackermann1928\">Ackermann, Wilhelm, 1928, \u201c\u00dcber\ndie Erf\u00fcllbarkeit gewisser Z\u00e4hlausdr\u00fccke\u201d,\n<em>Mathematische Annalen</em>, 100: 638\u2013649.\ndoi:10.1007/BF01448869</li>\n<li id=\"ref-Adams2011\">Adams, Rod, 2011, <em>An Early History of\nRecursive Functions and Computability: From G\u00f6del to Turing</em>,\nBoston: Docent Press.</li>\n<li id=\"ref-Addison1954\">Addison, J.W., 1954, <em>On Some Points of\nthe Theory of Recursive Functions</em>, PhD thesis, University of\nWisconsin.</li>\n<li id=\"ref-Addison1958\">\u2013\u2013\u2013, 1958,\n\u201cSeparation Principles in the Hierarchies of Classical and\nEffective Descriptive Set Theory\u201d, <em>Fundamenta\nMathematicae</em>, 46(2): 123\u2013135.\ndoi:10.4064/fm-46-2-123-135</li>\n<li id=\"ref-Addison1959\">\u2013\u2013\u2013, 1959, \u201cSome\nConsequences of the Axiom of Constructibility\u201d, <em>Fundamenta\nMathematicae</em>, 46(3): 337\u2013357.\ndoi:10.4064/fm-46-3-337-357</li>\n<li id=\"ref-Basu2016\">Basu, Sankha S. and Stephen G. Simpson, 2016,\n\u201cMass Problems and Intuitionistic Higher-Order Logic\u201d,\n<em>Computability</em>, 5(1): 29\u201347. doi:10.3233/COM-150041</li>\n<li id=\"ref-Bimbo2010\">Bimb\u00f3, Katalin, 2012, <em>Combinatory\nLogic: Pure, Applied and Typed</em>, Boca Raton, FL: Chapman &amp;\nHall.</li>\n<li id=\"ref-Boolos2007\">Boolos, George S., John P. Burgess, and\nRichard C. Jeffrey, 2007, <em>Computability and Logic</em>, fifth\nedition, Cambridge: Cambridge University Press.\ndoi:10.1017/CBO9780511804076</li>\n<li id=\"ref-Calude1979\">Calude, Cristian, Solomon Marcus, and Ionel\nTevy, 1979, \u201cThe First Example of a Recursive Function Which Is\nNot Primitive Recursive\u201d, <em>Historia Mathematica</em>, 6(4):\n380\u2013384. doi:10.1016/0315-0860(79)90024-7</li>\n<li id=\"ref-Church1936a\">Church, Alonzo, 1936a, \u201cA Note on the\n<em>Entscheidungsproblem</em>\u201d, <em>Journal of Symbolic\nLogic</em>, 1(1): 40\u201341. doi:10.2307/2269326</li>\n<li id=\"ref-Church1936\">\u2013\u2013\u2013, 1936b, \u201cAn\nUnsolvable Problem of Elementary Number Theory\u201d, <em>American\nJournal of Mathematics</em>, 58(2): 345\u2013363.\ndoi:10.2307/2371045</li>\n<li id=\"ref-Clote2002\">Clote, Peter and Evangelos Kranakis, 2002,\n<em>Boolean Functions and Computation Models</em>, (Texts in\nTheoretical Computer Science. An EATCS Series), Berlin, Heidelberg:\nSpringer Berlin Heidelberg. doi:10.1007/978-3-662-04943-3</li>\n<li id=\"ref-Cooper2004\">Cooper, S. Barry, 2004, <em>Computability\nTheory</em>, Boca Raton, FL: Chapman &amp; Hall.</li>\n<li id=\"ref-Cutland1980\">Cutland, Nigel, 1980, <em>Computability: An\nIntroduction to Recursive Function Theory</em>, Cambridge: Cambridge\nUniversity Press. doi:10.1017/CBO9781139171496</li>\n<li id=\"ref-Davis1965\">Davis, Martin (ed.), 1965, <em>The Undecidable:\nBasic Papers on Undecidable Propositions, Unsolvable Problems and\nComputable Functions</em>, New York: Raven Press.</li>\n<li id=\"ref-Davis1982a\">\u2013\u2013\u2013, 1982, \u201cWhy\nG\u00f6del Didn\u2019t Have Church\u2019s Thesis\u201d,\n<em>Information and Control</em>, 54(1\u20132): 3\u201324.\ndoi:10.1016/S0019-9958(82)91226-8</li>\n<li id=\"ref-Davis1994\">Davis, Martin, Ron Sigal, and Elaine J.\nWeyuker, 1994, <em>Computability, Complexity, and Languages:\nFundamentals of Theoretical Computer Science</em>, second edition,\n(Computer Science and Scientific Computing), Boston: Academic Press,\nHarcourt, Brace.</li>\n<li id=\"ref-Dean2019a\">Dean, W., forthcoming, \u201cIncompleteness\nvia Paradox and Completeness\u201d, <em>The Review of Symbolic\nLogic</em>, first online: 23 May 2019.\ndoi:10.1017/S1755020319000212</li>\n<li id=\"ref-Dedekind1888\">Dedekind, Richard, 1888, <em>Was Sind Und\nWas Sollen Die Zahlen?</em>, Braunschweig: Vieweg.</li>\n<li id=\"ref-Enderton2010\">Enderton, Herbert B., 2010,\n<em>Computability Theory: An Introduction to Recursion Theory</em>,\nBurlington, MA: Academic Press.</li>\n<li id=\"ref-Epstein1989\">Epstein, Richard and Walter A. Carnielli,\n2008, <em>Computability: Computable Functions, Logic, and the\nFoundations of Mathematics</em>, Socorro, NM: Advance Reasoing\nForum.</li>\n<li id=\"ref-Ewald1996\">Ewald, William Bragg (ed.), 1996, <em>From Kant\nto Hilbert: A Source Book in the Foundations of Mathematics.</em>, New\nYork: Oxford University Press.</li>\n<li id=\"ref-Feferman1995a\">Feferman, Solomon, 1995, \u201cTuring in\nthe land of \\(O(z)\\)\u201d, in <em>The Universal Turing Machine a\nHalf-Century Survey</em>, Rolf Herken (ed.), Berlin: Springer, pp.\n103\u2013134.</li>\n<li id=\"ref-Sigler2003\">Fibonacci, 1202 [2003], <em>Fibonacci\u2019s\nLiber Abaci: A Translation into Modern English of Leonardo\nPisano\u2019s Book of Calculation</em>, L. E. Sigler (ed.), Berlin:\nSpringer.</li>\n<li id=\"ref-Friedberg1957\">Friedberg, R. M., 1957, \u201cTwo\nRecursively Enumerable Sets of Incomparable Degrees of Unsolvability\n(Solution of Post\u2019s Problem, 1944)\u201d, <em>Proceedings of\nthe National Academy of Sciences</em>, 43(2): 236\u2013238.\ndoi:10.1073/pnas.43.2.236</li>\n<li id=\"ref-Gandy1980\">Gandy, Robin, 1980, \u201cChurch\u2019s\nThesis and Principles for Mechanisms\u201d, in <em>The Kleene\nSymposium</em>, Jon Barwise, H. Jerome Keisler, and Kenneth Kunen\n(eds.), (Studies in Logic and the Foundations of Mathematics 101),\nAmsterdam: Elsevier, 123\u2013148.\ndoi:10.1016/S0049-237X(08)71257-6</li>\n<li id=\"ref-Godel1931a\">G\u00f6del, Kurt, 1931, \u201c\u00dcber\nformal unentscheidbare S\u00e4tze der Principia Mathematica und\nverwandter Systeme, I\u201d (On Formally Undecidable Propositions of\n<em>Principia Mathematica</em> and Related Systems\u00a0I),\n<em>Monatshefte f\u00fcr Mathematik und Physik</em>, 38:\n173\u2013198. Reprinted in G\u00f6del 1986: 144\u2013195.</li>\n<li id=\"ref-Godel1934a\">\u2013\u2013\u2013, 1934, \u201cOn\nUndecidable Propositions of Formal Mathematical Systems\u201d,\nPrinceton lectures. Reprinted in Godel 1986: 338-371.</li>\n<li id=\"ref-Godel1986\">\u2013\u2013\u2013, 1986, <em>Collected\nWorks. I: Publications 1929\u20131936</em>, Solomon Feferman, John W.\nDawson, Jr, Stephen C. Kleene, Gregory H. Moore, Robert M. Solovay,\nand Jean van Heijenoort (eds.), Oxford: Oxford University Press.</li>\n<li id=\"ref-Godel2003\">\u2013\u2013\u2013, 2003, <em>Collected\nWorks. V: Correspondence H\u2013Z</em>, Solomon Feferman, John W.\nDawson, Jr, Warren Goldfrab, Charles Parsons, and Wilfried Sieg\n(eds.), Oxford: Oxford University Press.</li>\n<li id=\"ref-Grassmann1861\">Grassmann, Hermann, 1861, <em>Lehrbuch Der\nArithmetik F\u00fcr H\u00f6here Lehranstalten</em>, Berin: Th. Chr.\nFr. Enslin.</li>\n<li id=\"ref-Greibach1975\">Greibach, Sheila A., 1975, <em>Theory of\nProgram Structures: Schemes, Semantics, Verification</em>, (Lecture\nNotes in Computer Science 36), Berlin/Heidelberg: Springer-Verlag.\ndoi:10.1007/BFb0023017</li>\n<li id=\"ref-Grzegorczyk1953\">Grzegorczyk, Andrzej, 1953, \u201cSome\nClasses of Recursive Functions\u201d, <em>Rozprawy Matematyczne</em>,\n4: 3\u201345.</li>\n<li id=\"ref-Grzegorczyk1958\">Grzegorczyk, A., A. Mostowski, and C.\nRyll-Nardzewski, 1958, \u201cThe Classical and the \u03c9-Complete\nArithmetic\u201d, <em>The Journal of Symbolic Logic</em>, 23(2):\n188\u2013206. doi:10.2307/2964398</li>\n<li id=\"ref-Heijenoort1967\">Heijenoort, Jean van (ed.), 1967, <em>From\nFrege to G\u00f6del : A Source Book in Mathematical Logic,\n1879\u20131931</em>, Cambridge, MA: Harvard University Press.</li>\n<li id=\"ref-Herbrand1930\">Herbrand, Jacques, 1930, \u201cLes Bases de\nla Logique Hilbertienne\u201d, <em>Revue de Metaphysique et de\nMorale</em>, 37(2): 243\u2013255.</li>\n<li id=\"ref-Herbrand1931\">\u2013\u2013\u2013, 1932, \u201cSur La\nNon-Contradiction de l\u2019Arithm\u00e9tique.\u201d, <em>Journal\nF\u00fcr Die Reine Und Angewandte Mathematik (Crelles Journal)</em>,\n166: 1\u20138. doi:10.1515/crll.1932.166.1</li>\n<li id=\"ref-Hilbert1900\">Hilbert, David, 1900, \u201cMathematische\nProbleme. Vortrag, Gehalten Auf Dem Internationalen\nMathematiker-Congress Zu Paris 1900\u201d, <em>Nachrichten von Der\nGesellschaft Der Wissenschaften Zu G\u00f6ttingen,\nMathematisch-Physikalische Klasse</em>, 253\u2013297. English\ntranslation as \u201cMathematical Problems\u201d in Ewald, 1996,\n1096\u20131105.</li>\n<li id=\"ref-Hilbert1905\">\u2013\u2013\u2013, 1905, \u201c\u00dcber\nDie Grundlagen Der Logik Und Der Arithmetik\u201d, in\n<em>Verhandlungen Des 3. Internationalen Mathematiker-Kongresses : In\nHeidelberg Vom 8. Bis 13. August 1904</em>, Leipzig: Teubner, pp.\n174\u2013185. English translation as \u201cOn the foundations of\nlogic and and arithmetic\u201d in van Heijenoort, 1967.</li>\n<li id=\"ref-Hilbert1920\">\u2013\u2013\u2013, 1920, \u201cLectures\non Logic \u2018Logic-Kalk\u00fcl\u2019 (1920)\u201d, reprinted in\nHilbert 2013: 298\u2013377.</li>\n<li id=\"ref-Hilbert1922\">\u2013\u2013\u2013, 1922,\n\u201cNeubegr\u00fcndung der Mathematik. Erste Mitteilung\u201d,\n<em>Abhandlungen aus dem Mathematischen Seminar der Universit\u00e4t\nHamburg</em>, 1(1): 157\u2013177. English translation as \u201cThe\nnew grounding of mathematics: First report\u201d in Ewald 1996,\n1115\u20131134. doi:10.1007/BF02940589</li>\n<li id=\"ref-Hilbert1923\">\u2013\u2013\u2013, 1923, \u201cDie\nlogischen Grundlagen der Mathematik\u201d, <em>Mathematische\nAnnalen</em>, 88(1\u20132): 151\u2013165. English translation as\n\u201cThe logical foundations of mathematics\u201d in Ewald 1996,\n1134\u20131148. doi:10.1007/BF01448445</li>\n<li id=\"ref-Hilbert1926\">\u2013\u2013\u2013, 1926, \u201c\u00dcber\ndas Unendliche\u201d, <em>Mathematische Annalen</em>, 95:\n161\u2013190. English translation as \u201cOn the infinite\u201d in\nvan Heijenoort 1967, 367\u2013292. doi:10.1007/BF01206605 </li>\n<li id=\"ref-Hilbert1929\">\u2013\u2013\u2013, 1930, \u201cProbleme\nder Grundlegung der Mathematik\u201d, <em>Mathematische Annalen</em>,\n102: 1\u20139. English translation as \u201cProblems of the\nGrounding of Mathematics\u201d in Mancosu 1998, 223\u2013233.\ndoi:10.1007/BF01782335</li>\n<li id=\"ref-Hilbert2013\">Hilbert, David, 2013, <em>David\nHilbert\u2019s Lectures on the Foundations of Arithmetic and Logic\n1917\u20131933</em>, William Ewald and Wilfried Sieg (eds.), Berlin,\nHeidelberg: Springer Berlin Heidelberg.\ndoi:10.1007/978-3-540-69444-1</li>\n<li id=\"ref-Hilbert1928\">Hilbert, David and Wilhelm Ackermann, 1928,\n<em>Grundz\u00fcge der theoretischen Logik</em>, first edition,\nBerlin: J. Springer.</li>\n<li id=\"ref-Hilbert1934\">Hilbert, David and Paul Bernays, 1934,\n<em>Grundlagen der Mathematik</em>, Vol. I, Berlin: Springer.</li>\n<li id=\"ref-Hilbert1939\">\u2013\u2013\u2013, 1939, <em>Grundlagen\nder Mathematik</em>, Vol. II, Berlin: Springer.</li>\n<li id=\"ref-Hinman1978\">Hinman, Peter G., 1978,\n<em>Recursion-Theoretic Hierarchies</em>, Berlin: Springer.</li>\n<li id=\"ref-Hopcroft1979\">Hopcroft, John and Jeffrey Ulman, 1979,\n<em>Introduction to Automata Theory, Languages, and Computation</em>,\nReading, MA: Addison-Wesley.</li>\n<li id=\"ref-Kaye1991\">Kaye, Richard, 1991, <em>Models of Peano\nArithmetic</em>, (Oxford Logic Guides, 15), Oxford: Clarendon\nPress.</li>\n<li id=\"ref-Kechris1995\">Kechris, Alexander S., 1995, <em>Classical\nDescriptive Set Theory</em>, Berlin: Springer.\ndoi:10.1007/978-1-4612-4190-4</li>\n<li id=\"ref-Kleene1936\">Kleene, S. C., 1936a, \u201cGeneral Recursive\nFunctions of Natural Numbers\u201d, <em>Mathematische Annalen</em>,\n112(1): 727\u2013742. doi:10.1007/BF01565439</li>\n<li id=\"ref-Kleene1936b\">\u2013\u2013\u2013, 1936b,\n\u201c\u03bb-Definability and Recursiveness\u201d, <em>Duke\nMathematical Journal</em>, 2(2): 340\u2013353.\ndoi:10.1215/S0012-7094-36-00227-2</li>\n<li id=\"ref-Kleene1938\">\u2013\u2013\u2013, 1938, \u201cOn\nNotation for Ordinal Numbers\u201d, <em>Journal of Symbolic\nLogic</em>, 3(4): 150\u2013155. doi:10.2307/2267778</li>\n<li id=\"ref-Kleene1943\">\u2013\u2013\u2013, 1943, \u201cRecursive\nPredicates and Quantifiers\u201d, <em>Transactions of the American\nMathematical Society</em>, 53(1): 41\u201341.\ndoi:10.1090/S0002-9947-1943-0007371-8</li>\n<li id=\"ref-Kleene1952\">\u2013\u2013\u2013, 1952, <em>Introduction\nto Metamathematics</em>, Amsterdam: North-Holland.</li>\n<li id=\"ref-Kleene1955a\">\u2013\u2013\u2013, 1955a,\n\u201cArithmetical Predicates and Function Quantifiers\u201d,\n<em>Transactions of the American Mathematical Society</em>, 79(2):\n312\u2013312. doi:10.1090/S0002-9947-1955-0070594-4</li>\n<li id=\"ref-Kleene1955b\">\u2013\u2013\u2013, 1955b,\n\u201cHierarchies of Number-Theoretic Predicates\u201d, <em>Bulletin\nof the American Mathematical Society</em>, 61(3): 193\u2013214.\ndoi:10.1090/S0002-9904-1955-09896-3</li>\n<li id=\"ref-Kleene1955c\">\u2013\u2013\u2013, 1955c, \u201cOn the\nForms of the Predicates in the Theory of Constructive Ordinals (Second\nPaper)\u201d, <em>American Journal of Mathematics</em>, 77(3):\n405\u2013428. doi:10.2307/2372632</li>\n<li id=\"ref-Kleene1954\">Kleene, S. C. and Emil L. Post, 1954,\n\u201cThe Upper Semi-Lattice of Degrees of Recursive\nUnsolvability\u201d, <em>The Annals of Mathematics</em>, 59(3):\n379\u2013407. doi:10.2307/1969708</li>\n<li id=\"ref-Kolmogorov1932\">Kolmogorov, Andrei, 1932, \u201cZur\nDeutung der intuitionistischen Logik\u201d, <em>Mathematische\nZeitschrift</em>, 35(1): 58\u201365. doi:10.1007/BF01186549</li>\n<li id=\"ref-Kondo1939\">Kond\u00f4, Motokiti, 1939, \u201cSur\nl\u2019uniformisation des Compl\u00e9mentaires Analytiques et les\nEnsembles Projectifs de la Seconde Classe\u201d, <em>Japanese Journal\nof Mathematics\u202f:Transactions and Abstracts</em>, 15:\n197\u2013230. doi:10.4099/jjm1924.15.0_197</li>\n<li id=\"ref-Kreisel1960\">Kreisel, George, 1960, \u201cLa\nPr\u00e9dicativit\u00e9\u201d, <em>Bulletin de La\nSoci\u00e9t\u00e9 Math\u00e9matique de France</em>, 79:\n371\u2013391. doi:10.24033/bsmf.1554</li>\n<li id=\"ref-Kreisel1965\">Kreisel, George and Gerald E. Sacks, 1965,\n\u201cMetarecursive Sets\u201d, <em>Journal of Symbolic Logic</em>,\n30(3): 318\u2013338. doi:10.2307/2269621</li>\n<li id=\"ref-Lachlan1966\">Lachlan, A. H., 1966, \u201cLower Bounds for\nPairs of Recursively Enumerable Degrees\u201d, <em>Proceedings of the\nLondon Mathematical Society</em>, s3-16(1): 537\u2013569.\ndoi:10.1112/plms/s3-16.1.537</li>\n<li id=\"ref-Lachlan1968\">\u2013\u2013\u2013, 1968,\n\u201cDistributive Initial Segments of the Degrees of\nUnsolvability\u201d, <em>Zeitschrift f\u00fcr Mathematische Logik und\nGrundlagen der Mathematik/Mathematical Logic Quarterly</em>, 14(30):\n457\u2013472. doi:10.1002/malq.19680143002</li>\n<li id=\"ref-Lachlan1980\">Lachlan, A.H and R.I Soare, 1980, \u201cNot\nEvery Finite Lattice Is Embeddable in the Recursively Enumerable\nDegrees\u201d, <em>Advances in Mathematics</em>, 37(1): 74\u201382.\ndoi:10.1016/0001-8708(80)90027-4</li>\n<li id=\"ref-Lusin1927\">Lusin, Nicolas, 1927, \u201cSur Les Ensembles\nAnalytiques\u201d, <em>Fundamenta Mathematicae</em>, 10: 1\u201395.\ndoi:10.4064/fm-10-1-1-95</li>\n<li id=\"ref-Mancosu1998\">Mancosu, Paolo, (ed.), 1998, <em>From Brouwer\nto Hilbert: The Debate on the Foundations of Mathematics in the\n1920s</em>, Oxford: Oxford University Press.</li>\n<li id=\"ref-McCarthy1963\">McCarthy, John, 1961, \u201cA Basis for a\nMathematical Theory of Computation, Preliminary Report\u201d, in\n<em>Papers Presented at the May 9-11, 1961, Western Joint IRE-AIEE-ACM\nComputer Conference on - IRE-AIEE-ACM \u201961 (Western)</em>, Los\nAngeles, California: ACM Press, 225\u2013238.\ndoi:10.1145/1460690.1460715</li>\n<li id=\"ref-Medvedev1955\">M\u00e9dv\u00e9d\u00e9v, \u00da. T.,\n1955, \u201cSt\u00e9p\u00e9ni trudnosti massovyh\nprobl\u00e9m\u201d (Degrees of Difficulty of Mass Problems),\n<em>Doklady Akad\u00e9mii Nauk SSSR</em>, 104: 501\u2013504.</li>\n<li id=\"ref-Moschovakis1989\">Moschovakis, Yiannis N., 1989, \u201cThe\nFormal Language of Recursion\u201d, <em>The Journal of Symbolic\nLogic</em>, 54(4): 1216\u20131252. doi:10.2307/2274814</li>\n<li id=\"ref-Moschovakis1994\">\u2013\u2013\u2013, 1994, <em>Notes on\nSet Theory</em>, (Undergraduate Texts in Mathematics), New York, NY:\nSpringer New York. doi:10.1007/978-1-4757-4153-7</li>\n<li id=\"ref-Moschovakis2009a\">\u2013\u2013\u2013, 2009,\n<em>Descriptive Set Theory</em>, second edition, Providence, RI:\nAmerican Mathematical Society.</li>\n<li id=\"ref-Moschovakis2009\">\u2013\u2013\u2013, 2010,\n\u201cKleene\u2019s Amazing Second Recursion Theorem\u201d, <em>The\nBulletin of Symbolic Logic</em>, 16(2): 189\u2013239.\ndoi:10.2178/bsl/1286889124</li>\n<li id=\"ref-Mostowski1946\">Mostowski, Andrzej, 1947, \u201cOn\nDefinable Sets of Positive Integers\u201d, <em>Fundamenta\nMathematicae</em>, 34: 81\u2013112. doi:10.4064/fm-34-1-81-112</li>\n<li id=\"ref-Muchnik1956\">Muchnik, A. A., 1956, \u201cOn the\nUnsolvability of the Problem of Reducibility in the Theory of\nAlgorithms\u201d, <em>Doklady Akad\u00e9mii Nauk SSSR</em>, 108:\n194\u2013197.</li>\n<li id=\"ref-Murawski1999\">Murawski, Roman, 1999, <em>Recursive\nFunctions and Metamathematics: Problems of Completeness and\nDecidability, Goedel\u2019s Theorems</em>, Dordrecht, Boston:\nKluwer.</li>\n<li id=\"ref-Myhill1955\">Myhill, John, 1955, \u201cCreative\nsets\u201d, <em>Zeitschrift f\u00fcr Mathematische Logik und\nGrundlagen der Mathematik/Mathematical Logic Quarterly</em>, 1(2):\n97\u2013108. doi:10.1002/malq.19550010205</li>\n<li id=\"ref-Odifreddi1989\">Odifreddi, Piergiogio, 1989, <em>Classical\nRecursion Theory. volume 1: The Theory of Functions and Sets of\nNatural Numbers</em>, (Studies in Logic and the Foundations of\nMathematics 125), Amsterdam: North-Holland</li>\n<li id=\"ref-Odifreddi1999\">\u2013\u2013\u2013, 1999a, <em>Classical\nRecursion Theory. volume 2</em>, (Studies in Logic and the Foundations\nof Mathematics 143), Amsterdam: North-Holland.</li>\n<li id=\"ref-Odifreddi1999a\">\u2013\u2013\u2013, 1999b,\n\u201cReducibilities\u201d, in <em>Handbook of Computability\nTheory</em>, Edward R. Griffor (ed.), (Studies in Logic and the\nFoundations of Mathematics 140), Amsterdam: Elsevier, 89\u2013119.\ndoi:10.1016/S0049-237X(99)80019-6</li>\n<li id=\"ref-Owings1973\">Owings, James C., 1973, \u201cDiagonalization\nand the Recursion Theorem.\u201d, <em>Notre Dame Journal of Formal\nLogic</em>, 14(1): 95\u201399. doi:10.1305/ndjfl/1093890812</li>\n<li id=\"ref-Peano1889\">Peano, Giuseppe, 1889, <em>Arithmetices\nPrincipia, Nova Methodo Exposita</em>, Turin: Bocca.</li>\n<li id=\"ref-Peirce1881\">Peirce, C. S., 1881, \u201cOn the Logic of\nNumber\u201d, <em>American Journal of Mathematics</em>, 4(1/4):\n85\u201395. doi:10.2307/2369151</li>\n<li id=\"ref-Peter1932\">P\u00e9ter, R\u00f3zsa, 1932,\n\u201cRekursive Funktionen\u201d, in <em>Verhandlungen Des\nInternationalen Mathematiker- Kongresses Z\u00fcrich</em>, Vol. 2, pp.\n336\u2013337.</li>\n<li id=\"ref-Peter1935\">\u2013\u2013\u2013, 1935,\n\u201cKonstruktion nichtrekursiver Funktionen\u201d,\n<em>Mathematische Annalen</em>, 111(1): 42\u201360.\ndoi:10.1007/BF01472200</li>\n<li id=\"ref-Peter1959\">\u2013\u2013\u2013, 1959,\n\u201cRekursivit\u00e4t und Konstruktivit\u00e4t\u201d, in\n<em>Constructivity in Mathematics</em>, Arend Heyting (ed.),\nNorth-Holland, Amsterdam, pp. 226\u2013233.</li>\n<li id=\"ref-Peter1967\">\u2013\u2013\u2013, 1967, <em>Recursive\nFunctions</em>, Istv\u00e1n F\u00f6ldes (trans.), New York: Academic\nPress.</li>\n<li id=\"ref-Poincare1906\">Poincar\u00e9, Henri, 1906, \u201cLes\nMath\u00e9matiques et La Logique\u201d, <em>Revue de\nM\u00e9taphysique et de Morale</em>, 14(3): 294\u2013317.</li>\n<li id=\"ref-Post1944\">Post, Emil L., 1944, \u201cRecursively\nEnumerable Sets of Positive Integers and Their Decision\nProblems\u201d, <em>Bulletin of the American Mathematical\nSociety</em>, 50(5): 284\u2013317.\ndoi:10.1090/S0002-9904-1944-08111-1</li>\n<li id=\"ref-Post1965\">\u2013\u2013\u2013, 1965, \u201cAbsolutely\nunsolvable problems and relatively undecidable propositions: Account\nof an anticipation\u201d (1941) in <em>The undecidable</em> M. Davis,\ned., New York: Raven Press, 338\u2013433.</li>\n<li id=\"ref-Priest1997\">Priest, Graham, 1997, \u201cOn a Paradox of\nHilbert and Bernays\u201d, <em>Journal of Philosophical Logic</em>,\n26(1): 45\u201356. doi:10.1023/A:1017900703234</li>\n<li id=\"ref-Putnam1965\">Putnam, Hilary, 1965, \u201cTrial and Error\nPredicates and the Solution to a Problem of Mostowski\u201d,\n<em>Journal of Symbolic Logic</em>, 30(1): 49\u201357.\ndoi:10.2307/2270581</li>\n<li>Rice, H. G., 1953, \u201cClasses of Recursively Enumerable Sets\nand Their Decision Problems\u201d, <em>Transactions of the American\nMathematical Society</em>, 74(2): 358\u2013358.\ndoi:10.1090/S0002-9947-1953-0053041-6</li>\n<li id=\"ref-Robinson1947\">Robinson, Raphael, 1947, \u201cPrimitive\nRecursive Functions\u201d, <em>Bulletin of the American Mathematical\nSociety</em>, 53(10): 925\u2013942.\ndoi:10.1090/S0002-9904-1947-08911-4</li>\n<li id=\"ref-Rogers1987\">Rogers, Hartley, 1987, <em>Theory of Recursive\nFunctions and Effective Computability</em>, Cambridge, MA: MIT\nPress.</li>\n<li id=\"ref-Rose1984\">Rose, H. E., 1984, <em>Subrecursion: Functions\nand Hierarchies</em>, (Oxford Logic Guides, 9), Oxford: Clarendon\nPress.</li>\n<li id=\"ref-Sacks1963\">Sacks, Gerald E., 1963a, <em>Degrees of\nUnsolvability</em>, Princeton, NJ: Princeton University Press.</li>\n<li id=\"ref-Sacks1963b\">\u2013\u2013\u2013, 1963b, \u201cOn the\nDegrees Less than 0\u2032\u201d, <em>The Annals of Mathematics</em>,\n77(2): 211\u2013231. doi:10.2307/1970214</li>\n<li id=\"ref-Sacks1964\">\u2013\u2013\u2013, 1964, \u201cThe\nRecursively Enumerable Degrees Are Dense\u201d, <em>The Annals of\nMathematics</em>, 80(2): 300\u2013312. doi:10.2307/1970393</li>\n<li id=\"ref-Sacks1990\">\u2013\u2013\u2013, 1990, <em>Higher\nRecursion Theory</em>, Berlin: Springer.</li>\n<li id=\"ref-Schwichtenberg2011\">Schwichtenberg, Helmut and Stanley S.\nWainer, 2011, <em>Proofs and Computations</em>, Cambridge: Cambridge\nUniversity Press. doi:10.1017/CBO9781139031905</li>\n<li id=\"ref-Shepherdson1963\">Shepherdson, J. C. and H. E. Sturgis,\n1963, \u201cComputability of Recursive Functions\u201d, <em>Journal\nof the ACM</em>, 10(2): 217\u2013255. doi:10.1145/321160.321170</li>\n<li>Shoenfield, Joseph R., 1959, \u201cOn Degrees of\nUnsolvability\u201d, <em>The Annals of Mathematics</em>, 69(3):\n644\u2013653. doi:10.2307/1970028</li>\n<li id=\"ref-Shoenfield1960\">\u2013\u2013\u2013, 1960,\n\u201cDegrees of Models\u201d, <em>Journal of Symbolic Logic</em>,\n25(3): 233\u2013237. doi:10.2307/2964680</li>\n<li id=\"ref-Shoenfield1967\">\u2013\u2013\u2013, 1967,\n<em>Mathematical Logic</em>, (Addison-Wesley serices in logic),\nReading, MA: Addison-Wesley.</li>\n<li id=\"ref-Shoenfield1971\">\u2013\u2013\u2013, 1971, <em>Degrees\nof Unsolvability</em>, Amsterdam: North-Holland.</li>\n<li id=\"ref-Shore1999\">Shore, Richard A. and Theodore A. Slaman, 1999,\n\u201cDefining the Turing Jump\u201d, <em>Mathematical Research\nLetters</em>, 6(6): 711\u2013722. doi:10.4310/MRL.1999.v6.n6.a10</li>\n<li id=\"ref-Sieg1994\">Sieg, Wilfried, 1994, \u201cMechanical\nProcedures and Mathematical Experiences\u201d, in <em>Mathematics and\nMind</em>, Alexander George (ed.), Oxford: Oxford University Press,\npp. 71\u2013117.</li>\n<li id=\"ref-Sieg1997\">\u2013\u2013\u2013, 1997, \u201cStep by\nRecursive Step: Church\u2019s Analysis of Effective\nCalculability\u201d, <em>Bulletin of Symbolic Logic</em>, 3(2):\n154\u2013180. doi:10.2307/421012</li>\n<li id=\"ref-Sieg2005\">\u2013\u2013\u2013, 2005, \u201cOnly two\nletters: The correspondence between Herbrand and G\u00f6del\u201d,\n<em>Bulletin of Symbolic Logic</em>, 11(2): 172\u2013184.\ndoi:10.2178/bsl/1120231628</li>\n<li id=\"ref-Sieg2009\">\u2013\u2013\u2013, 2009, \u201cOn\nComputability\u201d, in <em>Philosophy of Mathematics</em>, Andrew D.\nIrvine (ed.), (Handbook of the Philosophy of Science), Amsterdam:\nElsevier, 535\u2013630. doi:10.1016/B978-0-444-51555-1.50017-1</li>\n<li id=\"ref-Simpson1977\">Simpson, Stephen G., 1977, \u201cFirst-Order\nTheory of the Degrees of Recursive Unsolvability\u201d, <em>The\nAnnals of Mathematics</em>, 105(1): 121\u2013139.\ndoi:10.2307/1971028</li>\n<li id=\"ref-Simpson2009\">\u2013\u2013\u2013, 2009, <em>Subsystems\nof Second Order Arithmetic</em>, second edition, (Perspectives in\nLogic), Cambridge: Cambridge University Press.\ndoi:10.1017/CBO9780511581007</li>\n<li id=\"ref-Singh1985\">Singh, Parmanand, 1985, \u201cThe So-Called\nFibonacci Numbers in Ancient and Medieval India\u201d, <em>Historia\nMathematica</em>, 12(3): 229\u2013244.\ndoi:10.1016/0315-0860(85)90021-7</li>\n<li id=\"ref-Skolem1923a\">Skolem, Thoralf, 1923, \u201cBegr\u00fcndung\nDer Elementaren Arithmetik Durch Die Rekurrierende Denkweise Ohne\nAnwendung Scheinbarer Veranderlichen Mit Unendlichem\nAusdehnungsbereich\u201d, <em>Videnskapsselskapets Skrifter, I.\nMatematisk-Naturvidenskabelig Klasse</em>, 6: 1\u201338.</li>\n<li id=\"ref-Skolem1946\">\u2013\u2013\u2013, 1946, \u201cThe\ndevelopment of recursive arithmetic\u201d In <em> Dix\u00edeme\nCongr\u00e9s des Mathimaticiens Scandinaves</em>, Copenhagen,\n1\u201316. Reprinted in Skolem 1970, pp. 499\u2013415. </li>\n<li id=\"ref-Skolem1970\"> \u2013\u2013\u2013, 1970, <em>Selected\nWorks in Logic</em> Olso: Universitetsforlaget. Edited by J.E.\nFenstad.</li>\n<li id=\"ref-Slaman2008\">Slaman, Theodore A., 2008, \u201cGlobal\nProperties of the Turing Degrees and the Turing Jump\u201d, in\n<em>Computational Prospects of Infinity</em>, by Chitat Chong, Qi\nFeng, Theodore A Slaman, W Hugh Woodin, and Yue Yang, (Lecture Notes\nSeries, Institute for Mathematical Sciences, National University of\nSingapore 14), Singapore: World Scientific, 83\u2013101.\ndoi:10.1142/9789812794055_0002</li>\n<li id=\"ref-Soare1987\">Soare, Robert I., 1987, <em>Recursively\nEnumerable Sets and Degrees: A Study of Computable Functions and\nComputably Generated Sets</em>, Berlin: Springer.</li>\n<li id=\"ref-Soare1996\">\u2013\u2013\u2013, 1996,\n\u201cComputability and Recursion\u201d, <em>Bulletin of Symbolic\nLogic</em>, 2(3): 284\u2013321. doi:10.2307/420992</li>\n<li id=\"ref-Soare2016\">\u2013\u2013\u2013, 2016, <em>Turing\nComputability: Theory and Applications</em>, Berlin: Springer.\ndoi:10.1007/978-3-642-31933-4</li>\n<li id=\"ref-Spector1955\">Spector, Clifford, 1955, \u201cRecursive\nWell-Orderings\u201d, <em>Journal of Symbolic Logic</em>, 20(2):\n151\u2013163. doi:10.2307/2266902</li>\n<li id=\"ref-Sudan1927\">Sudan, G., 1927, \u201cSur Le Nombre\nTransfinite \\(\\omega^{\\omega}\\)\u201d, <em>Bulletin\nMath\u00e9matique de La Soci\u00e9t\u00e9 Roumaine Des\nSciences</em>, 30(1): 11\u201330.</li>\n<li>Suslin, Michel, 1917, \u201cSur Une D\u00e9finition Des\nEnsembles Mesurables sans Nombres Transfinis\u201d, <em>Comptes\nRendus de l\u2019Acad\u00e9mie Des Sciences</em>, 164(2):\n88\u201391.</li>\n<li id=\"ref-Tait1981\">Tait, W. W., 1981, \u201cFinitism\u201d,\n<em>The Journal of Philosophy</em>, 78(9): 524\u2013546.\ndoi:10.2307/2026089</li>\n<li id=\"ref-Tarski1935\">Tarski, Alfred, 1935, \u201cDer\nWahrheitsbegriff in den formalisierten Sprachen\u201d, <em>Studia\nPhilosophica</em>, 1: 261\u2013405.</li>\n<li id=\"ref-Tarski1953\">Tarski, Alfred, Andrzej Mostowski, and Raphael\nM. Robinson, 1953, <em>Undecidable Theories</em>, (Studies in Logic\nand the Foundations of Mathematics), Amsterdam: North-Holland.</li>\n<li id=\"ref-Thomason1971\">Thomason, S. K., 1971, \u201cSublattices of\nthe Recursively Enumerable Degrees\u201d, <em>Zeitschrift f\u00fcr\nMathematische Logik und Grundlagen der Mathematik/Mathematical Logic\nQuarterly</em>, 17(1): 273\u2013280.\ndoi:10.1002/malq.19710170131</li>\n<li id=\"ref-Turing1936\">Turing, Alan M., 1937, \u201cOn Computable\nNumbers, with an Application to the Entscheidungsproblem\u201d,\n<em>Proceedings of the London Mathematical Society</em>, s2-42(1):\n230\u2013265. doi:10.1112/plms/s2-42.1.230</li>\n<li id=\"ref-Turing1939\">\u2013\u2013\u2013, 1939, \u201cSystems of\nLogic Based on Ordinals\u201d, <em>Proceedings of the London\nMathematical Society</em>, s2-45(1): 161\u2013228.\ndoi:10.1112/plms/s2-45.1.161</li>\n<li id=\"ref-Wang1957\">Wang, Hao, 1957, \u201cThe Axiomatization of\nArithmetic\u201d, <em>Journal of Symbolic Logic</em>, 22(2):\n145\u2013158. doi:10.2307/2964176</li>\n<li id=\"ref-Whitehead1910\">Whitehead, Alfred North and Bertrand\nRussell, 1910\u20131913, <em>Principia Mathematica</em>, first\nedition, Cambridge: Cambridge University Press.</li>\n</ul>\n</div>"
    },
    "related_entries": {
        "entry_list": [
            "chance: versus randomness",
            "Church, Alonzo",
            "Church-Turing Thesis",
            "computability and complexity",
            "computational complexity theory",
            "computer science, philosophy of",
            "G\u00f6del, Kurt",
            "G\u00f6del, Kurt: incompleteness theorems",
            "Hilbert, David: program in the foundations of mathematics",
            "lambda calculus, the",
            "learning theory, formal",
            "logic: combinatory",
            "paradoxes: and contemporary logic",
            "proof theory",
            "reverse mathematics",
            "self-reference",
            "Turing, Alan",
            "Turing machines"
        ],
        "entry_link": [
            {
                "../chance-randomness/": "chance: versus randomness"
            },
            {
                "../church/": "Church, Alonzo"
            },
            {
                "../church-turing/": "Church-Turing Thesis"
            },
            {
                "../computability/": "computability and complexity"
            },
            {
                "../computational-complexity/": "computational complexity theory"
            },
            {
                "../computer-science/": "computer science, philosophy of"
            },
            {
                "../goedel/": "G\u00f6del, Kurt"
            },
            {
                "../goedel-incompleteness/": "G\u00f6del, Kurt: incompleteness theorems"
            },
            {
                "../hilbert-program/": "Hilbert, David: program in the foundations of mathematics"
            },
            {
                "../lambda-calculus/": "lambda calculus, the"
            },
            {
                "../learning-formal/": "learning theory, formal"
            },
            {
                "../logic-combinatory/": "logic: combinatory"
            },
            {
                "../paradoxes-contemporary-logic/": "paradoxes: and contemporary logic"
            },
            {
                "../proof-theory/": "proof theory"
            },
            {
                "../self-reference/": "self-reference"
            },
            {
                "../turing/": "Turing, Alan"
            },
            {
                "../turing-machine/": "Turing machines"
            }
        ]
    },
    "academic_tools": {
        "listed_text": [
            "<img alt=\"sep man icon\" src=\"../../symbols/sepman-icon.jpg\"/>",
            "<a href=\"https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=recursive-functions\" target=\"other\">How to cite this entry</a>.",
            "<img alt=\"sep man icon\" src=\"../../symbols/sepman-icon.jpg\"/>",
            "<a href=\"https://leibniz.stanford.edu/friends/preview/recursive-functions/\" target=\"other\">Preview the PDF version of this entry</a> at the\n <a href=\"https://leibniz.stanford.edu/friends/\" target=\"other\">Friends of the SEP Society</a>.",
            "<img alt=\"inpho icon\" src=\"../../symbols/inpho.png\"/>",
            "<a href=\"https://www.inphoproject.org/entity?sep=recursive-functions&amp;redirect=True\" target=\"other\">Look up topics and thinkers related to this entry</a>\n at the Internet Philosophy Ontology Project (InPhO).",
            "<img alt=\"phil papers icon\" src=\"../../symbols/pp.gif\"/>",
            "<a href=\"https://philpapers.org/sep/recursive-functions/\" target=\"other\">Enhanced bibliography for this entry</a>\nat <a href=\"https://philpapers.org/\" target=\"other\">PhilPapers</a>, with links to its database."
        ],
        "listed_links": [
            {
                "https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=recursive-functions": "How to cite this entry"
            },
            {
                "https://leibniz.stanford.edu/friends/preview/recursive-functions/": "Preview the PDF version of this entry"
            },
            {
                "https://leibniz.stanford.edu/friends/": "Friends of the SEP Society"
            },
            {
                "https://www.inphoproject.org/entity?sep=recursive-functions&redirect=True": "Look up topics and thinkers related to this entry"
            },
            {
                "https://philpapers.org/sep/recursive-functions/": "Enhanced bibliography for this entry"
            },
            {
                "https://philpapers.org/": "PhilPapers"
            }
        ]
    },
    "other_internet_resources": {
        "listed_text": [
            "Odifreddi, Piergiorgio and S. Barry Cooper, \u201cRecursive\nFunctions,\u201d <em>Stanford Encyclopedia of Philosophy</em> (Spring\n2020 Edition), Edward N. Zalta (ed.), URL =\n &lt;<a href=\"https://plato.stanford.edu/archives/spr2020/entries/recursive-functions/\" target=\"other\">https://plato.stanford.edu/archives/spr2020/entries/recursive-functions/</a>&gt;.\n [This was the previous entry on recursive functions in the\n<em>Stanford Encyclopedia of Philosophy</em> \u2014 see the\n <a class=\"plain\" href=\"https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=recursive-functions\" target=\"other\">version history</a>.]"
        ],
        "listed_links": [
            {
                "https://plato.stanford.edu/archives/spr2020/entries/recursive-functions/": "https://plato.stanford.edu/archives/spr2020/entries/recursive-functions/"
            },
            {
                "https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=recursive-functions": "version history"
            }
        ]
    }
}