{"url": "reasoning-automated", "title": "Automated Reasoning", "authorship": {"year": "Copyright \u00a9 2019", "author_text": "Frederic Portoraro\n<fred.portoraro@symlog.ca>", "author_links": [{"http://www.symlog.ca/Profile/Fred.htm": "Frederic Portoraro"}, {"mailto:fred%2eportoraro%40symlog%2eca": "fred.portoraro@symlog.ca"}], "raw_html": "<div id=\"article-copyright\">\n<p>\n<a href=\"../../info.html#c\">Copyright \u00a9 2019</a> by\n\n<br/>\n<a href=\"http://www.symlog.ca/Profile/Fred.htm\" target=\"other\">Frederic Portoraro</a>\n&lt;<a href=\"mailto:fred%2eportoraro%40symlog%2eca\"><em>fred<abbr title=\" dot \">.</abbr>portoraro<abbr title=\" at \">@</abbr>symlog<abbr title=\" dot \">.</abbr>ca</em></a>&gt;\n    </p>\n</div>"}, "pubinfo": ["First published Wed Jul 18, 2001", "substantive revision Sat Mar 2, 2019"], "preamble": "\n\nReasoning is the ability to make inferences, and automated reasoning\nis concerned with the building of computing systems that automate this\nprocess. Although the overall goal is to mechanize different forms of\nreasoning, the term has largely been identified with valid deductive\nreasoning as practiced in mathematics and formal logic. In this\nrespect, automated reasoning is akin to mechanical theorem proving.\nBuilding an automated reasoning program means providing an algorithmic\ndescription to a formal calculus so that it can be implemented on a\ncomputer to prove theorems of the calculus in an efficient manner.\nImportant aspects of this exercise involve defining the class of\nproblems the program will be required to solve, deciding what language\nwill be used by the program to represent the information given to it\nas well as new information inferred by the program, specifying the\nmechanism that the program will use to conduct deductive inferences,\nand figuring out how to perform all these computations efficiently.\nWhile basic research work continues in order to provide the necessary\ntheoretical framework, the field has reached a point where automated\nreasoning programs are being used by researchers to attack open\nquestions in mathematics and logic, provide important applications in\ncomputing science, solve problems in engineering, and find novel\napproaches to questions in exact philosophy. \n", "toc": [{"#Int": "1. Introduction"}, {"#ProDom": "1.1 Problem Domain"}, {"#LanRep": "1.2 Language Representation"}, {"#DedCal": "2. Deduction Calculi"}, {"#Res": "2.1 Resolution"}, {"#SeqDed": "2.2 Sequent Deduction"}, {"#NatDed": "2.3 Natural Deduction"}, {"#MatConMet": "2.4 The Matrix Connection Method"}, {"#TerRew": "2.5 Term Rewriting"}, {"#MatInd": "2.6 Mathematical Induction"}, {"#OthLog": "3. Other Logics"}, {"#HigOrdLog": "3.1 Higher-Order Logic"}, {"#NonClaLog": "3.2 Non-classical Logics"}, {"#App": "4. Applications"}, {"#LogPro": "4.1 Logic Programming"}, {"#SATSol": "4.2 SAT Solvers"}, {"#DedComAlg": "4.3 Deductive Computer Algebra"}, {"#ForVerHar": "4.4 Formal Verification of Hardware"}, {"#ForVerSof": "4.5 Formal Verification of Software"}, {"#LogicAndPhil": "4.6 Logic and Philosophy"}, {"#Mathematics": "4.7 Mathematics"}, {"#AI": "4.8 Artificial Intelligence"}, {"#Con": "5. Conclusion"}, {"#Bib": "Bibliography"}, {"#Aca": "Academic Tools"}, {"#Oth": "Other Internet Resources"}, {"#Rel": "Related Entries"}], "main_text": "\n1. Introduction\n\nA problem being presented to an automated reasoning program consists\nof two main items, namely a statement expressing the particular\nquestion being asked called the problem\u2019s conclusion,\nand a collection of statements expressing all the relevant information\navailable to the program\u2014the problem\u2019s\nassumptions. Solving a problem means proving the conclusion\nfrom the given assumptions by the systematic application of rules of\ndeduction embedded within the reasoning program. The problem solving\nprocess ends when one such proof is found, when the program is able to\ndetect the non-existence of a proof, or when it simply runs out of\nresources.\n1.1 Problem Domain\n\nA first important consideration in the design of an automated\nreasoning program is to delineate the class of problems that the\nprogram will be required to solve\u2014the problem\ndomain. The domain can be very large, as would be the case\nfor a general-purpose theorem prover for first-order logic, or be more\nrestricted in scope as in a special-purpose theorem prover for\nTarski\u2019s geometry, or the modal logic K. A typical approach in the\ndesign of an automated reasoning program is to provide it first with\nsufficient logical power (e.g., first-order logic) and then further\ndemarcate its scope to the particular domain of interest defined by a\nset of domain axioms. To illustrate, EQP, a\ntheorem-proving program for equational logic, was used to solve an\nopen question in Robbins algebra (McCune 1997): Are all Robbins\nalgebras Boolean? For this, the program was provided with the\naxioms defining a Robbins algebra:\n\n\n\n(A1)\nx + y = y + x\n(commutativity) \n\n(A2)\n(x + y) + z = x +\n(y + z)\n(associativity) \n\n(A3)\n\u2212(\u2212(x + y) + \u2212(x +\n\u2212y)) = x\n(Robbins equation) \n\n\n\nThe program was then used to show that a characterization of Boolean\nalgebra that uses Huntington\u2019s equation,\n\n\u2212(\u2212x + y) + \u2212(\u2212x +\n\u2212y) = x,\n\n\nfollows from the axioms. We should remark that this problem is\nnon-trivial since deciding whether a finite set of equations provides\na basis for Boolean algebra is undecidable, that is, it does not\npermit an algorithmic representation; also, the problem was attacked\nby Robbins, Huntington, Tarski and many of his students with no\nsuccess. The key step was to establish that all Robbins algebras\nsatisfy \n\n\u2203x\u2203y(x + y =\nx),\n\n\nsince it was known that this formula is a sufficient condition for a\nRobbins algebra to be Boolean. When EQP was supplied with this piece\nof information, the program provided invaluable assistance by\ncompleting the proof automatically. \n\nA special-purpose theorem prover does not draw its main benefit by\nrestricting its attention to the domain axioms but from the fact that\nthe domain may enjoy particular theorem-proving techniques which can\nbe hardwired\u2014coded\u2014within the reasoning program itself and\nwhich may result in a more efficient logic implementation. Much of\nEQP\u2019s success at settling the Robbins question can be attributed to\nits built-in associative-commutative inference mechanisms.\n1.2 Language Representation\n\nA second important consideration in the building of an automated\nreasoning program is to decide (1) how problems in its domain will be\npresented to the reasoning program; (2) how they will actually be\nrepresented internally within the program; and, (3) how the solutions\nfound\u2014completed proofs\u2014will be displayed back to the user.\nThere are several formalisms available for this, and the choice is\ndependent on the problem domain and the underlying deduction calculus\nused by the reasoning program. The most commonly used formalisms\ninclude standard first-order logic, typed \u03bb-calculus, and\nclausal logic. We take up clausal logic here and assume that the\nreader is familiar with the rudiments of first-order logic; for the\ntyped \u03bb-calculus the reader may want to check Church 1940.\nClausal logic is a quantifier-free variation of first-order logic and\nhas been the most widely used notation within the automated reasoning\ncommunity. Some definitions are in order: A term is a\nconstant, a variable, or a function whose arguments are themselves\nterms. For example, a, x, f(x),\nand h(c,f(z),y) are all\nterms. A literal is either an atomic formula, e.g.\nF(x), or the negation of an atomic formula, e.g.\n~R(x,f(a)). Two literals are\ncomplementary if one is the negation of the other. A\nclause is a (possibly empty) finite disjunction of\nliterals l1\u2228 \u2026 \u2228\nln where no literal appears more than once in the\nclause (that is, clauses can be alternatively treated as sets of\nliterals). Ground terms, ground literals, and ground\nclauses have no variables. The empty clause,\n[\u00a0], is the clause having no literals and, hence, is\nunsatisfiable\u2014false under any interpretation. Some examples:\n~R(a,b), and F(a) \u2228\n~R(f(x),b) \u2228\nF(z) are both examples of clauses but only the\nformer is ground. The general idea is to be able to express a\nproblem\u2019s formulation as a set of clauses or, equivalently, as a\nformula in conjunctive normal form (CNF), that is, as\na conjunction of clauses.\n\nFor formulas already expressed in standard logic notation, there is a\nsystematic two-step procedure for transforming them into conjunctive\nnormal form. The first step consists in re-expressing a formula into a\nsemantically equivalent formula in prenex normal\nform,\n(\u0398x1)\u2026(\u0398xn)\u03b1(x1,\u2026,xn), consisting of a\nstring of quantifiers\n(\u0398x1)\u2026(\u0398xn)\nfollowed by a quantifier-free expression\n\u03b1(x1,\u2026,xn) called\nthe matrix. The second step in the transformation\nfirst converts the matrix into conjunctive normal form by using\nwell-known logical equivalences such as DeMorgan\u2019s laws, distribution,\ndouble-negation, and others; then, the quantifiers in front of the\nmatrix, which is now in conjunctive normal form, are dropped according\nto certain rules. In the presence of existential quantifiers, this\nlatter step does not always preserve equivalence and requires the\nintroduction of Skolem functions whose role is to\n\u201csimulate\u201d the behaviour of existentially quantified\nvariables. For example, applying the skolemizing process to the\nformula\n\n\u2200x\u2203y\u2200z\u2203u\u2200v[R(x,y,v)\n\u2228 ~K(x,z,u,v)]\n\n\nrequires the introduction of a one-place and two-place Skolem\nfunctions, f and g respectively, resulting in the\nformula\n\n\u2200x\u2200z\u2200v[R(x,f(x),v)\n\u2228\n~K(x,z,g(x,z),v)]\n\n\nThe universal quantifiers can then be removed to obtain the final\nclause, R(x,f(x),v) \u2228\n~K(x,z,g(x,z),v)\nin our example. The Skolemizing process may not preserve equivalence\nbut maintains satisfiability, which is enough for clause-based\nautomated reasoning.\n\nAlthough clausal form provides a more uniform and economical\nnotation\u2014there are no quantifiers and all formulas are\ndisjunctions\u2014it has certain disadvantages. One drawback is the\nincrease in the size of the resulting formula when transformed from\nstandard logic notation into clausal form. The increase in size is\naccompanied by an increase in cognitive complexity that makes it\nharder for humans to read proofs written with clauses. Another\ndisadvantage is that the syntactic structure of a formula in standard\nlogic notation can be used to guide the construction of a proof but\nthis information is completely lost in the transformation into clausal\nform.\n2. Deduction Calculi\n\nA third important consideration in the building of an automated\nreasoning program is the selection of the actual deduction calculus\nthat will be used by the program to perform its inferences. As\nindicated before, the choice is highly dependent on the nature of the\nproblem domain and there is a fair range of options available:\nGeneral-purpose theorem proving and problem solving (first-order\nlogic, simple type theory), program verification (first-order logic),\ndistributed and concurrent systems (modal and temporal logics),\nprogram specification (intuitionistic logic), hardware verification\n(higher-order logic), logic programming (Horn logic), constraint\nsatisfaction (propositional clausal logic), computational metaphysics\n(higher-order modal logic), and others.\n\nA deduction calculus consists of a set of logical axioms and a\ncollection of deduction rules for deriving new formulas from\npreviously derived formulas. Solving a problem in the program\u2019s\nproblem domain then really means establishing a particular formula\n\u03b1\u2014the problem\u2019s conclusion\u2014from the extended set\n\u0393 consisting of the logical axioms, the domain axioms, and the\nproblem assumptions. That is, the program needs to determine if\n\u0393 entails \u03b1, \u0393\u22a8\u00a0\u03b1. How the program\ngoes about establishing this semantic fact depends, of course, on the\ncalculus it implements. Some programs may take a very\ndirect route and attempt to establish that\n\u0393\u00a0\u22a8\u00a0\u03b1 by actually constructing a\nstep-by-step proof of \u03b1 from \u0393. If successful, this shows\nof course that \u0393 derives\u2014proves\u2014\u03b1, a fact we\ndenote by writing \u0393\u00a0\u22a2\u00a0\u03b1. Other reasoning\nprograms may instead opt for a more indirect approach\nand try to establish that \u0393\u00a0\u22a8\u00a0\u03b1 by showing\nthat \u0393 \u222a {~\u03b1} is inconsistent which, in turn, is shown\nby deriving a contradiction, \u22a5, from the set \u0393 \u222a\n{~\u03b1}. Automated systems that implement the former approach\ninclude natural deduction systems; the latter approach is used by\nsystems based on resolution, sequent deduction, and matrix connection\nmethods.\n\nSoundness and completeness are two (metatheoretical) properties of a\ncalculus that are particularly important for automated deduction.\nSoundness states that the rules of the calculus are\ntruth-preserving. For a direct calculus this means that if\n\u0393\u00a0\u22a2\u00a0\u03b1 then\n\u0393\u00a0\u22a8\u00a0\u03b1. For indirect calculi, soundness\nmeans that if \u0393\u222a{~\u03b1}\u00a0\u22a2\u00a0\u22a5 then\n\u0393\u00a0\u22a8\u00a0\u03b1. Completeness in a\ndirect calculus states that if \u0393\u00a0\u22a8\u00a0\u03b1 then\n\u0393\u00a0\u22a2\u00a0\u03b1. For indirect calculi, the\ncompleteness property is expressed in terms of\nrefutations since one establishes that\n\u0393\u00a0\u22a8\u00a0\u03b1 by showing the existence of a proof,\nnot of \u03b1 from \u0393, but of \u22a5 from\n\u0393\u222a{~\u03b1}. Thus, an indirect calculus is\nrefutation complete if \u0393 \u22a8 \u03b1\nimplies \u0393\u222a{~\u03b1}\u00a0\u22a2\u00a0\u22a5. Of the two\nproperties, soundness is the most desirable. An incomplete calculus\nindicates that there are entailment relations that cannot be\nestablished within the calculus. For an automated reasoning program\nthis means, informally, that there are true statements that the\nprogram cannot prove. Incompleteness may be an unfortunate affair but\nlack of soundness is a truly problematic situation since an unsound\nreasoning program would be able to generate false conclusions from\nperfectly true information.\n\nIt is important to appreciate the difference between a logical\ncalculus and its corresponding implementation in a reasoning program.\nThe implementation of a calculus invariably involves making some\nmodifications to the calculus and this results, strictly speaking, in\na new calculus. The most important modification to the original\ncalculus is the \u201cmechanization\u201d of its deduction rules,\nthat is, the specification of the systematic way in which the rules\nare to be applied. In the process of doing so, one must exercise care\nto preserve the metatheoretical properties of the original\ncalculus.\n\nTwo other metatheoretical properties of importance to automated\ndeduction are decidability and complexity. A calculus is\ndecidable if it admits an algorithmic representation,\nthat is, if there is an algorithm that, for any given \u0393 and\n\u03b1, it can determine in a finite amount of time the answer,\n\u201cYes\u201d or \u201cNo\u201d, to the question \u201cDoes\n\u0393\u00a0\u22a8\u00a0\u03b1?\u201d A calculus may be\nundecidable in which case one needs to determine which decidable\nfragment to implement. The time-space complexity of a\ncalculus specifies how efficient its algorithmic representation is.\nAutomated reasoning is made the more challenging because many calculi\nof interest are not decidable and have poor complexity measures\nforcing researchers to seek tradeoffs between deductive power versus\nalgorithmic efficiency.\n2.1 Resolution\n\nOf the many calculi used in the implementation of reasoning programs,\nthe ones based on the resolution principle have been\nthe most popular. Resolution is modeled after the chain rule (of which\nModus Ponens is a special case) and essentially states that from\np \u2228 q and ~q \u2228 r one can\ninfer p \u2228 r. More formally, let C\n\u2212 l denote the clause C with the literal\nl removed. Assume that C1 and\nC2 are ground clauses containing, respectively, a\npositive literal l1 and a negative literal\n~l2 such that l1 and\n~l2 are complementary. Then, the rule of\nground resolution states that, as a result of\nresolving C1 and\nC2, one can infer (C1 \u2212\nl1) \u2228 (C2 \u2212\n~l2):\n\n\n\n\nC1\u00a0\u00a0\u00a0\u00a0\u00a0C2\n\n (ground resolution) \n\n (C1 \u2212 l1) \u2228\n(C2 \u2212 ~l2) \n\n\n\nHerbrand\u2019s theorem (Herbrand 1930) assures us that\nthe non-satisfiability of any set of clauses, ground or not,\ncan be established by using ground resolution. This is a very\nsignificant result for automated deduction since it tells us that if a\nset \u0393 is not satisfied by any of the infinitely many\ninterpretations, this fact can be determined in finitely many\nsteps. Unfortunately, a direct implementation of ground resolution\nusing Herbrand\u2019s theorem requires the generation of a vast number of\nground terms making this approach hopelessly inefficient. This issue\nwas effectively addressed by generalizing the ground resolution rule\nto binary resolution and by introducing the notion of\nunification (Robinson 1965a). Unification allows resolution proofs to\nbe \u201clifted\u201d and be conducted at a more general level;\nclauses only need to be instantiated at the moment where they are to\nbe resolved. Moreover, the clauses resulting from the instantiation\nprocess do not have to be ground instances and may still contain\nvariables. The introduction of binary resolution and unification is\nconsidered one of the most important developments in the field of\nautomated reasoning.\nUnification\n\nA unifier of two expressions\u2014terms or\nclauses\u2014is a substitution that when applied to the expressions\nmakes them equal. For example, the substitution \u03c3 given by\n\n\u03c3 := {x \u2190 b, y \u2190\nb, z \u2190 f(a,b)}\n\n\nis a unifier for \n\nR(x,f(a,y)) and\nR(b,z)\n\n\nsince when applied to both expressions it makes them equal: \n\n\n\nR(x,f(a,y))\u03c3\n\n\u00a0\n=\n\u00a0\nR(b,f(a,b))\n\n\n\u00a0\n\u00a0\n=\n\u00a0\nR(b,z)\u03c3 \n\n\n\nA most general unifier (mgu) produces the most\ngeneral instance shared by two unifiable expressions. In the previous\nexample, the substitution {x \u2190 b, y\n\u2190 b, z \u2190\nf(a,b)} is a unifier but not an mgu;\nhowever, {x \u2190 b, z \u2190\nf(a,y)} is an mgu. Note that unification\nattempts to \u201cmatch\u201d two expressions and this fundamental\nprocess has become a central component of most automated deduction\nprograms, resolution-based and otherwise.\nTheory-unification is an extension of the unification\nmechanism that includes built-in inference capabilities. For example,\nthe clauses R(g(a,b),x)\nand R(g(b,a),d) do not\nunify but they AC-unify, where AC-unification is unification with\nbuilt-in associative and commutative rules such as\ng(a,b) = g(b,a).\nShifting inference capabilities into the unification mechanism adds\npower but at a price: The existence of an mgu for two unifiable\nexpressions may not be unique (there could actually be infinitely\nmany), and the unification process becomes undecidable in general.\n\nBinary resolution\n\nLet C1 and C2 be two clauses\ncontaining, respectively, a positive literal l1\nand a negative literal ~l2 such that\nl1 and l2 unify with mgu\n\u03b8. Then, \n\n\n\n\nC1\u00a0\u00a0\u00a0\u00a0\u00a0C2\n\n (binary resolution) \n\n (C1\u03b8 \u2212\nl1\u03b8) \u2228 (C2\u03b8\n\u2212 ~l2\u03b8) \n\n\n\nby binary resolution; the clause (C1\u03b8\n\u2212 l1\u03b8) \u2228\n(C2\u03b8 \u2212 ~l2\u03b8)\nis called a binary resolvent of\nC1 and C2. \nFactoring\n\nIf two or more literals occurring in a clause C share an mgu\n\u03b8 then C\u03b8 is a factor of\nC. For example, in R(x,a) \u2228\n~K(f(x),b) \u2228\nR(c,y) the literals\nR(x,a) and\nR(c,y) unify with mgu {x \u2190\nc, y \u2190 a} and, hence,\nR(c,a) \u2228\n~K(f(c),b) is a factor of the\noriginal clause. \nThe Resolution Principle\n\nLet C1and C2 be two clauses.\nThen, a resolvent obtained by\nresolution from C1 and\nC2 is defined as: (a) a binary resolvent of\nC1 and C2; (b) a binary\nresolvent of C1 and a factor of\nC2; (c) a binary resolvent of a factor of\nC1 and C2; or, (d) a binary\nresolvent of a factor of C1 and a factor of\nC2. \n\nResolution proofs, more precisely refutations, are constructed by\nderiving the empty clause [\u00a0] from \u0393 \u222a {~\u03b1} using\nresolution; this will always be possible if \u0393 \u222a {~\u03b1}\nis unsatisfiable since resolution is refutation complete (Robinson\n1965a). As an example of a resolution proof, we show that the set\n{\u2200x(P(x) \u2228\nQ(x)), \u2200x(P(x)\n\u2283\nR(x)),\u2200x(Q(x)\n\u2283 R(x))}, denoted by \u0393, entails the\nformula \u2203xR(x). The first step is to\nfind the clausal form of \u0393 \u222a\n{~\u2203xR(x)}; the resulting clause set,\ndenoted by S0, is shown in steps 1 to 4 in the\nrefutation below. The refutation is constructed by using a\nlevel-saturation method: Compute all the resolvents of the initial\nset, S0, add them to the set and repeat the\nprocess until the empty clause is derived. (This produces the sequence\nof increasingly larger sets: S0,\nS1, S2,\u2026) The only\nconstraint that we impose is that we do not resolve the same two\nclauses more than once.\n\n\n\nS0\n1\nP(x) \u2228 Q(x)\nAssumption \n\n\u00a0\n2\n~P(x) \u2228 R(x)\nAssumption \n\n\u00a0\n3\n~Q(x) \u2228 R(x)\nAssumption \n\n\u00a0\n4\n~R(a)\nNegate conclusion \n\nS1\n5\nQ(x) \u2228 R(x)\nRes 1 2 \n\n\u00a0\n6\nP(x) \u2228 R(x)\nRes 1 3 \n\n\u00a0\n7\n~P(a)\nRes 2 4 \n\n\u00a0\n8\n~Q(a)\nRes 3 4 \n\nS2\n9\nQ(a)\nRes 1 7 \n\n\u00a0\n10\nP(a)\nRes 1 8 \n\n\u00a0\n11\nR(x)\nRes 2 6 \n\n\u00a0\n12\nR(x)\nRes 3 5 \n\n\u00a0\n13\nQ(a)\nRes 4 5 \n\n\u00a0\n14\nP(a)\nRes 4 6 \n\n\u00a0\n15\nR(a)\nRes 5 8 \n\n\u00a0\n16\nR(a)\nRes 6 7 \n\nS3\u00a0\u00a0\n17\nR(a)\nRes 2 10 \n\n\u00a0\n18\nR(a)\nRes 2 14 \n\n\u00a0\n19\nR(a)\nRes 3 9 \n\n\u00a0\n20\nR(a)\nRes 3 13 \n\n\u00a0\n21\u00a0\n[\u00a0]\nRes 4 11 \n\n\n\nAlthough the resolution proof is successful in deriving [\u00a0], it\nhas some significant drawbacks. To start with, the refutation is too\nlong as it takes 21 steps to reach the contradiction, [\u00a0]. This\nis due to the na\u00efve brute-force nature of the implementation. The\napproach not only generates too many formulas but some are clearly\nredundant. Note how R(a) is derived six times; also,\nR(x) has more \u201cinformation content\u201d than\nR(a) and one should keep the former and disregard\nthe latter. Resolution, like all other automated deduction methods,\nmust be supplemented by strategies aimed at improving the efficiency\nof the deduction process. The above sample derivation has 21 steps but\nresearch-type problems command derivations with thousands or hundreds\nof thousands of steps.\nResolution Strategies\n\nThe successful implementation of a deduction calculus in an automated\nreasoning program requires the integration of search strategies that\nreduce the search space by pruning unnecessary deduction paths. Some\nstrategies remove redundant clauses or tautologies as soon as they\nappear in a derivation. Another strategy is to remove more specific\nclauses in the presence of more general ones by a process known as\nsubsumption (Robinson 1965a). Unrestricted\nsubsumption, however, does not preserve the refutation completeness of\nresolution and, hence, there is a need to restrict its applicability\n(Loveland 1978). Model elimination (Loveland 1969)\ncan discard a sentence by showing that it is false in some model of\nthe axioms. The subject of model generation has received much\nattention as a complementary process to theorem proving. The method\nhas been used successfully by automated reasoning programs to show the\nindependence of axioms sets and to determine the existence of discrete\nmathematical structures meeting some given criteria. \n\nInstead of removing redundant clauses, some strategies prevent the\ngeneration of useless clauses in the first place. The\nset-of-support strategy (Wos, Carson & Robinson\n1965) is one of the most powerful strategies of this kind. A subset\nT of the set S, where S is initially\n\u0393 \u222a {~\u03b1}, is called a set of support\nof S iff S \u2212 T is satisfiable.\nSet-of-support resolution dictates that the resolved clauses are not\nboth from S \u2212 T. The motivation behind\nset-of-support is that since the set \u0393 is usually satisfiable it\nmight be wise not to resolve two clauses from \u0393 against each\nother. Hyperresolution (Robinson 1965b) reduces the\nnumber of intermediate resolvents by combining several resolution\nsteps into a single inference step.\n\nIndependently co-discovered, linear resolution\n(Loveland 1970, Luckham 1970) always resolves a clause against the\nmost recently derived resolvent. This gives the deduction a simple\n\u201clinear\u201d structure affording a straightforward\nimplementation; yet, linear resolution preserves refutation\ncompleteness. Using linear resolution we can derive the empty clause\nin the above example in only eight steps:\n\n\n\n1\u00a0\nP(x) \u2228 Q(x)\nAssumption \n\n2\n~P(x) \u2228 R(x)\nAssumption \n\n3\n~Q(x) \u2228 R(x)\nAssumption \n\n4\n~R(a)\nNegated conclusion \n\n5\n~P(a)\nRes 2 4 \n\n6\nQ(a)\nRes 1 5 \n\n7\nR(a)\nRes 3 6 \n\n8\n[\u00a0]\nRes 4 7 \n\n\n\nWith the exception of unrestricted subsumption, all the strategies\nmentioned so far preserve refutation completeness. Efficiency is an\nimportant consideration in automated reasoning and one may sometimes\nbe willing to trade completeness for speed. Unit\nresolution and input resolution are two such\nrefinements of linear resolution. In the former, one of the resolved\nclauses is always a literal; in the latter, one of the resolved\nclauses is always selected from the original set to be refuted. Albeit\nefficient, neither strategy is complete. Ordering strategies impose\nsome form of partial ordering on the predicate symbols, terms,\nliterals, or clauses occurring in the deduction. Ordered\nresolution treats clauses not as sets of literals but as\nsequences\u2014linear orders\u2014of literals. Ordered resolution is\nextremely efficient but, like unit and input resolution, is not\nrefutation complete. To end, it must be noted that some strategies\nimprove certain aspects of the deduction process at the expense of\nothers. For instance, a strategy may reduce the size of the proof\nsearch space at the expense of increasing, say, the length of the\nshortest refutations. A taxonomy and detailed presentation of\ntheorem-proving strategies can be found in (Bonacina 1999).\n\nThere are several automated reasoning programs that are based on\nresolution, or refinements of resolution. Otter (succeeded by Prover4)\nwas a driving force in the development of automated reasoning (Wos,\nOverbeek, Lusk & Boyle 1984) but it has been superseded by more\ncapable programs like Vampire (Voronkov 1995, Kov\u00e1cs &\nVoronkov 2013). Resolution also provides the underlying\nlogico-computational mechanism for the popular logic programming\nlanguage Prolog (Clocksin & Mellish 1981).\n2.2 Sequent Deduction\n\nHilbert-style calculi (Hilbert and Ackermann 1928) have been\ntraditionally used to characterize logic systems. These calculi\nusually consist of a few axiom schemata and a small number of rules\nthat typically include modus ponens and the rule of substitution.\nAlthough they meet the required theoretical requisites (soundness,\ncompleteness, etc.) the approach at proof construction in these\ncalculi is difficult and does not reflect standard practice. It was\nGentzen\u2019s goal \u201cto set up a formalism that reflects as\naccurately as possible the actual logical reasoning involved in\nmathematical proofs\u201d (Gentzen 1935). To carry out this task,\nGentzen analyzed the proof-construction process and then devised two\ndeduction calculi for classical logic: the natural deduction calculus,\nNK, and the sequent calculus, LK.\n(Gentzen actually designed NK first and then introduced LK to pursue\nmetatheoretical investigations). The calculi met his goal to a large\nextent while at the same time managing to secure soundness and\ncompleteness. Both calculi are characterized by a relatively larger\nnumber of deduction rules and a simple axiom schema. Of the two\ncalculi, LK is the one that has been most widely used in\nimplementations of automated reasoning programs, and it is the one\nthat we will discuss first; NK will be discussed in the next\nsection.\n\nAlthough the application of the LK rules affect logic formulas, the\nrules are seen as manipulating not logic formulas themselves but\nsequents. Sequents are expressions of the form\n\u0393 \u2192 \u0394, where both \u0393 and \u0394 are (possibly\nempty) sets of formulas. \u0393 is the sequent\u2019s\nantecedent and \u0394 its\nsuccedent. Sequents can be interpreted thus: Let\nI be an interpretation. Then,\n\nI satisfies the sequent \u0393 \u2192\n\u0394 (written as: I\n\u22a8\u00a0\u0393\u2192\u0394) iff\n\neither I \u22ad \u03b1 (for some\n\u03b1 \u2208 \u0393) or I \u22a8\n\u03b2 (for some \u03b2 \u2208 \u0394).\n\n\nIn other words, \n\nI \u22a8\u0393 \u2192 \u0394 iff\nI \u22a8\u00a0(\u03b11\n& \u2026 & \u03b1n) \u2283\n(\u03b21 \u2228 \u2026 \u2228 \u03b2n),\nwhere \u03b11 & \u2026 &\n\u03b1n is the iterated conjunction of the\nformulas in \u0393 and \u03b21 \u2228 \u2026 \u2228\n\u03b2n is the iterated disjunction of those in\n\u0394.\n\n\nIf \u0393 or \u0394 are empty then they are respectively valid or\nunsatisfiable. An axiom of LK is a sequent \u0393\n\u2192 \u0394 where \u0393 \u2229 \u0394 \u2260 \u2205. Thus, the\nrequirement that the same formula occurs at each side of the \u2192\nsign means that the axioms of LK are valid, for no interpretation can\nthen make all the formulas in \u0393 true and, simultaneously, make\nall those in \u0394 false. LK has two rules per logical connective,\nplus one extra rule: the cut rule. \n\n\n Axioms \n Cut Rule  \n\n\n\n\n \u00a0\u00a0  \n\n \u0393, \u03b1 \u2192 \u0394, \u03b1\n \n \n\n\n\n \u0393 \u2192 \u0394,\n\u03b1 \n \u03b1, \u03bb \u2192\n\u03a3  \n\n \u0393, \u03bb \u2192\n\u0394, \u03a3  \n  \n\n Antecedent Rules (\u0398\u2192) \n Succedent Rules (\u2192\u0398)  \n\n&\u2192\n\n\n\n \u0393, \u03b1, \u03b2\n\u2192 \u0394  \n\n \u0393, \u03b1 & \u03b2 \u2192\n\u0394  \n \n\u2192&\n\n\n\n \u0393 \u2192 \u0394,\n\u03b1 \n \u0393 \u2192 \u0394,\n\u03b2  \n\n \u0393 \u2192 \u0394,\n\u03b1 & \u03b2  \n  \n\n\u2228\u2192\n\n\n\n \u0393, \u03b1 \u2192\n\u0394 \n \u0393, \u03b2 \u2192\n\u0394  \n\n \u0393, \u03b1 \u2228 \u03b2\n\u2192 \u0394  \n \n\u2192\u2228\n\n\n\n \u0393 \u2192 \u0394,\n\u03b1, \u03b2  \n\n \u0393 \u2192 \u0394, \u03b1 \u2228\n\u03b2  \n  \n\n\u2283\u2192\n\n\n\n \u0393 \u2192 \u0394,\n\u03b1 \n \u0393, \u03b2 \u2192\n\u0394  \n\n \u0393, \u03b1 \u2283 \u03b2\n\u2192 \u0394  \n \n\u2192\u2283\n\n\n\n \u0393, \u03b1 \u2192\n\u0394, \u03b2  \n\n \u0393 \u2192 \u0394, \u03b1 \u2283\n\u03b2  \n  \n\n\u2283\u2261\n\n\n\n \u0393, \u03b1, \u03b2\n\u2192 \u0394 \n \u0393 \u2192 \u0394,\n\u03b1, \u03b2  \n\n \u0393, \u03b1 \u2261\n\u03b2 \u2192 \u0394  \n \n\u2261\u2283\n\n\n\n \u0393, \u03b1 \u2192\n\u0394, \u03b2 \n \u0393, \u03b2, \u2192\n\u0394, \u03b1  \n\n \u0393 \u2192 \u0394,\n\u03b1 \u2261 \u03b2  \n  \n\n~\u2192\n\n\n\n \u0393 \u2192 \u0394,\n\u03b1  \n\n \u0393, ~\u03b1 \u2192 \u0394 \n\n \n\u2192~\n\n\n\n \u0393, \u03b1 \u2192\n\u0394  \n\n \u0393 \u2192 \u0394, ~\u03b1 \n\n  \n\n\u2203\u2192\n\n\n\n \u0393,\n\u03b1(a/x) \u2192 \u0394  \n\n \u0393,\n\u2203x\u03b1(x) \u2192 \u0394  \n \n\u2192\u2203\n\n\n\n \u0393 \u2192 \u0394,\n\u03b1(t/x), \u2203x\u03b1(x)\n \n\n \u0393 \u2192 \u0394,\n\u2203x\u03b1(x)  \n  \n\n\u2200\u2192\n\n\n\n \u0393,\n\u03b1(t/x), \u2200x\u03b1(x)\n\u2192 \u0394  \n\n \u0393,\n\u2200x\u03b1(x) \u2192 \u0394  \n \n\u2192\u2200\n\n\n\n \u0393 \u2192 \u0394,\n\u03b1(a/x)  \n\n \u0393 \u2192 \u0394,\n\u2200x\u03b1(x)  \n  \n\n\nThe sequents above a rule\u2019s line are called the rule\u2019s\npremises and the sequent below the line is the rule\u2019s\nconclusion. The quantification rules \u2203\u2192 and\n\u2192\u2200 have an eigenvariable condition that restricts their\napplicability, namely that a must not occur in \u0393,\n\u0394 or in the quantified sentence. The purpose of this restriction\nis to ensure that the choice of parameter, a, used in the\nsubstitution process is completely \u201carbitrary\u201d.\n\nProofs in LK are represented as trees where each node in the tree is\nlabeled with a sequent, and where the original sequent sits at the\nroot of the tree. The children of a node are the premises of the rule\nbeing applied at that node. The leaves of the tree are labeled with\naxioms. Here is the LK-proof of\n\u2203xR(x) from the set\n{\u2200x(P(x) \u2228\nQ(x)), \u2200x(P(x)\n\u2283\nR(x)),\u2200x(Q(x)\n\u2283 R(x))}. In the tree below, \u0393 stands for\nthis set:\n\n\n\n\n\n\n\n\u0393,P(a) \u2192\n\n\nP(a),R(a),\u2203xR(x)\n\n\n\u0393,P(a),R(a) \u2192\n\n\nR(a),\u2203xR(x) \n\n\n\n\u0393,P(a),P(a) \u2283\nR(a) \u2192\nR(a),\u2203xR(x) \n\n\n \u0393,P(a) \u2192\nR(a),\u2203xR(x) \n\n \n\n\n\n\n\u0393,Q(a) \u2192\n\n\nQ(a),R(a),\u2203xR(x)\n\n\n\u0393,Q(a),R(a) \u2192\n\n\nR(a),\u2203xR(x) \n\n\n\n\u0393,Q(a),Q(a) \u2283\nR(a) \u2192\nR(a),\u2203xR(x) \n\n\n \u0393,Q(a) \u2192\nR(a),\u2203xR(x) \n\n  \n\n\n\n\n\n\u0393,P(a) \u2228 Q(a) \u2192\nR(a),\u2203xR(x) \n\n\n \u0393 \u2192\nR(a),\u2203xR(x) \n\n\n \u0393 \u2192 \u2203xR(x) \n\n  \n\n\n\nIn our example, all the leaves in the proof tree are labeled with\naxioms. This establishes the validity of \u0393 \u2192\n\u2203xR(x) and, hence, the fact that\n\u0393\u00a0\u22a8\u00a0\u2203xR(x). LK\ntakes an indirect approach at proving the conclusion and this is an\nimportant difference between LK and NK. While NK constructs an actual\nproof (of the conclusion from the given assumptions), LK instead\nconstructs a proof that proves the existence of a proof (of the\nconclusion from the assumptions). For instance, to prove that \u03b1\nis entailed by \u0393, NK constructs a step-by-step proof of \u03b1\nfrom \u0393 (assuming that one exists); in contrast, LK first\nconstructs the sequent \u0393 \u2192 \u03b1 which then attempts to\nprove valid by showing that it cannot be made false. This is done by\nsearching for a counterexample that makes (all the sentences in)\n\u0393 true and makes \u03b1 false: If the search fails then a\ncounterexample does not exist and the sequent is therefore valid. In\nthis respect, proof trees in LK are actually refutation proofs. Like\nresolution, LK is refutation complete: If\n\u0393\u00a0\u22a8\u00a0\u03b1 then the sequent \u0393 \u2192\n\u03b1 has a proof tree.\n\nAs it stands, LK is unsuitable for automated deduction and there are\nsome obstacles that must be overcome before it can be efficiently\nimplemented. The reason is, of course, that the statement of the\ncompleteness of LK only has to assert, for each entailment relation,\nthe existence of a proof tree but a reasoning program has the more\ndifficult task of actually having to construct one. Some of the main\nobstacles: First, LK does not specify the order in which the rules\nmust be applied in the construction of a proof tree. Second, and as a\nparticular case of the first problem, the premises in the rules\n\u2200\u2192 and \u2192\u2203 rules inherit the quantificational\nformula to which the rule is applied, meaning that the rules can be\napplied repeatedly to the same formula sending the proof search into\nan endless loop. Third, LK does not indicate which formula must be\nselected next in the application of a rule. Fourth, the quantifier\nrules provide no indication as to what terms or free variables must be\nused in their deployment. Fifth, and as a particular case of the\nprevious problem, the application of a quantifier rule can lead into\nan infinitely long tree branch because the proper term to be used in\nthe instantiation never gets chosen. Fortunately, as we will hint at\nbelow each of these problems can be successfully addressed.\n\nAxiom sequents in LK are valid, and the conclusion of a rule is valid\niff its premises are. This fact allows us to apply the LK rules in\neither direction, forwards from axioms to conclusion, or backwards\nfrom conclusion to axioms. Also, with the exception of the cut rule,\nall the rules\u2019 premises are subformulas of their respective\nconclusions. For the purposes of automated deduction this is a\nsignificant fact and we would want to dispense with the cut rule;\nfortunately, the cut-free version of LK preserves its refutation\ncompleteness (Gentzen 1935). These results provide a strong case for\nconstructing proof trees in a backwards fashion; indeed, by working\nthis way a refutation in cut-free LK gets increasingly simpler as it\nprogresses since subformulas are simpler than their parent formulas.\nMoreover, and as far as propositional rules go, the new subformulas\nentered into the tree are completely dictated by the cut-free LK\nrules. Furthermore, and assuming the proof tree can be brought to\ncompletion, branches eventually end up with atoms and the presence of\naxioms can be quickly determined. Another reason for working backwards\nis that the truth-functional fragment of cut-free LK is\nconfluent in the sense that the order in which the\nnon-quantifier rules are applied is irrelevant: If there is a proof,\nregardless of what you do, you will run into it! To bring the\nquantifier rules into the picture, things can be arranged so that all\nrules have a fair chance of being deployed: Apply, as far as possible,\nall the non-quantifier rules before applying any of the quantifier\nrules. This takes care of the first and second obstacles, and it is no\ntoo difficult to see how the third one would now be handled. The\nfourth and fifth obstacles can be addressed by requiring that the\nterms to be used in the substitutions be suitably selected from the\nHerbrand universe (Herbrand 1930).\n\nThe use of sequent-type calculi in automated theorem proving was\ninitiated by efforts to mechanize mathematics (Wang 1960). At the\ntime, resolution captured most of the attention of the automated\nreasoning community but during the 1970s some researchers started to\nfurther investigate non-resolution methods (Bledsoe 1977), prompting a\nfrutiful and sustained effort to develop more human-oriented theorem\nproving systems (Bledsoe 1975, Nevins 1974). Eventually, sequent-type\ndeduction gained momentum again, particularly in its re-incarnation as\nanalytic tableaux (Fitting 1990). The method of\ndeduction used in tableaux is essentially cut-free LK\u2019s with sets used\nin lieu of sequents.\n2.3 Natural Deduction\n\nAlthough LK and NK are both commonly labeled as \u201cnatural\ndeduction\u201d systems, it is the latter which better deserves the\ntitle due to its more natural, human-like, approach to proof\nconstruction. The rules of NK are typically presented as acting on\nstandard logic formulas in an implicitly understood context, but they\nare also commonly given in the literature as acting more explicitly on\n\u201cjudgements\u201d, that is, expressions of the form\n\u0393\u00a0\u22a2\u00a0\u03b1 where \u0393 is a set of formulas\nand \u03b1 is a formula. This form is typically understood as making\nthe metastatement that there is a proof of \u03b1 from \u0393\n(Kleene 1962). Following Gentzen 1935 and Prawitz 1965 here we take\nthe former approach. The system NK has no logical axioms and provides\ntwo introduction-elimination rules for each logical connective:\n\n\n Introduction Rules (\u0398I)\n Elimination Rules (\u0398E)\n\n\n&I\n\n\n\n\n\u03b1 \n\n\u03b2  \n\n \u03b1\n& \u03b2  \n \n&E\n\n\n\n\n\u03b11 & \u03b12\n \n\n\n\u03b1i (for i = 1,2)  \n  \n\n\u2228I\n\n\n\n\n\u03b1i (for i =\n1,2)  \n\n \u03b11 \u2228 \u03b12  \n \n\u2228E\n\n\n\n\n\u03b1 \u2228 \u03b2 \n\n[\u03b1 \u2014 \u03b3] \n\n[\u03b2 \u2014 \u03b3]  \n\n \u03b3\n \n  \n\n\u2283I\n\n\n\n\n[\u03b1 \u2014 \u03b2]  \n\n \u03b1 \u2283 \u03b2\n \n \n\u2283E\n\n\n\n\n\u03b1 \n\n\u03b1 \u2283 \u03b2  \n\n \u03b2  \n  \n\n\u2261I\n\n\n\n\n[\u03b1 \u2014 \u03b2] \n\n[\u03b2 \u2014 \u03b1]  \n\n \u03b1 \u2261 \u03b2  \n \n\u2261E\n\n\n\n\n\u03b1i (i = 0,1) \n\n\u03b10 \u2261 \u03b11  \n\n \u03b11\u2212i  \n  \n\n~I\n\n\n\n\n[\u03b1 \u2014 \u22a5]  \n\n ~\u03b1  \n \n~E\n\n\n\n\n[~\u03b1 \u2014 \u22a5]  \n\n \u03b1  \n  \n\n\u2203I\n\n\n\n\n\u03b1(t/x)  \n\n\n\u2203x\u03b1(x)  \n \n\u2203E\n\n\n\n\n\u2203x\u03b1(x) \n\n[\u03b1(a/x) \u2014 \u03b2]  \n\n \u03b2  \n  \n\n\u2200I\n\n\n\n\n\u03b1(a/x)  \n\n\n\u2200x\u03b1(x)  \n \n\u2200E\n\n\n\n\n\u2200x\u03b1(x)  \n\n\n\u03b1(t/x)  \n  \n\n\nA few remarks: First, the expression\n[\u03b1\u00a0\u2014\u00a0\u03b3] represents the fact that \u03b1\nis an auxiliary assumption in the proof of \u03b3 that eventually\ngets discharged, i.e. discarded. For example, \u2203E tells us that\nif in the process of constructing a proof one has already derived\n\u2203x\u03b1(x) and also \u03b2 with\n\u03b1(a/x) as an auxiliary assumption then the\ninference to \u03b2 is allowed. Second, the eigenparameter,\na, in \u2203E and \u2200I must be foreign to the premises,\nundischarged\u2014\u201cactive\u201d\u2014assumptions, to the\nrule\u2019s conclusion and, in the case of \u2203E, to\n\u2203x\u03b1(x). Third, \u22a5 is shorthand for\ntwo contradictory formulas, \u03b2 and ~\u03b2. Finally, NK is\ncomplete: If \u0393\u00a0 \u22a8\u00a0\u00a0\u03b1 then there is a\nproof of \u03b1 from \u0393 using the rules of NK.\n\nAs in LK, proofs constructed in NK are represented as trees with the\nproof\u2019s conclusion sitting at the root of the tree, and the problem\u2019s\nassumptions sitting at the leaves. (Proofs are also typically given as\nsequences of judgements, \u0393\u00a0\u22a2\u00a0\u03b1, running\nfrom the top to the bottom of the printed page.) Here is a natural\ndeduction proof tree of \u2203xR(x) from\n\u2200x(P(x) \u2228\nQ(x)), \u2200x(P(x)\n\u2283 R(x)) and\n\u2200x(Q(x) \u2283\nR(x)):\n\n\n\n\n\n\n\n\u2200x(P(x)\u2228Q(x))\n \n\n P(a)\u2228Q(a)  \n \n\n\n\n\n\n\n\n\u2200x(P(x)\u2283R(x))\n \n\n P(a)\u2283R(a)  \n \n\n[P(a)\u2014R(a)]  \n\n R(a)  \n \n\n\n\n\n\n\n\n\u2200x(Q(x)\u2283R(x))\n \n\n Q(a)\u2283R(a)  \n \n\n[Q(a)\u2014R(a)]  \n\n R(a)  \n  \n\n\n R(a)\n\n \n\n\n \u2203xR(x) \n \n\n\n\nAs in LK, a forward-chaining strategy for proof construction is not\nwell focused. So, although proofs are read forwards, that is,\nfrom leaves to root or, logically speaking, from assumptions to\nconclusion, that is not the way in which they are typically\nconstructed. A backward-chaining strategy implemented by\napplying the rules in reverse order is more effective. Many of the\nobstacles that were discussed above in the implementation of sequent\ndeduction are applicable to natural deduction as well. These issues\ncan be handled in a similar way, but natural deduction introduces some\nissues of its own. For example, as suggested by the \u2283-Introduction\nrule, to prove a goal of the form \u03b1 \u2283 \u03b2 one could\nattempt to prove \u03b2 on the assumption that \u03b1. But note that\nalthough the goal \u03b1 \u2283 \u03b2 does not match the conclusion\nof any other introduction rule, it matches the conclusion of all\nelimination rules and the reasoning program would need to\nconsider those routes too. Similarly to forward-chaining, here there\nis the risk of setting goals that are irrelevant to the proof and that\ncould lead the program astray. To wit: What prevents a program from\nentering the never-ending process of building, say, larger and larger\nconjunctions? Or, what is there to prevent an uncontrolled chain of\nbackward applications of, say, \u2283-Elimination? Fortunately, NK\nenjoys the subformula property in the sense that each\nformula entering into a natural deduction proof can be restricted to\nbeing a subformula of \u0393 \u222a \u0394 \u222a {\u03b1}, where\n\u0394 is the set of auxiliary assumptions made by the ~-Elimination\nrule. By exploiting the subformula property a natural deduction\nautomated theorem prover can drastically reduce its search space and\nbring the backward application of the elimination rules under control\n(Portoraro 1998, Sieg & Byrnes 1996). Further gains can be realized\nif one is willing to restrict the scope of NK\u2019s logic to its\nintuitionistic fragment where every proof has a normal form in the\nsense that no formula is obtained by an introduction rule and then is\neliminated by an elimination rule (Prawitz 1965).\n\nImplementations of automated theorem proving systems using NK\ndeduction have been motivated by the desire to have the program reason\nwith precisely the same proof format and methods employed by the human\nuser. This has been particularly true in the area of education where\nthe student is engaged in the interactive construction of formal\nproofs in an NK-like calculus working under the guidance of a theorem\nprover ready to provide assistance when needed (Portoraro 1994, Suppes\n1981). Other, research-oriented, theorem provers true to the spirit of\nNK exist (Pelletier 1998) but are rare.\n2.4 The Matrix Connection Method\n\nThe name of the matrix connection method (Bibel 1981) is indicative of\nthe way it operates. The term \u201cmatrix\u201d refers to the form\nin which the set of logic formulas expressing the problem is\nrepresented; the term \u201cconnection\u201d refers to the way the\nmethod operates on these formulas. To illustrate the method at work,\nwe will use an example from propositional logic and show that\nR is entailed by P \u2228 Q, P \u2283\nR and Q \u2283 R. This is done by\nestablishing that the formula\n\n(P \u2228 Q) & (P \u2283 R) &\n(Q \u2283 R) & ~R\n\n\nis unsatisfiable. To do this, we begin by transforming it into\nconjunctive normal form: \n\n(P \u2228 Q) & (~P \u2228 R) &\n(~Q \u2228 R) & ~R\n\n\nThis formula is then represented as a matrix, one conjunct per row\nand, within a row, one disjunct per column:\n\n\nP\n\u00a0Q\u00a0 \n\n~P\nR \n\n~Q\nR \n\n~R\n\u00a0 \n\n\nThe idea now is to explore all the possible vertical paths running\nthrough this matrix. A vertical path is a set of\nliterals selected from each row in the matrix such that each literal\ncomes from a different row. The vertical paths:\n\n\nPath 1\nP, ~P, ~Q and ~R \n\nPath 2\nP, ~P, R and ~R \n\nPath 3\nP, R, ~Q and ~R \n\nPath 4\nP, R, R and ~R \n\nPath 5\nQ, ~P, ~Q and ~R \n\nPath 6\nQ, ~P, R and ~R \n\nPath 7\nQ, R, ~Q and ~R \n\nPath 8\nQ, R, R and ~R \n\n\nA path is complementary if it contains two literals\nwhich are complementary. For example, Path 2 is complementary since it\nhas both P and ~P but so is Path 6 since it contains\nboth R and ~R. Note that as soon as a path includes\ntwo complementary literals there is no point in pursuing the path\nsince it has itself become complementary. This typically allows for a\nlarge reduction in the number of paths to be inspected. In any event,\nall the paths in the above matrix are complementary and this fact\nestablishes the unsatisfiability of the original formula. This is the\nessence of the matrix connection method. The method can be extended to\npredicate logic but this demands additional logical apparatus:\nSkolemnization, variable renaming, quantifier duplication,\ncomplementarity of paths via unification, and simultaneous\nsubstitution across all matrix paths (Bibel 1981, Andrews 1981).\nVariations of the method have been implemented in reasoning programs\nin higher-order logic (Andrews 1981) and non-classical logics (Wallen\n1990).\n2.5 Term Rewriting\n\nEquality is an important logical relation whose behavior within\nautomated deduction deserves its own separate treatment.\nEquational logic and, more generally, term\nrewriting treat equality-like equations as rewrite\nrules, also known as reduction or\ndemodulation rules. An equality statement like\nf(a)= a allows the simplification of a term\nlike g(c,f(a)) to\ng(c,a). However, the same equation also has\nthe potential to generate an unboundedly large term:\ng(c,f(a)),\ng(c,f(f(a))),\ng(c,f(f(f(a)))),\n\u2026 . What distinguishes term rewriting from equational logic is\nthat in term rewriting equations are used as unidirectional reduction\nrules as opposed to equality which works in both directions. Rewrite\nrules have the form t1 \u21d2\nt2 and the basic idea is to look for terms\nt occurring in expressions e such that t\nunifies with t1 with unifier \u03b8 so that the\noccurrence t1\u03b8 in e\u03b8 can be\nreplaced by t2\u03b8. For example, the rewrite\nrule x + 0 \u21d2 x allows the rewriting of\nsucc(succ(0) + 0) as\nsucc(succ(0)).\n\nTo illustrate the main ideas in term rewriting, let us explore an\nexample involving symbolic differentiation (the example and ensuing\ndiscussion are adapted from Chapter 1 of Baader & Nipkow 1998). Let\nder denote the derivative respect to x, let\ny be a variable different from x, and let u\nand v be variables ranging over expressions. We define the\nrewrite system:\n\n\nR1:\nder(x) \u21d2 1 \n\nR2:\nder(y) \u21d2 0 \n\nR3:\nder(u + v) \u21d2\nder(u) + der(v) \n\nR4:\nder(u \u00d7 v) \u21d2 (u\n\u00d7 der(v)) + (der(u) \u00d7\nv) \n\n\nAgain, the symbol \u21d2 indicates that a term matching the left-hand\nside of a rewrite rule should be replaced by the rule\u2019s right-hand\nside. To see the differentiation system at work, let us compute the\nderivative of x \u00d7 x respect to x,\nder(x \u00d7 x):\n\n\nder(x \u00d7 x)\n\u21d2\n(x \u00d7 der(x)) +\n(der(x) \u00d7 x)\n\u00a0\nby R4 \n\n\u00a0\n\u21d2\n(x \u00d7 1) + (der(x) \u00d7\nx)\n\u00a0\nby R1 \n\n\u00a0\n\u21d2\n(x \u00d7 1) + (1 \u00d7 x)\n\u00a0\nby R1 \n\n\nAt this point, since none of the rules (R1)\u2013(R4) applies, no\nfurther reduction is possible and the rewriting process ends. The\nfinal expression obtained is called a normal form,\nand its existence motivates the following question: Is there an\nexpression whose reduction process will never terminate when applying\nthe rules (R1)\u2013(R4)? Or, more generally: Under what conditions a\nset of rewrite rules will always stop, for any given expression, at a\nnormal form after finitely many applications of the rules? This\nfundamental question is called the termination\nproblem of a rewrite system, and we state without proof that the\nsystem (R1)\u2013(R4) meets the termination condition.\n\nThere is the possibility that when reducing an expression, the set of\nrules of a rewrite system could be applied in more than one way. This\nis actually the case in the system (R1)\u2013(R4) where in the\nreduction of der(x \u00d7 x) we could have\napplied R1 first to the second sub-expression in (x \u00d7\nder(x)) + (der(x) \u00d7\nx), as shown below:\n\n\nder(x \u00d7 x)\n\u21d2\n(x \u00d7 der(x)) +\n(der(x) \u00d7 x)\n\u00a0\nby R4 \n\n\u00a0\n\u21d2\n(x \u00d7 der(x)) + (1 \u00d7\nx)\n\u00a0\nby R1 \n\n\u00a0\n\u21d2\n(x \u00d7 1) + (1 \u00d7 x)\n\u00a0\nby R1 \n\n\nFollowing this alternative course of action, the reduction terminates\nwith the same normal form as in the previous case. This fact, however,\nshould not be taken for granted: A rewriting system is said to be\n(globally) confluent if and only if independently of\nthe order in which its rules are applied every expression always ends\nup being reduced to its one and only normal form. It can be shown that\n(R1)\u2013(R4) is confluent and, hence, we are entitled to say:\n\u201cCompute the derivative of an expression\u201d (as\nopposed to simply \u201ca\u201d derivative). Adding more\nrules to a system in an effort to make it more practical can have\nundesired consequences. For example, if we add the rule\n\n\nR5:\nu + 0 \u21d2 u \n\n\nto (R1)\u2013(R4) then we will be able to further reduce certain\nexpressions but at the price of losing confluency. The following\nreductions show that der(x + 0) now has two normal\nforms: the computation\n\n\nder(x + 0)\n\u21d2\nder(x) + der(0)\n\u00a0\nby R3 \n\n\u00a0\n\u21d2\n1 + der(0)\n\u00a0\nby R1 \n\n\ngives one normal form, and\n\n\nder(x + 0)\n\u21d2\nder(x)\n\u00a0\nby R5 \n\n\u00a0\n\u21d2\n1\n\u00a0\nby R1 \n\n\ngives another. Adding the rule\n\n\nR6:\nder(0) \u21d2 0 \n\n\nwould allow the further reduction of 1 + der(0) to 1 + 0 and\nthen, by R5, to 1. Although the presence of this new rule actually\nincreases the number of alternative\npaths\u2014der(x + 0) can now be reduced in four\npossible ways\u2014they all end up with the same normal form, namely\n1. This is no coincidence as it can be shown that (R6) actually\nrestores confluency. This motivates another fundamental question:\nUnder what conditions can a non-confluent system be made into an\nequivalent confluent one? The Knuth-Bendix completion\nalgorithm (Knuth & Bendix 1970) gives a partial answer to this\nquestion.\n\nTerm rewriting, like any other automated deduction method, needs\nstrategies to direct its application. Rippling (Bundy, Stevens &\nHarmelen 1993, Basin & Walsh 1996) is a heuristic that has its\norigins in inductive theorem-proving that uses annotations to\nselectively restrict the rewriting process. The superposition calculus\nis a calculus of equational first-order logic that combines notions\nfrom first-order resolution and Knuth-Bendix ordering equality.\nSuperposition is refutation complete (Bachmair & Ganzinger 1994) and\nis at the heart of a number of theorem provers, most notably the E\nequational theorem prover (Schulz 2004) and Vampire (Voronkov\n1995).\n2.6 Mathematical Induction\n\nMathematical induction is a very important technique of theorem\nproving in mathematics and computer science. Problems stated in terms\nof objects or structures that involve recursive definitions or some\nform of repetition invariably require mathematical induction for their\nsolving. In particular, reasoning about the correctness of computer\nsystems requires induction and an automated reasoning program that\neffectively implements induction will have important applications.\n\nTo illustrate the need for mathematical induction, assume that a\nproperty \u03c6 is true of the number zero and also that if true of a\nnumber then is true of its successor. Then, with our deductive\nsystems, we can deduce that for any given number n, \u03c6 is\ntrue of it, \u03c6(n). But we cannot deduce that \u03c6 is true\nof all numbers, \u2200x\u03c6(x); this inference\nstep requires the rule of mathematical induction:\n\n\n\n\u03b1(0)\u00a0\u00a0\u00a0\u00a0\u00a0[\u03b1(n)\u00a0\u2014\u00a0\u03b1(succ(n))]\n\n (mathematical induction) \n\n\n\u2200x\u03b1(x) \n\n\nIn other words, to prove that \u2200x\u03b1(x)\none proves that \u03b1(0) is the case, and that\n\u03b1(succ(n)) follows from the assumption that\n\u03b1(n). The implementation of induction in a reasoning\nsystem presents very challenging search control problems. The most\nimportant of these is the ability to determine the particular way in\nwhich induction will be applied during the proof, that is, finding the\nappropriate induction schema. Related issues include selecting the\nproper variable of induction, and recognizing all the possible cases\nfor the base and the inductive steps.\n\nNqthm (Boyer & Moore 1979) has been one of the most successful\nimplementations of automated inductive theorem proving. In the spirit\nof Gentzen, Boyer and Moore were interested in how people prove\ntheorems by induction. Their theorem prover is written in the\nfunctional programming language Lisp which is also the language in\nwhich theorems are represented. For instance, to express the\ncommutativity of addition the user would enter the Lisp expression\n(EQUAL (PLUS X Y) (PLUS Y X)). Everything\ndefined in the system is a functional term, including its basic\n\u201cpredicates\u201d: T, F,\nEQUAL X Y, IF\nX Y Z, AND, NOT,\netc. The program operates largely as a black\nbox, that is, the inner working details are hidden from the user;\nproofs are conducted by rewriting terms that posses recursive\ndefinitions, ultimately reducing the conclusion\u2019s statement to the\nT predicate. The Boyer-Moore theorem prover\nhas been used to check the proofs of some quite deep theorems (Boyer,\nKaufmann & Moore 1995). Lemma caching, problem statement\ngeneralization, and proof planning are techniques particularly useful\nin inductive theorem proving (Bundy, Harmelen & Hesketh 1991).\n3. Other Logics\n3.1 Higher-Order Logic\n\nHigher-order logic differs from first-order logic in that\nquantification over functions and predicates is allowed. The statement\n\u201cAny two people are related to each other in one way or\nanother\u201d can be legally expressed in higher-order logic as\n\u2200x\u2200y\u2203RR(x,y)\nbut not in first-order logic. Higher-order logic is inherently more\nexpressive than first-order logic and is closer in spirit to actual\nmathematical reasoning. For example, the notion of set finiteness\ncannot be expressed as a first-order concept. Due to its richer\nexpressiveness, it should not come as a surprise that implementing an\nautomated theorem prover for higher-order logic is more challenging\nthan for first-order logic. This is largely due to the fact that\nunification in higher-order logic is more complex than in the\nfirst-order case: unifiable terms do not always possess a most general\nunifier, and higher-order unification is itself undecidable. Finally,\ngiven that higher-order logic is incomplete, there are always proofs\nthat will be entirely out of reach for any automated reasoning\nprogram.\n\nMethods used to automate first-order deduction can be adapted to\nhigher-order logic. TPS (Andrews et al. 1996, Andrews et\nal. 2006) is a theorem proving system for higher-order logic that\nuses Church\u2019s typed \u03bb-calculus as its logical representation\nlanguage and is based on a connection-type deduction mechanism that\nincorporates Huet\u2019s unification algorithm (Huet 1975). As a sample of\nthe capabilities of TPS, the program has proved automatically that a\nsubset of a finite set is finite, the equivalence among several\nformulations of the Axiom of Choice, and Cantor\u2019s Theorem that a set\nhas more subsets than members. The latter was proved by the program by\nasserting that there is no onto function from individuals to sets of\nindividuals, with the proof proceeding by a diagonal argument. HOL\n(Gordon & Melham 1993) is another higher-order proof development\nsystem primarily used as an aid in the development of hardware and\nsoftware safety-critical systems. HOL is based on the LCF approach to\ninteractive theorem proving (Gordon, Milner & Wadsworth 1979), and\nit is built on the strongly typed functional programming language ML.\nHOL, like TPS, can operate in automatic and interactive mode.\nAvailability of the latter mode is welcomed since the most useful\nautomated reasoning systems may well be those which place an emphasis\non interactive theorem proving (Farmer, Guttman & Thayer 1993) and\ncan be used as assistants operating under human guidance. (Harrison\n2000) discusses the verification of floating-point algorithms and the\nnon-trivial mathematical properties that are proved by HOL Light under\nthe guidance of the user. Isabelle (Paulson 1994) is a generic,\nhigher-order, framework for rapid prototyping of deductive systems.\nObject logics can be formulated within Isabelle\u2019s metalogic by using\nits many syntactic and deductive tools. Isabelle also provides some\nready-made theorem proving environments, including Isabelle/HOL,\nIsabelle/ZF and Isabelle/FOL, which can be used as starting points for\napplications and further development by the user (Paulson 1990, Nipkow\n& Paulson 2002). Isabelle/ZF has been used to prove equivalent\nformulations of the Axiom of Choice, formulations of the Well-Ordering\nPrinciple, as well as the key result about cardinal arithmetic that,\nfor any infinite cardinal \u03ba, \u03ba \u00b7 \u03ba = \u03ba\n(Paulson & Grabczewski 1996).\n\nTo help prove higher-order theorems and discharge goals arising in\ninteractive proofs, the user can ask Isabelle/HOL to invoke external\nfirst-order provers through Sledgehammer (Paulson 2010), a subsystem\naimed at combining the complementary capabilities of automated\nreasoning systems of different types, including SMT solvers (see\n4.2 SAT Solvers, in this article; Blanchette et al. 2013).\nLEO-II (Benzm\u00fcller et al. 2015) is also a resolution-based\nautomated theorem prover for higher-order logic that has been applied\nin a wide array of problems, most notably in the automation of\nG\u00f6del\u2019s ontological proof of God\u2019s existence (see 4.6 Logic\nand Philosophy, in this article). \n3.2 Non-classical Logics\n\nNon-classical logics (Haack 1978) such as modal logics, intuitionsitic\nlogic, multi-valued logics, autoepistemic logics, non-monotonic\nreasoning, commonsense and default reasoning, relevance logic,\nparaconsistent logic, and so on, have been increasingly gaining the\nattention of the automated reasoning community. One of the reasons has\nbeen the natural desire to extend automated deduction techniques to\nnew domains of logic. Another reason has been the need to mechanize\nnon-classical logics as an attempt to provide a suitable foundation\nfor artificial intelligence. A third reason has been the desire to\nattack some problems that are combinatorially too large to be handled\nby paper and pencil. Indeed, some of the work in automated\nnon-classical logic provides a prime example of automated reasoning\nprograms at work. To illustrate, the Ackerman Constant Problem asks\nfor the number of non-equivalent formulas in the relevance logic R.\nThere are actually 3,088 such formulas (Slaney 1984) and the number\nwas found by \u201csandwiching\u201d it between a lower and an upper\nlimit, a task that involved constraining a vast universe of\n20400 20-element models in search of those models that\nrejected non-theorems in R. It is safe to say that this result would\nhave been impossible to obtain without the assistance of an automated\nreasoning program.\n\nThere have been three basic approaches to automate the solving of\nproblems in non-classical logic (McRobie 1991). One approach has been,\nof course, to try to mechanize the non-classical deductive calculi.\nAnother has been to simply provide an equivalent formulation of the\nproblem in first-order logic and let a classical theorem prover handle\nit. A third approach has been to formulate the semantics of the\nnon-classical logic in a first-order framework where resolution or\nconnection-matrix methods would apply. (Pelletier et al.\n2017) describes an automated reasoning system for a paraconsistent\nlogic that takes both \u201cindirect\u201d approaches, the\ntranslational and the truth-value approach, to prove its theorems.\nModal logic\n\nModal logics find extensive use in computing science as logics of\nknowledge and belief, logics of programs, and in the specification of\ndistributed and concurrent systems. Thus, a program that automates\nreasoning in a modal logic such as K, K4, T, S4, or S5 would have\nimportant applications. With the exception of S5, these logics share\nsome of the important metatheoretical results of classical logic, such\nas cut-elimination, and hence cut-free (modal) sequent calculi can be\nprovided for them, along with techniques for their automation.\nConnection methods (Andrews 1981, Bibel 1981) have played an important\nrole in helping to understand the source of redundancies in the search\nspace induced by these modal sequent calculi and have provided a\nunifying framework not only for modal logics but also for\nintuitionistic and classical logic as well (Wallen 1990). Current\nefforts to automate modal logic reasoning revolve around the\ntranslational approach mentioned above, namely to embed modal logic\ninto classical logic and then use an existing automated reasoning\nsystem for the latter to prove theorems of the former.\n(Benzm\u00fcller & Paulson 2013) shows how to embed quantified modal\nlogic into simple type theory, proves the soundness and completeness\nof the embedding, and demonstrates with simple experiments how\nexisting higher-order theorem provers can be used to automate proofs\nin modal logic. The approach can be extended to higher-order modal\nlogic as well (Benzm\u00fcller & Paleo 2015).\nIntuitionistic logic\n\nThere are different ways in which intuitionsitic logic can be\nautomated. One is to directly implement the intuitionistic versions of\nGentzen\u2019s sequent and natural deduction calculi, LJ and NJ\nrespectively. This approach inherits the stronger normalization\nresults enjoyed by these calculi allowing for a more compact\nmechanization than their classical counterparts. Another approach at\nmechanizing intuitionistic logic is to exploit its semantic\nsimilarities with the modal logic S4 and piggy back on an automated\nimplementation of S4. Automating intuitionistic logic has applications\nin software development since writing a program that meets a\nspecification corresponds to the problem of proving the specification\nwithin an intuitionistic logic (Martin-L\u00f6f 1982). A system that\nautomated the proof construction process would have important\napplications in algorithm design but also in constructive mathematics.\nNuprl (Constable et al. 1986) is a computer system supporting\na particular mathematical theory, namely constructive type theory, and\nwhose aim is to provide assistance in the proof development process.\nThe focus is on logic-based tools to support programming and on\nimplementing formal computational mathematics. Over the years the\nscope of the Nuprl project has expanded from\n\u201cproofs-as-programs\u201d to \u201csystems-as-theories\u201d.\nSimilar in spirit and based on the Curry-Howard isomorphism, the Coq\nsystem formalizes its proofs in the Calculus of Inductive\nConstructions, a \u03bb-calculus with a rich system of types\nincluding dependent types (Coquand & Huet 1988, Coquand &\nPaulin-Mohring 1988). Like Nuprl, Coq is designed to assist in the\ndevelopment of mathematical proofs as well as computer programs from\ntheir formal specifications.\n4. Applications\n4.1 Logic Programming\n\nLogic programming, particularly represented by the language\nProlog (Colmerauer et al. 1973), is probably\nthe most important and widespread application of automated theorem\nproving. During the early 1970s, it was discovered that logic could be\nused as a programming language (Kowalski 1974). What distinguishes\nlogic programming from other traditional forms of programming is that\nlogic programs, in order to solve a problem, do not explicitly state\nhow a specific computation is to be performed; instead, a\nlogic program states what the problem is and then delegates\nthe task of actually solving it to an underlying theorem prover. In\nProlog, the theorem prover is based on a refinement of resolution\nknown as SLD-resolution. SLD-resolution is a\nvariation of linear input resolution that incorporates a special rule\nfor selecting the next literal to be resolved upon; SLD-resolution\nalso takes into consideration the fact that, in the computer\u2019s memory,\nthe literals in a clause are actually ordered, that is, they form a\nsequence as opposed to a set. A Prolog program\nconsists of clauses stating known facts and rules. For example, the\nfollowing clauses make some assertions about flight connections:\n\nflight(toronto, london).\n\nflight(london,rome).\n\nflight(chicago,london).\n\nflight(X,Y) :\u2013 flight(X,Z) ,\nflight(Z,Y).\n\n\nThe clause flight(toronto, london) is a fact while\nflight(X,Y) :\u2013 flight(X,Z)\n,\nflight(Z,Y) is a rule, written by convention as a\nreversed conditional (the symbol \u201c:\u2013\u201d means\n\u201cif\u201d; the comma means \u201cand\u201d; terms starting in\nuppercase are variables). The former states that there is flight\nconnection between Toronto and London; the latter states that there is\na flight between cities X and Y if, for some city\nZ, there is a flight between X and Z and\none between Z and Y. Clauses in Prolog programs are\na special type of Horn clauses having precisely one positive literal:\nFacts are program clauses with no negative literals\nwhile rules have at least one negative literal. (Note\nthat in standard clause notation the program rule in the previous\nexample would be written as flight(X,Y) \u2228\n~flight(X,Z) \u2228 ~flight(Z,Y).)\nThe specific form of the program rules is to effectively express\nstatements of the form: \u201cIf these conditions over here are\njointly met then this other fact will follow\u201d. Finally, a\ngoal is a Horn clause with no positive literals. The\nidea is that, once a Prolog program \u03a0 has been written, we can then\ntry to determine if a new clause \u03b3, the goal, is entailed by\n\u03a0, \u03a0 \u22a8 \u03b3; the Prolog prover does this by attempting\nto derive a contradiction from \u03a0 \u222a {~\u03b3}. We should remark\nthat program facts and rules alone cannot produce a contradiction; a\ngoal must enter into the process. Like input resolution,\nSLD-resolution is not refutation complete for first-order logic but it\nis complete for the Horn logic of Prolog programs. The fundamental\ntheorem: If \u03a0 is a Prolog program and \u03b3 is the goal clause\nthen \u03a0\u00a0\u22a8\u00a0\u03b3 iff \u03a0 \u222a {~\u03b3} \u22a2\n[\u00a0] by SLD-resolution (Lloyd 1984).\n\nFor instance, to find out if there is a flight from Toronto to Rome\none asks the Prolog prover to see if the clause flight(toronto, rome)\nfollows from the given program. To do this, the prover adds\n~flight(toronto,rome) to the program clauses and attempts to derive\nthe empty clause, [\u00a0], by SLD-resolution:\n\n\n1\nflight(toronto,london)\nProgram clause \n\n2\nflight(london,rome)\nProgram clause \n\n3\nflight(chicago,london)\nProgram clause \n\n4\nflight(X,Y) \u2228\n~flight(X,Z) \u2228\n~flight(Z,Y)\nProgram clause \n\n5\n~flight(toronto,rome)\nNegated conclusion \n\n6\n~flight(toronto,Z) \u2228 ~flight(Z,rome)\nRes 5 4 \n\n7\n~flight(london,rome)\nRes 6 1 \n\n8\n[\u00a0]\nRes 7 2 \n\n\nThe conditional form of rules in Prolog programs adds to their\nreadability and also allows reasoning about the underlying refutations\nin a more friendly way: To prove that there is a flight between\nToronto and Rome, flight(toronto,rome), unify this clause with the\nconsequent flight(X,Y) of the fourth clause in the\nprogram which itself becomes provable if both\nflight(toronto,Z) and flight(Z,rome) can be proved.\nThis can be seen to be the case under the substitution {Z\n\u2190 london} since both flight(toronto,london) and\nflight(london,rome) are themselves provable. Note that the theorem\nprover not only establishes that there is a flight between Toronto and\nRome but it can also come up with an actual itinerary,\nToronto-London-Rome, by extracting it from the unifications used in\nthe proof.\n\nThere are at least two broad problems that Prolog must address in\norder to achieve the ideal of a logic programming language. Logic\nprograms consist of facts and rules describing what is true; anything\nthat is not provable from a program is deemed to be false. In regards\nto our previous example, flight(toronto,\nboston) is not true since this literal cannot be deduced from\nthe program. The identification of falsity with non-provability is\nfurther exploited in most Prolog implementations by incorporating an\noperator, not, that allows programmers to explicitly\nexpress the negation of literals (or even subclauses) within a\nprogram. By definition, not l succeeds if the literal\nl itself fails to be deduced. This mechanism, known as\nnegation-by-failure, has been the target of\ncriticism. Negation-by-failure does not fully capture the standard\nnotion of negation and there are significant logical differences\nbetween the two. Standard logic, including Horn logic, is monotonic\nwhich means that enlarging an axiom set by adding new axioms simply\nenlarges the set of theorems derivable from it; negation-by-failure,\nhowever, is non-monotonic and the addition of new\nprogram clauses to an existing Prolog program may cause some goals to\ncease from being theorems. A second issue is the control\nproblem. Currently, programmers need to provide a fair amount\nof control information if a program is to achieve acceptable levels of\nefficiency. For example, a programmer must be careful with the order\nin which the clauses are listed within a program, or how the literals\nare ordered within a clause. Failure to do a proper job can result in\nan inefficient or, worse, non-terminating program. Programmers must\nalso embed hints within the program clauses to prevent the prover from\nrevisiting certain paths in the search space (by using the\ncut operator) or to prune them altogether (by using\nfail). Last but not least, in order to improve their\nefficiency, many implementations of Prolog do not implement\nunification fully and bypass a time-consuming yet critical\ntest\u2014the so-called\noccurs-check\u2014responsible for checking the\nsuitability of the unifiers being computed. This results in an unsound\ncalculus and may cause a goal to be entailed by a Prolog program (from\na computational point of view) when in fact it should not (from a\nlogical point of view).\n\nThere are variations of Prolog intended to extend its scope. By\nimplementing a model elimination procedure, the Prolog Technology\nTheorem Prover (PTTP) (Stickel 1992) extends Prolog into full\nfirst-order logic. The implementation achieves both soundness and\ncompleteness. Moving beyond first-order logic, \u03bbProlog (Miller\n& Nadathur 1988) bases the language on higher-order constructive\nlogic.\n4.2 SAT Solvers\n\nThe problem of determining the satisfiability of logic formulas has\nreceived much attention by the automated reasoning community due to\nits important applicability in industry. A propositional formula is\nsatisfiable if there is an assignment of truth-values\nto its variables that makes the formula true. For example, the\nassignment (P \u2190 true, Q \u2190 true, R\n\u2190 false) does not make (P \u2228R) &\n~Q true but (P \u2190 true, Q \u2190 false,\nR \u2190 false) does and, hence, the formula is satisfiable.\nDetermining whether a formula is satisfiable or not is called the\nBoolean Satisfiability Problem\u2014SAT for\nshort\u2014and for a formula with n variables SAT can be\nsettled thus: Inspect each of the 2n possible\nassignments to see if there is at least one assignment that satisfies\nthe formula, i.e. makes it true. This method is clearly complete: If\nthe original formula is satisfiable then we will eventually find one\nsuch satisfying assignment; but if the formula is contradictory (i.e.\nnon-satisfiable), we will be able to determine this too. Just as\nclearly, and particularly in this latter case, this search takes an\nexponential amount of time, and the desire to conceive more efficient\nalgorithms is well justified particularly because many computing\nproblems of great practical importance such as graph-theoretic\nproblems, network design, storage and retrieval, scheduling, program\noptimization, and many others (Garey & Johnson 1979) can be\nexpressed as SAT instances, i.e. as the SAT question of some\npropositional formula representing the problem. Given that SAT is\nNP-complete (Cook 1971) it is very unlikely that a polynomial\nalgorithm exists for it; however, this does not preclude the existence\nof sufficiently efficient algorithms for particular cases of SAT\nproblems.\n\nThe Davis-Putnam-Logemann-Loveland (DPLL) algorithm\nwas one of the first SAT search algorithms (Davis & Putnam 1960;\nDavis, Logemman & Loveland 1962) and is still considered one of the\nbest complete SAT solvers; many of the complete SAT procedures in\nexistence today can be considered optimizations and generalizations of\nDPLL. In essence, DPLL search procedures proceed by considering ways\nin which assignments can be chosen to make the original formula true.\nFor example, consider the formula in CNF\n\nP & ~Q & (~P \u2228 Q \u2228\nR) & (P \u2228 ~S)\n\n\nSince P is a conjunct, but also a unit clause, P\nmust be true if the entire formula is to be true. Moreover, the value\nof ~P does not contribute to the truth of ~P \u2228\nQ \u2228 R and P \u2228 ~S is true\nregardless of S. Thus, the whole formula reduces to\n\n~Q & (Q \u2228 R)\n\n\nSimilarly, ~Q must be true and the formula further reduces\nto\n\nR\n\n\nwhich forces R to be true. From this process we can recover\nthe assignment (P \u2190 true, Q \u2190 false,\nR \u2190 true, S \u2190 false) proving that the\noriginal formula is satisfiable. A formula may cause the algorithm to\nbranch; the search through a branch reaches a dead end the moment a\nclause is deemed false\u2014a conflicting\nclause\u2014and all variations of the assignment that has\nbeen partially constructed up to this point can be discarded. To\nillustrate:\n\n\n\n1\nR & (P \u2228 Q)\n& (~P \u2228 Q) & (~P \u2228\n~Q)\nGiven \n\n2\n(P \u2228 Q) & (~P \u2228 Q)\n& (~P \u2228 ~Q)\nBy letting R \u2190 true \n\n3\nQ & ~Q\nBy letting P \u2190 true \n\n4\n?\nConflict: Q and ~Q cannot both be true\n\n\n5\n(P \u2228 Q) & (~P \u2228 Q)\n& (~P \u2228 ~Q)\nBacktrack to (2): R \u2190 true still holds \n\n6\n~P\nBy letting Q \u2190 true \n\n7\ntrue\nBy letting ~P be true, i.e., P\n\u2190 false  \n\n\nHence, the formula is satisfiable by the existence of (P\n\u2190 false, Q \u2190 true, R \u2190 true). DPLL\nalgorithms are made more efficient by strategies such as term\nindexing (ordering of the formula variables in an\nadvantageous way), chronological backtracking\n(undoing work to a previous branching point if the process leads to a\nconflicting clause), and conflict-driven learning\n(determining the information to keep and where to backtrack). The\ncombination of these strategies results in a large prune of the search\nspace; for a more extensive discussion the interested reader is\ndirected to Zhang & Malik 2002.\n\nA quick back-envelope calculation reveals the staggering computing\ntimes of (algorithms for) SAT-type problems represented by formulas\nwith as little as, say, 60 variables. To wit: A problem represented as\na Boolean formula with 10 variables that affords a linear solution\ntaking one hundredth of a second to complete would take just four\nhundredths and six hundredths of a second to complete if the formula\nhad instead 40 and 60 variables respectively. In dramatic contrast, if\nthe solution to the problem were exponential (say\n2n) then the times to complete the job for 10, 40\nand 60 variables would be respectively one thousandth of a second, 13\ndays, and 365 centuries. It is a true testament to the ingenuity of\nthe automated reasoning community and the power of current SAT-based\nsearch algorithms that real-world problems with thousands of variables\ncan be handled with reasonable efficency. K\u00fcchlin & Sinz 2000\ndiscuss a SAT application in the realm of industrial automotive\nproduct data management where 18,000 (elementary) Boolean formulas and\n17,000 variables are used to express constraints on orders placed by\ncustomers. As another example, Massacci & Marraro 2000 discuss\nan application in logical cryptanalysis, that is, the verification of\nproperties of cryptographic algorithms expressed as SAT problems. They\ndemonstrate how finding a key with a cryptographic attack is analogous\nto finding a model\u2014assignment\u2014for a Boolean formula; the\nformula in their application encodes the commercial version of the U.S\nData Encryption Standard (DES) with the encoding requiring 60,000\nclauses and 10,000 variables.\n\nAlthough SAT is conceptually very simple, its inner nature is not well\nunderstood\u2014there are no criteria that can be generally applied\nto answer as to why one SAT problem is harder than another. It should\nthen come as no surprise that algorithms that tend to do well on some\nSAT instances do not perform so well on others, and efforts are being\nspent in designing hybrid algorithmic solutions that combine the\nstrength of complementary approaches\u2014see Prasad, Biere &\nGupta 2005 for an application of this hybrid approach in the\nverification of hardware design.\n\nRecent advances in SAT hybrid strategies coupled with supercomputing\npower has allowed a team of three computing scientists to solve the\nBoolean Pythagorean Triples Problem, a long-standing open question in\nRamsey Theory: Can the set {1, 2,...} of natural numbers be divided\ninto two parts with no part containing a triple\n(a, b, c) such that a2\n+ b2 = c2? Heule, Kullmann\n& Marek 2016 proved that this cannot be done by showing that the\nset {1, 2, \u2026 , n} can be so partitioned for n\n= 7824 but that this is impossible for n \u2265\n7825. Expressing this deceptively simple question as a SAT problem\nrequired close to 38,000 clauses and 13,000 variables with about half\nof these going to represent that the problem is satisfiable when n =\n7824 and the other half to represent that it is not when n = 7825; of\nthe two, proving the latter was far more challenging since it demanded\na proof of unsatisfiability, i.e. that no such partition exists. A\nna\u00efve brute-force approach considering all 27825\npossible two-part partitions was clearly out of the question and the\nproblem was attacked by using \u201cclever\u201d algorithms within a\nmulti-stage SAT-based framework for solving hard problems in\ncombinatorics, consisting of five phases: Encode (encoding\nthe problem as SAT formulas), Transform (optimizing the\nencoding using clause elimination and symmetry breaking\ntechniques), Split (dividing the problem effectively into\nsubproblems using splitting heuristics), Solve (searching for\nsatisfying assignments or their lack thereof using fast processing),\nand Validate (validating the results of the earlier\nphases). Of special importance was the application\nof cube-and-conquer, a hybrid SAT strategy\nparticularly effective for hard combinatorial problems. The strategy\ncombines look-ahead with conflict-driven\nclause-learning (CDCL), with the former\naiming to construct small binary search trees using global heuristics\nand the latter aiming to find short refutations using local\nheuristics.\n\nAfter splitting the problem into 106 hard subproblems\n(known as \u201ccubes\u201d), these were handed down to 800 cores\nworking in parallel on a Stampede supercomputer which, after\n2 days of further splitting and CDCL clause-crunching, settled the\nquestion and delivered a 200-terabyte proof validating the work. After\ndeservedly celebrating this significant accomplishment of automated\nreasoning, and after entertaining all the new applications that the\nenhanced SAT method would afford (particularly in the areas of\nhardware and software verification), we should then ask some questions\nthat are of especial importance to mathematicians: Is there a more\ninsightful way to establish this result that would involve more\ntraditional and intellectually satisfying mathematical proof methods?\nOr, as far as increasing our understanding of a given field\n(combinatorics in this case), what is the value of settling a question\nwhen no human can inspect the proof and hence get no insight from it?\nEven the team responsible for the result admits that \u201cthe proofs\nof unsatisfiability coming from SAT solvers are, from a human point of\nview, a giant heap of random information (no direct understanding is\ninvolved)\u201d. The conjecture has been settled but we basically\nhave no underlying idea what makes 7825 so special. Perhaps the real\nvalue to be drawn from these considerations is that they lead us to\nthink about the deeper question: What is it about the structure of a\nspecific problem that makes it amenable to standard mathematical\ntreatment as opposed to requiring a mindless brute-force approach?\nWhile this question is being contemplated, SAT may provide the best line of attack on certain mathematical problems.\n\nThe DPLL search procedure has been extended to quantified logic. MACE\nis a popular program based on the DPLL algorithm that searches for\nfinite models of first-order formulas with equality. As an example\n(McCune 2001), to show that not all groups are commutative one can\ndirect MACE to look for a model of the group axioms that also\nfalsifies the commutation law or, equivalently, to look for a model\nof:\n\n\n\n(G1)\ne \u00b7 x = x\n(left identity) \n\n(G2)\ni\u2009(x) \u00b7 x =\ne\n(left inverse) \n\n(G3)\n(x \u00b7 y) \u00b7 z =\nx \u00b7 (y \u00b7 z)\n(associativity) \n\n(DC)\na \u00b7 b \u2260 b \u00b7\na\n(denial of commutativity) \n\n\n\nMACE finds a six-element model of these axioms, where \u00b7 is\ndefined as:\n\n\n\u00b7\n0\n1\n2\n3\n4\n5 \n\n0\n0\n1\n2\n3\n4\n5 \n\n1\n1\n0\n4\n5\n2\n3 \n\n2\n2\n3\n0\n1\n5\n4 \n\n3\n3\n2\n5\n4\n0\n1 \n\n4\n4\n5\n1\n0\n3\n2 \n\n5\n5\n4\n3\n2\n1\n0 \n\n\nand where i are defined as:\n\n\nx\n0\n1\n2\n3\n4\n5 \n\ni(x)\n0\n1\n2\n3\n4\n5 \n\n\nThis example also illustrates, once again, the benefits of using an automated\ndeduction system: How long would have taken the human researcher to\ncome up with the above or a similar model? For more challenging\nproblems, the program is being used as a practical complement to the\nresolution-based theorem prover Prover9 (formerly Otter), with Prover9\nsearching for proofs and MACE jointly looking for (counter) models. To\nfind such models, MACE converts the first-order problem into a set of\n\"flattened\" clauses which, for increasing model sizes, are\ninstantiated into propositional clauses and solved as a SAT problem.\nThe method has been implemented in other automated reasoning systems\nas well, most notably in the Paradox model finder where the MACE-style\napproach has been enhanced by four additional techniques resulting in\nsome significant efficiency improvements (Claessen & S\u00f6rensson\n2003): term definitions (to reduce the number of variables in\nflattened clauses), static symmetric reduction (to reduce the number\nof isomorphic models), sort inference (to apply symmetric reduction at\na finer level) and incremental SAT (to reuse search information\nbetween consecutive model sizes). The strategy of pairing the\ncomplementary capabilities of separate automated reasoning systems has\nbeen applied to higher-order logic too as exemplified by Nitpick, a\ncounterexample generator for Isabelle/HOL (Blanchette & Nipkow\n2010). Brown 2013 describes a theorem proving procedure for\nhigher-order logic that uses SAT-solving to do most of the work; the\nprocedure is a complete, cut-free, ground refutation calculus that\nincorporates restrictions on instantiations and has been implemented\nin the Satallax theorem prover (Brown 2012).\n\nAn approach of great interest at solving SAT problems in first-order\nlogic is Satisfiability Modulo Theory\n(SMT) where the interpretation of symbols in the\nproblem\u2019s formulation is constrained by a background\ntheory. For example, in linear arithmetic the function\nsymbols are restricted to + and \u2212. As another example, in the\nextensional theory of arrays (McCarthy 1962) the array function\nread(a, i) returns the value of the array\na at index i, and write(a,\ni, x) returns the array identical to a but\nwhere the value of a at i is x. More\nformally,\n\n\n\n \u2200a : Array .\n\u2200i,j : Index . \u2200x :\nValue . i = j \u2192\n\n\u00a0\u00a0read(write(a, i,\nx), j) = x (read-write\naxiom 1)  \n\n \u2200a : Array .\n\u2200i,j : Index . \u2200x :\nValue . i \u2260 j \u2192\n\n\u00a0\u00a0read(write(a, i,\nx), j) = read(a, j) (read-write\naxiom 2)  \n\n \u2200a,b : Array .\n\u2200i : Index . a = b \u2192\nread(a, i) = read(b,\ni)  \n\n(extensionality) \n\n\n\nIn the context of these axioms, an SMT solver would attempt to\nestablish the satisfiability (or, dually, the validity) of a given\nfirst-order formula, or thousands of formulas for that matter, such\nas\n\ni \u2212 j = 1 &\nf(read(write(a, i, 2),\nj + 1) = read(write(a, i,\nf(i \u2212 j + 1)), i)\n\n\n(Ganzinger et al. 2004) discusses an approach to SMT called\nDPLL(T) consisting of a general\nDPLL(X) engine that works in conjunction with a solver\nSolverT for background theory T. Bofill\net al. (2008) present the approach in the setting of the theory of\narrays, where the DPLL engine is responsible for enumerating\npropositional models for the given formula whereas\nSolverT checks whether these models are consistent\nwith the theory of arrays. Their approach is sound and complete, and\ncan be smoothly extended to multidimensional arrays.\n\nSMT is particularly successful in verification applications, most\nnotably software verification. Having improved the efficiency of SAT\nsolvers with SMT, the effort is now on designing more efficient SMT\nsolvers (de Moura 2007).\n4.3 Deductive Computer Algebra\n\nTo prove automatically even the simplest mathematical facts requires a\nsignificant amount of domain knowledge. As a rule, automated theorem\nprovers lack such rich knowledge and attempt to construct proofs from\nfirst principles by the application of elementary deduction rules.\nThis approach results in very lengthy proofs (assuming a proof is\nfound) with each step being justified at a most basic logical level.\nLarger inference steps and a significant improvement in mathematical\nreasoning capability can be obtained, however, by having a theorem\nprover interact with a computer algebra system, also known as a\nsymbolic computation system. A computer algebra\nsystem is a computer program that assists the user with the\nsymbolic manipulation and numeric evaluation of mathematical\nexpressions. For example, when asked to compute the improper\nintegral\n\n\n\n \u00a0\u00a0\u00a0\u00a0\u221e\n\n\u222b\n\n0 \ne\u2212a2t2cos2bt\ndt \n\n\n\na competent computer algebra system would quickly reply with the\nanswer\n\n\n\n\n\n\n\u221a\u03c0\n\n\n2a \n \ne\u2212b2/a2\n\n\n\n\nEssentially, the computer algebra system operates by taking the input\nexpression entered by the user and successively applies to it a series\nof transformation rules until the result no longer changes (see the\nsection Term Rewriting in this article for more details).\nThese transformation rules encode a significant amount of domain\n(mathematical) knowledge making symbolic systems powerful tools in the\nhands of applied mathematicians, scientists, and engineers trying to\nattack problems in a wide variety of fields ranging from calculus and\nthe solving of equations to combinatorics and number theory.\n\nProblem solving in mathematics involves the interplay of deduction and\ncalculation, with decision procedures being a reminder of the fuzzy\ndivision between the two; hence, the integration of deductive and\nsymbolic systems, which we coin here as Deductive Computer\nAlgebra (DCA), is bound to be a fruitful combination.\nAnalytica (Bauer, Clarke & Zhao 1998) is a theorem prover built on\ntop of Mathematica, a powerful and popular computer algebra system.\nBesides supplying the deductive engine, Analytica also extends\nMathematica\u2019s capabilities by defining a number of rewrite\nrules\u2014more precisely, identities about summations and\ninequalities\u2014that are missing in the system, as well as\nproviding an implementation of Gosper\u2019s algorithm for finding closed\nforms of indefinite hypergeometric summations. Equipped with this\nextended knowledge, Analytica can prove semi-automatically some\nnontrivial theorems from real analysis, including a series of lemmas\ndirectly leading to a proof of the Bernstein Approximation Theorem.\nHere is the statement of the theorem simply to give the reader a sense\nof the level of the mathematical richness we are dealing with:\n\nBernstein Approximation Theorem.\n\nLet I = [0, 1] be the closed unit interval, f a real\ncontinuous function on I, and\nBn(x,f) the\nnth Bernstein polynomial for f defined as\n\n\n\nBn(x, f)\n = \n n\n\n\u2211\n\nk=0 \n(\nn\n\nk\n)\nf(k/n)xk(1\n\u2212 x)n\u2212k \n Then, on the interval I, the sequence of Bernstein\npolynomials for f converges uniformly to f.\n\n\nTo be frank, the program is supplied with key information to establish\nthe lemmas that lead to this theorem but the amount and type of\ndeductive work done by the program is certainly nontrivial. (Clarke\n& Zhao 1994) provides examples of fully automated proofs using\nproblems in Chapter 2 of Ramanujan\u2019s Notebooks (Berndt 1985)\nincluding the following example that the reader is invited to try.\nShow that:\n\n\n\n Ar\n\n\u2211\n\nk=n+1 \n\n\n\n1\n\n\nk \n \n = \nr + 2\n(\n r\n\n\u2211\n\nk=1 \n(r \u2212 k)\n(\n Ak\n\n\u2211\n\nj=Ak\u22121+1\n\n\n\n\n1\n\n\n(3j)3\u22123j\n\n \n)\n)\n + 2r\u03c6(3,A0) \n\n\n\nwhere A0=1,\nAn+1=3An+1 and\n\u03c6(x,n) is Ramanujan\u2019s abbreviation for\n\n\n\n\n\u03c6(x,n)\n =df \n n\n\n\u2211\n\nk=1 \n\n\n\n1\n\n\n\u2212(kx)+k3x3\n\n  \n\n\n\nAnalytica\u2019s proof of this identity proceeds by simplifying both the\nleft- and right-hand sides of the equality and showing that both sides\nreduce to the same expression, \u2212Hn +\nHAr. The simplification uses the added summation\nidentities mentioned before as well as some elementary properties of\nthe harmonic numbers,\n\n\n\nHn\n = \n n\n\n\u2211\n\nk=1 \n\n\n\n1\n\n\nk \n  \n\n\n\nThe resulting proof has 28 steps (some of which are nontrivial) taking\nabout 2 minutes to find.\n\nKerber, Kohlhase & Sorge 1998 use the \u03a9mega planning\nsystem as the overall way to integrate theorem proving and symbolic\ncomputation. In Harrison & Th\u00e9ry 1998, we find an example\nof the integration of a higher-order logic theorem proving system\n(HOL) with a computer algebra system (Maple).\n\nTheir great power notwithstanding, symbolic algebra systems do not\nenforce the same level of rigor and formality that is the essence of\nautomated deduction systems. In fact, the mathematical semantics of\nsome of the knowledge rules in most algebra systems is not entirely\nclear and are, in cases, logically unsound (Harrison & Th\u00e9ry\n1998). The main reason for this is an over-aggressiveness to provide\nthe user with an answer in a timely fashion at whatever cost,\nbypassing the checking of required assumptions even if it means\nsacrificing the soundness of the calculation. (This is strongly\nreminiscent of most Prolog implementations that bypass the so-called\n\u201coccurs-check\u201d also abandoning logical soundness in the\nname of efficiency.) This serious problem opens the opportunity for a\ndeduction system to provide a service to the computer algebra system:\nUse its deductive capabilities to verify that the computer algebra\u2019s\ncomputational steps meet the required assumptions. There is a catch in\nthis, however: For sufficiently large calculation steps, verifying is\ntantamount to proving and, to check these steps, the deduction system\nmay well need the assistance of the very same system that is in need\nof verification! The solution to the soundness problem may then well\nrequire an extensive modification of the chosen symbolic algebra\nsystem to make it sound; an alternative approach is to develop a new\nsystem, entirely from scratch, in conjunction with the development of\nthe automated theorem prover. In either case, the resulting combined\ndeductive computer algebra system should display a much improved\nability for automated mathematical reasoning.\n4.4 Formal Verification of Hardware\n\nAutomated reasoning has reached the level of maturity where theorem\nproving systems and techniques are being used for industrial-strength\napplications. One such application area is the formal verification of\nhardware and software systems. The cost of defects in hardware can\neasily run into the millions. In 1994, the Pentium processor was\nshipped with a defect in its floating-point unit and the subsequent\noffer by Intel to replace the flawed chip (which was taken up only by\na small fraction of all Pentium owners) cost the company close to $500\nmillion. To guard against situations like this, the practice of\ntesting chip designs is now considered insufficient and more formal\nmethods of verification have not only gained large attention in the\nmicroprocessor industry but have become a necessity. The idea behind\nformal verification is to rigorously prove with mathematical certainty\nthat the system functions as specified. Common applications to\nhardware design include formally establish that the system functions\ncorrectly on all inputs, or that two different circuits are\nfunctionally equivalent.\n\nDepending on the task at hand, one can draw from a number of automated\nformal verification techniques, including SAT solvers in propositional\nlogic, symbolic simulation using binary decision diagrams (BDDs),\nmodel checking in temporal logic, or conducting proofs in higher-order\nlogic. In the latter case, using an automated theorem prover like\nHOL\u2014see Section 10\u2014has shown to be invaluable in practice.\nProof construction in a system like HOL proceeds semi-automatically\nwith the user providing a fair amount of guidance as to how the proof\nshould proceed: The user tries to find a proof while being assisted by\nthe theorem prover which, on request, can either automatically fill in\na proof segment or verify proof steps given to it. Although some of\nthe techniques mentioned above provide decision procedures which\nhigher-order logic lacks, higher-order logic has the advantage of\nbeing very expressive. The tradeoff is justified since proving facts\nabout floating-point arithmetic requires the\nformalization of a large body of real analysis, including many\nelementary statements such as:\n\n\n\n|-\n(!x. a <= x /\\ x <= b ==> (f diffl (f' x)) x) /\\\n\n\n\nf(a) <= K /\\ \n\n\nf(b) <= K /\\ \n\n\n(!x. a <= x /\\ x <= b /\\ (f'(x) = 0) ==> f(x) <= K)\n==>  \n\n\n\u00a0\u00a0(!x. a <= x /\\ x <= b ==> f(x) <=\nK) \n\n\n\nThis statement from Harrison 2000 written in HOL says that if a\nfunction f is differentiable with derivative\nf\u2032 in an interval [a, b] then a\nsufficient condition for f(x) \u2264 K\nthroughout the interval is that f(x) \u2264 K\nat the endpoints a, b and at all points of zero\nderivative. The result is used to determine error bounds when\napproximating transcendental functions by truncated power series.\nConducting proofs in such a \u201cpainstakingly foundational\nsystem\u201d (Harrison 2006) has some significant benefits. First,\none achieves a high degree of assurance that the proofs are valid\nsince (admitedly lengthy) they are composed of small error-free\ndeductive steps. Second, the formalization of these elementary\nstatements and intermediate results can be reused in other tasks or\nprojects. For example, a library of formal statements and proven\nresults in floating-point division can be reused when proving other\nresults of floating-point algorithms for square roots or\ntranscendental functions. To further illustrate, different versions of\nthe square root algorithm for the Intel Itanium share many\nsimilarities and the proof of correctness for one version of the\nalgorithm can be carried over to another version after minor tweaking\nof the proof. A third benefit of using a prover like HOL is, of\ncourse, that such lengthy proofs are carried out mechanically and are\ndeductively certain; the likelihood of introducing a human error if\nthey were carried out manually would be just as certain.\n4.5 Formal Verification of Software\n\nSociety is becoming increasingly dependent on software systems for\ncritical services such as safety and security. Serious adverse effects\nof malfunctioning software include loss of human life, threats to\nsecurity, unauthorized access to sensitive information, large\nfinancial losses, denial of critical services, and risk to safety. One\nway to increase the quality of critical software is to supplement\ntraditional methods of testing and validation with techniques of\nformal verification. The basic approach to formal verification is to\ngenerate a number of conditions that the software must meet and to\nverify\u2014establish\u2014them by mathematical proof. As with\nhardware, automated formal verification (simply formal verification,\nhereafter) is concerned with discharging these proof obligations using\nan automated theorem prover.\n\nThe formal verification of security protocols is an\nalmost ideal application of automated theorem proving in industry.\nSecurity protocols are small distributed programs aimed at ensuring\nthat transactions take place securely over public networks. The\nspecification of a security protocol is relatively small and well\ndefined but its verification is certainly non-trivial. We have already\nmentioned in a previous section the use of SAT-based theorem provers\nin the verification of the U.S Data Encryption Standard (DES). As\nanother example, the Mondex \u201celectronic purse\u201d is a smart\ncard electronic cash system that was originally developed by National\nWestminster Bank and subsequently sold to MasterCard International.\nSchmitt & Tonin 2007 describe a Java Card implementation of the\nMondex protocol for which the security properties were reformulated in\nthe Java Modeling Language (JML) following closely the original Z\nspecification. Proof of correctness was conducted using the KeY tool\n(Beckert, Hanle & Schmitt 2007), an interactive theorem proving\nenvironment for first-order dynamic logic that allows the user to\nprove properties of imperative and object-oriented sequential\nprograms. This application of automated reasoning demonstrates, in the\nwords of the authors, that \u201cit is possible to bridge the gap\nbetween specification and implementation ensuring a fully verified\nresult\u201d.\n\nDenney, Fischer & Schumann 2004 describe a system to automate the\ncertification of safety properties of data-analysis aerospace\nsoftware at NASA. Using Hoare-style program verification\ntechniques, their system generates proof obligations that are then\nhandled by an automated theorem prover. The process is not fully\nautomated, however, since many of the obligations must be simplified\nfirst in order to improve the ability of the theorem prover to solve\nthe proof tasks. For example, one such class of obligations makes a\nstatement about a matrix, r, that needs to remain symmetric\nafter updates along its diagonal have been made, and has the form:\n\nOriginal form:\n\nsymm(r) \u2192\nsymm(diag-updates(r))\n\nSimplified form (when r is 2x2):\n\n\n\n(\u2200i)(\u2200j)(0 \u2264 i,\nj \u2264 1 \u2192 sel(r, i,\nj) = sel(r, j, i))\n\u2192 \n\n(\u2200k)(\u2200l)(0 \u2264 k,\nl \u2264 1 \u2192 \n\nsel(upd(upd(r,\n1, 1,\nr11), 0, 0, r00), k,\nl) = sel(upd(upd(r, 1, 1,\nr11), 0, 0, r00), l,\nk))) \n\n\n\nEven after the simplification, current theorem provers find the proof\ntask challenging. The task becomes intractable for larger matrices and\nnumber of updates (e.g. a 6\u00d76 matrix with 36 updates) and\nfurther preprocessing and simplification on the obligation is required\nbefore the task eventually falls within the reach of state-of-art\ntheorem provers. But it is worth remarking that proofs are found\nwithout using any specific features or configuration parameters of the\ntheorem provers which would improve their chances at completing the\nproofs.  This is important since the everyday application of theorem\nprovers in industry cannot presuppose such deep knowledge of the\nprover from their users. The formal verification of software remains a\ndemanding task but it is difficult to see how the certification of\nproperties could happen without the assistance of automated deduction\nwhen one faces the humanly impossible task of establishing thousands\nof such obligations.\n\nIn the field of nuclear engineering, techniques of\nautomated reasoning are deemed mature enough to assist in the formal\nverification of the safety-critical software responsible for\ncontrolling a nuclear power plant\u2019s reactor prevention systems (RPS).\nThe RPS component of the digital control system of the APR-1400\nnuclear reactor is specified using NuSCR, a formal specification\nlanguage customized for nuclear applications (Yoo, Jee & Cha 2009).\nModel checking in computation tree logic is used to check the\nspecifications for completeness and consistency. After this, nuclear\nengineers generate function block designs via a process of automatic\nsynthesis and formally verify the designs also using techniques of\nmodel checking in linear temporal logic; the techniques are also used\nto verify the equivalence of the multiple revisions and releases of\nthe design. These model-checking tools were implemented to make their\nuse as easy and intuitive as possible, in a way that did not require a\ndeep knowledge of the techniques, and used notations familiar to\nnuclear engineers. The use of automated reasoning tools not only helps\nthe design engineers to establish the desired results but it also\nraises the confidence of the government\u2019s regulatory personnel that\nneed to approve the RPS software before the reactor can be certified\nfor operation.\n4.6 Logic and Philosophy\n\nIn the spirit of Wos, Overbeek, Lusk & Boyle 1992, we pose the\nquestion: What do the following statements about different systems of\nformal logic and exact philosophy have in common?\n\nThe implicational fragments of the modal logics S4 and S5 have\nbeen studied extensively over the years. Posed as an open question, it\nwas eventually shown that there is a single axiom for implicational S4\nas well as several new shortest axioms for implicational S5 (Ernst,\nFitelson, Harris & Wos 2002).\nThe L combinator is defined as (Lx)y =\nx(yy). Although it was known that the\nL-based combinator E12 =\n((L(LL))(L(LL)))((L(LL))(L(LL)))\nsatisfies E12E12 =\nE12 the question remained whether a shorter\nL-based combinator satisfying this property existed.\n(Glickfeld & Overbeek 1986) showed this to be the case with\nE8 =\n((LL)(L(LL)))(L(LL)).\nThirteen shortest single axioms of length eleven for classical\nequivalence had been discovered, and XCB =\ne(x, e(e(e(x,\ny), e(z, y)), z)) was the\nonly remaining formula of that length whose status was\nundetermined\u2014was it an axiom? For a quarter of a century this\nquestion remained open despite intense study by various researchers.\nIt was finally settled that XCB is indeed such a single\naxiom, thus ending the search for shortest single axioms for the\nequivalential calculus (Wos, Ulrich & Fitelson 2002).\nSaint Anselm of Canterbury offered in his Proslogium a\nfamous argument for the existence of God. But, quite recently, a\nsimpler proof has been discovered in the sense that it is shorter and\nuses fewer assumptions (Oppenheimer & Zalta 2011). In the same\ntradition, G\u00f6del produced a proof of God\u2019s existence but\n(Benzm\u00fcller & Paleo 2014) have recently proved the same result\nusing a weaker logic system while simultaneously addressing a major\ncriticism of G\u00f6del\u2019s proof.\nIn the axioms defining a Robbins algebra, the Huntington\u2019s\nequation \u2212(\u2212(x + y) + \u2212(x\n+ \u2212y)) = x can be replaced by a simpler one,\nnamely the Robbins equation \u2212(\u2212x + y) +\n\u2212(\u2212x + \u2212y) = x. This\nconjecture went unproved for more than 50 years resisting the attacks\nof many logicians including Tarski until it was eventually proved in\n(McCune 1997).\n\n\nWe ask again, what do these results have in common? The answer is that\neach has been proved with the help of an automated reasoning program.\nHaving disclosed the answer to this question prompts a new one: How\nmuch longer would have taken to settle these open problems without the\napplication of such an automated reasoning tool? \n\nThe strict implicational fragments of the logical systems S4 and S5 of\nmodal logic are known as C4 and C5, respectively, and\ntheir Hilbert-style axiomatizations presuppose condensed detachment as\ntheir sole rule of inference. With insight from Kripke\u2019s work,\nAnderson & Belnap (1962) published the first axiomatization of C4\nusing the following 3-axiom basis, where the Polish notation\n\u2018Cpq\u2019 stands for \u2018p\n\u2192 q\u2019. \n\n\n(1)\nCpp\n\nCCpqCrCpq\n\nCCpCqrCCpqCpr \n\n\nA question was posed sometime after: Is there a shorter such\naxiomatization for C4, using a 2-axiom basis or even a single axiom?\nUsing the automated reasoning program Otter, the authors Ernst,\nFitelson, Harris & Wos (2001) settled both questions in the\naffirmative. In fact, several 2-axiom bases were discovered of which\nthe following turned out to be shortest: \n\n\n(2)\nCpCqq\n\nCCpCqrCCpqCsCpr \n\n\nFurther rounds of automated reasoning work were rewarded with the\ndiscovery of a single axiom for C4; the axiom is 21 symbols long and\nit was also proved that it is the shortest such axiom: \n\n\n(3)\nCCpCCqCrrCpsCCstCuCpt \n\n\nTo show that each of (2) and (3) is necessary and sufficient for (1),\na circle of proofs was produced using the automated reasoning tool:\n(1) \u21d2 (3) \u21d2 (2) \u21d2 (1). As for C5, its axiomatization\nwas originally published in a paper by Lemmon, A. Meredith, D. Meredith,\nPrior & Thomas (1957) giving several 4-, 3-, 2- and 1-axiom bases\nfor C5, including the following 3-axiom basis: \n\n\n(4)\nCqCpp\n\nCCpqCCqrCpr\n\nCCCCpqrCpqCpq \n\n\nThe publication also included the shortest known 2-axiom bases for C5\n(actually two of them, containing 20 symbols each) but the shortest\nsingle axiom for C5 was later discovered by (Meredith and Prior 1964)\nand having 21 symbols: \n\n\n(5)\nCCCCCppqrCstCCtqCsCsq \n\n\nApplying automated reasoning strategies again, Ernst, Fitelson,\nHarris & Wos 2001) discovered several new bases, including the\nfollowing 2-axiom basis of length 18 and six 1-axiom bases matching\nMeredith\u2019s length of 21 (only one of these is given below): \n\n\n(6)\nCpp\n\nCCpqCCCCqrsrCpr \n\n\n\n(7)\nCCCCpqrCCuuqCCqtCsCpt \n\n\nTo show that each of (6) and (7) is necessary and sufficient for (4),\na circle of proofs was also produced with the theorem prover: (6)\n\u21d2 (4) \u21d2 (7) \u21d2 (6). \n\nA charming foray into combinatory logic is presented\nin Smullyan 1985 and Glickfeld & Overbeek 1986, where we learn\nabout a certain enchanted forest inhabited by talking birds. Given any\nbirds A and B, if the name of bird B is\nspoken to bird A then A will respond with the name\nof some bird in the forest, AB, and this response to\nB from A will always be the same. Here are some\ndefinitions about enchanted birds: \n\n\n\nB1\nA mockingbird M mimics any bird in\nthe sense that M\u2019s response to a bird x is the same\nas x\u2019s response to itself, Mx = xx.\n\n\nB2\nA bird C composes birds A and\nB if A(Bx) = Cx, for any bird\nx. In other words, C\u2019s response to x is the\nsame as A\u2019s response to B\u2019s response to\nx. \n\nB3\nA bird A is fond of a bird B if A\u2019s\nresponse to B is B; that is, AB =\nB. \n\n\n\nAnd here are two facts about this enchanted forest: \n\n\n\nF1\nFor any birds A and B in the forest there is a\nbird C that composes them. \n\nF2\nThere is a mockingbird in the forest. \n\n\n\nThere have been rumors that every bird in the forest is fond of at\nleast one bird, and also that there is at least one bird that is not\nfond of any bird. The challenge to the reader now is, of course, to\nsettle these rumors using only F1 and F2, and the given definitions\n(B1)\u2013(B3). Glickfeld & Overbeek 1986 do this in mere\nseconds with an automated reasoning system using paramodulation,\ndemodulation and subsumption. For a more challenging problem, consider\nthe additional definitions: \n\n\n\nB4\nA bird is egocentric if it is fond of itself: EE =\nE. \n\nB5\nA bird L is a lark if for any birds x and\ny the following holds: (Lx)y =\nx(yy). \n\n\n\nSmullyan challenges us to prove a most surprising thing about larks:\nSuppose we are not given any other information except that the forest\ncontains a lark. Then, show that at least one bird in the forest must\nbe egocentric! Below we give the salient steps in the proof found by\nthe automated reasoning system, where \u2018S(x,\ny)\u2019 stands for \u2018xy\u2019 and where\nclauses (2) and (3) are, respectively, the definition of a lark and\nthe denial of the theorem; numbers on the right are applications of\nparamodulation: \n\n\n\n\n1\n(x1 = x1)\n \n\n2\n(S(S(L, x1), x2) = S(x1, S(x2, x2)))\n \n\n3\n-(S(x1, x1) = x1)\n \n\n6\n(S(x1, S(S(L, S(x2, x2)), x2)) = S(S(L,\nx1), S(x2, x2)))\n2\u00a02 \n\n8\n(S(x1, S(S(x2, x2), S(x2, x2))) =\nS(S(L, S(L, x1)), x2))\n2\u00a02 \n\n9\n(S(S(S(L, L), x1), x2) = S(S(x1, x1),\nS(x2, x2)))\n2\u00a02 \n\n18\n-(S(S(L, S(S(L, S(L, L)), x1)), x1) =\nS(S(L, S(x1,x1)), x1))\n6\u00a03\u00a06\u00a09\u00a08\u00a08 \n\n19\n[]\n18\u00a01 \n\n\n\n\nCloser inspection of the left and right hand sides of (18) under the\napplication of unification revealed the discovery of a 10-L\nbird, i.e. a 10-symbol bird expressed solely in terms of larks, which\nwas a strong candidate for egocentricity. This discovery was exciting\nbecause the shortest egocentric L-bird known to Smullyan was\nof length 12. A subsequent run of the automated reasoning system\nproduced a proof of this fact as well as another new significant bird:\nA possible egocentric 8-L bird! A few more runs of the system\neventually produced a 22-line proof (with terms with as many as 50\nsymbols, excluding commas and parentheses) of the fact that\n((LL)(L(LL)))(L(LL)) is\nindeed egocentric. The natural questions to ask next are, of course,\nwhether there are other 8-L egocentric birds and whether\nthere are shorter ones. The reader may want to attempt this with paper\nand pencil but, given that there are 429 such birds, it may be wiser\nto try it instead (or in conjunction) with an automated reasoning\nprogram; both approaches are explored in Glickfeld & Overbeek\n1986. For a more formal, but admittedly less colorful, introduction\nto combinatory logic and lambda-conversion the reader is referred to\nHindley & Seldin 1986. \n\nFormulas in the classical equivalential calculus are\nwritten using sentential variables and a two-place function symbol,\ne, for equivalence. The calculus has two rules of inference,\ndetachment (modus ponens) and substitution; the rules can be combined\ninto the single rule of condensed detachment: Obtain t\u03b8\nfrom e(s,t) and r where\ns\u03b8 = r\u03b8 with mgu \u03b8. The calculus\ncan be axiomatized with the formulas: \n\n\n(E1)\ne(x,x)\n(reflexivity) \n\n(E2)\ne(e(x,y),e(y,x))\n(symmetry) \n\n(E3)\ne(e(x,y),e(e(y,z),e(x,z)))\n(transitivity) \n\n\nWe can dispense with reflexivity since it is derivable from the other\ntwo formulas. This brings the number of axioms down to two and a\nnatural question to ask is whether there is a single axiom for the\nequivalential calculus. In 1933, \u0141ukasiewicz found three formulas\nof length eleven that each could act as a single axiom for the\ncalculus\u2014here\u2019s one of them:\ne(e(x,y),e(e(z,y),e(x,z)))\u2014and\nhe also showed that no shorter single axiom existed. Over time, other\nsingle axioms also of length eleven were found and the list kept\ngrowing with additions by Meredith, Kalman and Peterson to a total of\n14 formulas of which 13 were known to be single axioms and one formula\nwith a yet undetermined status: the formula XCB =\ne(x, e(e(e(x,\ny), e(z, y)), z)).\n(Actually, the list grew to 18 formulas but Wos, Winker, Veroff,\nSmith & Henschen 1983 reduced it to 14.) Resisting the intense\nstudy of various researchers, it remained as an open question for many\nyears whether the 14th formula, XCB, was a single axiom for\nthe equivalential calculus (Peterson 1977). One way to answer the\nquestion in the affirmative would be to show that at least one of the\n13 known single axioms is derivable from XCB alone; another\napproach would be to derive from XCB the 3-axiom set\n(E1)\u2013(E3). While Wos, Ulrich & Fitelson 2002 take shots at\nthe former, their line of attack concentrates on the latter with the\nmost challenging task being the proving of symmetry. Working with the\nassistance of a powerful automated reasoning program, Otter, they\nconducted a concerted, persistent and very aggressive assault on the\nopen question. (Their article sometimes reads like a military briefing\nfrom the front lines!) For simpler problems, proofs can be found by\nthe reasoning program automatically; deeper and more challenging ones\nlike the one at hand require the guidance of the user. The relentless\napplication of the reasoning tool involved much guidance in the\nsetting of lemmas as targets and the deployment of an arsenal of\nstrategies, including the set of support, forward and backward\nsubsumption, lemma adjunction, formula complexity, hints strategy,\nratio strategy, term avoidance, level saturation, and others. After\nmuch effort and CPU time, the open question finally succumbed to the\ncombined effort of man and machine and a 61-step proof of symmetry was\nfound, followed by one for transitivity after 10 more applications of\ncondensed detachment. Subsequent runs of the theorem prover using\ndemodulation blocking and the so-called cramming strategy delivered\nshorter proofs. Here are the last lines of their 25-step proof which\nin this case proves transitivity first followed by symmetry: \n\n\n\n123\n[hyper,51,106,122]\nP(e(e(e(e(x,y),e(z,y)),z),x)).\n\n\n124\n[hyper,51,53,123]\nP(e(e(e(e(e(e(e(x,y),e(z,y)),\n\nz),x),u),e(v,u)),v)). \n\n125\n[hyper,51,124,123]\nP(e(e(e(x,y),x),y)). \n\n127\n[hyper,51,124,108]\nP(e(e(e(e(x,e(e(e(x,y),e(z,y))\n\n,z)),e(e(e(e(e(u,v),e(w,v)),w),u),\n\nv6)),v7),e(v6,v7))). \n\n128\n[hyper,51,127,123]\nP(e(e(x,y),e(e(y,z),e(x,z)))).\n\n\n130\n[hyper,51,128,125]\nP(e(e(x,y),e(e(e(z,x),z),y))).\n\n\n131\n[hyper,51,128,130]\nP(e(e(e(e(e(x,y),x),z),u),\n\ne(e(y,z),u))). \n\n132\n[hyper,51,131,123]\nP(e(e(x,y),e(y,x))). \n\n\n\nWith an effective methodology and a strategy that included the\nassistance of an automated reasoning program in a crucial way, the\nsearch for shortest single axioms for the equivalent calculus came to\nan end. \n\nFitelson & Zalta 2007, Oppenheimer & Zalta 2011, and Alama,\nOppenheimer, & Zalta 2015 describe several applications of\nautomated reasoning in computational metaphysics. By\nrepresenting formal metaphysical claims as axioms and premises in an\nautomated reasoning environment using programs like Prover9, Mace4,\nthe E-prover system and Paradox, the logical status of metaphysical\narguments is investigated. After the suitable formalization of axioms\nand premises, the model finder program Mace4 is used to help verify\ntheir consistency. Then, using Prover9, proofs are automatically\ngenerated for a number of theorems of the Theory of Plato\u2019s Forms,\ntwenty five fundamental theorems of the Theory of Possible Worlds, the\ntheorems described in Leibniz\u2019s unpublished paper of 1690 and in his\nmodal metaphysics, and a fully automated construction of Saint\nAnselm\u2019s Ontological Argument. In the latter application, Saint Anselm\nis understood in Oppenheimer & Zalta 2011 as having found a way of\ninferring God\u2019s existence from His mere being as opposed to inferring\nGod\u2019s actuality from His mere possibility. This allows for a\nformalization that is free of modal operators, involving an underlying\nlogic of descriptions, three non-logical premises, and a definition of\nGod. Here are two key definitions in the formalization, as inputted\ninto Prover9, that helped express the concept of God: \n\n\n\n\n\nDefinition of none_greater: \n\nall x (Object(x) -> (Ex1(none_greater,x)\n<-> \n\n\u00a0(Ex1(conceivable,x) & \n\n\u00a0\u00a0-(exists y (Object(y) &\nEx2(greater_than,y,x) & \n\n\u00a0\u00a0\u00a0Ex1(conceivable,y)))))).\n\n\n\u00a0 \n\nDefinition of God: \n\nIs_the(g,none_greater). \n\n\n\n\n\nPart of the challenge when representing in Prover9 these and other\nstatements from axiomatic metaphysics was to circumvent some of the\nprover\u2019s linguistic limitations. For example, Prover9 does not have\ndefinite descriptions so statements of this kind as well as\nsecond-order concepts had to be expressed in terms of Prover9\u2019s\nexisting first-order logic. But the return is worth the investment\nsince Prover9 not only delivered a proof\nof Ex1(e,g)\u2014there is one and only one\nGod\u2014but does so with an added bonus. A close inspection of the\noutput provides yet another example of an automated theorem prover\n\"outreasoning\" its users, revealing that some of the logical machinery\nis actually redundant: The proof can be constructed only using two of\nthe logical theorems of the theory of descriptions (called \"Theorem 2\"\nand \"Theorem 3\" in their article), one of the non-logical premises\n(called \"Premise 2\"), and the definition of God. We cannot help but to\ninclude here Prover9\u2019s shorter proof, written in the more elegant\nnotation of standard logic (from Oppenheimer & Zalta 2011): \n\n\n1.\n~E!\u03b9x\u03c61\nAssumption, for Reductio \n\n2.\n\u2203y(Gy\u03b9x\u03c61\n& Cy)\nfrom (1), by Premise 2 and MP \n\n3.\nGh\u03b9x\u03c61 &\nCh\nfrom (2), by \u2203E, \u2018h\u2019 arbitrary\n\n\n4.\nGh\u03b9x\u03c61\nfrom (3), by &E \n\n5.\n\u2203y(y =\n\u03b9x\u03c61)\nfrom (4), by Theory of Descriptions, Theorem 3 \n\n6.\nC\u03b9x\u03c61 &\n~\u2203y(Gy\u03b9x\u03c61 &\nCy)\nfrom (5), by Theory of Descriptions, Theorem 2 \n\n7.\n~\u2203y(Gy\u03b9x\u03c61\n& Cy)\nfrom (6), by &E \n\n8.\nE!\u03b9x\u03c61\nfrom (1), (2), (7), by Reductio \n\n9.\nE!g\nfrom (8), by the definition of \u2018g\u2019 \n\n\nIn the same tradition as St. Anselm\u2019s, G\u00f6del also provided an\nontological proof of God\u2019s existence (G\u00f6del 1970, Scott 1972). An\nimportant difference between the two is G\u00f6del\u2019s use of modal\noperators to represent metaphysical possibility and necessity and, of\ncourse, his use of symbolic logic for added reasoning precision. In\nhis proof, G\u00f6del begins by framing the concept of \u201cpositive\nproperty\u201d using two axioms, and he introduces a definition\nstating that \u201cA God-like being possesses all positive\nproperties\u201d. This is enough logical machinery to prove as a\ntheorem the possibility of God\u2019s existence,\n\u25ca\u2203xG(x); three more axioms and\ntwo additional definitions allow G\u00f6del to further his proof to\nestablish not only that God exists,\n\u2203xG(x), but that this is so by\nnecessity, \u25a1\u2203xG(x).\nG\u00f6del\u2019s proof is in the formalism of higher-order modal logic\n(HOML) using modal operators and quantification over properties.\nG\u00f6del never published his proof but he shared it with Dana Scott\nwho produced the version presented below, which is taken from\n(Benzm\u00fcller & Paleo 2014) along with its English annotation to\naid the reader with its intended interpretation: \n\n\nAxiom A1\n\n\u2200\u03d5[P(~\u03d5)\u00a0\u2261\u00a0~P(\u03d5)]\n\n\u00a0\u00a0Either a property or its negation is positive, but not\nboth)\n\nAxiom A2\n\n\u2200\u03d5\u2200\u03c8[(P(\u03d5)\u00a0\u2227\u00a0\u25a1\u2200x[\u03d5(x)\u00a0\u2192\u00a0\u03c8(x)])\u00a0\u2283\u00a0P(\u03c8)]\n\n\u00a0\u00a0A property necessarily implied by a positive property\nis positive\n\nTheorem T1\n\n\u2200\u03d5[P(\u03d5)\u00a0\u2283\u00a0\u25ca\u2203x\u03d5(x)]\n\n\u00a0\u00a0Positive properties are possibly exemplified\n\nDefinition D1\n\nG(x)\u00a0\u2261\u00a0\u2200\u03d5[P(\u03d5)\u00a0\u2283\u00a0\u03d5(x)]\n\n\u00a0\u00a0A God-like being possesses all positive\nproperties\n\nAxiom A3\n\nP(G)\n\n\u00a0\u00a0The property of being God-like is positive\n\nCorollary C\n\n\u25ca\u2203xG(x)\n\n\u00a0\u00a0Possibly, God exists\n\nAxiom A4\n\n\u2200\u03d5[P(\u03d5)\u00a0\u2283\u00a0\u25a1P(\u03d5)]\n\n\u00a0\u00a0Positive properties are necessarily positive\n\nDefinition D2\n\n\u03d5 ess\nx\u00a0\u00a0\u2261\u00a0\u00a0\u03d5(x) \u2227\n\u2200\u03c8(\u03c8(x) \u2283\n\u25a1\u2200y(\u03d5(y) \u2283\n\u03c8(y)))\n\n\u00a0\u00a0An essence of an individual is a property possessed by\nit and\n\n\u00a0\u00a0necessarily implying any of its properties\n\nTheorem T2\n\n\u2200x[G(x)\u00a0\u2283\u00a0G ess\nx]\n\n\u00a0\u00a0Being God-like is an essence of any God-like\nbeing\n\nDefinition D3\n\nNE(x)\u00a0\u2261\u00a0\u2200\u03d5[\u03d5\ness x \u2283 \u25a1\u2203y\u03d5(y)]\n\n\u00a0\u00a0Necessary existence of an individual is the necessary\n\n\u00a0\u00a0 exemplification of all its essences\n\nAxiom A5\n\nP(NE)\n\n\u00a0\u00a0Necessary existence is a positive property\n\nTheorem T3\n\n\u25a1\u2203xG(x)\n\n\u00a0\u00a0Necessarily, God exists\n\n\nThe proof has recently been analysed to an unprecedented degree of\ndetail and precision by Benzm\u00fcller & Paleo 2014 with the help\nof automated theorem provers. A major challenge faced by these authors\nwas the lack of a HOML-based theorem prover that could carry out the\nwork but this was circumvented by embedding the logic into the\nclassical higher-order logic (HOL) already offered by existing theorem\nprovers like LEO-II, Satallax and the countermodel finder Nitpick.\nDetails of the syntactic and semantic embedding are given in their\npaper and it consists of encoding HOML formulas as HOL predicates via\nmappings, expansions, and \u03b2\u03b7-conversions. The\nmapping associates HOML types \u03b1, terms\ns\u03b1, and logical operators \u03b8 with\ncorresponding HOL \u201craised\u201d types\n\u2308\u03b1\u2309, type-raised terms\n\u2308s\u03b1\u2309, and type-raised logical\noperators \u03b8\u2022. If \u03bc\nand \u03bf are, respectively, the types of individuals and\nBooleans then \u2308\u03bc\u2309 = \u03bc and\n\u2308\u03bf\u2309 = \u03c3\nwhere \u03c3 is shorthand\nfor \u03b9\u00a0\u2192\u00a0\u03bf\nwith \u03b9 as the type of possible worlds; as for function\ntypes, \u2308\u03b2\u2192\u03b3\u2309 =\n\u2308\u03b2\u2309\u2192\u2308\u03b3\u2309. For\ntype-raised terms, \u2308s\u03b1\u2309\nis defined inductively on the structure\nof s\u03b1 as the following example\nillustrates:\n\n\n\n\u2308\u2203(\u03bc\u2192\u03bf)\u2192\u03bf\u00a0X\u03bc\u00a0.\u00a0g\u03bc\u2192\u03bf\u00a0X\u2309\n\n\n= \u2308\u2203(\u03bc\u2192\u03bf)\u2192\u03bf\u2309\u2308\u00a0X\u03bc\u00a0.\u00a0g\u03bc\u2192\u03bf\u00a0X\u2309\n\n\n\n\n\n= \u2308\u2203(\u03bc\u2192\u03bf)\u2192\u03bf\u2309\u2308\u00a0X\u03bc\u2309\u00a0.\u00a0\u2308g\u03bc\u2192\u03bf\u2309\u00a0\u2308X\u2309\n\n\n\n\n\n= \u2203\u2022\u2308(\u03bc\u2192\u03bf)\u2192\u03bf\u2309\u00a0X\u2308\u03bc\u2309\u00a0.\u00a0g\u2308\u03bc\u2192\u03bf\u2309\u00a0X\n\n\n\n\n\n= \u2203\u2022(\u03bc\u2192\u03c3)\u2192\u03c3\u00a0X\u03bc\u00a0.\u00a0g\u03bc\u2192\u03c3\u00a0X\n\n\n\n\nType-raised logical connectives, \u03b8\u2022, are defined below where r is a new constant symbol in HOL associated with the accessibility relation of HOML:\n\n\n\n~\u2022\u03c3\u2192\u03c3\n\u00a0=\u00a0\u00a0\n\u03bbs\u03c3\u00a0\u03bbw\u03b9\u00a0~(sw)\n\n\n\u2228\u2022\u03c3\u2192\u03c3\u2192\u03c3\n\u00a0=\u00a0\u00a0\n\u03bbs\u03c3\u00a0\u03bbt\u03c3\u00a0\u03bbw\u03b9\u00a0(sw\u00a0\u2228\u00a0tw)\n\n\n\u2200\u2022(\u03b1\u2192\u03c3)\u2192\u03c3\n\u00a0=\u00a0\u00a0\n\u03bbs\u03b1\u2192\u03c3\u00a0\u03bbw\u03b9\u2200x\u03b1\u00a0sxw\n\n\n\u25a1\u2022\u03c3\u2192\u03c3\n\u00a0=\u00a0\u00a0\n\u03bbs\u03c3\u00a0\u03bbw\u03b9\u2200u\u03b9\u00a0.\u00a0~(r\u03b9\u2192\u03b9\u2192owu)\u00a0\u2228\u00a0su\n\n\n\nThe other connectives can be defined in the usual way. Validity is\nexpressed as a \u03bb-term,\n\u03bbs\u03b9\u2192\u03bf\u2200w\u03b9\u00a0sw,\nthat when applied to a term s\u03c3 we write as\n[s\u03c3]. For example, under the embedding,\nproving in HOML the possibility of God\u2019s existence,\n\u25ca\u03bf\u2192\u03bf\u2203(\u03bc\u2192\u03bf)\u2192\u03bf\u00a0X\u03bc\u00a0.\u00a0g\u03bc\u2192\u03bf\u00a0X,\nis tantamount to proving its validity in HOL:\n[\u25ca\u2022\u03c3\u2192\u03c3\u2203\u2022(\u03bc\u2192\u03c3)\u2192\u03c3\u00a0X\u03bc\u00a0.\u00a0g\u03bc\u2192\u03c3\u00a0X]\u03bc\u2192\u03bf.\nTo prove so, the type-raised HOL expression\n[\u25ca\u2022\u2203\u2022X\u03bc\u00a0.\u00a0g\u03bc\u2192\u03c3\u00a0X]\nis then encoded in the so-called THF0 syntax (Sutcliffe &\nBenzm\u00fcller 2010) prior to being fed, along with the above set of\nequality rules, to the provers that were used in completing the proof:\n\n\n\nthf(corC, conjecture,\n\n \u00a0\u00a0 (v\n\n \u00a0\u00a0 \u00a0\u00a0 @(mdia\n\n \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0 @(mexists_ind\n\n \u00a0\u00a0 \u00a0 \u00a0\u00a0 \u00a0\u00a0 @^[X: mu]\n:\n\n \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0 \u00a0\u00a0\n\u00a0\u00a0 (g @ X)))))).\n\n\nThe proof in Benzm\u00fcller & Paleo 2014 is presented here,\nincluding the axioms and definitions as well as the derivation of its\nfour main results\u2014T1, C, T2, T3\u2014all written in the\ntype-decorated type-raised higher-order logic notation resulting from\nthe embedding. The proof steps are not fully expanded\u2014note the\npresence of type-raised connectives\u2014and the inferential moves\nare not broken down to lower levels of detail. Borrowing a phrase from\nBertrand Russell (Urquhart 1994), this was done to spare the reader of\nthe \u201ckind of nausea\u201d that the fully detailed automated\nproof would cause: \n\n\nA1\n[\u2200\u2022\u03d5\u03bc\u2192\u03c3\u00a0.\u00a0p(\u03bc\u2192\u03c3)\u2192\u03c3\u00a0(\u03bbX\u03bc\u00a0.\u00a0~\u2022(\u03d5X))\u00a0\u2261\u2022\u00a0~\u2022(p\u03d5)]\nAxiom\n\n\nA2\n[\u2200\u2022\u03d5\u03bc\u2192\u03c3\u00a0.\u2200\u2022\u03c8\u03bc\u2192\u03c3\u00a0.\u00a0(p(\u03bc\u2192\u03c3)\u2192\u03c3\u00a0\u03d5\u00a0\u2227\u2022\u00a0\u25a1\u2022\u2200\u2022X\u03bc\u00a0.\u00a0(\u03d5X\u00a0\u2283\u2022\u00a0\u03c8X))\u00a0\u2283\u2022\u00a0p\u03c8]\nAxiom\n\n\nT1\n[\u2200\u2022\u03d5\u03bc\u2192\u03c3\u00a0.\u00a0p(\u03bc\u2192\u03c3)\u2192\u03c3\u00a0\u03d5\u00a0\u2283\u2022\u00a0\u25ca\u2022\u2203\u2022X\u03bc\u00a0.\u00a0\u03d5X]\nA1, A2 (in K)\n\n\nD1\ng\u03bc\u2192\u03c3\u00a0=\u00a0\u03bbX\u03bc\u00a0.\u2200\u2022\u03d5\u03bc\u2192\u03c3\u00a0.\u00a0p(\u03bc\u2192\u03c3)\u2192\u03c3\u00a0\u03d5\u00a0\u2283\u2022\u00a0\u03d5X\nDefinition\n\n\nA3\n[p(\u03bc\u2192\u03c3)\u2192\u03c3\u00a0g\u03bc\u2192\u03c3]\nAxiom\n\n\nC\n[\u25ca\u2022\u2203\u2022X\u03bc\u00a0.\u00a0g\u03bc\u2192\u03c3\u00a0X]\nT1, D1, A3 (in K)\n\n\nA4\n[\u2200\u2022\u03d5\u03bc\u2192\u03c3\u00a0.\u00a0p(\u03bc\u2192\u03c3)\u2192\u03c3\u00a0\u03d5\u00a0\u2283\u2022\u00a0\u25a1\u2022p\u03d5]\nAxiom\n\n\nD2\ness(\u03bc\u2192\u03c3)\u2192\u03bc\u2192\u03c3\u00a0=\u00a0\u03bb\u03d5\u03bc\u2192\u03c3\u00a0.\u00a0\u03bbX\u03bc\u00a0.\u00a0\u03d5X\u00a0\u2227\u2200\u2022\u03c8\u03bc\u2192\u03c3\u00a0.\u00a0(\u03c8X\u00a0\u2283\u2022\u00a0\u25a1\u2022\u2200\u2022Y\u03bc\u00a0.\u00a0(\u03d5Y\u00a0\u2283\u2022\u00a0\u03c8Y))\nDefinition\n\n\nT2\n[\u2200\u2022X\u03bc\u00a0.\u00a0g\u03bc\u2192\u03c3\u00a0X\u00a0\u2283\u2022\u00a0ess(\u03bc\u2192\u03c3)\u2192\u03bc\u2192\u03c3\u00a0gX]\nA1, D1, A4, D2 (in K)\n\n\nD3\nNE\u03bc\u2192\u03c3\u00a0=\u00a0\u03bbX\u03bc\u00a0.\u2200\u2022\u03d5\u03bc\u2192\u03c3\u00a0.\u00a0(ess\u00a0\u03d5X\u00a0\u2283\u2022\u00a0\u25a1\u2022\u2203\u2022Y\u03bc\u00a0.\u00a0\u03d5Y)\nDefinition\n\n\nA5\n[p(\u03bc\u2192\u03c3)\u2192\u03c3\u00a0NE\u03bc\u2192\u03c3]\nAxiom\n\n\nT3\n[\u25a1\u2022\u2203X\u03bc\u00a0.\u00a0g\u03bc\u2192\u03c3\u00a0X]\nD1, C, T2, D3, A5 (in KB)\n\n\n\nBesides helping in the completion of the proof, the automated theorem\nprovers were also very instrumental in the finding of some novel\nresults. First, G\u00f6del\u2019s set of original assumptions was shown to\nbe inconsistent by LEO-II by proving that self-difference becomes an\nessential property of every entity; a re-formulation of the definition\nof essence due to Dana Scott\u2014this involved the addition of a\nmissing conjunct, \u03d5X, in the definition\u2014was shown\nby Nitpick to be consistent. Second, LEO-II and Satallax managed to\nprove C, T1 and T2 using only the logic system K and, moreover,\nNitpick found a counter-model for T3 in K thus showing that more\nlogical power is required to complete the rest of the proof. Third,\nusing LEO-II and Satallax, it is shown that the logic system KB\n(system K with the Brouwer axiom) is sufficient to establish the\nnecessity of God\u2019s existence,\n\u25a1\u2022\u2203\u2022X\u03bc\u00a0.\u00a0g\u03bc\u2192\u03c3\u00a0X,\nwhich is a double-win for automated reasoning: a gain in logical\neconomy, and the deeper philosophical result of having effectively\ndismissed a major criticism against G\u00f6del\u2019s proof, namely his use\nof the stronger logic system S5. Fourth, the authors also prove in KB\nthat:\n\n\u2200\u2022\u03d5\u03bc\u2192\u03c3\u00a0.\u2200\u2022X\u03bc\u00a0.\u00a0(g\u03bc\u2192\u03c3\u00a0X\u00a0\u2283\u2022\u00a0(~\u2022(p(\u03bc\u2192\u03c3)\u2192\u03c3\u00a0\u03d5)\u00a0\u2283\u2022\u00a0~\u2022(\u03d5X)))\n\n\nas well as:\n\n\u2200\u2022X\u03bc\u00a0.\u2200\u2022Y\u03bc\u00a0.\u00a0(g\u03bc\u2192\u03c3\u00a0X\u00a0\u2283\u2022\u00a0(g\u03bc\u2192\u03c3\u00a0Y\u00a0\u2283\u2022\u00a0X\u00a0=\u2022\u00a0Y)),\n\n\nthat is, that God is flawless and that monotheism holds, respectively.\nAt this point, it would be fair to say that any of these results would\nbe enough to vindicate the application of automated reasoning in exact\nphilosophy. Now, for the bad news followed by good news: Fifth, the\nformula\ns\u03c3\u00a0\u2283\u2022\u00a0\u25a1\u2022s\u03c3\ncan also be formally derived which is unfortunate since it implies\nthat there are no contingent truths and that everything is determined,\ni.e. there is no free will. However, the issue has been addressed by\nfollow-up work based on Fitting\u2019s and Anderson\u2019s variants of the\nontological argument (Fuenmayor & Benzm\u00fcller 2017, Fitting\n2002, Anderson 1990). \n\nLeibniz\u2019s dream was to have a charateristica universalis and\ncalculus ratiocinator that would allow us to reason in\nmetaphysics and morals in much the same way as we do in geometry and\nanalysis; that is to say, to settle disputes between philosophers as\naccountants do: \u201cTo take pen in hand, sit down at the abacus\nand, having called in a friend if they want, say to each other: Let us\ncalculate!\u201d From the above applications of automated reasoning,\none would agree with the researchers when they imply that these\nresults achieve, to some extent, Leibniz\u2019s goal of a computational\nmetaphysics (Fitelson & Zalta 2007, Benzm\u00fcller & Paleo\n2014).\n\n\nA nonmonotonic theorem prover can provide the basis for a\n\u201ccomputational laboratory\u201d in which to explore and\nexperiment with different models of artificial rationality; the\ntheorem prover can be used to equip an artificial rational agent with\nan inference engine to reason and gain information about the world. In\nsuch procedural epistemology, a rational agent is\ndefeasible (i.e. nonmonotonic) in the sense that new reasoning leads\nto the acceptance of new beliefs but also to the retraction of\npreviously held beliefs in the presence of new information. At any\ngiven point in time, the agent holds a set of justified beliefs but\nthis set is open to revision and is in a continuous set of flux as\nfurther reasoning is conducted. This model better reflects our\naccepted notion of rationality than a model in which all the beliefs\nare warranted, i.e. beliefs that once are attained are never\nretracted. Actually, a set of warranted beliefs can be seen as\njustified beliefs \u201cin the limit\u201d, that is, as the ultimate\nepistemic goal in the agent\u2019s search for true knowledge about its\nworld. (Pollock 1995) offers the following definition: \n\nA set is defeasible enumerable iff there is an effective computable\nfunction f such that for each n,\nf(n) is a recursive set and the following two\nconditions hold \n\n\n1.\n(\u2200x)(x \u2208 A \u2192\n(\u2203n)(\u2200m > n) x\n\u2208 f(m)) \n\n2.\n(\u2200x)(x \u2209 A \u2192\n(\u2203n)(\u2200m > n) x\n\u2209 f(m)) \n\n\nTo compare the concepts, if A is recursively enumerable then\nthere is a sequence of recursive sets Ai such that\neach Ai is a subset of A with each\nAi growing monotonically, approaching A\nin the limit. But if A is only defeasibly enumerable then the\nAi\u2019s still approach A in the limit but\nmay not be subsets of A and approach A\nintermittently from above and below. The goal of the OSCAR Project\n(Pollock 1989) is to construct a general theory of rationality and\nimplement it in an artificial computer-based rational agent. As such,\nthe system uses a defeasible automated reasoner that operates\naccording to the maxim that the set of warranted beliefs should be\ndefeasible enumerable. OSCAR has been in the making for some time and\nthe application of automated nonmonotonic reasoning has also been used\nto extend its capabilities to reason defeasibly about perception and\ntime, causation, and decision-theoretic planning (Pollock 2006). \n4.7 Mathematics\n\nOne of the main goals of automated reasoning has been the automation\nof mathematics. An early attempt at this was Automath (de Bruijn 1968)\nwhich was the first computer system used to check the correctness of\nproofs and whole books of mathematics, including Landau\u2019s\nGrundlagen der Analysis (van Benthem Jutting 1977). Automath\nhas been superseded by more modern and capable systems, most notably\nMizar. The Mizar system (Trybulec 1979, Muzalewski 1993) is based on\nTarski-Grothendieck set theory and, like Automath, consists of a\nformal language which is used to write mathematical theorems and their\nproofs. Once a proof is written in the language, it can be checked\nautomatically by Mizar for correctness. Mizar proofs are formal but\nquite readable, can refer to definitions and previously proved\ntheorems and, once formally checked, can be added to the growing Mizar\nMathematical Library (MML) (Bancerek & Rudnicki 2003, Bancerek\net al. 2018). As of June 2018, MML contained about 12,000\ndefinitions and 59,000 theorems. The Mizar language is a subset of\nstandard English as used in mathematical texts and is highly\nstructured to ensure the production of rigorous and semantically\nunambiguous texts. Here\u2019s a sample proof in Mizar of the existence of\na rational number xy where x and\ny are irrational: \n\n\ntheorem T2:\n\n\u00a0\u00a0ex x, y st x is irrational & y is irrational\n& x.^.y is rational\n\nproof\n\n\u00a0\u00a0set w = \u221a2;\n\n\u00a0\u00a0H1: w is irrational by INT_2:44,T1;\n\n\u00a0\u00a0w>0 by AXIOMS:22,SQUARE_1:84;\n\n\u00a0\u00a0then (w.^.w).^.w = w.^.(w\u2022w) by\nPOWER:38\n\n\u00a0\u00a0\u00a0\u00a0.= w.^.(w2) by\nSQUARE_1:58\n\n\u00a0\u00a0\u00a0\u00a0.= w.^.2 by SQUARE_1:88\n\n\u00a0\u00a0\u00a0\u00a0.= w2 by POWER:53\n\n\u00a0\u00a0\u00a0\u00a0.= 2 by SQUARE_1:88;\n\n\u00a0\u00a0then H2: (w.^.w).^.w is rational by\nRAT_1:8;\n\n\u00a0\u00a0per cases;\n\n\u00a0\u00a0suppose H3: w.^.w is rational;\n\n\u00a0\u00a0\u00a0\u00a0take w, w;\n\n\u00a0\u00a0\u00a0\u00a0thus thesis by H1,H3;\n\n\u00a0\u00a0suppose H4: w.^.w is irrational;\n\n\u00a0\u00a0\u00a0\u00a0take w.^.w, w;\n\n\u00a0\u00a0\u00a0\u00a0thus thesis by H1,H2,H4;\n\nend;\n\n\nExamples of proofs that have been checked by Mizar include the\nHahn-Banach theorem, the Brouwer fixed-point theorem, K\u0151nig\u2019s lemma,\nthe Jordan curve theorem, and G\u00f6del\u2019s completeness theorem.\nRudnicki (2004) discusses the challenges of formalizing Witt\u2019s proof\nof the Wedderburn theorem: Every finite division ring is commutative.\nThe theorem was formulated easily using the existing formalizations\navailable in MML but the proof demanded further entries into the\nlibrary to formalize notions and facts from algebra, complex numbers,\nintegers, roots of unity, cyclotomic polynomials, and polynomials in\ngeneral. It took several months of effort to supply the missing\nmaterial to the MML library but, once in place, the proof was\nformalized and checked correct in a matter of days. Clearly, a\nrepository of formalized mathematical facts and definitions is a\nprerequisite for more advanced applications. The QED Manifesto (Boyer\net al. 1994, Wiedijk 2007) has such aim in mind and there is\nmuch work to do: Mizar has the largest such repository but even after\n30 years of work \u201cit is minuscule with respect to the body of\nestablished mathematics\u201d (Rudnicki 2004). This last remark\nshould be construed as a call to increase the effort toward this\nimportant aspect in the automation of mathematics. \n\nMizar\u2019s goal is to assist the practitioner in the formalization of\nproofs and to help check their correctness; other systems aim at\nfinding the proofs themselves. Geometry has been a target of early\nautomated proof-finding efforts. Chou (1987) proves over 500 geometry\ntheorems using the algebraic approach offered by Wu\u2019s method and the\nGr\u00f6bner basis method by representing hypotheses and conclusions\nas polynomial equations. Quaife (1992) provides another early effort\nto find proofs in first-order mathematics: over 400 theorems in\nNeumann-Bernays-G\u00f6del set theory, over 1,000 theorems in\narithmetic, a number of theorems in Euclidian geometry, and\nG\u00f6del\u2019s incompleteness theorems. The approach is best described\nas semi-automatic or \u201cinteractive\u201d with the user providing\na significant amount of input to guide the theorem-proving effort.\nThis is no surprise since, as one applies automated reasoning systems\ninto richer areas of mathematics, the systems take more on the role of\nproof assistants than theorem provers. This is because in richer\nmathematical domains the systems need to reason about theories and\nhigher-order objects which in general takes them deeper into the\nundecidable. Interactive theorem proving is arguably\nthe \u201ckiller\u201d application of automated reasoning in\nmathematics and much effort is being expended in the building of\nincreasingly capable reasoning systems that can act as assistants to\nprofessional mathematicians. The proof assistant Isabelle/HOL provides\nthe user with an environment in which to conduct proofs expressed in a\nstructured, yet human-readable, higher-order logic language and which\nincorporates a number of facilities that increase the user\u2019s\nproductivity, automates proof-verification and proof-finding tasks,\nand provides a modular way for the user to build and manage theory\nhierarchies (Ballarin 2014). \n\nDifferent proof assistants offer different capabilities measured by\ntheir power at automating reasoning tasks, supported logic, object\ntyping, size of mathematical library, and readability of input and\noutput. A \u201ccanonical\u201d proof which is not too trivial but\nnot too complex either can be used as a baseline for system\ncomparison, as done in (Wiedijk 2006) where the authors of seventeen\nreasoning systems are tasked with establishing the irrationality of\n\u221a2. The systems discussed are certainly more capable than this\nand some have been used to assist in the formalization of far more\nadvanced proofs such as Erd\u00f6s-Selberg\u2019s proof of the Prime Number\nTheorem (about 30,000 lines in Isabelle), the formalization of the\nFour Color Theorem (60,000 lines in Coq), and the Jordan Curve Theorem\n(75,000 lines in HOL Light). A milestone in interactive theorem\nproving was reached in 2012 when, after six-years of effort and using\nthe Coq proof assistant, George Gonthier and his team completed the\nformal verification of the 255-page proof of the Feit-Thompson\ntheorem, also known as the Odd Order Theorem, a major step in the\nclassification of finite simple groups. \n\nThe above notwithstanding, automated reasoning has had a small impact\non the practice of doing mathematics and there is a number of reasons\ngiven for this. One reason is that automated theorem provers are not\nsufficiently powerful to attempt the kind of problems mathematicians\ntypically deal with; that their current power is, at best, at the\nlevel of first-year undergraduate mathematics and still far from\nleading edge mathematical research. While it is true that current\nsystems cannot prove completely on their own problems at this level of\ndifficulty we should remember that the goal is to build reasoning\nsystems so that \u201ceventually machines are to be an aid to\nmathematical research and not a substitute for it\u201d (Wang 1960).\nWith this in mind, and while the automated reasoning community\ncontinues to try to meet the grand challenge of building increasingly\npowerful theorem provers, mathematicians can draw now some of the\nbenefits offered by current systems, including assistance in\ncompleting proof gaps or formalizing and checking the correctness of\nproposed proofs. Indeed, the latter may be an application that could\nhelp address some real issues currently being faced by the\nmathematical community. Consider the announcement by Daniel Goldston\nand Cem Yildrim of a proof of the Twin Prime Conjecture where,\nalthough experts initially agreed that the proof was correct, an\ninsurmountable error was found shortly after. Or, think about the case\nof Hales\u2019 proof of the Kepler Conjecture which asserts that no packing\nof congruent balls in Euclidean 3-space has density greater than the\nface-centered cubic packing. Hales\u2019 proof consists of about 300 pages\nof text and a large number of computer calculations. After four years\nof hard work, the 12-person panel assigned by Annals of\nMathematics to the task of verifying the proof still had genuine\ndoubts about its correctness. Thomas Hales, for one, took upon himself\nto formalize his proof and have it checked by an automated proof\nassistant with the aim of convincing others of its correctness (Hales\n2005b, in Other Internet Resources). His task was admittedly heavy but\nthe outcome is potentially very significant to both the mathematical\nand automated reasoning communities. All eyes were on Hales and his\nformal proof as he announced the completion of the Flyspeck\nproject (Hales 2014, in Other Internet Resources; Hales 2015) having\nconstructed a formal proof of the conjecture using the Isabelle and\nHOL Light automated proof assistants: \u201cIn truth, my motivations\nfor the project are far more complex than a simple hope of removing\nresidual doubt from the minds of few referees. Indeed, I see formal\nmethods as fundamental to the long-term growth of mathematics.\u201d\n(Hales 2006).\n\nChurch 1936a, 1936b and Turing 1936 imply the existence of\ntheorems whose shortest proof is very large, and the proof of the Four\nColor Theorem in (Appel & Haken 1977), the Classification of Simple\nGroups in (Gorenstein 1982), and the proof of the Kepler Conjecture in\n(Hales 2005a) may well be just samples of what is yet to come. As\n(Bundy 2011) puts it: \u201cAs important theorems requiring larger\nand larger proofs emerge, mathematics faces a dilemma: either these\ntheorems must be ignored or computers must be used to assist with\ntheir proofs.\u201d\n\nThe above remarks also counter another argument given for not using\nautomated theorem provers: Mathematicians enjoy proving theorems, so\nwhy let machines take away the fun? The answer to this is, of course,\nthat mathematicians can have even more fun by letting the machine do\nthe more tedious and menial tasks: \u201cIt is unworthy of excellent\nmen to lose hours like slaves in the labour of calculation which could\nsafely be relegated to anyone else if machines were used\u201d (G. W.\nLeibniz, New Essays Concerning Human Understanding). If still\nnot convinced, just consider the sobering prospect of having to\nmanually check the 23,000 inequalities used in Hales\u2019 proof!\n\nAnother reason that is given for the weak acceptance of automated\nreasoning by the mathematical community is that the programs are not\nto be trusted since they may contain bugs\u2014software\ndefects\u2014and hence may produce erroneous results. Formally\nverifying automated reasoning programs will help ameliorate this,\nparticularly in the case of proof checkers. Proving programs correct\nis no easy task but the same is true about proving theorems in\nadvanced mathematics: Gonthier proved correct the programs used in the\nformalization of his proof of the Four Color Theorem, but he spent far\nmore effort formalizing all the graph theory that was part of the\nproof. So ironically enough, it turns out that at least in this case,\nand surely there are others, \u201cit is actually easier to verify\nthe correctness of the program than to verify the correctness of the\npen-and-paper mathematics\u201d (Wiedijk 2006). For theorem provers\nand model finders, a complementary strategy would be to verify the\nprograms\u2019 results as opposed to the programs themselves. Paraphrasing\n(Slaney 1994): It does not matter to the mathematician how many\ndefects a program may have as long as the proof (or model) it outputs\nis correct. So, the onus is in the verification of results, whether\nproduced by machine or man, and checking them by independent parties\n(where of course the effort may well use automated checkers) should\nincrease the confidence on the validity of the proofs. \n\nIt is often argued that automated proofs are too long and detailed.\nThat a proof can be expressed in more elementary steps is in principle\nvery beneficial since this allows a mathematician to request a proof\nassistant justify its steps in terms of simpler ones. But proof\nassistants should also allow the opposite, namely to abstract detail\nand present results and their justifications using the higher-level\nconcepts, language, and notation mathematicians are accustomed to.\nExploiting the hierarchical structure of proofs as done in (Denney\n2006) is a step in this direction but more work along these lines is\nneeded. Having the proof assistant work at the desired level of\ngranularity provides more opportunity for insight during the proof\ndiscovery process. This is an important consideration since\nmathematicians are equally interested in gaining understanding from\ntheir proofs as in establishing facts. \n\n(Bundy 2011) alludes to a deadlock that is preventing the wider\nadoption of theorem provers by the mathematical community: On the one\nhand, the mathematicians need to use the proof assistants to build a\nlarge formal library of mathematical results. But, on the other hand,\nthey do not want to use the provers since there is no such library of\npreviously proved results they can build upon. To break the impasse, a\nnumber of applications are proposed of which assisting the\nmathematician in the search of previously proved theorems is of\nparticular promise. During its history, mathematics has accumulated a\nhuge number of theorems and the number of mathematical results\ncontinues to grow dramatically. In 2010, Zentralblatt MATH\ncovered about 120,000 new publications (Wegner 2011). Clearly, no\nindividual researcher can be acquainted with all this mathematical\nknowledge and it will be increasingly difficult to cope with one\u2019s\never-growing area of specialty unless assisted with automated\ntheorem-proving tools that can search in intelligent ways for\npreviously proved results of interest. An alternative approach to this\nproblem is for mathematicians to tap into each other\u2019s knowledge as\nenabled in computational social systems like polymath and\nmathoverflow. The integration of automated reasoning tools\ninto such social systems would increase the effectiveness of their\ncollective intelligence by supporting \u201cthe combination of\nprecise formal deductions and the more informal loose interaction seen\nin mathematical practice\u201d (Martin & Pease 2013, in Other\nInternet Resources). \n\nDue to real pressing needs from industry, some applications of\nautomated reasoning in pure and applied mathematics are more of\nnecessity than choice. After having worked on the formalization of\nsome elementary real analysis to verify hardware-based floating point\ntrigonometric functions, (Harrison 2006, Harrison 2000) mentions the\nfurther need to formalize more pure mathematics\u2014italics\nare his\u2014to extend his formalization to power series for\ntrigonometric functions and basic theorems about Diophantine\napproximations. Harrison finds it surprising that \u201csuch\nextensive mathematical developments are used simply to verify that a\nfloating point tangent function satisfies a certain error bound\u201d\nand, from this remark, one would expect there are other industrial\napplications that will demand more extensive formalizations.\n\nAlbeit not at the rate originally anticipated, automated reasoning is\nfinding applications in mathematics. Of these, formal verification of\nproofs is of special significance since it not only provides a viable\nmechanism to check proofs that humans alone could not but it also has,\nas a side effect, the potential to redefine what it would take for a\nproof to be accepted as such. As the use of automated reasoning\nassistants becomes more widespread one can envision their use\nfollowing a certain methodical order: First, automated reasoning tools\nare used for theory exploration and discovery. Then, having identified\nsome target problem, the practitioner works interactively with an\nautomated assistant to find proofs and establish facts. Finally, an\nautomated proof checker is used to check the correctness of all final\nproofs prior to being submitted for publication and being made\navailable to the rest of the mathematical community via the creation\nof new entries in a repository of formalized mathematics. It is indeed\na matter of time before the application of automated proof assistants\nbecomes an everyday affair in the life of the mathematician; it is the\ngrand challenge of the automated reasoning community to make it happen\nsooner than later.\n4.8 Artificial Intelligence\n\nSince its inception, the field of automated theorem proving has had\nimportant applications in the larger field of artificial intelligence\n(AI). Automated deduction is at the heart of AI applications like\nlogic programming (see section 4.1 Logic Programming, in this\narticle) where computation is equated with deduction; robotics and\nproblem solving (Green 1969) where the steps to achieve goals are\nsteps extracted from proofs; deductive databases (Minker et\nal. 2014) where factual knowledge is expressed as atomic clauses\nand inference rules, and new facts are inferred by deduction; expert\nsystems (Giarratano & Riley 2004) where human expertise in a given\ndomain (e.g. blood infections) is captured as a collection of IF-THEN\ndeduction rules and where conclusions (e.g. diagnoses) are obtained by\nthe application of the inference rules; and many others. An\napplication of automated reasoning in AI which is bound to have deep\nphilosophical implications is the increased use of BDI computational\nlogics for describing the beliefs, desires, and intentions of\nintelligent agents and multi-agent systems (Meyer 2014) and, in\nparticular, endowing future intelligent systems, such as\ndecision-support systems or robots, with legal and ethical behaviour.\nDeontic logic can be automated for the task (Furbach et al.\n2014) but given that there is no agreement on a universal system of\ndeontic logic, ethics \u201ccode designers\u201d need a way to\nexperiment with the different deontic systems (i.e., to lay out axioms\nand see what conclusions follow from them) to help them identify the\ndesired ethic code for the specific application at hand;\n(Benzm\u00fcller et al. 2018) discusses an environment for this. If\nactual, physical, robots were to be used in these experiments, the\nterm \u201cdeontic laboratory\u201d would be quite descriptive\nalbeit somewhat eerie.\n\nRestricting the proof search space has always been a key consideration\nin the implementation of automated deduction, and traditional\nAI-approaches to search have been an integral part of theorem provers.\nThe main idea is to prevent the prover from pursuing unfruitful\nreasoning paths. A dual aspect of search is to try to look for a\npreviously proved result that could be useful in the completion of the\ncurrent proof. Automatically identifying those results is no easy task\nand it becomes less easy as the size of the problem domain, and the\nnumber of already established results, grows. This is not a happy\nsituation particularly in light of the growing trend to build large\nlibraries of theorems such as the Mizar Problems for Theorem Proving\n(MPTP) (Urban et al. 2010, Bancerek & Rudnicki 2003) or the\nIsabelle/HOL mathematical library (Meng & Paulson 2008), so\ndeveloping techniques for the discovery, evaluation, and selection of\nexisting suitable definitions, premises and lemmas in large libraries\nof formal mathematics as discussed in (K\u00fchlwein et al.\n2012) is an important line of research. \n\nAmong many other methods, and in stark contrast to automated provers,\nmathematicians combine induction heuristics with deductive techniques\nwhen attacking a problem. The former helps them guide the\nproof-finding effort while the latter allows them to close proof gaps.\nAnd of course all this happens in the presence of the very large body\nof knowledge that the human possesses. For an automated prover, the\nanalogous counterpart to the mathematician\u2019s body of knowledge is a\nlarge library like MPTP. An analogous approach to using inductive\nheuristics would be to endow the theorem prover with inductive,\ndata-driven, machine learning abilities. Urban & Vyskocil 2012\nrun a number of experiments to determine any gains that may result\nfrom such an approach. For this, they use MPTP and theorem provers\nlike E and SPASS enhanced with symbol-based machine learning\nmechanisms. A detailed presentation and statistical results can be\nfound in the above reference but in summary, and quoting the authors,\n\u201cthis experiment demonstrates a very real and quite unique\nbenefit of large formal mathematical libraries for conducting novel\nintegration of AI methods. As the machine learner is trained on\nprevious proofs, it recommends relevant premises from the large\nlibrary that (according to the past experience) should be useful for\nproving new conjectures.\u201d Urban 2007 discusses MaLARea (a\nMachine Learner for Automated Reasoning), a meta-system that also\ncombines inductive and deductive reasoning methods. MaLARea is\nintended to be used in large theories, i.e. problems with a large\nnumber of symbols, definitions, premises, lemmas, and theorems. The\nsystem works in cycles where results proved deductively in a given\niteration are then used by the inductive machine-learning component to\nplace restrictions in the search space for the next theorem-proving\ncycle. Albeit simple in design, the first version of MaLARea solved\n142 problems out of 252 in the MPTP Challenge, outperforming the more\nseasoned provers E (89 problems solved) and SPASS (81 problems\nsolved).\n\nBesides using large mathematical libraries, tapping into web-based\nsemantic ontologies is another possible source of knowledge. Pease\n& Sutcliffe 2007 discuss ways for making the SUMO ontology\nsuitable for first-order theorem proving, and describes work on\ntranslating SUMO into TPTP. An added benefit of successfully reasoning\nover large semantic ontologies is that this promotes the application\nof automated reasoning into other fields of science. Tapping into its\nfull potential, however, will require a closer alignment of methods\nfrom automated reasoning and artificial intelligence.\n5. Conclusion\n\nAutomated reasoning is a growing field that provides a healthy\ninterplay between basic research and application. Automated deduction\nis being conducted using a multiplicity of theorem-proving methods,\nincluding resolution, sequent calculi, natural deduction, matrix\nconnection methods, term rewriting, mathematical induction, and\nothers. These methods are implemented using a variety of logic\nformalisms such as first-order logic, type theory and higher-order\nlogic, clause and Horn logic, non-classical logics, and so on.\nAutomated reasoning programs are being applied to solve a growing\nnumber of problems in formal logic, mathematics and computer science,\nlogic programming, software and hardware verification, circuit design,\nexact philosophy, and many others. One of the results of this variety\nof formalisms and automated deduction methods has been the\nproliferation of a large number of theorem proving programs. To test\nthe capabilities of these different programs, selections of problems\nhave been proposed against which their performance can be measured\n(McCharen, Overbeek & Wos 1976, Pelletier 1986). The TPTP\n(Sutcliffe & Suttner 1998) is a library of such problems that is\nupdated on a regular basis. There is also a competition among\nautomated theorem provers held regularly at the CADE conference\n(Pelletier, Sutcliffe & Suttner 2002; Sutcliffe 2016, in Other\nInternet Resources); the problems for the competition are selected\nfrom the TPTP library. There is a similar library and competition for\nSMT solvers (Barret et al. 2013).\n\nInitially, computers were used to aid scientists with their complex\nand often tedious numerical calculations. The power of the machines\nwas then extended from the numeric into the symbolic domain where\ninfinite-precision computations performed by computer algebra programs\nhave become an everyday affair. The goal of automated reasoning has\nbeen to further extend the machine\u2019s reach into the realm of deduction\nwhere they can be used as reasoning assistants in helping their users\nestablish truth through proof.\n", "bibliography": {"categories": [], "cat_ref_text": {"ref_list": ["Alama, J., P. Oppenheimer, and E. Zalta, \u201cAutomating\nLeibniz\u2019s Theory of Concepts\u201d, <em>CADE 25:\nProceedings of the 25th International Conference on Automated\nDeduction</em>, (Lecture Notes in Artificial Intelligence: Volume\n9195), A. Felty and A. Middeldorp (eds.), Berlin: Springer, pp. 73\u201397.", "Anderson, C. A., 1990, \u201cSome Emendations of G\u00f6del\u2019s\nOntological Proof\u201d, <em>Faith and Philosophy</em>, 7(3):\n291\u2013303.", "Anderson, A. R. and N. D. Belnap, 1962, \u201cThe Pure Calculus\nof Entailment\u201d, <em>Journal of Symbolic Logic</em>, 27:\n19\u201352.", "Andrews, P. B., 1981, \u201cTheorem-Proving via General\nMatings\u201d, <em>Journal of the Association for Computing\nMachinery</em>, 28 (2): 193\u2013214.", "Andrews, P. B., M. Bishop and C. E. Brown, 2006, \u201cTPS: A Hybrid\nAutomatic-Interactive System for Developing Proofs\u201d, <em>Journal\nof Applied Logic</em>, 4: 367\u2013395. ", "Andrews, P. B., M. Bishop, S. Issar, D. Nesmith, F. Pfenning and\nH. Xi, 1996, \u201cTPS: A Theorem-Proving System for Classical Type\nTheory\u201d, <em>Journal of Automated Reasoning</em>, 16 (3):\n321\u2013353.", "Appel, K., and W. Haken, 1977, \u201cEvery Planar Map is Four\nColorable Part I. Discharging\u201d, <em>Illinois Journal of\nMathematics</em>, 21: 429\u2013490.", "Avigad, J. and J. Harrison, 2014, \u201cFormally Verified\nMathematics\u201d, <em>Communications of the ACM</em>, 57 (4):\n66\u201375.", "Baader, F. and T. Nipkow, 1998, <em>Term Rewriting and All\nThat</em>, Cambridge: Cambridge University Press.", "Bachmair, L. and H. Ganzinger, 1994, \u201cRewrite-Based\nEquational Theorem Proving with Selection and Simplification\u201d,\n<em>Journal of Logic and Computation</em>, 4 (3): 217\u2013247.", "Ballarin, C., 2014, \u201cLocales: A Module System for\nMathematical Theories\u201d, <em>Journal of Automated Reasoning</em>,\n52 (2): 123\u2013153.", "Bancerek, G. and P. Rudnicki, 2003, \u201cInformation Retrieval\nin MML\u201d, <em>Proceedings of the Second International Conference\non Mathematical Knowledge Management</em>, LNCS 2594, Heidelberg:\nSpringer-Verlag, pp. 119-132 ", "Bancerek, G., C. Byli\u0144ski, A. Grabowski, A. Korni\u0142owicz,\nR. Matuszewski, A. Naumowicz and K. P\u0105k, 2018, \u201cThe Role of\nthe Mizar Mathematical Library for Interactive Proof Development in\nMizar\u201d, <em>Journal of Automated Reasoning (Special Issue:\nMilestones in Interactive Theorem Proving)</em>, 61 (9):\n9\u201331.", "Barret C., M. Deters, L. de Moura, A. Oliveras and A. Stump, 2013,\n\u201c6 Years of SMT-COMP\u201d, <em>Journal of Automated\nReasoning</em>, 50 (3): 243\u2013277.", "Basin, D. A. and T. Walsh, 1996, \u201cA Calculus for and\nTermination of Rippling\u201d, <em>Journal of Automated\nReasoning</em>, 16 (1\u20132): 147\u2013180.", "Bauer, A., E. Clarke and X. Zhao, 1998, \u201cAnalytica: An\nExperiment in Combining Theorem Proving and Symbolic\nComputation\u201d, <em>Journal of Automated Reasoning</em>, 21:\n295\u2013325.", "Beckert, B., R. Hanle and P.H. Schmitt (eds.), 2007,\n\u201cVerification of Object-Oriented Software: The KeY\nApproach\u201d, <em>Lecture Notes in Artificial Intelligence</em>\n(Volume 4334), Berlin: Springer-Verlag.", "Benzm\u00fcller, C. and B. W. Paleo, 2014, \u201cAutomating\nG\u00f6del\u2019s Ontological Proof of God\u2019s Existence with Higher-Order\nAutomated Theorem Provers\u201d, <em>ECAI 2014: Proceedings of the\n21st European Conference on Artificial Intelligence</em>, T. Schaub <em>et\nal</em>. (eds.), IOS Press, pp. 93\u201398.", "\u2013\u2013\u2013, 2015, \u201cHigher-Order\nModal Logics: Automation and Applications\u201d, <em>Reasoning Web\n2015</em>, LNCS 9203, W. Faber and A. Paschke (eds.), pp.\n32\u201374.", "Benzm\u00fcller C., X. Parent and L. van der Torre, 2018, \u201cA\nDeontic Logic Reasoning Infrastructure\u201d, <em>CiE2018:\nProceedings of the 14th Conference on Computability in Europe</em>,\nLNCS 10936, F. Manea <em>et al</em>. (eds.), pp. 60\u201369.", "Benzm\u00fcller C. and L. C. Paulson, 2013, \u201cQuantified\nMultimodal Logics in Simple Type Theory\u201d, <em>Logica\nUniversalis</em>, 7 (1): 7\u201320.", "Benzm\u00fcller, C., N. Sultana, L. C. Paulson and F. Thei\u00df,\n2015, \u201cThe Higher-Order Prover LEO-II\u201d, <em>Journal of\nAutomated Reasoning</em>, 55 (4): 389\u2013404.", "Berndt, B., 1985, <em>Ramanujan\u2019s Notebooks</em> (Part I), Berlin:\nSpringer-Verlag, pp. 25-43.", "Bibel, W., 1981, \u201cOn Matrices with Connections\u201d,\n<em>Journal of the Association of Computing Machinery</em>, 28 (4):\n633\u2013645.", "Blanchette, J. C., S. B\u00f6hme and L. C. Paulson, 2013,\n\u201cExtending Sledgehammer with SMT Solvers\u201d, <em>Journal of\nAutomated Reasoning</em>, 51 (1): 109\u2013128.", "Blanchette, J. C. and T. Nipkow, 2010, \u201cNitpick: A\nCounterexample Generator for Higher-Order Logic Based on a Relational\nModel Finder\u201d, <em>ITP2010: First International Conference on\nInteractive Theorem Proving</em>, LNCS 6172, M. Kaufmann and L. C.\nPaulson (eds.), pp. 131\u2013146.", "Bledsoe, W. W., 1977, \u201cNon-resolution Theorem\nProving\u201d, <em>Artificial Intelligence</em>, 9: 1\u201335.", "Bledsoe, W. W. and M. Tyson, 1975, \u201cThe UT Interactive\nProver\u201d, <em>Memo ATP-17A</em>, Department of Mathematics,\nUniversity of Texas.", "Bofill, M., R. Nieuwenhuis, A. Oliveras, E. Rodriguez-Carbonell\nand A. Rubio, 2008, \u201cA Write-Based Solver for SAT Modulo the\nTheory of Arrays\u201d, <em>Formal Methods in Computer-Aided Design\n(FMCAD\u201908)</em>, pp. 1\u20138.", "Bonacina, M. P., 1999, \u201cA Taxonomy of Theorem-Proving\nStrategies\u201d, <em>Artificial Intelligence Today</em>, (Lecture\nNotes in Computer Science: Volume 1600), Berlin: Springer-Verlag, pp.\n43\u201384.", "Boyer R., <em>et al</em>., 1994, \u201cThe QED Manifesto\u201d,\n<em>CADE-12: Proceedings of the 12th International Conference on\nAutomated Deduction</em>, (Lecture Notes in Artificial Intelligence:\nVolume 814), A. Bundy (ed.), Berlin: Springer-Verlag, pp.\n238\u2013251.", "Boyer, R. S., M. Kaufmann and J. S. Moore, 1995, \u201cThe\nBoyer-Moore Theorem Prover and its Interactive Enhancement\u201d,\n<em>Computers and Mathematics with Applications</em>, 29:\n27\u201362.", "Boyer, R.S. and J. S. Moore, 1979, <em>A Computational Logic</em>,\nNew York: Academic Press.", "Brown, C. E., 2012, \u201cSatallax: An Automatic Higher-Order\nProver\u201d, <em>Automated Reasoning: Proceedings of the 6th\nInternational Joint Conference on Automated Reasoning (IJCAR\n2012)</em>, LNAI 7364, B. Gramlich <em>et al</em>. (eds.), pp. 111\u2013117,\nSpringer-Verlag.", "\u2013\u2013\u2013, 2013, \u201cReducing Higher-Order Theorem Proving\nto a Sequence of SAT Problems\u201d, <em>Journal of Automated\nReasoning</em>, 51 (1): 57\u201377.", "Bundy, A., 2011, \u201cAutomated theorem proving: a practical\ntool for the working mathematician?\u201d, <em>Annals of Mathematics\nand Artificial Intelligence</em>, 61 (1): 3\u201314.", "Bundy, A., F. van Harmelen, J. Hesketh and A. Smaill, 1991,\n\u201cExperiments with Proof Plans for Induction\u201d, <em>Journal\nof Automated Reasoning</em>, 7 (3): 303\u2013324.", "Bundy, A., A. Stevens, F. van Harmelen, A. Ireland and A. Smaill,\n1993, \u201cRippling: A Heuristic for Guiding Inductive\nProofs\u201d, <em>Artificial Intelligence</em>, 62:\n185\u2013253.", "Church, A., 1936a, \u201cAn unsolvable problem of elementary\nnumber theory\u201d, <em>American Journal of Mathematics</em>, 58\n(2): 345\u2013363.", "\u2013\u2013\u2013, 1936b, \u201cA note on the\nEntscheidungsproblem\u201d, <em>Journal of Symbolic Logic</em>, 1\n(1): 40\u201341.", "\u2013\u2013\u2013, 1940, \u201cA Formulation of the Simple Theory of\nTypes\u201d, <em>Journal of Symbolic Logic</em>, 5: 56\u201368.", "Chang, C. L. and R. C. T. Lee, 1973, <em>Symbolic Logic and\nMechanical Theorem Proving</em>, New York: Academic Press.", "Chou, S., 1987, <em>Mechanical Geometry Theorem Proving</em>,\nDordrecht: Kluwer Academic Publishers.", "Claessen, K. and N. S\u00f6rensson, 2003, \u201cNew Techniques\nthat Improve MACE-style Finite Model Finding\u201d, <em>Proceedings\nof the CADE-19 Workshop: Model Computation \u2013 Principles,\nAlgorithms, Applications</em>, P. Baumgartner and C. Fermueller\n(eds.)", "Clarke, E. and X. Zhao, 1994, \u201cCombining Symbolic\nComputation and Theorem Proving: Some Problems of Ramanujan\u201d,\n<em>CADE-12: Proceedings of the 12th International Conference on\nAutomated Deduction</em>, (Lecture Notes in Artificial Intelligence:\nVolume 814), A. Bundy (ed.), Berlin: Springer-Verlag, pp.\n758-763.", "Clocksin, W. F. and C. S. Mellish, 1981, <em>Programming in\nProlog</em>, Berlin: Springer-Verlag.", "Colmerauer, A., H. Kanoui, R. Pasero and P. Roussel, 1973, <em>Un\nSyst\u00e8me de Communication Homme-machine en Fran\u00e7ais</em>,\nRapport, Groupe Intelligence Artificielle, Universit\u00e9 d\u2019Aix\nMarseille.", "Constable, R. L., S. F. Allen, H. M. Bromley, W.R. Cleaveland, J.\nF. Cremer, R. W. Harper, D. J. Howe, T. B. Knoblock, N. P. Mendler, P.\nPanangaden, J. T. Sasaki and S. F. Smith, 1986, <em>Implementing\nMathematics with the Nuprl Proof Development System</em>, Englewood\nCliffs, NJ: Prentice Hall.", "Cook, S. A., 1971, \u201cThe complexity of Theorem-Proving\nProcedures\u201d, <em>Proceedings of the 3rd Annual ACM Symposium on\nTheory of Computing</em>, New York: Association for Computing\nMachinery, pp. 151\u2013158.", "Coquand, T. and G. Huet, 1988, \u201cThe Calculus of\nConstructions\u201d, <em>Information and Computation - Semantics of\nData Types</em>, A. R. Meyer (ed.), 76 (2\u20133): 95\u2013120.", "Coquand, T. and C. Paulin-Mohring, 1988, \u201cInductively\nDefined Types\u201d, <em>COLOG88: Proceedings of the International\nConference on Computer Logic</em>, P. Martin-L\u00f6f and G. Mints\n(eds.), LNCS 417, pp. 50\u201366.", "Davis, M., G. Logemann and D. Loveland, 1962, \u201cA Machine\nProgram for Theorem-Proving\u201d, <em>Communications of the\nAssociation for Computing Machinery</em>, 5 (7): 394\u2013397.", "Davis, M. and H. Putnam, 1960, \u201cA Computing Procedure for\nQuantification Theory\u201d, <em>Journal of the Association for\nComputing Machinery</em>, 7 (3): 201\u2013215.", "de Bruijn, N. G., 1968, \u201cAutomath, a Language for\nMathematics\u201d, in <em>Automation of Reasoning (Volume 2)</em>, J.\nSiekmann and G. Wrighston (eds.), Berlin: Springer-Verlag, 1983, pp.\n159\u2013200.", "de Moura, L., 2007, \u201cDeveloping Efficient SMT\nSolvers\u201d, <em>Proceedings of the CADE-21 Workshop on Empirically\nSuccessful Automated Reasoning in Large Theories</em>, G. Sutcliffe,\nJ. Urban and S. Schulz (eds.), Bremen.", "Denney, E., B. Fischer and J. Schumann, 2004, \u201cUsing\nAutomated Theorem Provers to Certify Auto-generated Aerospace\nSoftware\u201d, <em>Automated Reasoning, Second International Joint\nConference (IJCAR)</em> (Lecture Notes in Artificial Intelligence:\nVolume 3097), D. Basin and M. Rusinowitch (eds.), Berlin:\nSpringer-Verlag, pp. 198-212.", "Denney, E., J. Power and K. Tourlas, 2006, \u201cHiproofs: A\nHierarchical Notion of Proof Tree\u201d, <em>Proceedings of the 21st\nAnnual Conference on Mathematical Foundations of Programming Semantics\n(MFPS XXI)</em> (Electronic Notes in Theoretical Computer Science,\nVol. 155), pp. 341\u2013359.", "Ernst, Z., B. Fitelson, K. Harris and L. Wos, 2002,\n\u201cShortest Axiomatizations of Implicational S4 and S5\u201d,\n<em>Notre Dame Journal of Formal Logic</em>, 43 (3):\n169\u2013179.", "Farmer, W. M., J. D. Guttman and F. J. Thayer, 1993, \u201cIMPS:\nAn Interactive Mathematical Proof System\u201d, <em>Journal of\nAutomated Reasoning</em>, 11 (2): 213\u2013248.", "Fitelson B. and E. Zalta, 2007, \u201cSteps Toward a\nComputational Metaphysics\u201d, <em>Journal of Philosophical\nLogic</em>, 36 (2): 227\u2013247.", "Fitting, M., 1990, <em>First-Order Logic and Automated Theorem\nProving</em>, Berlin: Springer-Verlag.", "\u2013\u2013\u2013, 2002, <em>Types, Tableaus and G\u00f6del\u2019s God</em>.\nKluwer.", "Fuenmayor, D. and C. Benzm\u00fcller, 2017, \u201cAutomating\nEmendations of the Ontological Argument in Intensional Higher-Order\nModal Logic\u201d, <em>KI 2017: Advances in Artificial Intelligence -\nProceedings of the 40th Annual German Conference on AI</em>, LNCS\n10505, G. Kern-Isberner <em>et al</em>. (eds.), pp. 114-127.", "Furbach , U., 1994, \u201cTheory Reasoning in First Order\nCalculi\u201d, <em>Management and Processing of Complex Data\nStructures</em>, (Lecture Notes in Computer Science Volume 777), pp.\n139\u2013156.", "Furbach, U., C. Schon and F. Stolzenburg, 2014, \u201cAutomated\nReasoning in Deontic Logic\u201d, <em>MIWAI2014: Proceedings of the\n8th Multi-disciplinary International Workshop on Artificial\nIntelligence</em>, LNAI 8875, M. N. Murty <em>et al</em>. (eds.), pp.\n57\u201368.", "Ganzinger, H., G. Hagen, R. Nieuwenhuis, A. Oliveras, C. Tinelli,\n2004, \u201cDPLL(T): Fast Decision Procedures\u201d, <em>Computer\nAided Verification</em>, (Lecture Notes in Computer Science: Volume\n3114), pp. 175\u2013188.", "Gentzen, G., 1935, \u201cInvestigations into Logical\nDeduction\u201d, in Szabo 1969, pp. 68\u2013131.", "Giarratano, J. and G. Riley, 2004, <em>Expert Systems: Principles\nand Programming</em>, 4th edition, Boston, MA: PWS Publishing Co.", "G\u00f6del, K., 1970, \u201cAppendix A: Notes in Kurt\nG\u00f6del\u2019s Hand\u201c, in Sobel 2004, pp. 144\u2013145.", "Gordon, M. J. C. and T. F. Melham, eds., 1993, <em>Introduction to\nHOL: A Theorem Proving Environment for Higher Order Logic</em>,\nCambridge: Cambridge University Press.", "Gordon, M. J. C., A. J. Milner and C. P. Wadsworth, 1979,\n<em>Edinburgh LCF: A Mechanised Logic of Computation</em> (LNCS 78),\nBerlin: Springer-Verlag.", "Gorenstein, D., 1982, <em>Finite Simple Groups: An Introduction to\ntheir Classification</em> (University Series in Mathematics), New\nYork: Plenum Press.", "Green, C., 1969, \u201cApplication of Theorem Proving to Problem\nSolving\u201d, <em>IJCAI\u201969 Proceedings of the 1st international\njoint conference on Artificial intelligence</em>, San Francisco:\nMorgan Kaufmann, pp. 219\u2013239", "Haack, S., 1978, <em>Philosophy of Logics</em>, Cambridge:\nCambridge University Press.", "Hales, T. C., 2005a, \u201cA proof of the Kepler\nConjecture\u201d, <em>Annals of Mathematics</em>, 162 (3):\n1065\u20131185.", "\u2013\u2013\u2013, 2006, \u201cIntroduction to the Flyspeck\nProject\u201d, <em>Dagstuhl Seminar Proceedings 05021: Mathematics,\nAlgorithms, Proofs</em>, T. Coquand <em>et al</em>. (eds.)", "Hales, T. C. <em>et al</em>., 2015, \u201cA Formal Proof of the\nKepler Conjecture\u201d, <em>arXiv:1501.02.02155 9 [mat.MG]</em>,\nCornell University Library.", "Harrison, J., 2000, \u201cHigh-Level Verification Using Theorem\nProving and Formalized Mathematics\u201d, <em>CADE-17: Proceedings of\nthe 17th International Conference on Automated Deduction</em>,\n(Lecture Notes in Artificial Intelligence: Volume 1831), D. McAllester\n(ed.), Berlin: Springer-Verlag, pp. 1-6.", "\u2013\u2013\u2013, 2006, \u201cVerification: Industrial\nApplications\u201d, <em>Proof Technology and Computation</em>, H.\nSchwichtenberg and K. Spies (eds.), Amsterdam: IOS Press, pp.\n161\u2013205.", "\u2013\u2013\u2013, 2009, \u201cFormalizing an Analytic Proof of the\nPrime Number Theorem\u201d, <em>Journal of Automated Reasoning\n(Special Issue: A Festschrift for Michael J. C. Gordon)</em>, 43 (3):\n243\u2013261.", "Harrison, J. and L. Th\u00e9ry, 1998, \u201cA Skeptic\u2019s\nApproach to Combining HOL and Maple\u201d, <em>Journal of Automated\nReasoning</em>, 21: 279\u2013294.", "Herbrand, J., 1930, <em>Recherches sur la Theorie de la\nDemonstration</em>, Travaux de la Societ\u00e9 des Sciences at des\nLettres de Varsovie, Classe III, Science Math\u00e9matique et\nPhysique, No. 33, 128.", "Heule, M. J. H. and O. Kullmann, 2017, \u201cThe Science of Brute\nForce\u201d, <em>Communications of the ACM</em>, 60 (8):\n70\u201379.", "Heule, M. J. H., O. Kullmann and V. W. Marek, 2016, \u201cSolving\nand Verifying the Boolean Pythagorean Triples problem via\nCube-and-Conquer\u201d, <em>Theory and Applications of Satisfiability\nTesting \u2014 SAT 2016, 19th International Conference</em>, LNCS\n9710, N. Creignou and D. Le Berre (eds.), pp. 228\u2013245.", "Hilbert, D. and W. Ackermann, 1928, <em>Principles of Mathematical\nLogic</em>, L. Hammond, G. Leckie, and F. Steinhardt (trans.), New\nYork: Chelsea Publishing Co., 1950.", "Huet, G. P., 1975, \u201cA Unification Algorithm for Typed\n\u03bb-calculus\u201d, <em>Theoretical Computer Science</em>, 1:\n27\u201357.", "Kanckos, A., and B. W. Paleo, 2017, \u201cVariants of\nG\u00f6del\u2019s Ontological Proof in a Natural Deduction Calculus\u201d,\n<em>Studia Logica</em>, (3): 553\u2013586.", "Kerber, M., Kohlhase and V. Sorge, 1998, \u201cIntegrating\nComputer Algebra into Proof Planning\u201d, <em>Journal of Automated\nReasoning</em>, 21: 327\u2013355.", "Knuth, D. and P. B. Bendix, 1970, \u201cSimple Word Problems in\nUniversal Algebras\u201d, in <em>Computational Problems in Abstract\nAlgebra</em>, J. Leech (ed.), Oxford, New York: Pergamon Press, pp.\n263\u2013297.", "Kleene, S. C., 1962, <em>Introduction to Metamathematics</em>,\nAmsterdam: North-Holland.", "Kov\u00e1cs, L. and A. Voronkov, 2013, \u201cFirst-Order\nTheorem Proving and VAMPIRE\u201d, <em>CAV 2013: Proceedings of the\nInternational Conference on Computer Aided Verification</em>, N.\nSharygina and H. Veith (eds.), LNCS 8044, pp. 1\u201335.", "Kowalski, R., 1974, \u201cPredicate Logic as a Programming\nLanguage\u201d, <em>Proceedings of the International Federation for\nInformation Processing</em> (Proc. IFIP \u201974), Amsterdam: North\nHolland, pp. 569\u2013574.", "K\u00fcchlin, W. and C. Sinz, 2000, \u201cProving Consistency\nAssertions for Automotive Product Data Management\u201d, <em>Journal\nof Automated Reasoning</em> (Special Issue: Satisfiability in the Year\n2000), I. P. Gent and T. Walsh (eds.), 24 (1\u20132):\n145\u2013163.", "K\u00fchlwein, D., T. van Laarhoven, E. Tsivtsivadze, J. Urban and\nT. Heskes, 2012, \u201cOverview and Evaluation of Premise Selection\nTechniques for Large Theory Mathematics\u201d, <em>Automated\nReasoning: 6th International Joint Conference, IJCAR 2012</em>,\n(Lecture Notes in Computer Science: Volume 7364), B. Gramlich, D.\nMiller and U. Sattler (eds.), Manchester, UK: Springer-Verlag, pp.\n378\u2013392.", "Lemmon, E. J., C. A. Meredith, D. Meredith, A. N. Prioir and I.\nThomas, 1957, <em>Calculi of Pure Strict Implication</em>, Philosophy\nDept., Canterbury University, Christchurch, New Zealand.", "Lloyd, J. W., 1984, <em>Foundations of Logic Programming</em>,\nBerlin: Springer-Verlag.", "Loveland, D. W., 1969, \u201cA Simplified Format for the Model\nElimination Procedure\u201d, <em>Journal of the Association for\nComputing Machinery</em>, 16: 349\u2013363.", "\u2013\u2013\u2013, 1970, \u201cA Linear Format for\nResolution\u201d, <em>Proceedings of the IRIA Symposium on Automatic\nDemonstration</em>, New York: Springer-Verlag, pp. 147-162.", "\u2013\u2013\u2013, 1978, <em>Automated Theorem Proving: A Logical\nBasis</em>, Amsterdam: North Holland.", "Luckham, D., 1970, \u201cRefinements in Resolution Theory\u201d,\n<em>Proceedings of the IRIA Symposium on Automatic Demonstration</em>,\nNew York: Springer-Verlag, pp. 163-190.", "Martin-L\u00f6f, P., 1982, \u201cConstructive Mathematics and\nComputer Programming\u201d, <em>Logic, Methodology and Philosophy of\nScience</em> (Volume IV), Amsterdam: North-Holland, pp. 153-175.", "Massacci, F. and L. Marraro, 2000, \u201cLogical Cryptanalysis:\nEncoding and Analysis of the U.S. Data Encryption Standard\u201d,\n<em>Journal of Automated Reasoning</em> (Special Issue: Satisfiability\nin the Year 2000), I. P. Gent and T. Walsh (eds.), 24 (1\u20132):\n165\u2013203.", "McCarthy, J., 1962, \u201cTowards a Mathematical Science of\nComputation\u201d, <em>International Federation for Information\nProcessing Congress</em> (Munich, 1962), Amsterdam: North Holland, pp.\n21\u201328.", "McCharen, J. D., R. A. Overbeek and L. A. Wos, 1976,\n\u201cProblems and Experiments for and with Automated Theorem-Proving\nPrograms\u201d, <em>IEEE Transactions on Computers</em> 8:\n773\u2013782.", "McCune, W., 1997, \u201cSolution of the Robbins Problem\u201d,\n<em>Journal of Automated Reasoning</em>, 19 (3): 263\u2013276.", "\u2013\u2013\u2013, 2001, <em>MACE 2.0 Reference Manual and Guide</em>,\nMathematics and Computer Science Division, ANL/MSC-TM-249, Argonne\nNational Laboratory.", "McRobie, M. A., 1991, \u201cAutomated Reasoning and Nonclassical\nLogics: Introduction\u201d, <em>Journal of Automated Reasoning</em>,\n7 (4): 447\u2013451.", "Meng, J. and L. C. Paulson, 2008, \u201cTranslating higher-order\nclauses to first-order clauses\u201d, <em>Journal of Automated\nReasoning</em>, 40 (1): 35\u201360.", "Meredith, C. A. and A. N. Prior, 1964, \u201cInvestigations into\nImplicational S5\u201d, <em>Z. Math. Logik Grundlagen Math.</em>,\n10:203\u2013220.", "Meyer, J.-J. Ch., 2014, \u201cLogics for Intelligent Agents and\nMulti-Agent Systems\u201d, <em>Handbook of the History of Logic,\nVolume 9: Computational Logic</em>, J. Siekmann (ed.), pp.\n629\u2013658, Elsevier.", "Miller, D. and G. Nadathur, 1988, \u201cAn Overview of\n\u03bbProlog\u201d, <em>Proceedings of the Fifth International\nLogic Programming Conference \u2014 Fifth Symposium in Logic\nProgramming</em>, R. Bowen and R. Kowalski (eds.), Cambridge, MA: MIT\nPress.", "Minker, J., D. Seipel and C. Zaniolo, 2014, \u201cLogic and\nDatabases: A History of Deductive Databases\u201d, <em>Handbook of\nthe History of Logic, Volume 9: Computational Logic</em>, J. Siekmann\n(ed.), pp. 571\u2013627, Elsevier.", "Muzalewski, M., 1993, <em>An Outline of PC Mizar</em>, Fondation\nPhilippe le Hodey, Brussels.", "Nipkow, T., L. C. Paulson and M. Wenzel, 2002,\n\u201cIsabelle/HOL: A Proof Assistant for Higher-Order Logic\u201c,\nLNCS Vol. 2283, pp. 207\u2013208.", "Nivens, A. J., 1974, \u201cA Human-Oriented Logic for Automatic\nTheorem Proving\u201d, <em>Journal of the Association of Computing\nMachinery</em>, 21 (4): 606\u2013621.", "Oppenheimer, P. and E. Zalta, 2011, \u201cA\nComputationally-Discovered Simplification of the Ontological\nArgument\u201d, <em>Australasian Journal of Philosophy</em>, 89 (2):\n333\u2013349.", "Paulson, L. C., 1990, \u201cIsabelle: The Next 700 Theorem\nProvers\u201d, <em>Logic and Computer Science</em>, P. Odifreddi\n(ed.), Academic Press, pp. 361\u2013386.", "\u2013\u2013\u2013, 1994, <em>Isabelle: A Generic Theorem Prover</em>\n(Lecture Notes in Computer Science: Volume 828), Berlin:\nSpringer-Verlag.", "\u2013\u2013\u2013, 2010. \u201cThree Years of Experience with\nSledgehammer, a Practical Link Between Automatic and Interactive\nTheorem Provers\u201d, <em>PAAR-2010</em>, B. Konev <em>et al</em>. (eds.),\npp. 1\u201310.", "Paulson, L. C. and K. Grabczewski, 1996, \u201cMechanizing Set\nTheory\u201d, <em>Journal of Automated Reasoning</em>, 17 (3):\n291\u2013323.", "Pease, A. and G. Sutcliffe, 2007, \u201cFirst Order Reasoning on\na Large Ontology\u201d, <em>Proceedings of the CADE-21 Workshop on\nEmpirically Successful Automated Reasoning in Large Theories</em>\n(Volume 257), G. Sutcliffe and J. Urban (eds.), Bremen.", "Pelletier, F. J., 1986, \u201cSeventy-Five Problems for Testing\nAutomatic Theorem Provers\u201d, <em>Journal of Automated\nReasoning</em>, 2 (2): 191\u2013216.", "\u2013\u2013\u2013, 1998, \u201cNatural Deduction Theorem Proving\nin THINKER\u201d, <em>Studia Logica</em>, 60 (1): 3\u201343.", "Pelletier, F. J., G. Sutcliffe and A. P. Hazen, 2017,\n\u201cAutomated Reasoning for the Dialetheic Logic RM3\u201d,\n<em>Proceedings of the Thirtieth International Florida Artificial\nIntelligence Research Society Conference</em>, V. Rus and Z. Markov\n(eds.), pp. 110\u2013115.", "Pelletier, F. J., G. Sutcliffe, and C. Suttner, 2002, \u201cThe\nDevelopment of CASC\u201d, <em>AI Communications</em>, 15\n(2\u20133): 79\u201390.", "Peterson, J. G., 1977, <em>The Possible Shortest Single Axiom for\nEC-Tautologies</em>, Report 105, Department of Mathematics, University\nof Auckland.", "Pollock, J., 1989, \u201cOSCAR: A General Theory of\nRationality\u201d, <em>Journal of Experimental &amp; Theoretical\nArtificial Intelligence</em>, 1 (3): 209\u2013226", "\u2013\u2013\u2013, 1995, <em>Cognitive Carpentry</em>, Cambridge, MA:\nBradford/MIT Press.", "\u2013\u2013\u2013, 2006, \u201cAgainst Optimality: Logical Foundations\nfor Decision-Theoretic Planning in Autonomous Agents\u201d,\n<em>Computational Intelligence</em>, 22(1): 1\u201325.", "Portoraro, F. D., 1994, \u201cSymlog: Automated Advice in\nFitch-style Proof Construction\u201d, <em>CADE-12: Proceedings of the\n12th International Conference on Automated Deduction</em>, (Lecture\nNotes in Artificial Intelligence: Volume 814), A. Bundy (ed.), Berlin:\nSpringer-Verlag, pp. 802-806.", "\u2013\u2013\u2013, 1998, \u201cStrategic Construction of\nFitch-style Proofs\u201d, <em>Studia Logica</em>, 60 (1):\n45\u201366.", "Prasad, M., A. Biere and A. Gupta, 2005, \u201cA Survey of Recent\nAdvances in SAT-Based Formal Verification\u201d, <em>International\nJournal on Software Tools for Technology Transfer</em>, 7 (2):\n156\u2013173.", "Prawitz, D., 1965, <em>Natural Deduction: A Proof Theoretical\nStudy</em>, Stockholm: Almqvist &amp; Wiksell.", "Quaife, A., 1992, <em>Automated Development of Fundamental\nMathematical Theories</em>, Kluwer Academic Publishers.", "Robinson, J. A., 1965, \u201cA Machine Oriented Logic Based on\nthe Resolution Principle\u201d, <em>Journal of the Association of\nComputing Machinery</em>, 12: 23\u201341.", "\u2013\u2013\u2013, 1965, \u201cAutomatic Deduction with\nHyper-resolution\u201d, <em>Internat. J. Comput. Math.</em>, 1:\n227\u2013234.", "Robinson, J. A. and A. Voronkov (eds.), 2001, <em>Handbook of\nAutomated Reasoning: Volumes I and II</em>, Cambridge, MA: MIT Press.\n", "Schmitt, P. and I. Tonin, 2007, \u201cVerifying the Mondex Case\nStudy\u201d, <em>Proceedings of the Fifth IEEE International\nConference on Software Engineering and Formal Methods</em>, IEEE\nComputer Society, pp. 47\u201358.", "Schulz, S., 2004, \u201cSystem Abstract: E 0.81\u201d,\n<em>Proceedings of the 2nd International Joint Conference on Automated\nReasoning</em> (Lecture Notes in Artificial Intelligence: Volume\n3097), D. Basin and M. Rusinowitch (eds.), Berlin: Springer-Verlag,\npp.223-228.", "Scott, D., 1972, \u201cAppendix B: Notes in Dana Scott\u2019s\nHand\u201d, in Sobel 2004, pp. 145\u2013146.", "Sieg, W. and J. Byrnes, 1996, <em>Normal Natural Deduction Proofs\n(in Classical Logic)</em>, Report CMU-PHIL 74, Department of\nPhilosophy, Carnegie-Mellon University.", "Slaney, J. K., 1984, \u201c3,088 Varieties: A Solution to the\nAckerman Constant Problem\u201d, <em>Journal of Symbolic Logic</em>,\n50: 487\u2013501.", "Sobel, J. H., 2004, <em>Logic and Theism: Arguments for and\nAgainst Beliefs in God</em>, Cambridge University Press.", "Stickel, M. E., 1992, \u201cA Prolog Technology Theorem Prover: A\nNew Exposition and Implementation in Prolog\u201d, <em>Theoretical\nComputer Science</em>, 104: 109\u2013128.", "Suppes, P., <em>et al</em>., 1981, \u201cPart I: Interactive\nTheorem Proving in CAI Courses\u201d, <em>University-Level\nComputer-Assisted Instruction at Stanford: 1968\u20131980</em>, P.\nSuppes (ed.), Institute for the Mathematical Study of the Social\nSciences, Stanford University.", "Sutcliffe, G. and C. Benzm\u00fcller, 2010, \u201cAutomated\nReasoning in Higher-Order Logic Using TPTP THF Infrastructure\u201d,\n<em>Journal of Formalized Reasoning</em>, 43 (4): 337\u2013362.", "Sutcliffe, G. and C. Suttner, 1998, \u201cThe TPTP Problem\nLibrary \u2013 CNF Release v1.2.1\u201d, <em>Journal of Automated\nReasoning</em>, 21 (2): 177\u2013203.", "Szabo, M. E. (ed.), 1969, <em>The Collected Papers of Gerhard\nGentzen</em>, Amsterdam: North-Holland.", "Trybulec, A., 1978, \u201cThe Mizar Logic Information\nLanguage\u201d, <em>Bulletin of the Association for Literary\nLinguistic Computing</em>, 6(2): 136\u2013140.", "Trybulec, A. and H. Blair, 1985, \u201cComputer Assisted\nReasoning with Mizar\u201d, <em>Proceedings of the 9th International\nJoint Conference on Artificial Intelligence</em>, (IJCAI-85: Volume\n1), Los Angeles, pp. 26\u201328.", "Turing, A., 1936, \u201cOn computable numbers, with an\napplication to the Entscheidungsproblem\u201d, <em>Proceedings of the\nLondon Mathematical Society</em>, 42 (2): 230\u2013265.", "Urban, J., 2007, \u201cMaLARea: A Metasystem for Automated\nReasoning in Large Theories\u201d, <em>Proceedings of the CADE-21\nWorkshop on Empirically Successful Automated Reasoning in Large\nTheories</em>, J. Urban, G. Sutcliffe and S. Schulz (eds.), pp.\n45\u201358.", "Urban, J., K. Hoder, A. Voronkov, 2010, \u201cEvaluation of\nAutomated Theorem Proving on the Mizar Mathematical Library\u201d,\n<em>Mathematical Software \u2013 ICMS 2010: Proceedings of the Third\nInternational Congress on Mathematical Software</em>, Kobe, Japan,\n(Lecture Notes in Computer Science, Volume 6327), pp.\n155\u2013166.", "Urban, J. and J. Vyskocil, 2012, \u201cTheorem Proving in Large\nFormal Mathematics as an Emerging AI Field\u201d, <em>arXiv:1209.3914\n[cs.AI]</em>, Report No. DPA-12271, Cornell University.", "Urquhart, A., 1994 (ed.), <em>The Collected Papers of Bertrand\nRussell, Volume 4: Foundations of Logic, 1903-05</em>, Routledge,\nLondon and New York.", "van Benthem Jutting, L. S., 1977, <em>Checking Landau\u2019s\n\u201cGrundlagen\u201d in the Automath system</em>, Ph.D. Thesis,\nEindhoven University of Technology; published in <em>Mathematical\nCentre Tracts</em>, Number 83, Amsterdam: Mathematisch Centrum,\n1979. ", "Voronkov, A., 1995, \u201cThe Anatomy of Vampire: Implementing\nBottom-Up Procedures with Code Trees\u201d, <em>Journal of Automated\nReasoning</em>, 15 (2): 237\u2013265.", "Wallen, L. A., 1990, <em>Automated Deduction in Nonclassical\nLogics</em>, Cambridge, MA: MIT Press.", "Wang, H., 1960, \u201cProving Theorems by Pattern Recognition\n\u2013 I\u201d, in <em>Automation of Reasoning (Volume 1)</em>, J.\nSiekmann and G. Wrightson (eds.), Berlin: Springer-Verlag, 1983, pp.\n229\u2013243.", "\u2013\u2013\u2013, 1960, \u201cToward Mechanical\nMathematics\u201d, in <em>Automation of Reasoning</em> (Volume 1),\nJ. Siekmann and G.  Wrightson (eds.), Berlin: Springer-Verlag, 1983,\npp. 244-264.", "Wegner, B., 2011, \u201cCompleteness of reference databases,\nold-fashioned or not?\u201d, <em>Newsletter of the European\nMathematical Society</em>, 80: 50\u201352.", "Wiedijk, F., 2006, <em>The Seventeen Provers of the World</em>,\n(Lecture Notes in Artificial Intelligence: Volume 3600), F. Wiedijk\n(ed.), New York: Springer-Verlag.", "\u2013\u2013\u2013, 2007, \u201cThe QED Manifesto\nRevisited\u201d, <em>Studies in Logic, Grammar and Rhetoric</em>, 10\n(23): 121\u2013133.", "Wos, L. (ed.), 2001, <em>Journal of Automated Reasoning</em>\n(Special Issue: Advances in Logic Through Automated Reasoning), 27\n(2).", "Wos, L., D. Carson and G. R. Robinson, 1965, \u201cEfficiency and\nCompleteness of the Set of Support Strategy in Theorem Proving\u201d,\n<em>Journal of the Association of Computing Machinery</em>, 12:\n698\u2013709.", "Wos, L., R. Overbeek, E. Lusk and J. Boyle, 1984, <em>Automated\nReasoning: Introduction and Applications</em>, Englewood Cliffs, NJ:\nPrentice-Hall.", "Wos, L., D. Ulrich, and B. Fitelson, 2002, \u201cVanquishing the\nXCB Question; The Methodological Discovery of the Last Shortest Single\nAxiom for the Equivalential Calculus\u201d, <em>Journal of Automated\nReasoning</em>, 29 (2):107\u2013124.", "Wos, L., S. Winker, R. Veroff, B. Smith and L. Henschen, 1983,\n\u201cQuestions Concerning Possible Shortest Single Axiom for the\nEquivalential Calculus: An Application of Automated Theorem Proving to\nInfinite Domains\u201d, <em>Notre Dame Journal of Formal Logic</em>,\n24: 205\u2013223.", "Yoo, J., E. Jee and S. Cha, 2009, \u201cFormal Modeling and\nVerification of Safety-Critical Software\u201d, <em>IEEE\nSoftware</em>, 26 (3): 42\u201349.", "Zhang, L. and S. Malik, 2002, \u201cThe Quest for Efficient\nBoolean Satisfiability Solvers\u201d, <em>CADE-18: Proceedings of the\n18th International Conference on Automated Deduction</em>, (Lecture\nNotes in Artificial Intelligence: Volume 2392), A. Voronkov (ed.),\nBerlin: Springer-Verlag, pp. 295-313."]}, "raw_text": "<div id=\"bibliography\">\n<h2><a name=\"Bib\">Bibliography</a></h2>\n<ul class=\"hanging\">\n<li>Alama, J., P. Oppenheimer, and E. Zalta, \u201cAutomating\nLeibniz\u2019s Theory of Concepts\u201d, <em>CADE 25:\nProceedings of the 25th International Conference on Automated\nDeduction</em>, (Lecture Notes in Artificial Intelligence: Volume\n9195), A. Felty and A. Middeldorp (eds.), Berlin: Springer, pp. 73\u201397.</li>\n<li>Anderson, C. A., 1990, \u201cSome Emendations of G\u00f6del\u2019s\nOntological Proof\u201d, <em>Faith and Philosophy</em>, 7(3):\n291\u2013303.</li>\n<li>Anderson, A. R. and N. D. Belnap, 1962, \u201cThe Pure Calculus\nof Entailment\u201d, <em>Journal of Symbolic Logic</em>, 27:\n19\u201352.</li>\n<li>Andrews, P. B., 1981, \u201cTheorem-Proving via General\nMatings\u201d, <em>Journal of the Association for Computing\nMachinery</em>, 28 (2): 193\u2013214.</li>\n<li>Andrews, P. B., M. Bishop and C. E. Brown, 2006, \u201cTPS: A Hybrid\nAutomatic-Interactive System for Developing Proofs\u201d, <em>Journal\nof Applied Logic</em>, 4: 367\u2013395. </li>\n<li>Andrews, P. B., M. Bishop, S. Issar, D. Nesmith, F. Pfenning and\nH. Xi, 1996, \u201cTPS: A Theorem-Proving System for Classical Type\nTheory\u201d, <em>Journal of Automated Reasoning</em>, 16 (3):\n321\u2013353.</li>\n<li>Appel, K., and W. Haken, 1977, \u201cEvery Planar Map is Four\nColorable Part I. Discharging\u201d, <em>Illinois Journal of\nMathematics</em>, 21: 429\u2013490.</li>\n<li>Avigad, J. and J. Harrison, 2014, \u201cFormally Verified\nMathematics\u201d, <em>Communications of the ACM</em>, 57 (4):\n66\u201375.</li>\n<li>Baader, F. and T. Nipkow, 1998, <em>Term Rewriting and All\nThat</em>, Cambridge: Cambridge University Press.</li>\n<li>Bachmair, L. and H. Ganzinger, 1994, \u201cRewrite-Based\nEquational Theorem Proving with Selection and Simplification\u201d,\n<em>Journal of Logic and Computation</em>, 4 (3): 217\u2013247.</li>\n<li>Ballarin, C., 2014, \u201cLocales: A Module System for\nMathematical Theories\u201d, <em>Journal of Automated Reasoning</em>,\n52 (2): 123\u2013153.</li>\n<li>Bancerek, G. and P. Rudnicki, 2003, \u201cInformation Retrieval\nin MML\u201d, <em>Proceedings of the Second International Conference\non Mathematical Knowledge Management</em>, LNCS 2594, Heidelberg:\nSpringer-Verlag, pp. 119-132 </li>\n<li>Bancerek, G., C. Byli\u0144ski, A. Grabowski, A. Korni\u0142owicz,\nR. Matuszewski, A. Naumowicz and K. P\u0105k, 2018, \u201cThe Role of\nthe Mizar Mathematical Library for Interactive Proof Development in\nMizar\u201d, <em>Journal of Automated Reasoning (Special Issue:\nMilestones in Interactive Theorem Proving)</em>, 61 (9):\n9\u201331.</li>\n<li>Barret C., M. Deters, L. de Moura, A. Oliveras and A. Stump, 2013,\n\u201c6 Years of SMT-COMP\u201d, <em>Journal of Automated\nReasoning</em>, 50 (3): 243\u2013277.</li>\n<li>Basin, D. A. and T. Walsh, 1996, \u201cA Calculus for and\nTermination of Rippling\u201d, <em>Journal of Automated\nReasoning</em>, 16 (1\u20132): 147\u2013180.</li>\n<li>Bauer, A., E. Clarke and X. Zhao, 1998, \u201cAnalytica: An\nExperiment in Combining Theorem Proving and Symbolic\nComputation\u201d, <em>Journal of Automated Reasoning</em>, 21:\n295\u2013325.</li>\n<li>Beckert, B., R. Hanle and P.H. Schmitt (eds.), 2007,\n\u201cVerification of Object-Oriented Software: The KeY\nApproach\u201d, <em>Lecture Notes in Artificial Intelligence</em>\n(Volume 4334), Berlin: Springer-Verlag.</li>\n<li>Benzm\u00fcller, C. and B. W. Paleo, 2014, \u201cAutomating\nG\u00f6del\u2019s Ontological Proof of God\u2019s Existence with Higher-Order\nAutomated Theorem Provers\u201d, <em>ECAI 2014: Proceedings of the\n21st European Conference on Artificial Intelligence</em>, T. Schaub <em>et\nal</em>. (eds.), IOS Press, pp. 93\u201398.</li>\n<li>\u2013\u2013\u2013, 2015, \u201cHigher-Order\nModal Logics: Automation and Applications\u201d, <em>Reasoning Web\n2015</em>, LNCS 9203, W. Faber and A. Paschke (eds.), pp.\n32\u201374.</li>\n<li>Benzm\u00fcller C., X. Parent and L. van der Torre, 2018, \u201cA\nDeontic Logic Reasoning Infrastructure\u201d, <em>CiE2018:\nProceedings of the 14th Conference on Computability in Europe</em>,\nLNCS 10936, F. Manea <em>et al</em>. (eds.), pp. 60\u201369.</li>\n<li>Benzm\u00fcller C. and L. C. Paulson, 2013, \u201cQuantified\nMultimodal Logics in Simple Type Theory\u201d, <em>Logica\nUniversalis</em>, 7 (1): 7\u201320.</li>\n<li>Benzm\u00fcller, C., N. Sultana, L. C. Paulson and F. Thei\u00df,\n2015, \u201cThe Higher-Order Prover LEO-II\u201d, <em>Journal of\nAutomated Reasoning</em>, 55 (4): 389\u2013404.</li>\n<li>Berndt, B., 1985, <em>Ramanujan\u2019s Notebooks</em> (Part I), Berlin:\nSpringer-Verlag, pp. 25-43.</li>\n<li>Bibel, W., 1981, \u201cOn Matrices with Connections\u201d,\n<em>Journal of the Association of Computing Machinery</em>, 28 (4):\n633\u2013645.</li>\n<li>Blanchette, J. C., S. B\u00f6hme and L. C. Paulson, 2013,\n\u201cExtending Sledgehammer with SMT Solvers\u201d, <em>Journal of\nAutomated Reasoning</em>, 51 (1): 109\u2013128.</li>\n<li>Blanchette, J. C. and T. Nipkow, 2010, \u201cNitpick: A\nCounterexample Generator for Higher-Order Logic Based on a Relational\nModel Finder\u201d, <em>ITP2010: First International Conference on\nInteractive Theorem Proving</em>, LNCS 6172, M. Kaufmann and L. C.\nPaulson (eds.), pp. 131\u2013146.</li>\n<li>Bledsoe, W. W., 1977, \u201cNon-resolution Theorem\nProving\u201d, <em>Artificial Intelligence</em>, 9: 1\u201335.</li>\n<li>Bledsoe, W. W. and M. Tyson, 1975, \u201cThe UT Interactive\nProver\u201d, <em>Memo ATP-17A</em>, Department of Mathematics,\nUniversity of Texas.</li>\n<li>Bofill, M., R. Nieuwenhuis, A. Oliveras, E. Rodriguez-Carbonell\nand A. Rubio, 2008, \u201cA Write-Based Solver for SAT Modulo the\nTheory of Arrays\u201d, <em>Formal Methods in Computer-Aided Design\n(FMCAD\u201908)</em>, pp. 1\u20138.</li>\n<li>Bonacina, M. P., 1999, \u201cA Taxonomy of Theorem-Proving\nStrategies\u201d, <em>Artificial Intelligence Today</em>, (Lecture\nNotes in Computer Science: Volume 1600), Berlin: Springer-Verlag, pp.\n43\u201384.</li>\n<li>Boyer R., <em>et al</em>., 1994, \u201cThe QED Manifesto\u201d,\n<em>CADE-12: Proceedings of the 12th International Conference on\nAutomated Deduction</em>, (Lecture Notes in Artificial Intelligence:\nVolume 814), A. Bundy (ed.), Berlin: Springer-Verlag, pp.\n238\u2013251.</li>\n<li>Boyer, R. S., M. Kaufmann and J. S. Moore, 1995, \u201cThe\nBoyer-Moore Theorem Prover and its Interactive Enhancement\u201d,\n<em>Computers and Mathematics with Applications</em>, 29:\n27\u201362.</li>\n<li>Boyer, R.S. and J. S. Moore, 1979, <em>A Computational Logic</em>,\nNew York: Academic Press.</li>\n<li>Brown, C. E., 2012, \u201cSatallax: An Automatic Higher-Order\nProver\u201d, <em>Automated Reasoning: Proceedings of the 6th\nInternational Joint Conference on Automated Reasoning (IJCAR\n2012)</em>, LNAI 7364, B. Gramlich <em>et al</em>. (eds.), pp. 111\u2013117,\nSpringer-Verlag.</li>\n<li>\u2013\u2013\u2013, 2013, \u201cReducing Higher-Order Theorem Proving\nto a Sequence of SAT Problems\u201d, <em>Journal of Automated\nReasoning</em>, 51 (1): 57\u201377.</li>\n<li>Bundy, A., 2011, \u201cAutomated theorem proving: a practical\ntool for the working mathematician?\u201d, <em>Annals of Mathematics\nand Artificial Intelligence</em>, 61 (1): 3\u201314.</li>\n<li>Bundy, A., F. van Harmelen, J. Hesketh and A. Smaill, 1991,\n\u201cExperiments with Proof Plans for Induction\u201d, <em>Journal\nof Automated Reasoning</em>, 7 (3): 303\u2013324.</li>\n<li>Bundy, A., A. Stevens, F. van Harmelen, A. Ireland and A. Smaill,\n1993, \u201cRippling: A Heuristic for Guiding Inductive\nProofs\u201d, <em>Artificial Intelligence</em>, 62:\n185\u2013253.</li>\n<li>Church, A., 1936a, \u201cAn unsolvable problem of elementary\nnumber theory\u201d, <em>American Journal of Mathematics</em>, 58\n(2): 345\u2013363.</li>\n<li>\u2013\u2013\u2013, 1936b, \u201cA note on the\nEntscheidungsproblem\u201d, <em>Journal of Symbolic Logic</em>, 1\n(1): 40\u201341.</li>\n<li>\u2013\u2013\u2013, 1940, \u201cA Formulation of the Simple Theory of\nTypes\u201d, <em>Journal of Symbolic Logic</em>, 5: 56\u201368.</li>\n<li>Chang, C. L. and R. C. T. Lee, 1973, <em>Symbolic Logic and\nMechanical Theorem Proving</em>, New York: Academic Press.</li>\n<li>Chou, S., 1987, <em>Mechanical Geometry Theorem Proving</em>,\nDordrecht: Kluwer Academic Publishers.</li>\n<li>Claessen, K. and N. S\u00f6rensson, 2003, \u201cNew Techniques\nthat Improve MACE-style Finite Model Finding\u201d, <em>Proceedings\nof the CADE-19 Workshop: Model Computation \u2013 Principles,\nAlgorithms, Applications</em>, P. Baumgartner and C. Fermueller\n(eds.)</li>\n<li>Clarke, E. and X. Zhao, 1994, \u201cCombining Symbolic\nComputation and Theorem Proving: Some Problems of Ramanujan\u201d,\n<em>CADE-12: Proceedings of the 12th International Conference on\nAutomated Deduction</em>, (Lecture Notes in Artificial Intelligence:\nVolume 814), A. Bundy (ed.), Berlin: Springer-Verlag, pp.\n758-763.</li>\n<li>Clocksin, W. F. and C. S. Mellish, 1981, <em>Programming in\nProlog</em>, Berlin: Springer-Verlag.</li>\n<li>Colmerauer, A., H. Kanoui, R. Pasero and P. Roussel, 1973, <em>Un\nSyst\u00e8me de Communication Homme-machine en Fran\u00e7ais</em>,\nRapport, Groupe Intelligence Artificielle, Universit\u00e9 d\u2019Aix\nMarseille.</li>\n<li>Constable, R. L., S. F. Allen, H. M. Bromley, W.R. Cleaveland, J.\nF. Cremer, R. W. Harper, D. J. Howe, T. B. Knoblock, N. P. Mendler, P.\nPanangaden, J. T. Sasaki and S. F. Smith, 1986, <em>Implementing\nMathematics with the Nuprl Proof Development System</em>, Englewood\nCliffs, NJ: Prentice Hall.</li>\n<li>Cook, S. A., 1971, \u201cThe complexity of Theorem-Proving\nProcedures\u201d, <em>Proceedings of the 3rd Annual ACM Symposium on\nTheory of Computing</em>, New York: Association for Computing\nMachinery, pp. 151\u2013158.</li>\n<li>Coquand, T. and G. Huet, 1988, \u201cThe Calculus of\nConstructions\u201d, <em>Information and Computation - Semantics of\nData Types</em>, A. R. Meyer (ed.), 76 (2\u20133): 95\u2013120.</li>\n<li>Coquand, T. and C. Paulin-Mohring, 1988, \u201cInductively\nDefined Types\u201d, <em>COLOG88: Proceedings of the International\nConference on Computer Logic</em>, P. Martin-L\u00f6f and G. Mints\n(eds.), LNCS 417, pp. 50\u201366.</li>\n<li>Davis, M., G. Logemann and D. Loveland, 1962, \u201cA Machine\nProgram for Theorem-Proving\u201d, <em>Communications of the\nAssociation for Computing Machinery</em>, 5 (7): 394\u2013397.</li>\n<li>Davis, M. and H. Putnam, 1960, \u201cA Computing Procedure for\nQuantification Theory\u201d, <em>Journal of the Association for\nComputing Machinery</em>, 7 (3): 201\u2013215.</li>\n<li>de Bruijn, N. G., 1968, \u201cAutomath, a Language for\nMathematics\u201d, in <em>Automation of Reasoning (Volume 2)</em>, J.\nSiekmann and G. Wrighston (eds.), Berlin: Springer-Verlag, 1983, pp.\n159\u2013200.</li>\n<li>de Moura, L., 2007, \u201cDeveloping Efficient SMT\nSolvers\u201d, <em>Proceedings of the CADE-21 Workshop on Empirically\nSuccessful Automated Reasoning in Large Theories</em>, G. Sutcliffe,\nJ. Urban and S. Schulz (eds.), Bremen.</li>\n<li>Denney, E., B. Fischer and J. Schumann, 2004, \u201cUsing\nAutomated Theorem Provers to Certify Auto-generated Aerospace\nSoftware\u201d, <em>Automated Reasoning, Second International Joint\nConference (IJCAR)</em> (Lecture Notes in Artificial Intelligence:\nVolume 3097), D. Basin and M. Rusinowitch (eds.), Berlin:\nSpringer-Verlag, pp. 198-212.</li>\n<li>Denney, E., J. Power and K. Tourlas, 2006, \u201cHiproofs: A\nHierarchical Notion of Proof Tree\u201d, <em>Proceedings of the 21st\nAnnual Conference on Mathematical Foundations of Programming Semantics\n(MFPS XXI)</em> (Electronic Notes in Theoretical Computer Science,\nVol. 155), pp. 341\u2013359.</li>\n<li>Ernst, Z., B. Fitelson, K. Harris and L. Wos, 2002,\n\u201cShortest Axiomatizations of Implicational S4 and S5\u201d,\n<em>Notre Dame Journal of Formal Logic</em>, 43 (3):\n169\u2013179.</li>\n<li>Farmer, W. M., J. D. Guttman and F. J. Thayer, 1993, \u201cIMPS:\nAn Interactive Mathematical Proof System\u201d, <em>Journal of\nAutomated Reasoning</em>, 11 (2): 213\u2013248.</li>\n<li>Fitelson B. and E. Zalta, 2007, \u201cSteps Toward a\nComputational Metaphysics\u201d, <em>Journal of Philosophical\nLogic</em>, 36 (2): 227\u2013247.</li>\n<li>Fitting, M., 1990, <em>First-Order Logic and Automated Theorem\nProving</em>, Berlin: Springer-Verlag.</li>\n<li>\u2013\u2013\u2013, 2002, <em>Types, Tableaus and G\u00f6del\u2019s God</em>.\nKluwer.</li>\n<li>Fuenmayor, D. and C. Benzm\u00fcller, 2017, \u201cAutomating\nEmendations of the Ontological Argument in Intensional Higher-Order\nModal Logic\u201d, <em>KI 2017: Advances in Artificial Intelligence -\nProceedings of the 40th Annual German Conference on AI</em>, LNCS\n10505, G. Kern-Isberner <em>et al</em>. (eds.), pp. 114-127.</li>\n<li>Furbach , U., 1994, \u201cTheory Reasoning in First Order\nCalculi\u201d, <em>Management and Processing of Complex Data\nStructures</em>, (Lecture Notes in Computer Science Volume 777), pp.\n139\u2013156.</li>\n<li>Furbach, U., C. Schon and F. Stolzenburg, 2014, \u201cAutomated\nReasoning in Deontic Logic\u201d, <em>MIWAI2014: Proceedings of the\n8th Multi-disciplinary International Workshop on Artificial\nIntelligence</em>, LNAI 8875, M. N. Murty <em>et al</em>. (eds.), pp.\n57\u201368.</li>\n<li>Ganzinger, H., G. Hagen, R. Nieuwenhuis, A. Oliveras, C. Tinelli,\n2004, \u201cDPLL(T): Fast Decision Procedures\u201d, <em>Computer\nAided Verification</em>, (Lecture Notes in Computer Science: Volume\n3114), pp. 175\u2013188.</li>\n<li>Gentzen, G., 1935, \u201cInvestigations into Logical\nDeduction\u201d, in Szabo 1969, pp. 68\u2013131.</li>\n<li>Giarratano, J. and G. Riley, 2004, <em>Expert Systems: Principles\nand Programming</em>, 4th edition, Boston, MA: PWS Publishing Co.</li>\n<li>G\u00f6del, K., 1970, \u201cAppendix A: Notes in Kurt\nG\u00f6del\u2019s Hand\u201c, in Sobel 2004, pp. 144\u2013145.</li>\n<li>Gordon, M. J. C. and T. F. Melham, eds., 1993, <em>Introduction to\nHOL: A Theorem Proving Environment for Higher Order Logic</em>,\nCambridge: Cambridge University Press.</li>\n<li>Gordon, M. J. C., A. J. Milner and C. P. Wadsworth, 1979,\n<em>Edinburgh LCF: A Mechanised Logic of Computation</em> (LNCS 78),\nBerlin: Springer-Verlag.</li>\n<li>Gorenstein, D., 1982, <em>Finite Simple Groups: An Introduction to\ntheir Classification</em> (University Series in Mathematics), New\nYork: Plenum Press.</li>\n<li>Green, C., 1969, \u201cApplication of Theorem Proving to Problem\nSolving\u201d, <em>IJCAI\u201969 Proceedings of the 1st international\njoint conference on Artificial intelligence</em>, San Francisco:\nMorgan Kaufmann, pp. 219\u2013239</li>\n<li>Haack, S., 1978, <em>Philosophy of Logics</em>, Cambridge:\nCambridge University Press.</li>\n<li>Hales, T. C., 2005a, \u201cA proof of the Kepler\nConjecture\u201d, <em>Annals of Mathematics</em>, 162 (3):\n1065\u20131185.</li>\n<li>\u2013\u2013\u2013, 2006, \u201cIntroduction to the Flyspeck\nProject\u201d, <em>Dagstuhl Seminar Proceedings 05021: Mathematics,\nAlgorithms, Proofs</em>, T. Coquand <em>et al</em>. (eds.)</li>\n<li>Hales, T. C. <em>et al</em>., 2015, \u201cA Formal Proof of the\nKepler Conjecture\u201d, <em>arXiv:1501.02.02155 9 [mat.MG]</em>,\nCornell University Library.</li>\n<li>Harrison, J., 2000, \u201cHigh-Level Verification Using Theorem\nProving and Formalized Mathematics\u201d, <em>CADE-17: Proceedings of\nthe 17th International Conference on Automated Deduction</em>,\n(Lecture Notes in Artificial Intelligence: Volume 1831), D. McAllester\n(ed.), Berlin: Springer-Verlag, pp. 1-6.</li>\n<li>\u2013\u2013\u2013, 2006, \u201cVerification: Industrial\nApplications\u201d, <em>Proof Technology and Computation</em>, H.\nSchwichtenberg and K. Spies (eds.), Amsterdam: IOS Press, pp.\n161\u2013205.</li>\n<li>\u2013\u2013\u2013, 2009, \u201cFormalizing an Analytic Proof of the\nPrime Number Theorem\u201d, <em>Journal of Automated Reasoning\n(Special Issue: A Festschrift for Michael J. C. Gordon)</em>, 43 (3):\n243\u2013261.</li>\n<li>Harrison, J. and L. Th\u00e9ry, 1998, \u201cA Skeptic\u2019s\nApproach to Combining HOL and Maple\u201d, <em>Journal of Automated\nReasoning</em>, 21: 279\u2013294.</li>\n<li>Herbrand, J., 1930, <em>Recherches sur la Theorie de la\nDemonstration</em>, Travaux de la Societ\u00e9 des Sciences at des\nLettres de Varsovie, Classe III, Science Math\u00e9matique et\nPhysique, No. 33, 128.</li>\n<li>Heule, M. J. H. and O. Kullmann, 2017, \u201cThe Science of Brute\nForce\u201d, <em>Communications of the ACM</em>, 60 (8):\n70\u201379.</li>\n<li>Heule, M. J. H., O. Kullmann and V. W. Marek, 2016, \u201cSolving\nand Verifying the Boolean Pythagorean Triples problem via\nCube-and-Conquer\u201d, <em>Theory and Applications of Satisfiability\nTesting \u2014 SAT 2016, 19th International Conference</em>, LNCS\n9710, N. Creignou and D. Le Berre (eds.), pp. 228\u2013245.</li>\n<li>Hilbert, D. and W. Ackermann, 1928, <em>Principles of Mathematical\nLogic</em>, L. Hammond, G. Leckie, and F. Steinhardt (trans.), New\nYork: Chelsea Publishing Co., 1950.</li>\n<li>Huet, G. P., 1975, \u201cA Unification Algorithm for Typed\n\u03bb-calculus\u201d, <em>Theoretical Computer Science</em>, 1:\n27\u201357.</li>\n<li>Kanckos, A., and B. W. Paleo, 2017, \u201cVariants of\nG\u00f6del\u2019s Ontological Proof in a Natural Deduction Calculus\u201d,\n<em>Studia Logica</em>, (3): 553\u2013586.</li>\n<li>Kerber, M., Kohlhase and V. Sorge, 1998, \u201cIntegrating\nComputer Algebra into Proof Planning\u201d, <em>Journal of Automated\nReasoning</em>, 21: 327\u2013355.</li>\n<li>Knuth, D. and P. B. Bendix, 1970, \u201cSimple Word Problems in\nUniversal Algebras\u201d, in <em>Computational Problems in Abstract\nAlgebra</em>, J. Leech (ed.), Oxford, New York: Pergamon Press, pp.\n263\u2013297.</li>\n<li>Kleene, S. C., 1962, <em>Introduction to Metamathematics</em>,\nAmsterdam: North-Holland.</li>\n<li>Kov\u00e1cs, L. and A. Voronkov, 2013, \u201cFirst-Order\nTheorem Proving and VAMPIRE\u201d, <em>CAV 2013: Proceedings of the\nInternational Conference on Computer Aided Verification</em>, N.\nSharygina and H. Veith (eds.), LNCS 8044, pp. 1\u201335.</li>\n<li>Kowalski, R., 1974, \u201cPredicate Logic as a Programming\nLanguage\u201d, <em>Proceedings of the International Federation for\nInformation Processing</em> (Proc. IFIP \u201974), Amsterdam: North\nHolland, pp. 569\u2013574.</li>\n<li>K\u00fcchlin, W. and C. Sinz, 2000, \u201cProving Consistency\nAssertions for Automotive Product Data Management\u201d, <em>Journal\nof Automated Reasoning</em> (Special Issue: Satisfiability in the Year\n2000), I. P. Gent and T. Walsh (eds.), 24 (1\u20132):\n145\u2013163.</li>\n<li>K\u00fchlwein, D., T. van Laarhoven, E. Tsivtsivadze, J. Urban and\nT. Heskes, 2012, \u201cOverview and Evaluation of Premise Selection\nTechniques for Large Theory Mathematics\u201d, <em>Automated\nReasoning: 6th International Joint Conference, IJCAR 2012</em>,\n(Lecture Notes in Computer Science: Volume 7364), B. Gramlich, D.\nMiller and U. Sattler (eds.), Manchester, UK: Springer-Verlag, pp.\n378\u2013392.</li>\n<li>Lemmon, E. J., C. A. Meredith, D. Meredith, A. N. Prioir and I.\nThomas, 1957, <em>Calculi of Pure Strict Implication</em>, Philosophy\nDept., Canterbury University, Christchurch, New Zealand.</li>\n<li>Lloyd, J. W., 1984, <em>Foundations of Logic Programming</em>,\nBerlin: Springer-Verlag.</li>\n<li>Loveland, D. W., 1969, \u201cA Simplified Format for the Model\nElimination Procedure\u201d, <em>Journal of the Association for\nComputing Machinery</em>, 16: 349\u2013363.</li>\n<li>\u2013\u2013\u2013, 1970, \u201cA Linear Format for\nResolution\u201d, <em>Proceedings of the IRIA Symposium on Automatic\nDemonstration</em>, New York: Springer-Verlag, pp. 147-162.</li>\n<li>\u2013\u2013\u2013, 1978, <em>Automated Theorem Proving: A Logical\nBasis</em>, Amsterdam: North Holland.</li>\n<li>Luckham, D., 1970, \u201cRefinements in Resolution Theory\u201d,\n<em>Proceedings of the IRIA Symposium on Automatic Demonstration</em>,\nNew York: Springer-Verlag, pp. 163-190.</li>\n<li>Martin-L\u00f6f, P., 1982, \u201cConstructive Mathematics and\nComputer Programming\u201d, <em>Logic, Methodology and Philosophy of\nScience</em> (Volume IV), Amsterdam: North-Holland, pp. 153-175.</li>\n<li>Massacci, F. and L. Marraro, 2000, \u201cLogical Cryptanalysis:\nEncoding and Analysis of the U.S. Data Encryption Standard\u201d,\n<em>Journal of Automated Reasoning</em> (Special Issue: Satisfiability\nin the Year 2000), I. P. Gent and T. Walsh (eds.), 24 (1\u20132):\n165\u2013203.</li>\n<li>McCarthy, J., 1962, \u201cTowards a Mathematical Science of\nComputation\u201d, <em>International Federation for Information\nProcessing Congress</em> (Munich, 1962), Amsterdam: North Holland, pp.\n21\u201328.</li>\n<li>McCharen, J. D., R. A. Overbeek and L. A. Wos, 1976,\n\u201cProblems and Experiments for and with Automated Theorem-Proving\nPrograms\u201d, <em>IEEE Transactions on Computers</em> 8:\n773\u2013782.</li>\n<li>McCune, W., 1997, \u201cSolution of the Robbins Problem\u201d,\n<em>Journal of Automated Reasoning</em>, 19 (3): 263\u2013276.</li>\n<li>\u2013\u2013\u2013, 2001, <em>MACE 2.0 Reference Manual and Guide</em>,\nMathematics and Computer Science Division, ANL/MSC-TM-249, Argonne\nNational Laboratory.</li>\n<li>McRobie, M. A., 1991, \u201cAutomated Reasoning and Nonclassical\nLogics: Introduction\u201d, <em>Journal of Automated Reasoning</em>,\n7 (4): 447\u2013451.</li>\n<li>Meng, J. and L. C. Paulson, 2008, \u201cTranslating higher-order\nclauses to first-order clauses\u201d, <em>Journal of Automated\nReasoning</em>, 40 (1): 35\u201360.</li>\n<li>Meredith, C. A. and A. N. Prior, 1964, \u201cInvestigations into\nImplicational S5\u201d, <em>Z. Math. Logik Grundlagen Math.</em>,\n10:203\u2013220.</li>\n<li>Meyer, J.-J. Ch., 2014, \u201cLogics for Intelligent Agents and\nMulti-Agent Systems\u201d, <em>Handbook of the History of Logic,\nVolume 9: Computational Logic</em>, J. Siekmann (ed.), pp.\n629\u2013658, Elsevier.</li>\n<li>Miller, D. and G. Nadathur, 1988, \u201cAn Overview of\n\u03bbProlog\u201d, <em>Proceedings of the Fifth International\nLogic Programming Conference \u2014 Fifth Symposium in Logic\nProgramming</em>, R. Bowen and R. Kowalski (eds.), Cambridge, MA: MIT\nPress.</li>\n<li>Minker, J., D. Seipel and C. Zaniolo, 2014, \u201cLogic and\nDatabases: A History of Deductive Databases\u201d, <em>Handbook of\nthe History of Logic, Volume 9: Computational Logic</em>, J. Siekmann\n(ed.), pp. 571\u2013627, Elsevier.</li>\n<li>Muzalewski, M., 1993, <em>An Outline of PC Mizar</em>, Fondation\nPhilippe le Hodey, Brussels.</li>\n<li>Nipkow, T., L. C. Paulson and M. Wenzel, 2002,\n\u201cIsabelle/HOL: A Proof Assistant for Higher-Order Logic\u201c,\nLNCS Vol. 2283, pp. 207\u2013208.</li>\n<li>Nivens, A. J., 1974, \u201cA Human-Oriented Logic for Automatic\nTheorem Proving\u201d, <em>Journal of the Association of Computing\nMachinery</em>, 21 (4): 606\u2013621.</li>\n<li>Oppenheimer, P. and E. Zalta, 2011, \u201cA\nComputationally-Discovered Simplification of the Ontological\nArgument\u201d, <em>Australasian Journal of Philosophy</em>, 89 (2):\n333\u2013349.</li>\n<li>Paulson, L. C., 1990, \u201cIsabelle: The Next 700 Theorem\nProvers\u201d, <em>Logic and Computer Science</em>, P. Odifreddi\n(ed.), Academic Press, pp. 361\u2013386.</li>\n<li>\u2013\u2013\u2013, 1994, <em>Isabelle: A Generic Theorem Prover</em>\n(Lecture Notes in Computer Science: Volume 828), Berlin:\nSpringer-Verlag.</li>\n<li>\u2013\u2013\u2013, 2010. \u201cThree Years of Experience with\nSledgehammer, a Practical Link Between Automatic and Interactive\nTheorem Provers\u201d, <em>PAAR-2010</em>, B. Konev <em>et al</em>. (eds.),\npp. 1\u201310.</li>\n<li>Paulson, L. C. and K. Grabczewski, 1996, \u201cMechanizing Set\nTheory\u201d, <em>Journal of Automated Reasoning</em>, 17 (3):\n291\u2013323.</li>\n<li>Pease, A. and G. Sutcliffe, 2007, \u201cFirst Order Reasoning on\na Large Ontology\u201d, <em>Proceedings of the CADE-21 Workshop on\nEmpirically Successful Automated Reasoning in Large Theories</em>\n(Volume 257), G. Sutcliffe and J. Urban (eds.), Bremen.</li>\n<li>Pelletier, F. J., 1986, \u201cSeventy-Five Problems for Testing\nAutomatic Theorem Provers\u201d, <em>Journal of Automated\nReasoning</em>, 2 (2): 191\u2013216.</li>\n<li>\u2013\u2013\u2013, 1998, \u201cNatural Deduction Theorem Proving\nin THINKER\u201d, <em>Studia Logica</em>, 60 (1): 3\u201343.</li>\n<li>Pelletier, F. J., G. Sutcliffe and A. P. Hazen, 2017,\n\u201cAutomated Reasoning for the Dialetheic Logic RM3\u201d,\n<em>Proceedings of the Thirtieth International Florida Artificial\nIntelligence Research Society Conference</em>, V. Rus and Z. Markov\n(eds.), pp. 110\u2013115.</li>\n<li>Pelletier, F. J., G. Sutcliffe, and C. Suttner, 2002, \u201cThe\nDevelopment of CASC\u201d, <em>AI Communications</em>, 15\n(2\u20133): 79\u201390.</li>\n<li>Peterson, J. G., 1977, <em>The Possible Shortest Single Axiom for\nEC-Tautologies</em>, Report 105, Department of Mathematics, University\nof Auckland.</li>\n<li>Pollock, J., 1989, \u201cOSCAR: A General Theory of\nRationality\u201d, <em>Journal of Experimental &amp; Theoretical\nArtificial Intelligence</em>, 1 (3): 209\u2013226</li>\n<li>\u2013\u2013\u2013, 1995, <em>Cognitive Carpentry</em>, Cambridge, MA:\nBradford/MIT Press.</li>\n<li>\u2013\u2013\u2013, 2006, \u201cAgainst Optimality: Logical Foundations\nfor Decision-Theoretic Planning in Autonomous Agents\u201d,\n<em>Computational Intelligence</em>, 22(1): 1\u201325.</li>\n<li>Portoraro, F. D., 1994, \u201cSymlog: Automated Advice in\nFitch-style Proof Construction\u201d, <em>CADE-12: Proceedings of the\n12th International Conference on Automated Deduction</em>, (Lecture\nNotes in Artificial Intelligence: Volume 814), A. Bundy (ed.), Berlin:\nSpringer-Verlag, pp. 802-806.</li>\n<li>\u2013\u2013\u2013, 1998, \u201cStrategic Construction of\nFitch-style Proofs\u201d, <em>Studia Logica</em>, 60 (1):\n45\u201366.</li>\n<li>Prasad, M., A. Biere and A. Gupta, 2005, \u201cA Survey of Recent\nAdvances in SAT-Based Formal Verification\u201d, <em>International\nJournal on Software Tools for Technology Transfer</em>, 7 (2):\n156\u2013173.</li>\n<li>Prawitz, D., 1965, <em>Natural Deduction: A Proof Theoretical\nStudy</em>, Stockholm: Almqvist &amp; Wiksell.</li>\n<li>Quaife, A., 1992, <em>Automated Development of Fundamental\nMathematical Theories</em>, Kluwer Academic Publishers.</li>\n<li>Robinson, J. A., 1965, \u201cA Machine Oriented Logic Based on\nthe Resolution Principle\u201d, <em>Journal of the Association of\nComputing Machinery</em>, 12: 23\u201341.</li>\n<li>\u2013\u2013\u2013, 1965, \u201cAutomatic Deduction with\nHyper-resolution\u201d, <em>Internat. J. Comput. Math.</em>, 1:\n227\u2013234.</li>\n<li>Robinson, J. A. and A. Voronkov (eds.), 2001, <em>Handbook of\nAutomated Reasoning: Volumes I and II</em>, Cambridge, MA: MIT Press.\n</li>\n<li>Schmitt, P. and I. Tonin, 2007, \u201cVerifying the Mondex Case\nStudy\u201d, <em>Proceedings of the Fifth IEEE International\nConference on Software Engineering and Formal Methods</em>, IEEE\nComputer Society, pp. 47\u201358.</li>\n<li>Schulz, S., 2004, \u201cSystem Abstract: E 0.81\u201d,\n<em>Proceedings of the 2nd International Joint Conference on Automated\nReasoning</em> (Lecture Notes in Artificial Intelligence: Volume\n3097), D. Basin and M. Rusinowitch (eds.), Berlin: Springer-Verlag,\npp.223-228.</li>\n<li>Scott, D., 1972, \u201cAppendix B: Notes in Dana Scott\u2019s\nHand\u201d, in Sobel 2004, pp. 145\u2013146.</li>\n<li>Sieg, W. and J. Byrnes, 1996, <em>Normal Natural Deduction Proofs\n(in Classical Logic)</em>, Report CMU-PHIL 74, Department of\nPhilosophy, Carnegie-Mellon University.</li>\n<li>Slaney, J. K., 1984, \u201c3,088 Varieties: A Solution to the\nAckerman Constant Problem\u201d, <em>Journal of Symbolic Logic</em>,\n50: 487\u2013501.</li>\n<li>Sobel, J. H., 2004, <em>Logic and Theism: Arguments for and\nAgainst Beliefs in God</em>, Cambridge University Press.</li>\n<li>Stickel, M. E., 1992, \u201cA Prolog Technology Theorem Prover: A\nNew Exposition and Implementation in Prolog\u201d, <em>Theoretical\nComputer Science</em>, 104: 109\u2013128.</li>\n<li>Suppes, P., <em>et al</em>., 1981, \u201cPart I: Interactive\nTheorem Proving in CAI Courses\u201d, <em>University-Level\nComputer-Assisted Instruction at Stanford: 1968\u20131980</em>, P.\nSuppes (ed.), Institute for the Mathematical Study of the Social\nSciences, Stanford University.</li>\n<li>Sutcliffe, G. and C. Benzm\u00fcller, 2010, \u201cAutomated\nReasoning in Higher-Order Logic Using TPTP THF Infrastructure\u201d,\n<em>Journal of Formalized Reasoning</em>, 43 (4): 337\u2013362.</li>\n<li>Sutcliffe, G. and C. Suttner, 1998, \u201cThe TPTP Problem\nLibrary \u2013 CNF Release v1.2.1\u201d, <em>Journal of Automated\nReasoning</em>, 21 (2): 177\u2013203.</li>\n<li>Szabo, M. E. (ed.), 1969, <em>The Collected Papers of Gerhard\nGentzen</em>, Amsterdam: North-Holland.</li>\n<li>Trybulec, A., 1978, \u201cThe Mizar Logic Information\nLanguage\u201d, <em>Bulletin of the Association for Literary\nLinguistic Computing</em>, 6(2): 136\u2013140.</li>\n<li>Trybulec, A. and H. Blair, 1985, \u201cComputer Assisted\nReasoning with Mizar\u201d, <em>Proceedings of the 9th International\nJoint Conference on Artificial Intelligence</em>, (IJCAI-85: Volume\n1), Los Angeles, pp. 26\u201328.</li>\n<li>Turing, A., 1936, \u201cOn computable numbers, with an\napplication to the Entscheidungsproblem\u201d, <em>Proceedings of the\nLondon Mathematical Society</em>, 42 (2): 230\u2013265.</li>\n<li>Urban, J., 2007, \u201cMaLARea: A Metasystem for Automated\nReasoning in Large Theories\u201d, <em>Proceedings of the CADE-21\nWorkshop on Empirically Successful Automated Reasoning in Large\nTheories</em>, J. Urban, G. Sutcliffe and S. Schulz (eds.), pp.\n45\u201358.</li>\n<li>Urban, J., K. Hoder, A. Voronkov, 2010, \u201cEvaluation of\nAutomated Theorem Proving on the Mizar Mathematical Library\u201d,\n<em>Mathematical Software \u2013 ICMS 2010: Proceedings of the Third\nInternational Congress on Mathematical Software</em>, Kobe, Japan,\n(Lecture Notes in Computer Science, Volume 6327), pp.\n155\u2013166.</li>\n<li>Urban, J. and J. Vyskocil, 2012, \u201cTheorem Proving in Large\nFormal Mathematics as an Emerging AI Field\u201d, <em>arXiv:1209.3914\n[cs.AI]</em>, Report No. DPA-12271, Cornell University.</li>\n<li>Urquhart, A., 1994 (ed.), <em>The Collected Papers of Bertrand\nRussell, Volume 4: Foundations of Logic, 1903-05</em>, Routledge,\nLondon and New York.</li>\n<li>van Benthem Jutting, L. S., 1977, <em>Checking Landau\u2019s\n\u201cGrundlagen\u201d in the Automath system</em>, Ph.D. Thesis,\nEindhoven University of Technology; published in <em>Mathematical\nCentre Tracts</em>, Number 83, Amsterdam: Mathematisch Centrum,\n1979. </li>\n<li>Voronkov, A., 1995, \u201cThe Anatomy of Vampire: Implementing\nBottom-Up Procedures with Code Trees\u201d, <em>Journal of Automated\nReasoning</em>, 15 (2): 237\u2013265.</li>\n<li>Wallen, L. A., 1990, <em>Automated Deduction in Nonclassical\nLogics</em>, Cambridge, MA: MIT Press.</li>\n<li>Wang, H., 1960, \u201cProving Theorems by Pattern Recognition\n\u2013 I\u201d, in <em>Automation of Reasoning (Volume 1)</em>, J.\nSiekmann and G. Wrightson (eds.), Berlin: Springer-Verlag, 1983, pp.\n229\u2013243.</li>\n<li>\u2013\u2013\u2013, 1960, \u201cToward Mechanical\nMathematics\u201d, in <em>Automation of Reasoning</em> (Volume 1),\nJ. Siekmann and G.  Wrightson (eds.), Berlin: Springer-Verlag, 1983,\npp. 244-264.</li>\n<li>Wegner, B., 2011, \u201cCompleteness of reference databases,\nold-fashioned or not?\u201d, <em>Newsletter of the European\nMathematical Society</em>, 80: 50\u201352.</li>\n<li>Wiedijk, F., 2006, <em>The Seventeen Provers of the World</em>,\n(Lecture Notes in Artificial Intelligence: Volume 3600), F. Wiedijk\n(ed.), New York: Springer-Verlag.</li>\n<li>\u2013\u2013\u2013, 2007, \u201cThe QED Manifesto\nRevisited\u201d, <em>Studies in Logic, Grammar and Rhetoric</em>, 10\n(23): 121\u2013133.</li>\n<li>Wos, L. (ed.), 2001, <em>Journal of Automated Reasoning</em>\n(Special Issue: Advances in Logic Through Automated Reasoning), 27\n(2).</li>\n<li>Wos, L., D. Carson and G. R. Robinson, 1965, \u201cEfficiency and\nCompleteness of the Set of Support Strategy in Theorem Proving\u201d,\n<em>Journal of the Association of Computing Machinery</em>, 12:\n698\u2013709.</li>\n<li>Wos, L., R. Overbeek, E. Lusk and J. Boyle, 1984, <em>Automated\nReasoning: Introduction and Applications</em>, Englewood Cliffs, NJ:\nPrentice-Hall.</li>\n<li>Wos, L., D. Ulrich, and B. Fitelson, 2002, \u201cVanquishing the\nXCB Question; The Methodological Discovery of the Last Shortest Single\nAxiom for the Equivalential Calculus\u201d, <em>Journal of Automated\nReasoning</em>, 29 (2):107\u2013124.</li>\n<li>Wos, L., S. Winker, R. Veroff, B. Smith and L. Henschen, 1983,\n\u201cQuestions Concerning Possible Shortest Single Axiom for the\nEquivalential Calculus: An Application of Automated Theorem Proving to\nInfinite Domains\u201d, <em>Notre Dame Journal of Formal Logic</em>,\n24: 205\u2013223.</li>\n<li>Yoo, J., E. Jee and S. Cha, 2009, \u201cFormal Modeling and\nVerification of Safety-Critical Software\u201d, <em>IEEE\nSoftware</em>, 26 (3): 42\u201349.</li>\n<li>Zhang, L. and S. Malik, 2002, \u201cThe Quest for Efficient\nBoolean Satisfiability Solvers\u201d, <em>CADE-18: Proceedings of the\n18th International Conference on Automated Deduction</em>, (Lecture\nNotes in Artificial Intelligence: Volume 2392), A. Voronkov (ed.),\nBerlin: Springer-Verlag, pp. 295-313.</li>\n</ul>\n</div>"}, "related_entries": {"entry_list": ["artificial intelligence: logic and", "logic: classical", "logic: modal", "reasoning: defeasible"], "entry_link": [{"../logic-ai/": "artificial intelligence: logic and"}, {"../logic-classical/": "logic: classical"}, {"../logic-modal/": "logic: modal"}, {"../reasoning-defeasible/": "reasoning: defeasible"}]}, "academic_tools": {"listed_text": ["<img alt=\"sep man icon\" src=\"../../symbols/sepman-icon.jpg\"/>", "<a href=\"https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=reasoning-automated\" target=\"other\">How to cite this entry</a>.", "<img alt=\"sep man icon\" src=\"../../symbols/sepman-icon.jpg\"/>", "<a href=\"https://leibniz.stanford.edu/friends/preview/reasoning-automated/\" target=\"other\">Preview the PDF version of this entry</a> at the\n <a href=\"https://leibniz.stanford.edu/friends/\" target=\"other\">Friends of the SEP Society</a>.", "<img alt=\"inpho icon\" src=\"../../symbols/inpho.png\"/>", "<a href=\"https://www.inphoproject.org/entity?sep=reasoning-automated&amp;redirect=True\" target=\"other\">Look up topics and thinkers related to this entry</a>\n at the Internet Philosophy Ontology Project (InPhO).", "<img alt=\"phil papers icon\" src=\"../../symbols/pp.gif\"/>", "<a href=\"http://philpapers.org/sep/reasoning-automated/\" target=\"other\">Enhanced bibliography for this entry</a>\nat <a href=\"http://philpapers.org/\" target=\"other\">PhilPapers</a>, with links to its database."], "listed_links": [{"https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=reasoning-automated": "How to cite this entry"}, {"https://leibniz.stanford.edu/friends/preview/reasoning-automated/": "Preview the PDF version of this entry"}, {"https://leibniz.stanford.edu/friends/": "Friends of the SEP Society"}, {"https://www.inphoproject.org/entity?sep=reasoning-automated&redirect=True": "Look up topics and thinkers related to this entry"}, {"http://philpapers.org/sep/reasoning-automated/": "Enhanced bibliography for this entry"}, {"http://philpapers.org/": "PhilPapers"}]}, "other_internet_resources": {"listed_text": ["Hales, T. C., 2005b, <a href=\"http://code.google.com/p/flyspeck/wiki/FlyspeckFactSheet\" target=\"other\"><em>The Flyspeck Project Fact Sheet</em></a>\n", "Hales, T. C., 2014, <a href=\"http://code.google.com/p/flyspeck/wiki/AnnouncingCompletion\" target=\"other\"><em>Flyspeck</em></a>", "Martin, U. and A. Pease, 2013,\n \u201c<a href=\"http://arxiv.org/abs/1305.0904\" target=\"other\">What does mathoverflow tell us about the production of mathematics?</a>,\u201d\n <em>Computing Research Repository</em>, at arxiv.org.", "Sutcliffe, G., 2014, <em>Proceedings of the 7th IJCAR Automated\nTheorem Proving System Competition (CASC-J7)</em>,\n <a href=\"http://www.cs.miami.edu/~tptp/CASC/J7/Proceedings.pdf\" target=\"other\">available online</a>,\n pp. 1\u201336.", "Sutcliffe, G., 2016, <em>Proceedings of the 8th IJCAR Automated\nTheorem Proving System Competition (CASC-J8)</em>,\n <a href=\"http://www.cs.miami.edu/~tptp/CASC/J8/Proceedings.pdf\" target=\"other\">available online</a>,\n pp. 1\u201340.", "<a href=\"http://www.cs.utexas.edu/users/moore/acl2/\" target=\"other\">ACL2: A Computational Logic</a>", "<a href=\"http://wiki.portal.chalmers.se/agda/pmwiki.php\" target=\"other\">Alfa/Agda</a>", "<a href=\"http://coq.inria.fr/\" target=\"other\">The Coq Proof Assistant</a>", "<a href=\"http://cvc4.cs.stanford.edu/web/\" target=\"other\">CVC4</a>", "<a href=\"http://wwwlehre.dhbw-stuttgart.de/~sschulz/E/E.html\" target=\"other\">E Theorem Prover</a>", "<a href=\"http://www.cs.unm.edu/~mccune/eqp/\" target=\"other\">EQP Equational Prover</a>", "<a href=\"http://www.cl.cam.ac.uk/research/hvg/HOL/\" target=\"other\">HOL Automated Reasoning Group</a>", "<a href=\"http://www.cl.cam.ac.uk/~jrh13/hol-light/\" target=\"other\">HOL Light</a>", "<a href=\"http://imps.mcmaster.ca\" target=\"other\">IMPS: An Interactive Mathematical Proof System</a>", "<a href=\"http://www.cs.man.ac.uk/~korovink/iprover/\" target=\"other\">iProver</a>", "<a href=\"http://www.cl.cam.ac.uk/research/hvg/Isabelle/\" target=\"other\">Isabelle</a>", "<a href=\"http://www.leancop.de/\" target=\"other\">leanCoP</a>", "<a href=\"http://www.cl.cam.ac.uk/~lp15/Grants/LEO-II/index.html\" target=\"other\">LEO-II</a>", "<a href=\"http://page.mi.fu-berlin.de/lex/leo3/\" target=\"other\">LEO-III</a>", "<a href=\"http://us.metamath.org/\" target=\"other\">Metamath</a>", "<a href=\"http://www.cl.cam.ac.uk/~lp15/papers/Arith/\" target=\"other\">MetiTarski</a>", "<a href=\"http://www.minlog-system.de\" target=\"other\">The Minlog System</a>", "<a href=\"http://www.mizar.org/\" target=\"other\">The Mizar Project</a>", "<a href=\"http://www.nuprl.org/\" target=\"other\">The Nuprl Project</a>", "<a href=\"http://vlsicad.eecs.umich.edu/BK/Slots/cache/www.cs.chalmers.se/~koen/paradox/\" target=\"other\">Paradox</a>", "<a href=\"http://www.cs.unm.edu/~mccune/prover9/\" target=\"other\">Prover 9 and Mace 4</a>", "<a href=\"http://pvs.csl.sri.com/\" target=\"other\">PVS Specification and Verification System</a>", "<a href=\"http://www.ps.uni-saarland.de/~cebrown/satallax/\" target=\"other\">Satallax</a>", "<a href=\"http://www.spass-prover.org/\" target=\"other\">SPASS</a>", "<a href=\"http://gtps.math.cmu.edu/tps.html\" target=\"other\">TPS Theorem Proving System</a>", "<a href=\"http://vprover.github.io/\" target=\"other\">Vampire</a>", "<a href=\"http://www.waldmeister.org/\" target=\"other\">Waldmeister</a>", "<a href=\"http://yices.csl.sri.com/\" target=\"other\">Yices 2</a>", "<a href=\"http://github.com/Z3Prover/\" target=\"other\">Z3</a>", "<a href=\"http://www.cs.miami.edu/~tptp/CASC/\" target=\"other\">The CADE ATP System Competition</a>", "<a href=\"http://www.cs.miami.edu/~tptp/\" target=\"other\">The TPTP Problem Library for Automated Theorem Proving</a>", "<a href=\"http://smtlib.cs.uiowa.edu/\" target=\"other\">The SMT-LIB Satisfiability Modulo Theories Library</a>", "<a href=\"http://www.cs.ru.nl/~freek/qed/qed.html\" target=\"other\">The QED Manifesto</a>", "<a href=\"http://www.cadeinc.org/\" target=\"other\">CADE: The Conference on Automated Deduction</a>", "<a href=\"http://ijcar.org/\" target=\"other\">IJAR: The International Joint Conference on Automated Reasoning</a>"], "listed_links": [{"http://code.google.com/p/flyspeck/wiki/FlyspeckFactSheet": "The Flyspeck Project Fact Sheet"}, {"http://code.google.com/p/flyspeck/wiki/AnnouncingCompletion": "Flyspeck"}, {"http://arxiv.org/abs/1305.0904": "What does mathoverflow tell us about the production of mathematics?"}, {"http://www.cs.miami.edu/~tptp/CASC/J7/Proceedings.pdf": "available online"}, {"http://www.cs.miami.edu/~tptp/CASC/J8/Proceedings.pdf": "available online"}, {"http://www.cs.utexas.edu/users/moore/acl2/": "ACL2: A Computational Logic"}, {"http://wiki.portal.chalmers.se/agda/pmwiki.php": "Alfa/Agda"}, {"http://coq.inria.fr/": "The Coq Proof Assistant"}, {"http://cvc4.cs.stanford.edu/web/": "CVC4"}, {"http://wwwlehre.dhbw-stuttgart.de/~sschulz/E/E.html": "E Theorem Prover"}, {"http://www.cs.unm.edu/~mccune/eqp/": "EQP Equational Prover"}, {"http://www.cl.cam.ac.uk/research/hvg/HOL/": "HOL Automated Reasoning Group"}, {"http://www.cl.cam.ac.uk/~jrh13/hol-light/": "HOL Light"}, {"http://imps.mcmaster.ca": "IMPS: An Interactive Mathematical Proof System"}, {"http://www.cs.man.ac.uk/~korovink/iprover/": "iProver"}, {"http://www.cl.cam.ac.uk/research/hvg/Isabelle/": "Isabelle"}, {"http://www.leancop.de/": "leanCoP"}, {"http://www.cl.cam.ac.uk/~lp15/Grants/LEO-II/index.html": "LEO-II"}, {"http://page.mi.fu-berlin.de/lex/leo3/": "LEO-III"}, {"http://us.metamath.org/": "Metamath"}, {"http://www.cl.cam.ac.uk/~lp15/papers/Arith/": "MetiTarski"}, {"http://www.minlog-system.de": "The Minlog System"}, {"http://www.mizar.org/": "The Mizar Project"}, {"http://www.nuprl.org/": "The Nuprl Project"}, {"http://vlsicad.eecs.umich.edu/BK/Slots/cache/www.cs.chalmers.se/~koen/paradox/": "Paradox"}, {"http://www.cs.unm.edu/~mccune/prover9/": "Prover 9 and Mace 4"}, {"http://pvs.csl.sri.com/": "PVS Specification and Verification System"}, {"http://www.ps.uni-saarland.de/~cebrown/satallax/": "Satallax"}, {"http://www.spass-prover.org/": "SPASS"}, {"http://gtps.math.cmu.edu/tps.html": "TPS Theorem Proving System"}, {"http://vprover.github.io/": "Vampire"}, {"http://www.waldmeister.org/": "Waldmeister"}, {"http://yices.csl.sri.com/": "Yices 2"}, {"http://github.com/Z3Prover/": "Z3"}, {"http://www.cs.miami.edu/~tptp/CASC/": "The CADE ATP System Competition"}, {"http://www.cs.miami.edu/~tptp/": "The TPTP Problem Library for Automated Theorem Proving"}, {"http://smtlib.cs.uiowa.edu/": "The SMT-LIB Satisfiability Modulo Theories Library"}, {"http://www.cs.ru.nl/~freek/qed/qed.html": "The QED Manifesto"}, {"http://www.cadeinc.org/": "CADE: The Conference on Automated Deduction"}, {"http://ijcar.org/": "IJAR: The International Joint Conference on Automated Reasoning"}]}, "tokenized_text": ["1", "introduction", "problem", "presented", "automated", "reasoning", "program", "consists", "two", "main", "item", "namely", "statement", "expressing", "particular", "question", "asked", "called", "problem", "conclusion", "collection", "statement", "expressing", "relevant", "information", "available", "programthe", "problem", "assumption", "solving", "problem", "mean", "proving", "conclusion", "given", "assumption", "systematic", "application", "rule", "deduction", "embedded", "within", "reasoning", "program", "problem", "solving", "process", "end", "one", "proof", "found", "program", "able", "detect", "nonexistence", "proof", "simply", "run", "resource", "11", "problem", "domain", "first", "important", "consideration", "design", "automated", "reasoning", "program", "delineate", "class", "problem", "program", "required", "solvethe", "problem", "domain", "domain", "large", "would", "case", "generalpurpose", "theorem", "prover", "firstorder", "logic", "restricted", "scope", "specialpurpose", "theorem", "prover", "tarski", "geometry", "modal", "logic", "k", "typical", "approach", "design", "automated", "reasoning", "program", "provide", "first", "sufficient", "logical", "power", "eg", "firstorder", "logic", "demarcate", "scope", "particular", "domain", "interest", "defined", "set", "domain", "axiom", "illustrate", "eqp", "theoremproving", "program", "equational", "logic", "used", "solve", "open", "question", "robbins", "algebra", "mccune", "1997", "robbins", "algebra", "boolean", "program", "provided", "axiom", "defining", "robbins", "algebra", "a1", "x", "x", "commutativity", "a2", "x", "z", "x", "z", "associativity", "a3", "x", "x", "y", "x", "robbins", "equation", "program", "used", "show", "characterization", "boolean", "algebra", "us", "huntington", "equation", "x", "x", "y", "x", "follows", "axiom", "remark", "problem", "nontrivial", "since", "deciding", "whether", "finite", "set", "equation", "provides", "basis", "boolean", "algebra", "undecidable", "permit", "algorithmic", "representation", "also", "problem", "attacked", "robbins", "huntington", "tarski", "many", "student", "success", "key", "step", "establish", "robbins", "algebra", "satisfy", "xy", "x", "x", "since", "known", "formula", "sufficient", "condition", "robbins", "algebra", "boolean", "eqp", "supplied", "piece", "information", "program", "provided", "invaluable", "assistance", "completing", "proof", "automatically", "specialpurpose", "theorem", "prover", "draw", "main", "benefit", "restricting", "attention", "domain", "axiom", "fact", "domain", "may", "enjoy", "particular", "theoremproving", "technique", "hardwiredcodedwithin", "reasoning", "program", "may", "result", "efficient", "logic", "implementation", "much", "eqp", "success", "settling", "robbins", "question", "attributed", "builtin", "associativecommutative", "inference", "mechanism", "12", "language", "representation", "second", "important", "consideration", "building", "automated", "reasoning", "program", "decide", "1", "problem", "domain", "presented", "reasoning", "program", "2", "actually", "represented", "internally", "within", "program", "3", "solution", "foundcompleted", "proofswill", "displayed", "back", "user", "several", "formalism", "available", "choice", "dependent", "problem", "domain", "underlying", "deduction", "calculus", "used", "reasoning", "program", "commonly", "used", "formalism", "include", "standard", "firstorder", "logic", "typed", "\u03bbcalculus", "clausal", "logic", "take", "clausal", "logic", "assume", "reader", "familiar", "rudiment", "firstorder", "logic", "typed", "\u03bbcalculus", "reader", "may", "want", "check", "church", "1940", "clausal", "logic", "quantifierfree", "variation", "firstorder", "logic", "widely", "used", "notation", "within", "automated", "reasoning", "community", "definition", "order", "term", "constant", "variable", "function", "whose", "argument", "term", "example", "x", "f", "x", "h", "c", "f", "z", "term", "literal", "either", "atomic", "formula", "eg", "f", "x", "negation", "atomic", "formula", "eg", "r", "x", "f", "two", "literal", "complementary", "one", "negation", "clause", "possibly", "empty", "finite", "disjunction", "literal", "l1", "ln", "literal", "appears", "clause", "clause", "alternatively", "treated", "set", "literal", "ground", "term", "ground", "literal", "ground", "clause", "variable", "empty", "clause", "clause", "literal", "hence", "unsatisfiablefalse", "interpretation", "example", "r", "b", "f", "r", "f", "x", "b", "f", "z", "example", "clause", "former", "ground", "general", "idea", "able", "express", "problem", "formulation", "set", "clause", "equivalently", "formula", "conjunctive", "normal", "form", "cnf", "conjunction", "clause", "formula", "already", "expressed", "standard", "logic", "notation", "systematic", "twostep", "procedure", "transforming", "conjunctive", "normal", "form", "first", "step", "consists", "reexpressing", "formula", "semantically", "equivalent", "formula", "prenex", "normal", "form", "\u03b8x1", "\u03b8xn", "\u03b1", "x1", "xn", "consisting", "string", "quantifier", "\u03b8x1", "\u03b8xn", "followed", "quantifierfree", "expression", "\u03b1", "x1", "xn", "called", "matrix", "second", "step", "transformation", "first", "convert", "matrix", "conjunctive", "normal", "form", "using", "wellknown", "logical", "equivalence", "demorgan", "law", "distribution", "doublenegation", "others", "quantifier", "front", "matrix", "conjunctive", "normal", "form", "dropped", "according", "certain", "rule", "presence", "existential", "quantifier", "latter", "step", "always", "preserve", "equivalence", "requires", "introduction", "skolem", "function", "whose", "role", "simulate", "behaviour", "existentially", "quantified", "variable", "example", "applying", "skolemizing", "process", "formula", "xyzuv", "r", "x", "v", "k", "x", "z", "u", "v", "requires", "introduction", "oneplace", "twoplace", "skolem", "function", "f", "g", "respectively", "resulting", "formula", "xzv", "r", "x", "f", "x", "v", "k", "x", "z", "g", "x", "z", "v", "universal", "quantifier", "removed", "obtain", "final", "clause", "r", "x", "f", "x", "v", "k", "x", "z", "g", "x", "z", "v", "example", "skolemizing", "process", "may", "preserve", "equivalence", "maintains", "satisfiability", "enough", "clausebased", "automated", "reasoning", "although", "clausal", "form", "provides", "uniform", "economical", "notationthere", "quantifier", "formula", "disjunctionsit", "certain", "disadvantage", "one", "drawback", "increase", "size", "resulting", "formula", "transformed", "standard", "logic", "notation", "clausal", "form", "increase", "size", "accompanied", "increase", "cognitive", "complexity", "make", "harder", "human", "read", "proof", "written", "clause", "another", "disadvantage", "syntactic", "structure", "formula", "standard", "logic", "notation", "used", "guide", "construction", "proof", "information", "completely", "lost", "transformation", "clausal", "form", "2", "deduction", "calculus", "third", "important", "consideration", "building", "automated", "reasoning", "program", "selection", "actual", "deduction", "calculus", "used", "program", "perform", "inference", "indicated", "choice", "highly", "dependent", "nature", "problem", "domain", "fair", "range", "option", "available", "generalpurpose", "theorem", "proving", "problem", "solving", "firstorder", "logic", "simple", "type", "theory", "program", "verification", "firstorder", "logic", "distributed", "concurrent", "system", "modal", "temporal", "logic", "program", "specification", "intuitionistic", "logic", "hardware", "verification", "higherorder", "logic", "logic", "programming", "horn", "logic", "constraint", "satisfaction", "propositional", "clausal", "logic", "computational", "metaphysics", "higherorder", "modal", "logic", "others", "deduction", "calculus", "consists", "set", "logical", "axiom", "collection", "deduction", "rule", "deriving", "new", "formula", "previously", "derived", "formula", "solving", "problem", "program", "problem", "domain", "really", "mean", "establishing", "particular", "formula", "\u03b1the", "problem", "conclusionfrom", "extended", "set", "\u03b3", "consisting", "logical", "axiom", "domain", "axiom", "problem", "assumption", "program", "need", "determine", "\u03b3", "entail", "\u03b1", "\u03b3", "\u03b1", "program", "go", "establishing", "semantic", "fact", "depends", "course", "calculus", "implement", "program", "may", "take", "direct", "route", "attempt", "establish", "\u03b3", "\u03b1", "actually", "constructing", "stepbystep", "proof", "\u03b1", "\u03b3", "successful", "show", "course", "\u03b3", "derivesproves\u03b1", "fact", "denote", "writing", "\u03b3", "\u03b1", "reasoning", "program", "may", "instead", "opt", "indirect", "approach", "try", "establish", "\u03b3", "\u03b1", "showing", "\u03b3", "\u03b1", "inconsistent", "turn", "shown", "deriving", "contradiction", "set", "\u03b3", "\u03b1", "automated", "system", "implement", "former", "approach", "include", "natural", "deduction", "system", "latter", "approach", "used", "system", "based", "resolution", "sequent", "deduction", "matrix", "connection", "method", "soundness", "completeness", "two", "metatheoretical", "property", "calculus", "particularly", "important", "automated", "deduction", "soundness", "state", "rule", "calculus", "truthpreserving", "direct", "calculus", "mean", "\u03b3", "\u03b1", "\u03b3", "\u03b1", "indirect", "calculus", "soundness", "mean", "\u03b3", "\u03b1", "\u03b3", "\u03b1", "completeness", "direct", "calculus", "state", "\u03b3", "\u03b1", "\u03b3", "\u03b1", "indirect", "calculus", "completeness", "property", "expressed", "term", "refutation", "since", "one", "establishes", "\u03b3", "\u03b1", "showing", "existence", "proof", "\u03b1", "\u03b3", "\u03b3", "\u03b1", "thus", "indirect", "calculus", "refutation", "complete", "\u03b3", "\u03b1", "implies", "\u03b3", "\u03b1", "two", "property", "soundness", "desirable", "incomplete", "calculus", "indicates", "entailment", "relation", "established", "within", "calculus", "automated", "reasoning", "program", "mean", "informally", "true", "statement", "program", "prove", "incompleteness", "may", "unfortunate", "affair", "lack", "soundness", "truly", "problematic", "situation", "since", "unsound", "reasoning", "program", "would", "able", "generate", "false", "conclusion", "perfectly", "true", "information", "important", "appreciate", "difference", "logical", "calculus", "corresponding", "implementation", "reasoning", "program", "implementation", "calculus", "invariably", "involves", "making", "modification", "calculus", "result", "strictly", "speaking", "new", "calculus", "important", "modification", "original", "calculus", "mechanization", "deduction", "rule", "specification", "systematic", "way", "rule", "applied", "process", "one", "must", "exercise", "care", "preserve", "metatheoretical", "property", "original", "calculus", "two", "metatheoretical", "property", "importance", "automated", "deduction", "decidability", "complexity", "calculus", "decidable", "admits", "algorithmic", "representation", "algorithm", "given", "\u03b3", "\u03b1", "determine", "finite", "amount", "time", "answer", "yes", "question", "\u03b3", "\u03b1", "calculus", "may", "undecidable", "case", "one", "need", "determine", "decidable", "fragment", "implement", "timespace", "complexity", "calculus", "specifies", "efficient", "algorithmic", "representation", "automated", "reasoning", "made", "challenging", "many", "calculus", "interest", "decidable", "poor", "complexity", "measure", "forcing", "researcher", "seek", "tradeoff", "deductive", "power", "versus", "algorithmic", "efficiency", "21", "resolution", "many", "calculus", "used", "implementation", "reasoning", "program", "one", "based", "resolution", "principle", "popular", "resolution", "modeled", "chain", "rule", "modus", "ponens", "special", "case", "essentially", "state", "p", "q", "q", "r", "one", "infer", "p", "r", "formally", "let", "c", "l", "denote", "clause", "c", "literal", "l", "removed", "assume", "c1", "c2", "ground", "clause", "containing", "respectively", "positive", "literal", "l1", "negative", "literal", "l2", "l1", "l2", "complementary", "rule", "ground", "resolution", "state", "result", "resolving", "c1", "c2", "one", "infer", "c1", "l1", "c2", "l2", "c1", "c2", "ground", "resolution", "c1", "l1", "c2", "l2", "herbrand", "theorem", "herbrand", "1930", "assures", "u", "nonsatisfiability", "set", "clause", "ground", "established", "using", "ground", "resolution", "significant", "result", "automated", "deduction", "since", "tell", "u", "set", "\u03b3", "satisfied", "infinitely", "many", "interpretation", "fact", "determined", "finitely", "many", "step", "unfortunately", "direct", "implementation", "ground", "resolution", "using", "herbrand", "theorem", "requires", "generation", "vast", "number", "ground", "term", "making", "approach", "hopelessly", "inefficient", "issue", "effectively", "addressed", "generalizing", "ground", "resolution", "rule", "binary", "resolution", "introducing", "notion", "unification", "robinson", "1965a", "unification", "allows", "resolution", "proof", "lifted", "conducted", "general", "level", "clause", "need", "instantiated", "moment", "resolved", "moreover", "clause", "resulting", "instantiation", "process", "ground", "instance", "may", "still", "contain", "variable", "introduction", "binary", "resolution", "unification", "considered", "one", "important", "development", "field", "automated", "reasoning", "unification", "unifier", "two", "expressionsterms", "clausesis", "substitution", "applied", "expression", "make", "equal", "example", "substitution", "\u03c3", "given", "\u03c3", "x", "b", "b", "z", "f", "b", "unifier", "r", "x", "f", "r", "b", "z", "since", "applied", "expression", "make", "equal", "r", "x", "f", "\u03c3", "r", "b", "f", "b", "r", "b", "z", "\u03c3", "general", "unifier", "mgu", "produce", "general", "instance", "shared", "two", "unifiable", "expression", "previous", "example", "substitution", "x", "b", "b", "z", "f", "b", "unifier", "mgu", "however", "x", "b", "z", "f", "mgu", "note", "unification", "attempt", "match", "two", "expression", "fundamental", "process", "become", "central", "component", "automated", "deduction", "program", "resolutionbased", "otherwise", "theoryunification", "extension", "unification", "mechanism", "includes", "builtin", "inference", "capability", "example", "clause", "r", "g", "b", "x", "r", "g", "b", "unify", "acunify", "acunification", "unification", "builtin", "associative", "commutative", "rule", "g", "b", "g", "b", "shifting", "inference", "capability", "unification", "mechanism", "add", "power", "price", "existence", "mgu", "two", "unifiable", "expression", "may", "unique", "could", "actually", "infinitely", "many", "unification", "process", "becomes", "undecidable", "general", "binary", "resolution", "let", "c1", "c2", "two", "clause", "containing", "respectively", "positive", "literal", "l1", "negative", "literal", "l2", "l1", "l2", "unify", "mgu", "\u03b8", "c1", "c2", "binary", "resolution", "c1\u03b8", "l1\u03b8", "c2\u03b8", "l2\u03b8", "binary", "resolution", "clause", "c1\u03b8", "l1\u03b8", "c2\u03b8", "l2\u03b8", "called", "binary", "resolvent", "c1", "c2", "factoring", "two", "literal", "occurring", "clause", "c", "share", "mgu", "\u03b8", "c\u03b8", "factor", "c", "example", "r", "x", "k", "f", "x", "b", "r", "c", "literal", "r", "x", "r", "c", "unify", "mgu", "x", "c", "hence", "r", "c", "k", "f", "c", "b", "factor", "original", "clause", "resolution", "principle", "let", "c1and", "c2", "two", "clause", "resolvent", "obtained", "resolution", "c1", "c2", "defined", "binary", "resolvent", "c1", "c2", "b", "binary", "resolvent", "c1", "factor", "c2", "c", "binary", "resolvent", "factor", "c1", "c2", "binary", "resolvent", "factor", "c1", "factor", "c2", "resolution", "proof", "precisely", "refutation", "constructed", "deriving", "empty", "clause", "\u03b3", "\u03b1", "using", "resolution", "always", "possible", "\u03b3", "\u03b1", "unsatisfiable", "since", "resolution", "refutation", "complete", "robinson", "1965a", "example", "resolution", "proof", "show", "set", "x", "p", "x", "q", "x", "x", "p", "x", "r", "x", "x", "q", "x", "r", "x", "denoted", "\u03b3", "entail", "formula", "xr", "x", "first", "step", "find", "clausal", "form", "\u03b3", "xr", "x", "resulting", "clause", "set", "denoted", "s0", "shown", "step", "1", "4", "refutation", "refutation", "constructed", "using", "levelsaturation", "method", "compute", "resolvent", "initial", "set", "s0", "add", "set", "repeat", "process", "empty", "clause", "derived", "produce", "sequence", "increasingly", "larger", "set", "s0", "s1", "s2", "constraint", "impose", "resolve", "two", "clause", "s0", "1", "p", "x", "q", "x", "assumption", "2", "p", "x", "r", "x", "assumption", "3", "q", "x", "r", "x", "assumption", "4", "r", "negate", "conclusion", "s1", "5", "q", "x", "r", "x", "re", "1", "2", "6", "p", "x", "r", "x", "re", "1", "3", "7", "p", "re", "2", "4", "8", "q", "re", "3", "4", "s2", "9", "q", "re", "1", "7", "10", "p", "re", "1", "8", "11", "r", "x", "re", "2", "6", "12", "r", "x", "re", "3", "5", "13", "q", "re", "4", "5", "14", "p", "re", "4", "6", "15", "r", "re", "5", "8", "16", "r", "re", "6", "7", "s3", "17", "r", "re", "2", "10", "18", "r", "re", "2", "14", "19", "r", "re", "3", "9", "20", "r", "re", "3", "13", "21", "re", "4", "11", "although", "resolution", "proof", "successful", "deriving", "significant", "drawback", "start", "refutation", "long", "take", "21", "step", "reach", "contradiction", "due", "na\u00efve", "bruteforce", "nature", "implementation", "approach", "generates", "many", "formula", "clearly", "redundant", "note", "r", "derived", "six", "time", "also", "r", "x", "information", "content", "r", "one", "keep", "former", "disregard", "latter", "resolution", "like", "automated", "deduction", "method", "must", "supplemented", "strategy", "aimed", "improving", "efficiency", "deduction", "process", "sample", "derivation", "21", "step", "researchtype", "problem", "command", "derivation", "thousand", "hundred", "thousand", "step", "resolution", "strategy", "successful", "implementation", "deduction", "calculus", "automated", "reasoning", "program", "requires", "integration", "search", "strategy", "reduce", "search", "space", "pruning", "unnecessary", "deduction", "path", "strategy", "remove", "redundant", "clause", "tautology", "soon", "appear", "derivation", "another", "strategy", "remove", "specific", "clause", "presence", "general", "one", "process", "known", "subsumption", "robinson", "1965a", "unrestricted", "subsumption", "however", "preserve", "refutation", "completeness", "resolution", "hence", "need", "restrict", "applicability", "loveland", "1978", "model", "elimination", "loveland", "1969", "discard", "sentence", "showing", "false", "model", "axiom", "subject", "model", "generation", "received", "much", "attention", "complementary", "process", "theorem", "proving", "method", "used", "successfully", "automated", "reasoning", "program", "show", "independence", "axiom", "set", "determine", "existence", "discrete", "mathematical", "structure", "meeting", "given", "criterion", "instead", "removing", "redundant", "clause", "strategy", "prevent", "generation", "useless", "clause", "first", "place", "setofsupport", "strategy", "wos", "carson", "robinson", "1965", "one", "powerful", "strategy", "kind", "subset", "set", "initially", "\u03b3", "\u03b1", "called", "set", "support", "iff", "satisfiable", "setofsupport", "resolution", "dictate", "resolved", "clause", "t", "motivation", "behind", "setofsupport", "since", "set", "\u03b3", "usually", "satisfiable", "might", "wise", "resolve", "two", "clause", "\u03b3", "hyperresolution", "robinson", "1965b", "reduces", "number", "intermediate", "resolvent", "combining", "several", "resolution", "step", "single", "inference", "step", "independently", "codiscovered", "linear", "resolution", "loveland", "1970", "luckham", "1970", "always", "resolve", "clause", "recently", "derived", "resolvent", "give", "deduction", "simple", "linear", "structure", "affording", "straightforward", "implementation", "yet", "linear", "resolution", "preserve", "refutation", "completeness", "using", "linear", "resolution", "derive", "empty", "clause", "example", "eight", "step", "1", "p", "x", "q", "x", "assumption", "2", "p", "x", "r", "x", "assumption", "3", "q", "x", "r", "x", "assumption", "4", "r", "negated", "conclusion", "5", "p", "re", "2", "4", "6", "q", "re", "1", "5", "7", "r", "re", "3", "6", "8", "re", "4", "7", "exception", "unrestricted", "subsumption", "strategy", "mentioned", "far", "preserve", "refutation", "completeness", "efficiency", "important", "consideration", "automated", "reasoning", "one", "may", "sometimes", "willing", "trade", "completeness", "speed", "unit", "resolution", "input", "resolution", "two", "refinement", "linear", "resolution", "former", "one", "resolved", "clause", "always", "literal", "latter", "one", "resolved", "clause", "always", "selected", "original", "set", "refuted", "albeit", "efficient", "neither", "strategy", "complete", "ordering", "strategy", "impose", "form", "partial", "ordering", "predicate", "symbol", "term", "literal", "clause", "occurring", "deduction", "ordered", "resolution", "treat", "clause", "set", "literal", "sequenceslinear", "ordersof", "literal", "ordered", "resolution", "extremely", "efficient", "like", "unit", "input", "resolution", "refutation", "complete", "end", "must", "noted", "strategy", "improve", "certain", "aspect", "deduction", "process", "expense", "others", "instance", "strategy", "may", "reduce", "size", "proof", "search", "space", "expense", "increasing", "say", "length", "shortest", "refutation", "taxonomy", "detailed", "presentation", "theoremproving", "strategy", "found", "bonacina", "1999", "several", "automated", "reasoning", "program", "based", "resolution", "refinement", "resolution", "otter", "succeeded", "prover4", "driving", "force", "development", "automated", "reasoning", "wos", "overbeek", "lusk", "boyle", "1984", "superseded", "capable", "program", "like", "vampire", "voronkov", "1995", "kov\u00e1cs", "voronkov", "2013", "resolution", "also", "provides", "underlying", "logicocomputational", "mechanism", "popular", "logic", "programming", "language", "prolog", "clocksin", "mellish", "1981", "22", "sequent", "deduction", "hilbertstyle", "calculus", "hilbert", "ackermann", "1928", "traditionally", "used", "characterize", "logic", "system", "calculus", "usually", "consist", "axiom", "schema", "small", "number", "rule", "typically", "include", "modus", "ponens", "rule", "substitution", "although", "meet", "required", "theoretical", "requisite", "soundness", "completeness", "etc", "approach", "proof", "construction", "calculus", "difficult", "reflect", "standard", "practice", "gentzen", "goal", "set", "formalism", "reflects", "accurately", "possible", "actual", "logical", "reasoning", "involved", "mathematical", "proof", "gentzen", "1935", "carry", "task", "gentzen", "analyzed", "proofconstruction", "process", "devised", "two", "deduction", "calculus", "classical", "logic", "natural", "deduction", "calculus", "nk", "sequent", "calculus", "lk", "gentzen", "actually", "designed", "nk", "first", "introduced", "lk", "pursue", "metatheoretical", "investigation", "calculus", "met", "goal", "large", "extent", "time", "managing", "secure", "soundness", "completeness", "calculus", "characterized", "relatively", "larger", "number", "deduction", "rule", "simple", "axiom", "schema", "two", "calculus", "lk", "one", "widely", "used", "implementation", "automated", "reasoning", "program", "one", "discus", "first", "nk", "discussed", "next", "section", "although", "application", "lk", "rule", "affect", "logic", "formula", "rule", "seen", "manipulating", "logic", "formula", "sequents", "sequents", "expression", "form", "\u03b3", "\u03b4", "\u03b3", "\u03b4", "possibly", "empty", "set", "formula", "\u03b3", "sequent", "antecedent", "\u03b4", "succedent", "sequents", "interpreted", "thus", "let", "interpretation", "satisfies", "sequent", "\u03b3", "\u03b4", "written", "\u03b3\u03b4", "iff", "either", "\u03b1", "\u03b1", "\u03b3", "\u03b2", "\u03b2", "\u03b4", "word", "\u03b3", "\u03b4", "iff", "\u03b11", "\u03b1n", "\u03b21", "\u03b2n", "\u03b11", "\u03b1n", "iterated", "conjunction", "formula", "\u03b3", "\u03b21", "\u03b2n", "iterated", "disjunction", "\u03b4", "\u03b3", "\u03b4", "empty", "respectively", "valid", "unsatisfiable", "axiom", "lk", "sequent", "\u03b3", "\u03b4", "\u03b3", "\u03b4", "thus", "requirement", "formula", "occurs", "side", "sign", "mean", "axiom", "lk", "valid", "interpretation", "make", "formula", "\u03b3", "true", "simultaneously", "make", "\u03b4", "false", "lk", "two", "rule", "per", "logical", "connective", "plus", "one", "extra", "rule", "cut", "rule", "axiom", "cut", "rule", "\u03b3", "\u03b1", "\u03b4", "\u03b1", "\u03b3", "\u03b4", "\u03b1", "\u03b1", "\u03bb", "\u03c3", "\u03b3", "\u03bb", "\u03b4", "\u03c3", "antecedent", "rule", "\u03b8", "succedent", "rule", "\u03b8", "\u03b3", "\u03b1", "\u03b2", "\u03b4", "\u03b3", "\u03b1", "\u03b2", "\u03b4", "\u03b3", "\u03b4", "\u03b1", "\u03b3", "\u03b4", "\u03b2", "\u03b3", "\u03b4", "\u03b1", "\u03b2", "\u03b3", "\u03b1", "\u03b4", "\u03b3", "\u03b2", "\u03b4", "\u03b3", "\u03b1", "\u03b2", "\u03b4", "\u03b3", "\u03b4", "\u03b1", "\u03b2", "\u03b3", "\u03b4", "\u03b1", "\u03b2", "\u03b3", "\u03b4", "\u03b1", "\u03b3", "\u03b2", "\u03b4", "\u03b3", "\u03b1", "\u03b2", "\u03b4", "\u03b3", "\u03b1", "\u03b4", "\u03b2", "\u03b3", "\u03b4", "\u03b1", "\u03b2", "\u03b3", "\u03b1", "\u03b2", "\u03b4", "\u03b3", "\u03b4", "\u03b1", "\u03b2", "\u03b3", "\u03b1", "\u03b2", "\u03b4", "\u03b3", "\u03b1", "\u03b4", "\u03b2", "\u03b3", "\u03b2", "\u03b4", "\u03b1", "\u03b3", "\u03b4", "\u03b1", "\u03b2", "\u03b3", "\u03b4", "\u03b1", "\u03b3", "\u03b1", "\u03b4", "\u03b3", "\u03b1", "\u03b4", "\u03b3", "\u03b4", "\u03b1", "\u03b3", "\u03b1", "ax", "\u03b4", "\u03b3", "x\u03b1", "x", "\u03b4", "\u03b3", "\u03b4", "\u03b1", "tx", "x\u03b1", "x", "\u03b3", "\u03b4", "x\u03b1", "x", "\u03b3", "\u03b1", "tx", "x\u03b1", "x", "\u03b4", "\u03b3", "x\u03b1", "x", "\u03b4", "\u03b3", "\u03b4", "\u03b1", "ax", "\u03b3", "\u03b4", "x\u03b1", "x", "sequents", "rule", "line", "called", "rule", "premise", "sequent", "line", "rule", "conclusion", "quantification", "rule", "eigenvariable", "condition", "restricts", "applicability", "namely", "must", "occur", "\u03b3", "\u03b4", "quantified", "sentence", "purpose", "restriction", "ensure", "choice", "parameter", "used", "substitution", "process", "completely", "arbitrary", "proof", "lk", "represented", "tree", "node", "tree", "labeled", "sequent", "original", "sequent", "sits", "root", "tree", "child", "node", "premise", "rule", "applied", "node", "leaf", "tree", "labeled", "axiom", "lkproof", "xr", "x", "set", "x", "p", "x", "q", "x", "x", "p", "x", "r", "x", "x", "q", "x", "r", "x", "tree", "\u03b3", "stand", "set", "\u03b3", "p", "p", "r", "xr", "x", "\u03b3", "p", "r", "r", "xr", "x", "\u03b3", "p", "p", "r", "r", "xr", "x", "\u03b3", "p", "r", "xr", "x", "\u03b3", "q", "q", "r", "xr", "x", "\u03b3", "q", "r", "r", "xr", "x", "\u03b3", "q", "q", "r", "r", "xr", "x", "\u03b3", "q", "r", "xr", "x", "\u03b3", "p", "q", "r", "xr", "x", "\u03b3", "r", "xr", "x", "\u03b3", "xr", "x", "example", "leaf", "proof", "tree", "labeled", "axiom", "establishes", "validity", "\u03b3", "xr", "x", "hence", "fact", "\u03b3", "xr", "x", "lk", "take", "indirect", "approach", "proving", "conclusion", "important", "difference", "lk", "nk", "nk", "construct", "actual", "proof", "conclusion", "given", "assumption", "lk", "instead", "construct", "proof", "prof", "existence", "proof", "conclusion", "assumption", "instance", "prove", "\u03b1", "entailed", "\u03b3", "nk", "construct", "stepbystep", "proof", "\u03b1", "\u03b3", "assuming", "one", "exists", "contrast", "lk", "first", "construct", "sequent", "\u03b3", "\u03b1", "attempt", "prove", "valid", "showing", "made", "false", "done", "searching", "counterexample", "make", "sentence", "\u03b3", "true", "make", "\u03b1", "false", "search", "fails", "counterexample", "exist", "sequent", "therefore", "valid", "respect", "proof", "tree", "lk", "actually", "refutation", "proof", "like", "resolution", "lk", "refutation", "complete", "\u03b3", "\u03b1", "sequent", "\u03b3", "\u03b1", "proof", "tree", "stand", "lk", "unsuitable", "automated", "deduction", "obstacle", "must", "overcome", "efficiently", "implemented", "reason", "course", "statement", "completeness", "lk", "assert", "entailment", "relation", "existence", "proof", "tree", "reasoning", "program", "difficult", "task", "actually", "construct", "one", "main", "obstacle", "first", "lk", "specify", "order", "rule", "must", "applied", "construction", "proof", "tree", "second", "particular", "case", "first", "problem", "premise", "rule", "rule", "inherit", "quantificational", "formula", "rule", "applied", "meaning", "rule", "applied", "repeatedly", "formula", "sending", "proof", "search", "endless", "loop", "third", "lk", "indicate", "formula", "must", "selected", "next", "application", "rule", "fourth", "quantifier", "rule", "provide", "indication", "term", "free", "variable", "must", "used", "deployment", "fifth", "particular", "case", "previous", "problem", "application", "quantifier", "rule", "lead", "infinitely", "long", "tree", "branch", "proper", "term", "used", "instantiation", "never", "get", "chosen", "fortunately", "hint", "problem", "successfully", "addressed", "axiom", "sequents", "lk", "valid", "conclusion", "rule", "valid", "iff", "premise", "fact", "allows", "u", "apply", "lk", "rule", "either", "direction", "forward", "axiom", "conclusion", "backwards", "conclusion", "axiom", "also", "exception", "cut", "rule", "rule", "premise", "subformulas", "respective", "conclusion", "purpose", "automated", "deduction", "significant", "fact", "would", "want", "dispense", "cut", "rule", "fortunately", "cutfree", "version", "lk", "preserve", "refutation", "completeness", "gentzen", "1935", "result", "provide", "strong", "case", "constructing", "proof", "tree", "backwards", "fashion", "indeed", "working", "way", "refutation", "cutfree", "lk", "get", "increasingly", "simpler", "progress", "since", "subformulas", "simpler", "parent", "formula", "moreover", "far", "propositional", "rule", "go", "new", "subformulas", "entered", "tree", "completely", "dictated", "cutfree", "lk", "rule", "furthermore", "assuming", "proof", "tree", "brought", "completion", "branch", "eventually", "end", "atom", "presence", "axiom", "quickly", "determined", "another", "reason", "working", "backwards", "truthfunctional", "fragment", "cutfree", "lk", "confluent", "sense", "order", "nonquantifier", "rule", "applied", "irrelevant", "proof", "regardless", "run", "bring", "quantifier", "rule", "picture", "thing", "arranged", "rule", "fair", "chance", "deployed", "apply", "far", "possible", "nonquantifier", "rule", "applying", "quantifier", "rule", "take", "care", "first", "second", "obstacle", "difficult", "see", "third", "one", "would", "handled", "fourth", "fifth", "obstacle", "addressed", "requiring", "term", "used", "substitution", "suitably", "selected", "herbrand", "universe", "herbrand", "1930", "use", "sequenttype", "calculus", "automated", "theorem", "proving", "initiated", "effort", "mechanize", "mathematics", "wang", "1960", "time", "resolution", "captured", "attention", "automated", "reasoning", "community", "1970s", "researcher", "started", "investigate", "nonresolution", "method", "bledsoe", "1977", "prompting", "frutiful", "sustained", "effort", "develop", "humanoriented", "theorem", "proving", "system", "bledsoe", "1975", "nevins", "1974", "eventually", "sequenttype", "deduction", "gained", "momentum", "particularly", "reincarnation", "analytic", "tableau", "fitting", "1990", "method", "deduction", "used", "tableau", "essentially", "cutfree", "lk", "set", "used", "lieu", "sequents", "23", "natural", "deduction", "although", "lk", "nk", "commonly", "labeled", "natural", "deduction", "system", "latter", "better", "deserves", "title", "due", "natural", "humanlike", "approach", "proof", "construction", "rule", "nk", "typically", "presented", "acting", "standard", "logic", "formula", "implicitly", "understood", "context", "also", "commonly", "given", "literature", "acting", "explicitly", "judgement", "expression", "form", "\u03b3", "\u03b1", "\u03b3", "set", "formula", "\u03b1", "formula", "form", "typically", "understood", "making", "metastatement", "proof", "\u03b1", "\u03b3", "kleene", "1962", "following", "gentzen", "1935", "prawitz", "1965", "take", "former", "approach", "system", "nk", "logical", "axiom", "provides", "two", "introductionelimination", "rule", "logical", "connective", "introduction", "rule", "\u03b8i", "elimination", "rule", "\u03b8e", "\u03b1", "\u03b2", "\u03b1", "\u03b2", "e", "\u03b11", "\u03b12", "\u03b1i", "12", "i", "\u03b1i", "12", "\u03b11", "\u03b12", "e", "\u03b1", "\u03b2", "\u03b1", "\u03b3", "\u03b2", "\u03b3", "\u03b3", "i", "\u03b1", "\u03b2", "\u03b1", "\u03b2", "e", "\u03b1", "\u03b1", "\u03b2", "\u03b2", "i", "\u03b1", "\u03b2", "\u03b2", "\u03b1", "\u03b1", "\u03b2", "e", "\u03b1i", "01", "\u03b10", "\u03b11", "\u03b11i", "i", "\u03b1", "\u03b1", "e", "\u03b1", "\u03b1", "i", "\u03b1", "tx", "x\u03b1", "x", "e", "x\u03b1", "x", "\u03b1", "ax", "\u03b2", "\u03b2", "i", "\u03b1", "ax", "x\u03b1", "x", "e", "x\u03b1", "x", "\u03b1", "tx", "remark", "first", "expression", "\u03b1", "\u03b3", "represents", "fact", "\u03b1", "auxiliary", "assumption", "proof", "\u03b3", "eventually", "get", "discharged", "ie", "discarded", "example", "e", "tell", "u", "process", "constructing", "proof", "one", "already", "derived", "x\u03b1", "x", "also", "\u03b2", "\u03b1", "ax", "auxiliary", "assumption", "inference", "\u03b2", "allowed", "second", "eigenparameter", "e", "i", "must", "foreign", "premise", "undischarged", "active", "assumptions", "rule", "conclusion", "case", "e", "x\u03b1", "x", "third", "shorthand", "two", "contradictory", "formula", "\u03b2", "\u03b2", "finally", "nk", "complete", "\u03b3", "\u03b1", "proof", "\u03b1", "\u03b3", "using", "rule", "nk", "lk", "proof", "constructed", "nk", "represented", "tree", "proof", "conclusion", "sitting", "root", "tree", "problem", "assumption", "sitting", "leaf", "proof", "also", "typically", "given", "sequence", "judgement", "\u03b3", "\u03b1", "running", "top", "bottom", "printed", "page", "natural", "deduction", "proof", "tree", "xr", "x", "x", "p", "x", "q", "x", "x", "p", "x", "r", "x", "x", "q", "x", "r", "x", "x", "p", "x", "q", "x", "p", "q", "x", "p", "x", "r", "x", "p", "r", "p", "r", "r", "x", "q", "x", "r", "x", "q", "r", "q", "r", "r", "r", "xr", "x", "lk", "forwardchaining", "strategy", "proof", "construction", "well", "focused", "although", "proof", "read", "forward", "leaf", "root", "logically", "speaking", "assumption", "conclusion", "way", "typically", "constructed", "backwardchaining", "strategy", "implemented", "applying", "rule", "reverse", "order", "effective", "many", "obstacle", "discussed", "implementation", "sequent", "deduction", "applicable", "natural", "deduction", "well", "issue", "handled", "similar", "way", "natural", "deduction", "introduces", "issue", "example", "suggested", "introduction", "rule", "prove", "goal", "form", "\u03b1", "\u03b2", "one", "could", "attempt", "prove", "\u03b2", "assumption", "\u03b1", "note", "although", "goal", "\u03b1", "\u03b2", "match", "conclusion", "introduction", "rule", "match", "conclusion", "elimination", "rule", "reasoning", "program", "would", "need", "consider", "route", "similarly", "forwardchaining", "risk", "setting", "goal", "irrelevant", "proof", "could", "lead", "program", "astray", "wit", "prevents", "program", "entering", "neverending", "process", "building", "say", "larger", "larger", "conjunction", "prevent", "uncontrolled", "chain", "backward", "application", "say", "elimination", "fortunately", "nk", "enjoys", "subformula", "property", "sense", "formula", "entering", "natural", "deduction", "proof", "restricted", "subformula", "\u03b3", "\u03b4", "\u03b1", "\u03b4", "set", "auxiliary", "assumption", "made", "elimination", "rule", "exploiting", "subformula", "property", "natural", "deduction", "automated", "theorem", "prover", "drastically", "reduce", "search", "space", "bring", "backward", "application", "elimination", "rule", "control", "portoraro", "1998", "sieg", "byrnes", "1996", "gain", "realized", "one", "willing", "restrict", "scope", "nk", "logic", "intuitionistic", "fragment", "every", "proof", "normal", "form", "sense", "formula", "obtained", "introduction", "rule", "eliminated", "elimination", "rule", "prawitz", "1965", "implementation", "automated", "theorem", "proving", "system", "using", "nk", "deduction", "motivated", "desire", "program", "reason", "precisely", "proof", "format", "method", "employed", "human", "user", "particularly", "true", "area", "education", "student", "engaged", "interactive", "construction", "formal", "proof", "nklike", "calculus", "working", "guidance", "theorem", "prover", "ready", "provide", "assistance", "needed", "portoraro", "1994", "suppes", "1981", "researchoriented", "theorem", "provers", "true", "spirit", "nk", "exist", "pelletier", "1998", "rare", "24", "matrix", "connection", "method", "name", "matrix", "connection", "method", "bibel", "1981", "indicative", "way", "operates", "term", "matrix", "refers", "form", "set", "logic", "formula", "expressing", "problem", "represented", "term", "connection", "refers", "way", "method", "operates", "formula", "illustrate", "method", "work", "use", "example", "propositional", "logic", "show", "r", "entailed", "p", "q", "p", "r", "q", "r", "done", "establishing", "formula", "p", "q", "p", "r", "q", "r", "r", "unsatisfiable", "begin", "transforming", "conjunctive", "normal", "form", "p", "q", "p", "r", "q", "r", "r", "formula", "represented", "matrix", "one", "conjunct", "per", "row", "within", "row", "one", "disjunct", "per", "column", "p", "q", "p", "r", "q", "r", "r", "idea", "explore", "possible", "vertical", "path", "running", "matrix", "vertical", "path", "set", "literal", "selected", "row", "matrix", "literal", "come", "different", "row", "vertical", "path", "path", "1", "p", "p", "q", "r", "path", "2", "p", "p", "r", "r", "path", "3", "p", "r", "q", "r", "path", "4", "p", "r", "r", "r", "path", "5", "q", "p", "q", "r", "path", "6", "q", "p", "r", "r", "path", "7", "q", "r", "q", "r", "path", "8", "q", "r", "r", "r", "path", "complementary", "contains", "two", "literal", "complementary", "example", "path", "2", "complementary", "since", "p", "p", "path", "6", "since", "contains", "r", "r", "note", "soon", "path", "includes", "two", "complementary", "literal", "point", "pursuing", "path", "since", "become", "complementary", "typically", "allows", "large", "reduction", "number", "path", "inspected", "event", "path", "matrix", "complementary", "fact", "establishes", "unsatisfiability", "original", "formula", "essence", "matrix", "connection", "method", "method", "extended", "predicate", "logic", "demand", "additional", "logical", "apparatus", "skolemnization", "variable", "renaming", "quantifier", "duplication", "complementarity", "path", "via", "unification", "simultaneous", "substitution", "across", "matrix", "path", "bibel", "1981", "andrew", "1981", "variation", "method", "implemented", "reasoning", "program", "higherorder", "logic", "andrew", "1981", "nonclassical", "logic", "wallen", "1990", "25", "term", "rewriting", "equality", "important", "logical", "relation", "whose", "behavior", "within", "automated", "deduction", "deserves", "separate", "treatment", "equational", "logic", "generally", "term", "rewriting", "treat", "equalitylike", "equation", "rewrite", "rule", "also", "known", "reduction", "demodulation", "rule", "equality", "statement", "like", "f", "allows", "simplification", "term", "like", "g", "c", "f", "g", "c", "however", "equation", "also", "potential", "generate", "unboundedly", "large", "term", "g", "c", "f", "g", "c", "f", "f", "g", "c", "f", "f", "f", "distinguishes", "term", "rewriting", "equational", "logic", "term", "rewriting", "equation", "used", "unidirectional", "reduction", "rule", "opposed", "equality", "work", "direction", "rewrite", "rule", "form", "t1", "t2", "basic", "idea", "look", "term", "occurring", "expression", "e", "unifies", "t1", "unifier", "\u03b8", "occurrence", "t1\u03b8", "e\u03b8", "replaced", "t2\u03b8", "example", "rewrite", "rule", "x", "0", "x", "allows", "rewriting", "succ", "succ", "0", "0", "succ", "succ", "0", "illustrate", "main", "idea", "term", "rewriting", "let", "u", "explore", "example", "involving", "symbolic", "differentiation", "example", "ensuing", "discussion", "adapted", "chapter", "1", "baader", "nipkow", "1998", "let", "der", "denote", "derivative", "respect", "x", "let", "variable", "different", "x", "let", "u", "v", "variable", "ranging", "expression", "define", "rewrite", "system", "r1", "der", "x", "1", "r2", "der", "0", "r3", "der", "u", "v", "der", "u", "der", "v", "r4", "der", "u", "v", "u", "der", "v", "der", "u", "v", "symbol", "indicates", "term", "matching", "lefthand", "side", "rewrite", "rule", "replaced", "rule", "righthand", "side", "see", "differentiation", "system", "work", "let", "u", "compute", "derivative", "x", "x", "respect", "x", "der", "x", "x", "der", "x", "x", "x", "der", "x", "der", "x", "x", "r4", "x", "1", "der", "x", "x", "r1", "x", "1", "1", "x", "r1", "point", "since", "none", "rule", "r1", "r4", "applies", "reduction", "possible", "rewriting", "process", "end", "final", "expression", "obtained", "called", "normal", "form", "existence", "motivates", "following", "question", "expression", "whose", "reduction", "process", "never", "terminate", "applying", "rule", "r1", "r4", "generally", "condition", "set", "rewrite", "rule", "always", "stop", "given", "expression", "normal", "form", "finitely", "many", "application", "rule", "fundamental", "question", "called", "termination", "problem", "rewrite", "system", "state", "without", "proof", "system", "r1", "r4", "meet", "termination", "condition", "possibility", "reducing", "expression", "set", "rule", "rewrite", "system", "could", "applied", "one", "way", "actually", "case", "system", "r1", "r4", "reduction", "der", "x", "x", "could", "applied", "r1", "first", "second", "subexpression", "x", "der", "x", "der", "x", "x", "shown", "der", "x", "x", "x", "der", "x", "der", "x", "x", "r4", "x", "der", "x", "1", "x", "r1", "x", "1", "1", "x", "r1", "following", "alternative", "course", "action", "reduction", "terminates", "normal", "form", "previous", "case", "fact", "however", "taken", "granted", "rewriting", "system", "said", "globally", "confluent", "independently", "order", "rule", "applied", "every", "expression", "always", "end", "reduced", "one", "normal", "form", "shown", "r1", "r4", "confluent", "hence", "entitled", "say", "compute", "derivative", "expression", "opposed", "simply", "derivative", "adding", "rule", "system", "effort", "make", "practical", "undesired", "consequence", "example", "add", "rule", "r5", "u", "0", "u", "r1", "r4", "able", "reduce", "certain", "expression", "price", "losing", "confluency", "following", "reduction", "show", "der", "x", "0", "two", "normal", "form", "computation", "der", "x", "0", "der", "x", "der", "0", "r3", "1", "der", "0", "r1", "give", "one", "normal", "form", "der", "x", "0", "der", "x", "r5", "1", "r1", "give", "another", "adding", "rule", "r6", "der", "0", "0", "would", "allow", "reduction", "1", "der", "0", "1", "0", "r5", "1", "although", "presence", "new", "rule", "actually", "increase", "number", "alternative", "pathsder", "x", "0", "reduced", "four", "possible", "waysthey", "end", "normal", "form", "namely", "1", "coincidence", "shown", "r6", "actually", "restores", "confluency", "motivates", "another", "fundamental", "question", "condition", "nonconfluent", "system", "made", "equivalent", "confluent", "one", "knuthbendix", "completion", "algorithm", "knuth", "bendix", "1970", "give", "partial", "answer", "question", "term", "rewriting", "like", "automated", "deduction", "method", "need", "strategy", "direct", "application", "rippling", "bundy", "stevens", "harmelen", "1993", "basin", "walsh", "1996", "heuristic", "origin", "inductive", "theoremproving", "us", "annotation", "selectively", "restrict", "rewriting", "process", "superposition", "calculus", "calculus", "equational", "firstorder", "logic", "combine", "notion", "firstorder", "resolution", "knuthbendix", "ordering", "equality", "superposition", "refutation", "complete", "bachmair", "ganzinger", "1994", "heart", "number", "theorem", "provers", "notably", "e", "equational", "theorem", "prover", "schulz", "2004", "vampire", "voronkov", "1995", "26", "mathematical", "induction", "mathematical", "induction", "important", "technique", "theorem", "proving", "mathematics", "computer", "science", "problem", "stated", "term", "object", "structure", "involve", "recursive", "definition", "form", "repetition", "invariably", "require", "mathematical", "induction", "solving", "particular", "reasoning", "correctness", "computer", "system", "requires", "induction", "automated", "reasoning", "program", "effectively", "implement", "induction", "important", "application", "illustrate", "need", "mathematical", "induction", "assume", "property", "\u03c6", "true", "number", "zero", "also", "true", "number", "true", "successor", "deductive", "system", "deduce", "given", "number", "n", "\u03c6", "true", "\u03c6", "n", "deduce", "\u03c6", "true", "number", "x\u03c6", "x", "inference", "step", "requires", "rule", "mathematical", "induction", "\u03b1", "0", "\u03b1", "n", "\u03b1", "succ", "n", "mathematical", "induction", "x\u03b1", "x", "word", "prove", "x\u03b1", "x", "one", "prof", "\u03b1", "0", "case", "\u03b1", "succ", "n", "follows", "assumption", "\u03b1", "n", "implementation", "induction", "reasoning", "system", "present", "challenging", "search", "control", "problem", "important", "ability", "determine", "particular", "way", "induction", "applied", "proof", "finding", "appropriate", "induction", "schema", "related", "issue", "include", "selecting", "proper", "variable", "induction", "recognizing", "possible", "case", "base", "inductive", "step", "nqthm", "boyer", "moore", "1979", "one", "successful", "implementation", "automated", "inductive", "theorem", "proving", "spirit", "gentzen", "boyer", "moore", "interested", "people", "prove", "theorem", "induction", "theorem", "prover", "written", "functional", "programming", "language", "lisp", "also", "language", "theorem", "represented", "instance", "express", "commutativity", "addition", "user", "would", "enter", "lisp", "expression", "equal", "plus", "x", "plus", "x", "everything", "defined", "system", "functional", "term", "including", "basic", "predicate", "f", "equal", "x", "x", "z", "etc", "program", "operates", "largely", "black", "box", "inner", "working", "detail", "hidden", "user", "proof", "conducted", "rewriting", "term", "posse", "recursive", "definition", "ultimately", "reducing", "conclusion", "statement", "predicate", "boyermoore", "theorem", "prover", "used", "check", "proof", "quite", "deep", "theorem", "boyer", "kaufmann", "moore", "1995", "lemma", "caching", "problem", "statement", "generalization", "proof", "planning", "technique", "particularly", "useful", "inductive", "theorem", "proving", "bundy", "harmelen", "hesketh", "1991", "3", "logic", "31", "higherorder", "logic", "higherorder", "logic", "differs", "firstorder", "logic", "quantification", "function", "predicate", "allowed", "statement", "two", "people", "related", "one", "way", "another", "legally", "expressed", "higherorder", "logic", "xyrr", "x", "firstorder", "logic", "higherorder", "logic", "inherently", "expressive", "firstorder", "logic", "closer", "spirit", "actual", "mathematical", "reasoning", "example", "notion", "set", "finiteness", "expressed", "firstorder", "concept", "due", "richer", "expressiveness", "come", "surprise", "implementing", "automated", "theorem", "prover", "higherorder", "logic", "challenging", "firstorder", "logic", "largely", "due", "fact", "unification", "higherorder", "logic", "complex", "firstorder", "case", "unifiable", "term", "always", "posse", "general", "unifier", "higherorder", "unification", "undecidable", "finally", "given", "higherorder", "logic", "incomplete", "always", "proof", "entirely", "reach", "automated", "reasoning", "program", "method", "used", "automate", "firstorder", "deduction", "adapted", "higherorder", "logic", "tps", "andrew", "et", "al", "1996", "andrew", "et", "al", "2006", "theorem", "proving", "system", "higherorder", "logic", "us", "church", "typed", "\u03bbcalculus", "logical", "representation", "language", "based", "connectiontype", "deduction", "mechanism", "incorporates", "huet", "unification", "algorithm", "huet", "1975", "sample", "capability", "tps", "program", "proved", "automatically", "subset", "finite", "set", "finite", "equivalence", "among", "several", "formulation", "axiom", "choice", "cantor", "theorem", "set", "subset", "member", "latter", "proved", "program", "asserting", "onto", "function", "individual", "set", "individual", "proof", "proceeding", "diagonal", "argument", "hol", "gordon", "melham", "1993", "another", "higherorder", "proof", "development", "system", "primarily", "used", "aid", "development", "hardware", "software", "safetycritical", "system", "hol", "based", "lcf", "approach", "interactive", "theorem", "proving", "gordon", "milner", "wadsworth", "1979", "built", "strongly", "typed", "functional", "programming", "language", "ml", "hol", "like", "tps", "operate", "automatic", "interactive", "mode", "availability", "latter", "mode", "welcomed", "since", "useful", "automated", "reasoning", "system", "may", "well", "place", "emphasis", "interactive", "theorem", "proving", "farmer", "guttman", "thayer", "1993", "used", "assistant", "operating", "human", "guidance", "harrison", "2000", "discus", "verification", "floatingpoint", "algorithm", "nontrivial", "mathematical", "property", "proved", "hol", "light", "guidance", "user", "isabelle", "paulson", "1994", "generic", "higherorder", "framework", "rapid", "prototyping", "deductive", "system", "object", "logic", "formulated", "within", "isabelle", "metalogic", "using", "many", "syntactic", "deductive", "tool", "isabelle", "also", "provides", "readymade", "theorem", "proving", "environment", "including", "isabellehol", "isabellezf", "isabellefol", "used", "starting", "point", "application", "development", "user", "paulson", "1990", "nipkow", "paulson", "2002", "isabellezf", "used", "prove", "equivalent", "formulation", "axiom", "choice", "formulation", "wellordering", "principle", "well", "key", "result", "cardinal", "arithmetic", "infinite", "cardinal", "\u03ba", "\u03ba", "\u03ba", "\u03ba", "paulson", "grabczewski", "1996", "help", "prove", "higherorder", "theorem", "discharge", "goal", "arising", "interactive", "proof", "user", "ask", "isabellehol", "invoke", "external", "firstorder", "provers", "sledgehammer", "paulson", "2010", "subsystem", "aimed", "combining", "complementary", "capability", "automated", "reasoning", "system", "different", "type", "including", "smt", "solver", "see", "42", "sat", "solver", "article", "blanchette", "et", "al", "2013", "leoii", "benzm\u00fcller", "et", "al", "2015", "also", "resolutionbased", "automated", "theorem", "prover", "higherorder", "logic", "applied", "wide", "array", "problem", "notably", "automation", "g\u00f6del", "ontological", "proof", "god", "existence", "see", "46", "logic", "philosophy", "article", "32", "nonclassical", "logic", "nonclassical", "logic", "haack", "1978", "modal", "logic", "intuitionsitic", "logic", "multivalued", "logic", "autoepistemic", "logic", "nonmonotonic", "reasoning", "commonsense", "default", "reasoning", "relevance", "logic", "paraconsistent", "logic", "increasingly", "gaining", "attention", "automated", "reasoning", "community", "one", "reason", "natural", "desire", "extend", "automated", "deduction", "technique", "new", "domain", "logic", "another", "reason", "need", "mechanize", "nonclassical", "logic", "attempt", "provide", "suitable", "foundation", "artificial", "intelligence", "third", "reason", "desire", "attack", "problem", "combinatorially", "large", "handled", "paper", "pencil", "indeed", "work", "automated", "nonclassical", "logic", "provides", "prime", "example", "automated", "reasoning", "program", "work", "illustrate", "ackerman", "constant", "problem", "asks", "number", "nonequivalent", "formula", "relevance", "logic", "r", "actually", "3088", "formula", "slaney", "1984", "number", "found", "sandwiching", "lower", "upper", "limit", "task", "involved", "constraining", "vast", "universe", "20400", "20element", "model", "search", "model", "rejected", "nontheorems", "r", "safe", "say", "result", "would", "impossible", "obtain", "without", "assistance", "automated", "reasoning", "program", "three", "basic", "approach", "automate", "solving", "problem", "nonclassical", "logic", "mcrobie", "1991", "one", "approach", "course", "try", "mechanize", "nonclassical", "deductive", "calculus", "another", "simply", "provide", "equivalent", "formulation", "problem", "firstorder", "logic", "let", "classical", "theorem", "prover", "handle", "third", "approach", "formulate", "semantics", "nonclassical", "logic", "firstorder", "framework", "resolution", "connectionmatrix", "method", "would", "apply", "pelletier", "et", "al", "2017", "describes", "automated", "reasoning", "system", "paraconsistent", "logic", "take", "indirect", "approach", "translational", "truthvalue", "approach", "prove", "theorem", "modal", "logic", "modal", "logic", "find", "extensive", "use", "computing", "science", "logic", "knowledge", "belief", "logic", "program", "specification", "distributed", "concurrent", "system", "thus", "program", "automates", "reasoning", "modal", "logic", "k", "k4", "s4", "s5", "would", "important", "application", "exception", "s5", "logic", "share", "important", "metatheoretical", "result", "classical", "logic", "cutelimination", "hence", "cutfree", "modal", "sequent", "calculus", "provided", "along", "technique", "automation", "connection", "method", "andrew", "1981", "bibel", "1981", "played", "important", "role", "helping", "understand", "source", "redundancy", "search", "space", "induced", "modal", "sequent", "calculus", "provided", "unifying", "framework", "modal", "logic", "also", "intuitionistic", "classical", "logic", "well", "wallen", "1990", "current", "effort", "automate", "modal", "logic", "reasoning", "revolve", "around", "translational", "approach", "mentioned", "namely", "embed", "modal", "logic", "classical", "logic", "use", "existing", "automated", "reasoning", "system", "latter", "prove", "theorem", "former", "benzm\u00fcller", "paulson", "2013", "show", "embed", "quantified", "modal", "logic", "simple", "type", "theory", "prof", "soundness", "completeness", "embedding", "demonstrates", "simple", "experiment", "existing", "higherorder", "theorem", "provers", "used", "automate", "proof", "modal", "logic", "approach", "extended", "higherorder", "modal", "logic", "well", "benzm\u00fcller", "paleo", "2015", "intuitionistic", "logic", "different", "way", "intuitionsitic", "logic", "automated", "one", "directly", "implement", "intuitionistic", "version", "gentzen", "sequent", "natural", "deduction", "calculus", "lj", "nj", "respectively", "approach", "inherits", "stronger", "normalization", "result", "enjoyed", "calculus", "allowing", "compact", "mechanization", "classical", "counterpart", "another", "approach", "mechanizing", "intuitionistic", "logic", "exploit", "semantic", "similarity", "modal", "logic", "s4", "piggy", "back", "automated", "implementation", "s4", "automating", "intuitionistic", "logic", "application", "software", "development", "since", "writing", "program", "meet", "specification", "corresponds", "problem", "proving", "specification", "within", "intuitionistic", "logic", "martinl\u00f6f", "1982", "system", "automated", "proof", "construction", "process", "would", "important", "application", "algorithm", "design", "also", "constructive", "mathematics", "nuprl", "constable", "et", "al", "1986", "computer", "system", "supporting", "particular", "mathematical", "theory", "namely", "constructive", "type", "theory", "whose", "aim", "provide", "assistance", "proof", "development", "process", "focus", "logicbased", "tool", "support", "programming", "implementing", "formal", "computational", "mathematics", "year", "scope", "nuprl", "project", "expanded", "proofsasprograms", "systemsastheories", "similar", "spirit", "based", "curryhoward", "isomorphism", "coq", "system", "formalizes", "proof", "calculus", "inductive", "construction", "\u03bbcalculus", "rich", "system", "type", "including", "dependent", "type", "coquand", "huet", "1988", "coquand", "paulinmohring", "1988", "like", "nuprl", "coq", "designed", "assist", "development", "mathematical", "proof", "well", "computer", "program", "formal", "specification", "4", "application", "41", "logic", "programming", "logic", "programming", "particularly", "represented", "language", "prolog", "colmerauer", "et", "al", "1973", "probably", "important", "widespread", "application", "automated", "theorem", "proving", "early", "1970s", "discovered", "logic", "could", "used", "programming", "language", "kowalski", "1974", "distinguishes", "logic", "programming", "traditional", "form", "programming", "logic", "program", "order", "solve", "problem", "explicitly", "state", "specific", "computation", "performed", "instead", "logic", "program", "state", "problem", "delegate", "task", "actually", "solving", "underlying", "theorem", "prover", "prolog", "theorem", "prover", "based", "refinement", "resolution", "known", "sldresolution", "sldresolution", "variation", "linear", "input", "resolution", "incorporates", "special", "rule", "selecting", "next", "literal", "resolved", "upon", "sldresolution", "also", "take", "consideration", "fact", "computer", "memory", "literal", "clause", "actually", "ordered", "form", "sequence", "opposed", "set", "prolog", "program", "consists", "clause", "stating", "known", "fact", "rule", "example", "following", "clause", "make", "assertion", "flight", "connection", "flight", "toronto", "london", "flight", "london", "rome", "flight", "chicago", "london", "flight", "x", "flight", "x", "z", "flight", "z", "clause", "flight", "toronto", "london", "fact", "flight", "x", "flight", "x", "z", "flight", "z", "rule", "written", "convention", "reversed", "conditional", "symbol", "mean", "comma", "mean", "term", "starting", "uppercase", "variable", "former", "state", "flight", "connection", "toronto", "london", "latter", "state", "flight", "city", "x", "city", "z", "flight", "x", "z", "one", "z", "y", "clause", "prolog", "program", "special", "type", "horn", "clause", "precisely", "one", "positive", "literal", "fact", "program", "clause", "negative", "literal", "rule", "least", "one", "negative", "literal", "note", "standard", "clause", "notation", "program", "rule", "previous", "example", "would", "written", "flight", "x", "flight", "x", "z", "flight", "z", "specific", "form", "program", "rule", "effectively", "express", "statement", "form", "condition", "jointly", "met", "fact", "follow", "finally", "goal", "horn", "clause", "positive", "literal", "idea", "prolog", "program", "\u03c0", "written", "try", "determine", "new", "clause", "\u03b3", "goal", "entailed", "\u03c0", "\u03c0", "\u03b3", "prolog", "prover", "attempting", "derive", "contradiction", "\u03c0", "\u03b3", "remark", "program", "fact", "rule", "alone", "produce", "contradiction", "goal", "must", "enter", "process", "like", "input", "resolution", "sldresolution", "refutation", "complete", "firstorder", "logic", "complete", "horn", "logic", "prolog", "program", "fundamental", "theorem", "\u03c0", "prolog", "program", "\u03b3", "goal", "clause", "\u03c0", "\u03b3", "iff", "\u03c0", "\u03b3", "sldresolution", "lloyd", "1984", "instance", "find", "flight", "toronto", "rome", "one", "asks", "prolog", "prover", "see", "clause", "flight", "toronto", "rome", "follows", "given", "program", "prover", "add", "flight", "toronto", "rome", "program", "clause", "attempt", "derive", "empty", "clause", "sldresolution", "1", "flight", "toronto", "london", "program", "clause", "2", "flight", "london", "rome", "program", "clause", "3", "flight", "chicago", "london", "program", "clause", "4", "flight", "x", "flight", "x", "z", "flight", "z", "program", "clause", "5", "flight", "toronto", "rome", "negated", "conclusion", "6", "flight", "toronto", "z", "flight", "z", "rome", "re", "5", "4", "7", "flight", "london", "rome", "re", "6", "1", "8", "re", "7", "2", "conditional", "form", "rule", "prolog", "program", "add", "readability", "also", "allows", "reasoning", "underlying", "refutation", "friendly", "way", "prove", "flight", "toronto", "rome", "flight", "toronto", "rome", "unify", "clause", "consequent", "flight", "x", "fourth", "clause", "program", "becomes", "provable", "flight", "toronto", "z", "flight", "z", "rome", "proved", "seen", "case", "substitution", "z", "london", "since", "flight", "toronto", "london", "flight", "london", "rome", "provable", "note", "theorem", "prover", "establishes", "flight", "toronto", "rome", "also", "come", "actual", "itinerary", "torontolondonrome", "extracting", "unification", "used", "proof", "least", "two", "broad", "problem", "prolog", "must", "address", "order", "achieve", "ideal", "logic", "programming", "language", "logic", "program", "consist", "fact", "rule", "describing", "true", "anything", "provable", "program", "deemed", "false", "regard", "previous", "example", "flight", "toronto", "boston", "true", "since", "literal", "deduced", "program", "identification", "falsity", "nonprovability", "exploited", "prolog", "implementation", "incorporating", "operator", "allows", "programmer", "explicitly", "express", "negation", "literal", "even", "subclauses", "within", "program", "definition", "l", "succeeds", "literal", "l", "fails", "deduced", "mechanism", "known", "negationbyfailure", "target", "criticism", "negationbyfailure", "fully", "capture", "standard", "notion", "negation", "significant", "logical", "difference", "two", "standard", "logic", "including", "horn", "logic", "monotonic", "mean", "enlarging", "axiom", "set", "adding", "new", "axiom", "simply", "enlarges", "set", "theorem", "derivable", "negationbyfailure", "however", "nonmonotonic", "addition", "new", "program", "clause", "existing", "prolog", "program", "may", "cause", "goal", "cease", "theorem", "second", "issue", "control", "problem", "currently", "programmer", "need", "provide", "fair", "amount", "control", "information", "program", "achieve", "acceptable", "level", "efficiency", "example", "programmer", "must", "careful", "order", "clause", "listed", "within", "program", "literal", "ordered", "within", "clause", "failure", "proper", "job", "result", "inefficient", "worse", "nonterminating", "program", "programmer", "must", "also", "embed", "hint", "within", "program", "clause", "prevent", "prover", "revisiting", "certain", "path", "search", "space", "using", "cut", "operator", "prune", "altogether", "using", "fail", "last", "least", "order", "improve", "efficiency", "many", "implementation", "prolog", "implement", "unification", "fully", "bypass", "timeconsuming", "yet", "critical", "testthe", "socalled", "occurscheckresponsible", "checking", "suitability", "unifiers", "computed", "result", "unsound", "calculus", "may", "cause", "goal", "entailed", "prolog", "program", "computational", "point", "view", "fact", "logical", "point", "view", "variation", "prolog", "intended", "extend", "scope", "implementing", "model", "elimination", "procedure", "prolog", "technology", "theorem", "prover", "pttp", "stickel", "1992", "extends", "prolog", "full", "firstorder", "logic", "implementation", "achieves", "soundness", "completeness", "moving", "beyond", "firstorder", "logic", "\u03bbprolog", "miller", "nadathur", "1988", "base", "language", "higherorder", "constructive", "logic", "42", "sat", "solver", "problem", "determining", "satisfiability", "logic", "formula", "received", "much", "attention", "automated", "reasoning", "community", "due", "important", "applicability", "industry", "propositional", "formula", "satisfiable", "assignment", "truthvalues", "variable", "make", "formula", "true", "example", "assignment", "p", "true", "q", "true", "r", "false", "make", "p", "r", "q", "true", "p", "true", "q", "false", "r", "false", "hence", "formula", "satisfiable", "determining", "whether", "formula", "satisfiable", "called", "boolean", "satisfiability", "problemsat", "shortand", "formula", "n", "variable", "sat", "settled", "thus", "inspect", "2n", "possible", "assignment", "see", "least", "one", "assignment", "satisfies", "formula", "ie", "make", "true", "method", "clearly", "complete", "original", "formula", "satisfiable", "eventually", "find", "one", "satisfying", "assignment", "formula", "contradictory", "ie", "nonsatisfiable", "able", "determine", "clearly", "particularly", "latter", "case", "search", "take", "exponential", "amount", "time", "desire", "conceive", "efficient", "algorithm", "well", "justified", "particularly", "many", "computing", "problem", "great", "practical", "importance", "graphtheoretic", "problem", "network", "design", "storage", "retrieval", "scheduling", "program", "optimization", "many", "others", "garey", "johnson", "1979", "expressed", "sat", "instance", "ie", "sat", "question", "propositional", "formula", "representing", "problem", "given", "sat", "npcomplete", "cook", "1971", "unlikely", "polynomial", "algorithm", "exists", "however", "preclude", "existence", "sufficiently", "efficient", "algorithm", "particular", "case", "sat", "problem", "davisputnamlogemannloveland", "dpll", "algorithm", "one", "first", "sat", "search", "algorithm", "davis", "putnam", "1960", "davis", "logemman", "loveland", "1962", "still", "considered", "one", "best", "complete", "sat", "solver", "many", "complete", "sat", "procedure", "existence", "today", "considered", "optimization", "generalization", "dpll", "essence", "dpll", "search", "procedure", "proceed", "considering", "way", "assignment", "chosen", "make", "original", "formula", "true", "example", "consider", "formula", "cnf", "p", "q", "p", "q", "r", "p", "s", "since", "p", "conjunct", "also", "unit", "clause", "p", "must", "true", "entire", "formula", "true", "moreover", "value", "p", "contribute", "truth", "p", "q", "r", "p", "s", "true", "regardless", "s", "thus", "whole", "formula", "reduces", "q", "q", "r", "similarly", "q", "must", "true", "formula", "reduces", "r", "force", "r", "true", "process", "recover", "assignment", "p", "true", "q", "false", "r", "true", "false", "proving", "original", "formula", "satisfiable", "formula", "may", "cause", "algorithm", "branch", "search", "branch", "reach", "dead", "end", "moment", "clause", "deemed", "falsea", "conflicting", "clauseand", "variation", "assignment", "partially", "constructed", "point", "discarded", "illustrate", "1", "r", "p", "q", "p", "q", "p", "q", "given", "2", "p", "q", "p", "q", "p", "q", "letting", "r", "true", "3", "q", "q", "letting", "p", "true", "4", "conflict", "q", "q", "true", "5", "p", "q", "p", "q", "p", "q", "backtrack", "2", "r", "true", "still", "hold", "6", "p", "letting", "q", "true", "7", "true", "letting", "p", "true", "ie", "p", "false", "hence", "formula", "satisfiable", "existence", "p", "false", "q", "true", "r", "true", "dpll", "algorithm", "made", "efficient", "strategy", "term", "indexing", "ordering", "formula", "variable", "advantageous", "way", "chronological", "backtracking", "undoing", "work", "previous", "branching", "point", "process", "lead", "conflicting", "clause", "conflictdriven", "learning", "determining", "information", "keep", "backtrack", "combination", "strategy", "result", "large", "prune", "search", "space", "extensive", "discussion", "interested", "reader", "directed", "zhang", "malik", "2002", "quick", "backenvelope", "calculation", "reveals", "staggering", "computing", "time", "algorithm", "sattype", "problem", "represented", "formula", "little", "say", "60", "variable", "wit", "problem", "represented", "boolean", "formula", "10", "variable", "affords", "linear", "solution", "taking", "one", "hundredth", "second", "complete", "would", "take", "four", "hundredth", "six", "hundredth", "second", "complete", "formula", "instead", "40", "60", "variable", "respectively", "dramatic", "contrast", "solution", "problem", "exponential", "say", "2n", "time", "complete", "job", "10", "40", "60", "variable", "would", "respectively", "one", "thousandth", "second", "13", "day", "365", "century", "true", "testament", "ingenuity", "automated", "reasoning", "community", "power", "current", "satbased", "search", "algorithm", "realworld", "problem", "thousand", "variable", "handled", "reasonable", "efficency", "k\u00fcchlin", "sinz", "2000", "discus", "sat", "application", "realm", "industrial", "automotive", "product", "data", "management", "18000", "elementary", "boolean", "formula", "17000", "variable", "used", "express", "constraint", "order", "placed", "customer", "another", "example", "massacci", "marraro", "2000", "discus", "application", "logical", "cryptanalysis", "verification", "property", "cryptographic", "algorithm", "expressed", "sat", "problem", "demonstrate", "finding", "key", "cryptographic", "attack", "analogous", "finding", "modelassignmentfor", "boolean", "formula", "formula", "application", "encodes", "commercial", "version", "us", "data", "encryption", "standard", "de", "encoding", "requiring", "60000", "clause", "10000", "variable", "although", "sat", "conceptually", "simple", "inner", "nature", "well", "understoodthere", "criterion", "generally", "applied", "answer", "one", "sat", "problem", "harder", "another", "come", "surprise", "algorithm", "tend", "well", "sat", "instance", "perform", "well", "others", "effort", "spent", "designing", "hybrid", "algorithmic", "solution", "combine", "strength", "complementary", "approachessee", "prasad", "biere", "gupta", "2005", "application", "hybrid", "approach", "verification", "hardware", "design", "recent", "advance", "sat", "hybrid", "strategy", "coupled", "supercomputing", "power", "allowed", "team", "three", "computing", "scientist", "solve", "boolean", "pythagorean", "triple", "problem", "longstanding", "open", "question", "ramsey", "theory", "set", "1", "2", "natural", "number", "divided", "two", "part", "part", "containing", "triple", "b", "c", "a2", "b2", "c2", "heule", "kullmann", "marek", "2016", "proved", "done", "showing", "set", "1", "2", "n", "partitioned", "n", "7824", "impossible", "n", "7825", "expressing", "deceptively", "simple", "question", "sat", "problem", "required", "close", "38000", "clause", "13000", "variable", "half", "going", "represent", "problem", "satisfiable", "n", "7824", "half", "represent", "n", "7825", "two", "proving", "latter", "far", "challenging", "since", "demanded", "proof", "unsatisfiability", "ie", "partition", "exists", "na\u00efve", "bruteforce", "approach", "considering", "27825", "possible", "twopart", "partition", "clearly", "question", "problem", "attacked", "using", "clever", "algorithm", "within", "multistage", "satbased", "framework", "solving", "hard", "problem", "combinatorics", "consisting", "five", "phase", "encode", "encoding", "problem", "sat", "formula", "transform", "optimizing", "encoding", "using", "clause", "elimination", "symmetry", "breaking", "technique", "split", "dividing", "problem", "effectively", "subproblems", "using", "splitting", "heuristic", "solve", "searching", "satisfying", "assignment", "lack", "thereof", "using", "fast", "processing", "validate", "validating", "result", "earlier", "phase", "special", "importance", "application", "cubeandconquer", "hybrid", "sat", "strategy", "particularly", "effective", "hard", "combinatorial", "problem", "strategy", "combine", "lookahead", "conflictdriven", "clauselearning", "cdcl", "former", "aiming", "construct", "small", "binary", "search", "tree", "using", "global", "heuristic", "latter", "aiming", "find", "short", "refutation", "using", "local", "heuristic", "splitting", "problem", "106", "hard", "subproblems", "known", "cube", "handed", "800", "core", "working", "parallel", "stampede", "supercomputer", "2", "day", "splitting", "cdcl", "clausecrunching", "settled", "question", "delivered", "200terabyte", "proof", "validating", "work", "deservedly", "celebrating", "significant", "accomplishment", "automated", "reasoning", "entertaining", "new", "application", "enhanced", "sat", "method", "would", "afford", "particularly", "area", "hardware", "software", "verification", "ask", "question", "especial", "importance", "mathematician", "insightful", "way", "establish", "result", "would", "involve", "traditional", "intellectually", "satisfying", "mathematical", "proof", "method", "far", "increasing", "understanding", "given", "field", "combinatorics", "case", "value", "settling", "question", "human", "inspect", "proof", "hence", "get", "insight", "even", "team", "responsible", "result", "admits", "proof", "unsatisfiability", "coming", "sat", "solver", "human", "point", "view", "giant", "heap", "random", "information", "direct", "understanding", "involved", "conjecture", "settled", "basically", "underlying", "idea", "make", "7825", "special", "perhaps", "real", "value", "drawn", "consideration", "lead", "u", "think", "deeper", "question", "structure", "specific", "problem", "make", "amenable", "standard", "mathematical", "treatment", "opposed", "requiring", "mindless", "bruteforce", "approach", "question", "contemplated", "sat", "may", "provide", "best", "line", "attack", "certain", "mathematical", "problem", "dpll", "search", "procedure", "extended", "quantified", "logic", "mace", "popular", "program", "based", "dpll", "algorithm", "search", "finite", "model", "firstorder", "formula", "equality", "example", "mccune", "2001", "show", "group", "commutative", "one", "direct", "mace", "look", "model", "group", "axiom", "also", "falsifies", "commutation", "law", "equivalently", "look", "model", "g1", "e", "x", "x", "left", "identity", "g2", "x", "x", "e", "left", "inverse", "g3", "x", "z", "x", "z", "associativity", "dc", "b", "b", "denial", "commutativity", "mace", "find", "sixelement", "model", "axiom", "defined", "0", "1", "2", "3", "4", "5", "0", "0", "1", "2", "3", "4", "5", "1", "1", "0", "4", "5", "2", "3", "2", "2", "3", "0", "1", "5", "4", "3", "3", "2", "5", "4", "0", "1", "4", "4", "5", "1", "0", "3", "2", "5", "5", "4", "3", "2", "1", "0", "defined", "x", "0", "1", "2", "3", "4", "5", "x", "0", "1", "2", "3", "4", "5", "example", "also", "illustrates", "benefit", "using", "automated", "deduction", "system", "long", "would", "taken", "human", "researcher", "come", "similar", "model", "challenging", "problem", "program", "used", "practical", "complement", "resolutionbased", "theorem", "prover", "prover9", "formerly", "otter", "prover9", "searching", "proof", "mace", "jointly", "looking", "counter", "model", "find", "model", "mace", "convert", "firstorder", "problem", "set", "flattened", "clause", "increasing", "model", "size", "instantiated", "propositional", "clause", "solved", "sat", "problem", "method", "implemented", "automated", "reasoning", "system", "well", "notably", "paradox", "model", "finder", "macestyle", "approach", "enhanced", "four", "additional", "technique", "resulting", "significant", "efficiency", "improvement", "claessen", "s\u00f6rensson", "2003", "term", "definition", "reduce", "number", "variable", "flattened", "clause", "static", "symmetric", "reduction", "reduce", "number", "isomorphic", "model", "sort", "inference", "apply", "symmetric", "reduction", "finer", "level", "incremental", "sat", "reuse", "search", "information", "consecutive", "model", "size", "strategy", "pairing", "complementary", "capability", "separate", "automated", "reasoning", "system", "applied", "higherorder", "logic", "exemplified", "nitpick", "counterexample", "generator", "isabellehol", "blanchette", "nipkow", "2010", "brown", "2013", "describes", "theorem", "proving", "procedure", "higherorder", "logic", "us", "satsolving", "work", "procedure", "complete", "cutfree", "ground", "refutation", "calculus", "incorporates", "restriction", "instantiation", "implemented", "satallax", "theorem", "prover", "brown", "2012", "approach", "great", "interest", "solving", "sat", "problem", "firstorder", "logic", "satisfiability", "modulo", "theory", "smt", "interpretation", "symbol", "problem", "formulation", "constrained", "background", "theory", "example", "linear", "arithmetic", "function", "symbol", "restricted", "another", "example", "extensional", "theory", "array", "mccarthy", "1962", "array", "function", "read", "return", "value", "array", "index", "write", "x", "return", "array", "identical", "value", "x", "formally", "a", "array", "i", "j", "index", "x", "value", "j", "read", "write", "x", "j", "x", "readwrite", "axiom", "1", "a", "array", "i", "j", "index", "x", "value", "j", "read", "write", "x", "j", "read", "j", "readwrite", "axiom", "2", "a", "b", "array", "i", "index", "b", "read", "read", "b", "extensionality", "context", "axiom", "smt", "solver", "would", "attempt", "establish", "satisfiability", "dually", "validity", "given", "firstorder", "formula", "thousand", "formula", "matter", "j", "1", "f", "read", "write", "2", "j", "1", "read", "write", "f", "j", "1", "ganzinger", "et", "al", "2004", "discus", "approach", "smt", "called", "dpll", "consisting", "general", "dpll", "x", "engine", "work", "conjunction", "solver", "solvert", "background", "theory", "t", "bofill", "et", "al", "2008", "present", "approach", "setting", "theory", "array", "dpll", "engine", "responsible", "enumerating", "propositional", "model", "given", "formula", "whereas", "solvert", "check", "whether", "model", "consistent", "theory", "array", "approach", "sound", "complete", "smoothly", "extended", "multidimensional", "array", "smt", "particularly", "successful", "verification", "application", "notably", "software", "verification", "improved", "efficiency", "sat", "solver", "smt", "effort", "designing", "efficient", "smt", "solver", "de", "moura", "2007", "43", "deductive", "computer", "algebra", "prove", "automatically", "even", "simplest", "mathematical", "fact", "requires", "significant", "amount", "domain", "knowledge", "rule", "automated", "theorem", "provers", "lack", "rich", "knowledge", "attempt", "construct", "proof", "first", "principle", "application", "elementary", "deduction", "rule", "approach", "result", "lengthy", "proof", "assuming", "proof", "found", "step", "justified", "basic", "logical", "level", "larger", "inference", "step", "significant", "improvement", "mathematical", "reasoning", "capability", "obtained", "however", "theorem", "prover", "interact", "computer", "algebra", "system", "also", "known", "symbolic", "computation", "system", "computer", "algebra", "system", "computer", "program", "assist", "user", "symbolic", "manipulation", "numeric", "evaluation", "mathematical", "expression", "example", "asked", "compute", "improper", "integral", "0", "ea2t2cos2bt", "dt", "competent", "computer", "algebra", "system", "would", "quickly", "reply", "answer", "\u03c0", "2a", "eb2a2", "essentially", "computer", "algebra", "system", "operates", "taking", "input", "expression", "entered", "user", "successively", "applies", "series", "transformation", "rule", "result", "longer", "change", "see", "section", "term", "rewriting", "article", "detail", "transformation", "rule", "encode", "significant", "amount", "domain", "mathematical", "knowledge", "making", "symbolic", "system", "powerful", "tool", "hand", "applied", "mathematician", "scientist", "engineer", "trying", "attack", "problem", "wide", "variety", "field", "ranging", "calculus", "solving", "equation", "combinatorics", "number", "theory", "problem", "solving", "mathematics", "involves", "interplay", "deduction", "calculation", "decision", "procedure", "reminder", "fuzzy", "division", "two", "hence", "integration", "deductive", "symbolic", "system", "coin", "deductive", "computer", "algebra", "dca", "bound", "fruitful", "combination", "analytica", "bauer", "clarke", "zhao", "1998", "theorem", "prover", "built", "top", "mathematica", "powerful", "popular", "computer", "algebra", "system", "besides", "supplying", "deductive", "engine", "analytica", "also", "extends", "mathematica", "capability", "defining", "number", "rewrite", "rulesmore", "precisely", "identity", "summation", "inequalitiesthat", "missing", "system", "well", "providing", "implementation", "gosper", "algorithm", "finding", "closed", "form", "indefinite", "hypergeometric", "summation", "equipped", "extended", "knowledge", "analytica", "prove", "semiautomatically", "nontrivial", "theorem", "real", "analysis", "including", "series", "lemma", "directly", "leading", "proof", "bernstein", "approximation", "theorem", "statement", "theorem", "simply", "give", "reader", "sense", "level", "mathematical", "richness", "dealing", "bernstein", "approximation", "theorem", "let", "0", "1", "closed", "unit", "interval", "f", "real", "continuous", "function", "bn", "x", "f", "nth", "bernstein", "polynomial", "f", "defined", "bn", "x", "f", "n", "k0", "n", "k", "f", "kn", "xk", "1", "x", "nk", "interval", "sequence", "bernstein", "polynomial", "f", "converges", "uniformly", "f", "frank", "program", "supplied", "key", "information", "establish", "lemma", "lead", "theorem", "amount", "type", "deductive", "work", "done", "program", "certainly", "nontrivial", "clarke", "zhao", "1994", "provides", "example", "fully", "automated", "proof", "using", "problem", "chapter", "2", "ramanujan", "notebook", "berndt", "1985", "including", "following", "example", "reader", "invited", "try", "show", "ar", "kn1", "1", "k", "r", "2", "r", "k1", "r", "k", "ak", "jak11", "1", "3j", "33j", "2r\u03c6", "3", "a0", "a01", "an13an1", "\u03c6", "x", "n", "ramanujan", "abbreviation", "\u03c6", "x", "n", "df", "n", "k1", "1", "kx", "k3x3", "analytica", "proof", "identity", "proceeds", "simplifying", "left", "righthand", "side", "equality", "showing", "side", "reduce", "expression", "hn", "har", "simplification", "us", "added", "summation", "identity", "mentioned", "well", "elementary", "property", "harmonic", "number", "hn", "n", "k1", "1", "k", "resulting", "proof", "28", "step", "nontrivial", "taking", "2", "minute", "find", "kerber", "kohlhase", "sorge", "1998", "use", "\u03c9mega", "planning", "system", "overall", "way", "integrate", "theorem", "proving", "symbolic", "computation", "harrison", "th\u00e9ry", "1998", "find", "example", "integration", "higherorder", "logic", "theorem", "proving", "system", "hol", "computer", "algebra", "system", "maple", "great", "power", "notwithstanding", "symbolic", "algebra", "system", "enforce", "level", "rigor", "formality", "essence", "automated", "deduction", "system", "fact", "mathematical", "semantics", "knowledge", "rule", "algebra", "system", "entirely", "clear", "case", "logically", "unsound", "harrison", "th\u00e9ry", "1998", "main", "reason", "overaggressiveness", "provide", "user", "answer", "timely", "fashion", "whatever", "cost", "bypassing", "checking", "required", "assumption", "even", "mean", "sacrificing", "soundness", "calculation", "strongly", "reminiscent", "prolog", "implementation", "bypass", "socalled", "occurscheck", "also", "abandoning", "logical", "soundness", "name", "efficiency", "serious", "problem", "open", "opportunity", "deduction", "system", "provide", "service", "computer", "algebra", "system", "use", "deductive", "capability", "verify", "computer", "algebra", "computational", "step", "meet", "required", "assumption", "catch", "however", "sufficiently", "large", "calculation", "step", "verifying", "tantamount", "proving", "check", "step", "deduction", "system", "may", "well", "need", "assistance", "system", "need", "verification", "solution", "soundness", "problem", "may", "well", "require", "extensive", "modification", "chosen", "symbolic", "algebra", "system", "make", "sound", "alternative", "approach", "develop", "new", "system", "entirely", "scratch", "conjunction", "development", "automated", "theorem", "prover", "either", "case", "resulting", "combined", "deductive", "computer", "algebra", "system", "display", "much", "improved", "ability", "automated", "mathematical", "reasoning", "44", "formal", "verification", "hardware", "automated", "reasoning", "reached", "level", "maturity", "theorem", "proving", "system", "technique", "used", "industrialstrength", "application", "one", "application", "area", "formal", "verification", "hardware", "software", "system", "cost", "defect", "hardware", "easily", "run", "million", "1994", "pentium", "processor", "shipped", "defect", "floatingpoint", "unit", "subsequent", "offer", "intel", "replace", "flawed", "chip", "taken", "small", "fraction", "pentium", "owner", "cost", "company", "close", "500", "million", "guard", "situation", "like", "practice", "testing", "chip", "design", "considered", "insufficient", "formal", "method", "verification", "gained", "large", "attention", "microprocessor", "industry", "become", "necessity", "idea", "behind", "formal", "verification", "rigorously", "prove", "mathematical", "certainty", "system", "function", "specified", "common", "application", "hardware", "design", "include", "formally", "establish", "system", "function", "correctly", "input", "two", "different", "circuit", "functionally", "equivalent", "depending", "task", "hand", "one", "draw", "number", "automated", "formal", "verification", "technique", "including", "sat", "solver", "propositional", "logic", "symbolic", "simulation", "using", "binary", "decision", "diagram", "bdds", "model", "checking", "temporal", "logic", "conducting", "proof", "higherorder", "logic", "latter", "case", "using", "automated", "theorem", "prover", "like", "holsee", "section", "10has", "shown", "invaluable", "practice", "proof", "construction", "system", "like", "hol", "proceeds", "semiautomatically", "user", "providing", "fair", "amount", "guidance", "proof", "proceed", "user", "try", "find", "proof", "assisted", "theorem", "prover", "request", "either", "automatically", "fill", "proof", "segment", "verify", "proof", "step", "given", "although", "technique", "mentioned", "provide", "decision", "procedure", "higherorder", "logic", "lack", "higherorder", "logic", "advantage", "expressive", "tradeoff", "justified", "since", "proving", "fact", "floatingpoint", "arithmetic", "requires", "formalization", "large", "body", "real", "analysis", "including", "many", "elementary", "statement", "x", "x", "x", "b", "f", "diffl", "f", "x", "x", "f", "k", "f", "b", "k", "x", "x", "x", "b", "f", "x", "0", "f", "x", "k", "x", "x", "x", "b", "f", "x", "k", "statement", "harrison", "2000", "written", "hol", "say", "function", "f", "differentiable", "derivative", "f", "interval", "b", "sufficient", "condition", "f", "x", "k", "throughout", "interval", "f", "x", "k", "endpoint", "b", "point", "zero", "derivative", "result", "used", "determine", "error", "bound", "approximating", "transcendental", "function", "truncated", "power", "series", "conducting", "proof", "painstakingly", "foundational", "system", "harrison", "2006", "significant", "benefit", "first", "one", "achieves", "high", "degree", "assurance", "proof", "valid", "since", "admitedly", "lengthy", "composed", "small", "errorfree", "deductive", "step", "second", "formalization", "elementary", "statement", "intermediate", "result", "reused", "task", "project", "example", "library", "formal", "statement", "proven", "result", "floatingpoint", "division", "reused", "proving", "result", "floatingpoint", "algorithm", "square", "root", "transcendental", "function", "illustrate", "different", "version", "square", "root", "algorithm", "intel", "itanium", "share", "many", "similarity", "proof", "correctness", "one", "version", "algorithm", "carried", "another", "version", "minor", "tweaking", "proof", "third", "benefit", "using", "prover", "like", "hol", "course", "lengthy", "proof", "carried", "mechanically", "deductively", "certain", "likelihood", "introducing", "human", "error", "carried", "manually", "would", "certain", "45", "formal", "verification", "software", "society", "becoming", "increasingly", "dependent", "software", "system", "critical", "service", "safety", "security", "serious", "adverse", "effect", "malfunctioning", "software", "include", "loss", "human", "life", "threat", "security", "unauthorized", "access", "sensitive", "information", "large", "financial", "loss", "denial", "critical", "service", "risk", "safety", "one", "way", "increase", "quality", "critical", "software", "supplement", "traditional", "method", "testing", "validation", "technique", "formal", "verification", "basic", "approach", "formal", "verification", "generate", "number", "condition", "software", "must", "meet", "verifyestablishthem", "mathematical", "proof", "hardware", "automated", "formal", "verification", "simply", "formal", "verification", "hereafter", "concerned", "discharging", "proof", "obligation", "using", "automated", "theorem", "prover", "formal", "verification", "security", "protocol", "almost", "ideal", "application", "automated", "theorem", "proving", "industry", "security", "protocol", "small", "distributed", "program", "aimed", "ensuring", "transaction", "take", "place", "securely", "public", "network", "specification", "security", "protocol", "relatively", "small", "well", "defined", "verification", "certainly", "nontrivial", "already", "mentioned", "previous", "section", "use", "satbased", "theorem", "provers", "verification", "us", "data", "encryption", "standard", "de", "another", "example", "mondex", "electronic", "purse", "smart", "card", "electronic", "cash", "system", "originally", "developed", "national", "westminster", "bank", "subsequently", "sold", "mastercard", "international", "schmitt", "tonin", "2007", "describe", "java", "card", "implementation", "mondex", "protocol", "security", "property", "reformulated", "java", "modeling", "language", "jml", "following", "closely", "original", "z", "specification", "proof", "correctness", "conducted", "using", "key", "tool", "beckert", "hanle", "schmitt", "2007", "interactive", "theorem", "proving", "environment", "firstorder", "dynamic", "logic", "allows", "user", "prove", "property", "imperative", "objectoriented", "sequential", "program", "application", "automated", "reasoning", "demonstrates", "word", "author", "possible", "bridge", "gap", "specification", "implementation", "ensuring", "fully", "verified", "result", "denney", "fischer", "schumann", "2004", "describe", "system", "automate", "certification", "safety", "property", "dataanalysis", "aerospace", "software", "nasa", "using", "hoarestyle", "program", "verification", "technique", "system", "generates", "proof", "obligation", "handled", "automated", "theorem", "prover", "process", "fully", "automated", "however", "since", "many", "obligation", "must", "simplified", "first", "order", "improve", "ability", "theorem", "prover", "solve", "proof", "task", "example", "one", "class", "obligation", "make", "statement", "matrix", "r", "need", "remain", "symmetric", "update", "along", "diagonal", "made", "form", "original", "form", "symm", "r", "symm", "diagupdates", "r", "simplified", "form", "r", "2x2", "i", "j", "0", "j", "1", "sel", "r", "j", "sel", "r", "j", "k", "l", "0", "k", "l", "1", "sel", "upd", "upd", "r", "1", "1", "r11", "0", "0", "r00", "k", "l", "sel", "upd", "upd", "r", "1", "1", "r11", "0", "0", "r00", "l", "k", "even", "simplification", "current", "theorem", "provers", "find", "proof", "task", "challenging", "task", "becomes", "intractable", "larger", "matrix", "number", "update", "eg", "66", "matrix", "36", "update", "preprocessing", "simplification", "obligation", "required", "task", "eventually", "fall", "within", "reach", "stateofart", "theorem", "provers", "worth", "remarking", "proof", "found", "without", "using", "specific", "feature", "configuration", "parameter", "theorem", "provers", "would", "improve", "chance", "completing", "proof", "important", "since", "everyday", "application", "theorem", "provers", "industry", "presuppose", "deep", "knowledge", "prover", "user", "formal", "verification", "software", "remains", "demanding", "task", "difficult", "see", "certification", "property", "could", "happen", "without", "assistance", "automated", "deduction", "one", "face", "humanly", "impossible", "task", "establishing", "thousand", "obligation", "field", "nuclear", "engineering", "technique", "automated", "reasoning", "deemed", "mature", "enough", "assist", "formal", "verification", "safetycritical", "software", "responsible", "controlling", "nuclear", "power", "plant", "reactor", "prevention", "system", "rps", "rps", "component", "digital", "control", "system", "apr1400", "nuclear", "reactor", "specified", "using", "nuscr", "formal", "specification", "language", "customized", "nuclear", "application", "yoo", "jee", "cha", "2009", "model", "checking", "computation", "tree", "logic", "used", "check", "specification", "completeness", "consistency", "nuclear", "engineer", "generate", "function", "block", "design", "via", "process", "automatic", "synthesis", "formally", "verify", "design", "also", "using", "technique", "model", "checking", "linear", "temporal", "logic", "technique", "also", "used", "verify", "equivalence", "multiple", "revision", "release", "design", "modelchecking", "tool", "implemented", "make", "use", "easy", "intuitive", "possible", "way", "require", "deep", "knowledge", "technique", "used", "notation", "familiar", "nuclear", "engineer", "use", "automated", "reasoning", "tool", "help", "design", "engineer", "establish", "desired", "result", "also", "raise", "confidence", "government", "regulatory", "personnel", "need", "approve", "rps", "software", "reactor", "certified", "operation", "46", "logic", "philosophy", "spirit", "wos", "overbeek", "lusk", "boyle", "1992", "pose", "question", "following", "statement", "different", "system", "formal", "logic", "exact", "philosophy", "common", "implicational", "fragment", "modal", "logic", "s4", "s5", "studied", "extensively", "year", "posed", "open", "question", "eventually", "shown", "single", "axiom", "implicational", "s4", "well", "several", "new", "shortest", "axiom", "implicational", "s5", "ernst", "fitelson", "harris", "wos", "2002", "l", "combinator", "defined", "lx", "x", "yy", "although", "known", "lbased", "combinator", "e12", "l", "l", "l", "l", "satisfies", "e12e12", "e12", "question", "remained", "whether", "shorter", "lbased", "combinator", "satisfying", "property", "existed", "glickfeld", "overbeek", "1986", "showed", "case", "e8", "l", "l", "thirteen", "shortest", "single", "axiom", "length", "eleven", "classical", "equivalence", "discovered", "xcb", "e", "x", "e", "e", "e", "x", "e", "z", "z", "remaining", "formula", "length", "whose", "status", "undeterminedwas", "axiom", "quarter", "century", "question", "remained", "open", "despite", "intense", "study", "various", "researcher", "finally", "settled", "xcb", "indeed", "single", "axiom", "thus", "ending", "search", "shortest", "single", "axiom", "equivalential", "calculus", "wos", "ulrich", "fitelson", "2002", "saint", "anselm", "canterbury", "offered", "proslogium", "famous", "argument", "existence", "god", "quite", "recently", "simpler", "proof", "discovered", "sense", "shorter", "us", "fewer", "assumption", "oppenheimer", "zalta", "2011", "tradition", "g\u00f6del", "produced", "proof", "god", "existence", "benzm\u00fcller", "paleo", "2014", "recently", "proved", "result", "using", "weaker", "logic", "system", "simultaneously", "addressing", "major", "criticism", "g\u00f6del", "proof", "axiom", "defining", "robbins", "algebra", "huntington", "equation", "x", "x", "y", "x", "replaced", "simpler", "one", "namely", "robbins", "equation", "x", "x", "y", "x", "conjecture", "went", "unproved", "50", "year", "resisting", "attack", "many", "logician", "including", "tarski", "eventually", "proved", "mccune", "1997", "ask", "result", "common", "answer", "proved", "help", "automated", "reasoning", "program", "disclosed", "answer", "question", "prompt", "new", "one", "much", "longer", "would", "taken", "settle", "open", "problem", "without", "application", "automated", "reasoning", "tool", "strict", "implicational", "fragment", "logical", "system", "s4", "s5", "modal", "logic", "known", "c4", "c5", "respectively", "hilbertstyle", "axiomatizations", "presuppose", "condensed", "detachment", "sole", "rule", "inference", "insight", "kripke", "work", "anderson", "belnap", "1962", "published", "first", "axiomatization", "c4", "using", "following", "3axiom", "basis", "polish", "notation", "cpq", "stand", "p", "q", "1", "cpp", "ccpqcrcpq", "ccpcqrccpqcpr", "question", "posed", "sometime", "shorter", "axiomatization", "c4", "using", "2axiom", "basis", "even", "single", "axiom", "using", "automated", "reasoning", "program", "otter", "author", "ernst", "fitelson", "harris", "wos", "2001", "settled", "question", "affirmative", "fact", "several", "2axiom", "base", "discovered", "following", "turned", "shortest", "2", "cpcqq", "ccpcqrccpqcscpr", "round", "automated", "reasoning", "work", "rewarded", "discovery", "single", "axiom", "c4", "axiom", "21", "symbol", "long", "also", "proved", "shortest", "axiom", "3", "ccpccqcrrcpsccstcucpt", "show", "2", "3", "necessary", "sufficient", "1", "circle", "proof", "produced", "using", "automated", "reasoning", "tool", "1", "3", "2", "1", "c5", "axiomatization", "originally", "published", "paper", "lemmon", "a", "meredith", "d", "meredith", "prior", "thomas", "1957", "giving", "several", "4", "3", "2", "1axiom", "base", "c5", "including", "following", "3axiom", "basis", "4", "cqcpp", "ccpqccqrcpr", "ccccpqrcpqcpq", "publication", "also", "included", "shortest", "known", "2axiom", "base", "c5", "actually", "two", "containing", "20", "symbol", "shortest", "single", "axiom", "c5", "later", "discovered", "meredith", "prior", "1964", "21", "symbol", "5", "cccccppqrcstcctqcscsq", "applying", "automated", "reasoning", "strategy", "ernst", "fitelson", "harris", "wos", "2001", "discovered", "several", "new", "base", "including", "following", "2axiom", "basis", "length", "18", "six", "1axiom", "base", "matching", "meredith", "length", "21", "one", "given", "6", "cpp", "ccpqccccqrsrcpr", "7", "ccccpqrccuuqccqtcscpt", "show", "6", "7", "necessary", "sufficient", "4", "circle", "proof", "also", "produced", "theorem", "prover", "6", "4", "7", "6", "charming", "foray", "combinatory", "logic", "presented", "smullyan", "1985", "glickfeld", "overbeek", "1986", "learn", "certain", "enchanted", "forest", "inhabited", "talking", "bird", "given", "bird", "b", "name", "bird", "b", "spoken", "bird", "respond", "name", "bird", "forest", "ab", "response", "b", "always", "definition", "enchanted", "bird", "b1", "mockingbird", "mimic", "bird", "sense", "response", "bird", "x", "x", "response", "mx", "xx", "b2", "bird", "c", "composes", "bird", "b", "bx", "cx", "bird", "x", "word", "c", "response", "x", "response", "b", "response", "x", "b3", "bird", "fond", "bird", "b", "response", "b", "b", "ab", "b", "two", "fact", "enchanted", "forest", "f1", "bird", "b", "forest", "bird", "c", "composes", "f2", "mockingbird", "forest", "rumor", "every", "bird", "forest", "fond", "least", "one", "bird", "also", "least", "one", "bird", "fond", "bird", "challenge", "reader", "course", "settle", "rumor", "using", "f1", "f2", "given", "definition", "b1", "b3", "glickfeld", "overbeek", "1986", "mere", "second", "automated", "reasoning", "system", "using", "paramodulation", "demodulation", "subsumption", "challenging", "problem", "consider", "additional", "definition", "b4", "bird", "egocentric", "fond", "ee", "e", "b5", "bird", "l", "lark", "bird", "x", "following", "hold", "lx", "x", "yy", "smullyan", "challenge", "u", "prove", "surprising", "thing", "lark", "suppose", "given", "information", "except", "forest", "contains", "lark", "show", "least", "one", "bird", "forest", "must", "egocentric", "give", "salient", "step", "proof", "found", "automated", "reasoning", "system", "x", "stand", "xy", "clause", "2", "3", "respectively", "definition", "lark", "denial", "theorem", "number", "right", "application", "paramodulation", "1", "x1", "x1", "2", "l", "x1", "x2", "x1", "x2", "x2", "3", "x1", "x1", "x1", "6", "x1", "l", "x2", "x2", "x2", "l", "x1", "x2", "x2", "2", "2", "8", "x1", "x2", "x2", "x2", "x2", "l", "l", "x1", "x2", "2", "2", "9", "l", "l", "x1", "x2", "x1", "x1", "x2", "x2", "2", "2", "18", "l", "l", "l", "l", "x1", "x1", "l", "x1", "x1", "x1", "6", "3", "6", "9", "8", "8", "19", "18", "1", "closer", "inspection", "left", "right", "hand", "side", "18", "application", "unification", "revealed", "discovery", "10l", "bird", "ie", "10symbol", "bird", "expressed", "solely", "term", "lark", "strong", "candidate", "egocentricity", "discovery", "exciting", "shortest", "egocentric", "lbird", "known", "smullyan", "length", "12", "subsequent", "run", "automated", "reasoning", "system", "produced", "proof", "fact", "well", "another", "new", "significant", "bird", "possible", "egocentric", "8l", "bird", "run", "system", "eventually", "produced", "22line", "proof", "term", "many", "50", "symbol", "excluding", "comma", "parenthesis", "fact", "l", "l", "indeed", "egocentric", "natural", "question", "ask", "next", "course", "whether", "8l", "egocentric", "bird", "whether", "shorter", "one", "reader", "may", "want", "attempt", "paper", "pencil", "given", "429", "bird", "may", "wiser", "try", "instead", "conjunction", "automated", "reasoning", "program", "approach", "explored", "glickfeld", "overbeek", "1986", "formal", "admittedly", "le", "colorful", "introduction", "combinatory", "logic", "lambdaconversion", "reader", "referred", "hindley", "seldin", "1986", "formula", "classical", "equivalential", "calculus", "written", "using", "sentential", "variable", "twoplace", "function", "symbol", "e", "equivalence", "calculus", "two", "rule", "inference", "detachment", "modus", "ponens", "substitution", "rule", "combined", "single", "rule", "condensed", "detachment", "obtain", "t\u03b8", "e", "r", "s\u03b8", "r\u03b8", "mgu", "\u03b8", "calculus", "axiomatized", "formula", "e1", "e", "x", "x", "reflexivity", "e2", "e", "e", "x", "e", "x", "symmetry", "e3", "e", "e", "x", "e", "e", "z", "e", "x", "z", "transitivity", "dispense", "reflexivity", "since", "derivable", "two", "formula", "brings", "number", "axiom", "two", "natural", "question", "ask", "whether", "single", "axiom", "equivalential", "calculus", "1933", "\u0142ukasiewicz", "found", "three", "formula", "length", "eleven", "could", "act", "single", "axiom", "calculushere", "one", "e", "e", "x", "e", "e", "z", "e", "x", "z", "and", "also", "showed", "shorter", "single", "axiom", "existed", "time", "single", "axiom", "also", "length", "eleven", "found", "list", "kept", "growing", "addition", "meredith", "kalman", "peterson", "total", "14", "formula", "13", "known", "single", "axiom", "one", "formula", "yet", "undetermined", "status", "formula", "xcb", "e", "x", "e", "e", "e", "x", "e", "z", "z", "actually", "list", "grew", "18", "formula", "wos", "winker", "veroff", "smith", "henschen", "1983", "reduced", "14", "resisting", "intense", "study", "various", "researcher", "remained", "open", "question", "many", "year", "whether", "14th", "formula", "xcb", "single", "axiom", "equivalential", "calculus", "peterson", "1977", "one", "way", "answer", "question", "affirmative", "would", "show", "least", "one", "13", "known", "single", "axiom", "derivable", "xcb", "alone", "another", "approach", "would", "derive", "xcb", "3axiom", "set", "e1", "e3", "wos", "ulrich", "fitelson", "2002", "take", "shot", "former", "line", "attack", "concentrate", "latter", "challenging", "task", "proving", "symmetry", "working", "assistance", "powerful", "automated", "reasoning", "program", "otter", "conducted", "concerted", "persistent", "aggressive", "assault", "open", "question", "article", "sometimes", "read", "like", "military", "briefing", "front", "line", "simpler", "problem", "proof", "found", "reasoning", "program", "automatically", "deeper", "challenging", "one", "like", "one", "hand", "require", "guidance", "user", "relentless", "application", "reasoning", "tool", "involved", "much", "guidance", "setting", "lemma", "target", "deployment", "arsenal", "strategy", "including", "set", "support", "forward", "backward", "subsumption", "lemma", "adjunction", "formula", "complexity", "hint", "strategy", "ratio", "strategy", "term", "avoidance", "level", "saturation", "others", "much", "effort", "cpu", "time", "open", "question", "finally", "succumbed", "combined", "effort", "man", "machine", "61step", "proof", "symmetry", "found", "followed", "one", "transitivity", "10", "application", "condensed", "detachment", "subsequent", "run", "theorem", "prover", "using", "demodulation", "blocking", "socalled", "cramming", "strategy", "delivered", "shorter", "proof", "last", "line", "25step", "proof", "case", "prof", "transitivity", "first", "followed", "symmetry", "123", "hyper51106122", "p", "e", "e", "e", "e", "x", "e", "z", "z", "x", "124", "hyper5153123", "p", "e", "e", "e", "e", "e", "e", "e", "x", "e", "z", "z", "x", "u", "e", "v", "u", "v", "125", "hyper51124123", "p", "e", "e", "e", "x", "x", "127", "hyper51124108", "p", "e", "e", "e", "e", "x", "e", "e", "e", "x", "e", "z", "z", "e", "e", "e", "e", "e", "u", "v", "e", "w", "v", "w", "u", "v6", "v7", "e", "v6", "v7", "128", "hyper51127123", "p", "e", "e", "x", "e", "e", "z", "e", "x", "z", "130", "hyper51128125", "p", "e", "e", "x", "e", "e", "e", "z", "x", "z", "131", "hyper51128130", "p", "e", "e", "e", "e", "e", "x", "x", "z", "u", "e", "e", "z", "u", "132", "hyper51131123", "p", "e", "e", "x", "e", "x", "effective", "methodology", "strategy", "included", "assistance", "automated", "reasoning", "program", "crucial", "way", "search", "shortest", "single", "axiom", "equivalent", "calculus", "came", "end", "fitelson", "zalta", "2007", "oppenheimer", "zalta", "2011", "alama", "oppenheimer", "zalta", "2015", "describe", "several", "application", "automated", "reasoning", "computational", "metaphysics", "representing", "formal", "metaphysical", "claim", "axiom", "premise", "automated", "reasoning", "environment", "using", "program", "like", "prover9", "mace4", "eprover", "system", "paradox", "logical", "status", "metaphysical", "argument", "investigated", "suitable", "formalization", "axiom", "premise", "model", "finder", "program", "mace4", "used", "help", "verify", "consistency", "using", "prover9", "proof", "automatically", "generated", "number", "theorem", "theory", "plato", "form", "twenty", "five", "fundamental", "theorem", "theory", "possible", "world", "theorem", "described", "leibniz", "unpublished", "paper", "1690", "modal", "metaphysics", "fully", "automated", "construction", "saint", "anselm", "ontological", "argument", "latter", "application", "saint", "anselm", "understood", "oppenheimer", "zalta", "2011", "found", "way", "inferring", "god", "existence", "mere", "opposed", "inferring", "god", "actuality", "mere", "possibility", "allows", "formalization", "free", "modal", "operator", "involving", "underlying", "logic", "description", "three", "nonlogical", "premise", "definition", "god", "two", "key", "definition", "formalization", "inputted", "prover9", "helped", "express", "concept", "god", "definition", "none_greater", "x", "object", "x", "ex1", "none_greater", "x", "ex1", "conceivable", "x", "exists", "object", "ex2", "greater_than", "x", "ex1", "conceivable", "definition", "god", "is_the", "g", "none_greater", "part", "challenge", "representing", "prover9", "statement", "axiomatic", "metaphysics", "circumvent", "prover", "linguistic", "limitation", "example", "prover9", "definite", "description", "statement", "kind", "well", "secondorder", "concept", "expressed", "term", "prover9", "existing", "firstorder", "logic", "return", "worth", "investment", "since", "prover9", "delivered", "proof", "ex1", "e", "g", "there", "one", "one", "godbut", "added", "bonus", "close", "inspection", "output", "provides", "yet", "another", "example", "automated", "theorem", "prover", "outreasoning", "user", "revealing", "logical", "machinery", "actually", "redundant", "proof", "constructed", "using", "two", "logical", "theorem", "theory", "description", "called", "theorem", "2", "theorem", "3", "article", "one", "nonlogical", "premise", "called", "premise", "2", "definition", "god", "help", "include", "prover9", "shorter", "proof", "written", "elegant", "notation", "standard", "logic", "oppenheimer", "zalta", "2011", "1", "e", "\u03b9x\u03c61", "assumption", "reductio", "2", "y", "gy\u03b9x\u03c61", "cy", "1", "premise", "2", "mp", "3", "gh\u03b9x\u03c61", "ch", "2", "e", "h", "arbitrary", "4", "gh\u03b9x\u03c61", "3", "e", "5", "y", "\u03b9x\u03c61", "4", "theory", "description", "theorem", "3", "6", "c\u03b9x\u03c61", "y", "gy\u03b9x\u03c61", "cy", "5", "theory", "description", "theorem", "2", "7", "y", "gy\u03b9x\u03c61", "cy", "6", "e", "8", "e", "\u03b9x\u03c61", "1", "2", "7", "reductio", "9", "e", "g", "8", "definition", "g", "tradition", "st", "anselm", "g\u00f6del", "also", "provided", "ontological", "proof", "god", "existence", "g\u00f6del", "1970", "scott", "1972", "important", "difference", "two", "g\u00f6del", "use", "modal", "operator", "represent", "metaphysical", "possibility", "necessity", "course", "use", "symbolic", "logic", "added", "reasoning", "precision", "proof", "g\u00f6del", "begin", "framing", "concept", "positive", "property", "using", "two", "axiom", "introduces", "definition", "stating", "godlike", "posse", "positive", "property", "enough", "logical", "machinery", "prove", "theorem", "possibility", "god", "existence", "xg", "x", "three", "axiom", "two", "additional", "definition", "allow", "g\u00f6del", "proof", "establish", "god", "exists", "xg", "x", "necessity", "xg", "x", "g\u00f6del", "proof", "formalism", "higherorder", "modal", "logic", "homl", "using", "modal", "operator", "quantification", "property", "g\u00f6del", "never", "published", "proof", "shared", "dana", "scott", "produced", "version", "presented", "taken", "benzm\u00fcller", "paleo", "2014", "along", "english", "annotation", "aid", "reader", "intended", "interpretation", "axiom", "a1", "\u03d5", "p", "\u03d5", "p", "\u03d5", "either", "property", "negation", "positive", "axiom", "a2", "\u03d5\u03c8", "p", "\u03d5", "x", "\u03d5", "x", "\u03c8", "x", "p", "\u03c8", "property", "necessarily", "implied", "positive", "property", "positive", "theorem", "t1", "\u03d5", "p", "\u03d5", "x\u03d5", "x", "positive", "property", "possibly", "exemplified", "definition", "d1", "g", "x", "\u03d5", "p", "\u03d5", "\u03d5", "x", "godlike", "posse", "positive", "property", "axiom", "a3", "p", "g", "property", "godlike", "positive", "corollary", "c", "xg", "x", "possibly", "god", "exists", "axiom", "a4", "\u03d5", "p", "\u03d5", "p", "\u03d5", "positive", "property", "necessarily", "positive", "definition", "d2", "\u03d5", "es", "x", "\u03d5", "x", "\u03c8", "\u03c8", "x", "y", "\u03d5", "\u03c8", "essence", "individual", "property", "possessed", "necessarily", "implying", "property", "theorem", "t2", "x", "g", "x", "g", "es", "x", "godlike", "essence", "godlike", "definition", "d3", "ne", "x", "\u03d5", "\u03d5", "es", "x", "y\u03d5", "necessary", "existence", "individual", "necessary", "exemplification", "essence", "axiom", "a5", "p", "ne", "necessary", "existence", "positive", "property", "theorem", "t3", "xg", "x", "necessarily", "god", "exists", "proof", "recently", "analysed", "unprecedented", "degree", "detail", "precision", "benzm\u00fcller", "paleo", "2014", "help", "automated", "theorem", "provers", "major", "challenge", "faced", "author", "lack", "homlbased", "theorem", "prover", "could", "carry", "work", "circumvented", "embedding", "logic", "classical", "higherorder", "logic", "hol", "already", "offered", "existing", "theorem", "provers", "like", "leoii", "satallax", "countermodel", "finder", "nitpick", "detail", "syntactic", "semantic", "embedding", "given", "paper", "consists", "encoding", "homl", "formula", "hol", "predicate", "via", "mapping", "expansion", "\u03b2\u03b7conversions", "mapping", "associate", "homl", "type", "\u03b1", "term", "s\u03b1", "logical", "operator", "\u03b8", "corresponding", "hol", "raised", "type", "\u03b1", "typeraised", "term", "s\u03b1", "typeraised", "logical", "operator", "\u03b8", "\u03bc", "\u03bf", "respectively", "type", "individual", "booleans", "\u03bc", "\u03bc", "\u03bf", "\u03c3", "\u03c3", "shorthand", "\u03b9", "\u03bf", "\u03b9", "type", "possible", "world", "function", "type", "\u03b2\u03b3", "\u03b2\u03b3", "typeraised", "term", "s\u03b1", "defined", "inductively", "structure", "s\u03b1", "following", "example", "illustrates", "\u03bc\u03bf", "\u03bf", "x\u03bc", "g\u03bc\u03bf", "x", "\u03bc\u03bf", "\u03bf", "x\u03bc", "g\u03bc\u03bf", "x", "\u03bc\u03bf", "\u03bf", "x\u03bc", "g\u03bc\u03bf", "x", "\u03bc\u03bf", "\u03bf", "x\u03bc", "g\u03bc\u03bf", "x", "\u03bc\u03c3", "\u03c3", "x\u03bc", "g\u03bc\u03c3", "x", "typeraised", "logical", "connective", "\u03b8", "defined", "r", "new", "constant", "symbol", "hol", "associated", "accessibility", "relation", "homl", "\u03c3\u03c3", "\u03bbs\u03c3", "\u03bbw\u03b9", "sw", "\u03c3\u03c3\u03c3", "\u03bbs\u03c3", "\u03bbt\u03c3", "\u03bbw\u03b9", "sw", "tw", "\u03b1\u03c3", "\u03c3", "\u03bbs\u03b1\u03c3", "\u03bbw\u03b9x\u03b1", "sxw", "\u03c3\u03c3", "\u03bbs\u03c3", "\u03bbw\u03b9u\u03b9", "r\u03b9\u03b9owu", "su", "connective", "defined", "usual", "way", "validity", "expressed", "\u03bbterm", "\u03bbs\u03b9\u03bfw\u03b9", "sw", "applied", "term", "s\u03c3", "write", "s\u03c3", "example", "embedding", "proving", "homl", "possibility", "god", "existence", "\u03bf\u03bf", "\u03bc\u03bf", "\u03bf", "x\u03bc", "g\u03bc\u03bf", "x", "tantamount", "proving", "validity", "hol", "\u03c3\u03c3", "\u03bc\u03c3", "\u03c3", "x\u03bc", "g\u03bc\u03c3", "x", "\u03bc\u03bf", "prove", "typeraised", "hol", "expression", "x\u03bc", "g\u03bc\u03c3", "x", "encoded", "socalled", "thf0", "syntax", "sutcliffe", "benzm\u00fcller", "2010", "prior", "fed", "along", "set", "equality", "rule", "provers", "used", "completing", "proof", "thf", "corc", "conjecture", "v", "mdia", "mexists_ind", "x", "mu", "g", "x", "proof", "benzm\u00fcller", "paleo", "2014", "presented", "including", "axiom", "definition", "well", "derivation", "four", "main", "resultst1", "c", "t2", "t3all", "written", "typedecorated", "typeraised", "higherorder", "logic", "notation", "resulting", "embedding", "proof", "step", "fully", "expandednote", "presence", "typeraised", "connectivesand", "inferential", "move", "broken", "lower", "level", "detail", "borrowing", "phrase", "bertrand", "russell", "urquhart", "1994", "done", "spare", "reader", "kind", "nausea", "fully", "detailed", "automated", "proof", "would", "cause", "a1", "\u03d5\u03bc\u03c3", "p", "\u03bc\u03c3", "\u03c3", "\u03bbx\u03bc", "\u03d5x", "p\u03d5", "axiom", "a2", "\u03d5\u03bc\u03c3", "\u03c8\u03bc\u03c3", "p", "\u03bc\u03c3", "\u03c3", "\u03d5", "x\u03bc", "\u03d5x", "\u03c8x", "p\u03c8", "axiom", "t1", "\u03d5\u03bc\u03c3", "p", "\u03bc\u03c3", "\u03c3", "\u03d5", "x\u03bc", "\u03d5x", "a1", "a2", "k", "d1", "g\u03bc\u03c3", "\u03bbx\u03bc", "\u03d5\u03bc\u03c3", "p", "\u03bc\u03c3", "\u03c3", "\u03d5", "\u03d5x", "definition", "a3", "p", "\u03bc\u03c3", "\u03c3", "g\u03bc\u03c3", "axiom", "c", "x\u03bc", "g\u03bc\u03c3", "x", "t1", "d1", "a3", "k", "a4", "\u03d5\u03bc\u03c3", "p", "\u03bc\u03c3", "\u03c3", "\u03d5", "p\u03d5", "axiom", "d2", "es", "\u03bc\u03c3", "\u03bc\u03c3", "\u03bb\u03d5\u03bc\u03c3", "\u03bbx\u03bc", "\u03d5x", "\u03c8\u03bc\u03c3", "\u03c8x", "y\u03bc", "\u03d5y", "\u03c8y", "definition", "t2", "x\u03bc", "g\u03bc\u03c3", "x", "es", "\u03bc\u03c3", "\u03bc\u03c3", "gx", "a1", "d1", "a4", "d2", "k", "d3", "ne\u03bc\u03c3", "\u03bbx\u03bc", "\u03d5\u03bc\u03c3", "es", "\u03d5x", "y\u03bc", "\u03d5y", "definition", "a5", "p", "\u03bc\u03c3", "\u03c3", "ne\u03bc\u03c3", "axiom", "t3", "x\u03bc", "g\u03bc\u03c3", "x", "d1", "c", "t2", "d3", "a5", "kb", "besides", "helping", "completion", "proof", "automated", "theorem", "provers", "also", "instrumental", "finding", "novel", "result", "first", "g\u00f6del", "set", "original", "assumption", "shown", "inconsistent", "leoii", "proving", "selfdifference", "becomes", "essential", "property", "every", "entity", "reformulation", "definition", "essence", "due", "dana", "scottthis", "involved", "addition", "missing", "conjunct", "\u03d5x", "definitionwas", "shown", "nitpick", "consistent", "second", "leoii", "satallax", "managed", "prove", "c", "t1", "t2", "using", "logic", "system", "k", "moreover", "nitpick", "found", "countermodel", "t3", "k", "thus", "showing", "logical", "power", "required", "complete", "rest", "proof", "third", "using", "leoii", "satallax", "shown", "logic", "system", "kb", "system", "k", "brouwer", "axiom", "sufficient", "establish", "necessity", "god", "existence", "x\u03bc", "g\u03bc\u03c3", "x", "doublewin", "automated", "reasoning", "gain", "logical", "economy", "deeper", "philosophical", "result", "effectively", "dismissed", "major", "criticism", "g\u00f6del", "proof", "namely", "use", "stronger", "logic", "system", "s5", "fourth", "author", "also", "prove", "kb", "\u03d5\u03bc\u03c3", "x\u03bc", "g\u03bc\u03c3", "x", "p", "\u03bc\u03c3", "\u03c3", "\u03d5", "\u03d5x", "well", "x\u03bc", "y\u03bc", "g\u03bc\u03c3", "x", "g\u03bc\u03c3", "x", "god", "flawless", "monotheism", "hold", "respectively", "point", "would", "fair", "say", "result", "would", "enough", "vindicate", "application", "automated", "reasoning", "exact", "philosophy", "bad", "news", "followed", "good", "news", "fifth", "formula", "s\u03c3", "s\u03c3", "also", "formally", "derived", "unfortunate", "since", "implies", "contingent", "truth", "everything", "determined", "ie", "free", "however", "issue", "addressed", "followup", "work", "based", "fitting", "anderson", "variant", "ontological", "argument", "fuenmayor", "benzm\u00fcller", "2017", "fitting", "2002", "anderson", "1990", "leibniz", "dream", "charateristica", "universalis", "calculus", "ratiocinator", "would", "allow", "u", "reason", "metaphysics", "moral", "much", "way", "geometry", "analysis", "say", "settle", "dispute", "philosopher", "accountant", "take", "pen", "hand", "sit", "abacus", "called", "friend", "want", "say", "let", "u", "calculate", "application", "automated", "reasoning", "one", "would", "agree", "researcher", "imply", "result", "achieve", "extent", "leibniz", "goal", "computational", "metaphysics", "fitelson", "zalta", "2007", "benzm\u00fcller", "paleo", "2014", "nonmonotonic", "theorem", "prover", "provide", "basis", "computational", "laboratory", "explore", "experiment", "different", "model", "artificial", "rationality", "theorem", "prover", "used", "equip", "artificial", "rational", "agent", "inference", "engine", "reason", "gain", "information", "world", "procedural", "epistemology", "rational", "agent", "defeasible", "ie", "nonmonotonic", "sense", "new", "reasoning", "lead", "acceptance", "new", "belief", "also", "retraction", "previously", "held", "belief", "presence", "new", "information", "given", "point", "time", "agent", "hold", "set", "justified", "belief", "set", "open", "revision", "continuous", "set", "flux", "reasoning", "conducted", "model", "better", "reflects", "accepted", "notion", "rationality", "model", "belief", "warranted", "ie", "belief", "attained", "never", "retracted", "actually", "set", "warranted", "belief", "seen", "justified", "belief", "limit", "ultimate", "epistemic", "goal", "agent", "search", "true", "knowledge", "world", "pollock", "1995", "offer", "following", "definition", "set", "defeasible", "enumerable", "iff", "effective", "computable", "function", "f", "n", "f", "n", "recursive", "set", "following", "two", "condition", "hold", "1", "x", "x", "n", "m", "n", "x", "f", "2", "x", "x", "n", "m", "n", "x", "f", "compare", "concept", "recursively", "enumerable", "sequence", "recursive", "set", "ai", "ai", "subset", "ai", "growing", "monotonically", "approaching", "limit", "defeasibly", "enumerable", "ai", "still", "approach", "limit", "may", "subset", "approach", "intermittently", "goal", "oscar", "project", "pollock", "1989", "construct", "general", "theory", "rationality", "implement", "artificial", "computerbased", "rational", "agent", "system", "us", "defeasible", "automated", "reasoner", "operates", "according", "maxim", "set", "warranted", "belief", "defeasible", "enumerable", "oscar", "making", "time", "application", "automated", "nonmonotonic", "reasoning", "also", "used", "extend", "capability", "reason", "defeasibly", "perception", "time", "causation", "decisiontheoretic", "planning", "pollock", "2006", "47", "mathematics", "one", "main", "goal", "automated", "reasoning", "automation", "mathematics", "early", "attempt", "automath", "de", "bruijn", "1968", "first", "computer", "system", "used", "check", "correctness", "proof", "whole", "book", "mathematics", "including", "landau", "grundlagen", "der", "analysis", "van", "benthem", "jutting", "1977", "automath", "superseded", "modern", "capable", "system", "notably", "mizar", "mizar", "system", "trybulec", "1979", "muzalewski", "1993", "based", "tarskigrothendieck", "set", "theory", "like", "automath", "consists", "formal", "language", "used", "write", "mathematical", "theorem", "proof", "proof", "written", "language", "checked", "automatically", "mizar", "correctness", "mizar", "proof", "formal", "quite", "readable", "refer", "definition", "previously", "proved", "theorem", "formally", "checked", "added", "growing", "mizar", "mathematical", "library", "mml", "bancerek", "rudnicki", "2003", "bancerek", "et", "al", "2018", "june", "2018", "mml", "contained", "12000", "definition", "59000", "theorem", "mizar", "language", "subset", "standard", "english", "used", "mathematical", "text", "highly", "structured", "ensure", "production", "rigorous", "semantically", "unambiguous", "text", "sample", "proof", "mizar", "existence", "rational", "number", "xy", "x", "irrational", "theorem", "t2", "ex", "x", "st", "x", "irrational", "irrational", "xy", "rational", "proof", "set", "w", "2", "h1", "w", "irrational", "int_244", "t1", "w", "0", "axioms22", "square_184", "ww", "w", "w", "ww", "power38", "w", "w2", "square_158", "w2", "square_188", "w2", "power53", "2", "square_188", "h2", "ww", "w", "rational", "rat_18", "per", "case", "suppose", "h3", "ww", "rational", "take", "w", "w", "thus", "thesis", "h1", "h3", "suppose", "h4", "ww", "irrational", "take", "ww", "w", "thus", "thesis", "h1", "h2", "h4", "end", "example", "proof", "checked", "mizar", "include", "hahnbanach", "theorem", "brouwer", "fixedpoint", "theorem", "k\u0151nig", "lemma", "jordan", "curve", "theorem", "g\u00f6del", "completeness", "theorem", "rudnicki", "2004", "discus", "challenge", "formalizing", "witt", "proof", "wedderburn", "theorem", "every", "finite", "division", "ring", "commutative", "theorem", "formulated", "easily", "using", "existing", "formalization", "available", "mml", "proof", "demanded", "entry", "library", "formalize", "notion", "fact", "algebra", "complex", "number", "integer", "root", "unity", "cyclotomic", "polynomial", "polynomial", "general", "took", "several", "month", "effort", "supply", "missing", "material", "mml", "library", "place", "proof", "formalized", "checked", "correct", "matter", "day", "clearly", "repository", "formalized", "mathematical", "fact", "definition", "prerequisite", "advanced", "application", "qed", "manifesto", "boyer", "et", "al", "1994", "wiedijk", "2007", "aim", "mind", "much", "work", "mizar", "largest", "repository", "even", "30", "year", "work", "minuscule", "respect", "body", "established", "mathematics", "rudnicki", "2004", "last", "remark", "construed", "call", "increase", "effort", "toward", "important", "aspect", "automation", "mathematics", "mizar", "goal", "assist", "practitioner", "formalization", "proof", "help", "check", "correctness", "system", "aim", "finding", "proof", "geometry", "target", "early", "automated", "prooffinding", "effort", "chou", "1987", "prof", "500", "geometry", "theorem", "using", "algebraic", "approach", "offered", "wu", "method", "gr\u00f6bner", "basis", "method", "representing", "hypothesis", "conclusion", "polynomial", "equation", "quaife", "1992", "provides", "another", "early", "effort", "find", "proof", "firstorder", "mathematics", "400", "theorem", "neumannbernaysg\u00f6del", "set", "theory", "1000", "theorem", "arithmetic", "number", "theorem", "euclidian", "geometry", "g\u00f6del", "incompleteness", "theorem", "approach", "best", "described", "semiautomatic", "interactive", "user", "providing", "significant", "amount", "input", "guide", "theoremproving", "effort", "surprise", "since", "one", "applies", "automated", "reasoning", "system", "richer", "area", "mathematics", "system", "take", "role", "proof", "assistant", "theorem", "provers", "richer", "mathematical", "domain", "system", "need", "reason", "theory", "higherorder", "object", "general", "take", "deeper", "undecidable", "interactive", "theorem", "proving", "arguably", "killer", "application", "automated", "reasoning", "mathematics", "much", "effort", "expended", "building", "increasingly", "capable", "reasoning", "system", "act", "assistant", "professional", "mathematician", "proof", "assistant", "isabellehol", "provides", "user", "environment", "conduct", "proof", "expressed", "structured", "yet", "humanreadable", "higherorder", "logic", "language", "incorporates", "number", "facility", "increase", "user", "productivity", "automates", "proofverification", "prooffinding", "task", "provides", "modular", "way", "user", "build", "manage", "theory", "hierarchy", "ballarin", "2014", "different", "proof", "assistant", "offer", "different", "capability", "measured", "power", "automating", "reasoning", "task", "supported", "logic", "object", "typing", "size", "mathematical", "library", "readability", "input", "output", "canonical", "proof", "trivial", "complex", "either", "used", "baseline", "system", "comparison", "done", "wiedijk", "2006", "author", "seventeen", "reasoning", "system", "tasked", "establishing", "irrationality", "2", "system", "discussed", "certainly", "capable", "used", "assist", "formalization", "far", "advanced", "proof", "erd\u00f6sselberg", "proof", "prime", "number", "theorem", "30000", "line", "isabelle", "formalization", "four", "color", "theorem", "60000", "line", "coq", "jordan", "curve", "theorem", "75000", "line", "hol", "light", "milestone", "interactive", "theorem", "proving", "reached", "2012", "sixyears", "effort", "using", "coq", "proof", "assistant", "george", "gonthier", "team", "completed", "formal", "verification", "255page", "proof", "feitthompson", "theorem", "also", "known", "odd", "order", "theorem", "major", "step", "classification", "finite", "simple", "group", "notwithstanding", "automated", "reasoning", "small", "impact", "practice", "mathematics", "number", "reason", "given", "one", "reason", "automated", "theorem", "provers", "sufficiently", "powerful", "attempt", "kind", "problem", "mathematician", "typically", "deal", "current", "power", "best", "level", "firstyear", "undergraduate", "mathematics", "still", "far", "leading", "edge", "mathematical", "research", "true", "current", "system", "prove", "completely", "problem", "level", "difficulty", "remember", "goal", "build", "reasoning", "system", "eventually", "machine", "aid", "mathematical", "research", "substitute", "wang", "1960", "mind", "automated", "reasoning", "community", "continues", "try", "meet", "grand", "challenge", "building", "increasingly", "powerful", "theorem", "provers", "mathematician", "draw", "benefit", "offered", "current", "system", "including", "assistance", "completing", "proof", "gap", "formalizing", "checking", "correctness", "proposed", "proof", "indeed", "latter", "may", "application", "could", "help", "address", "real", "issue", "currently", "faced", "mathematical", "community", "consider", "announcement", "daniel", "goldston", "cem", "yildrim", "proof", "twin", "prime", "conjecture", "although", "expert", "initially", "agreed", "proof", "correct", "insurmountable", "error", "found", "shortly", "think", "case", "hale", "proof", "kepler", "conjecture", "asserts", "packing", "congruent", "ball", "euclidean", "3space", "density", "greater", "facecentered", "cubic", "packing", "hale", "proof", "consists", "300", "page", "text", "large", "number", "computer", "calculation", "four", "year", "hard", "work", "12person", "panel", "assigned", "annals", "mathematics", "task", "verifying", "proof", "still", "genuine", "doubt", "correctness", "thomas", "hale", "one", "took", "upon", "formalize", "proof", "checked", "automated", "proof", "assistant", "aim", "convincing", "others", "correctness", "hale", "2005b", "internet", "resource", "task", "admittedly", "heavy", "outcome", "potentially", "significant", "mathematical", "automated", "reasoning", "community", "eye", "hale", "formal", "proof", "announced", "completion", "flyspeck", "project", "hale", "2014", "internet", "resource", "hale", "2015", "constructed", "formal", "proof", "conjecture", "using", "isabelle", "hol", "light", "automated", "proof", "assistant", "truth", "motivation", "project", "far", "complex", "simple", "hope", "removing", "residual", "doubt", "mind", "referee", "indeed", "see", "formal", "method", "fundamental", "longterm", "growth", "mathematics", "hale", "2006", "church", "1936a", "1936b", "turing", "1936", "imply", "existence", "theorem", "whose", "shortest", "proof", "large", "proof", "four", "color", "theorem", "appel", "haken", "1977", "classification", "simple", "group", "gorenstein", "1982", "proof", "kepler", "conjecture", "hale", "2005a", "may", "well", "sample", "yet", "come", "bundy", "2011", "put", "important", "theorem", "requiring", "larger", "larger", "proof", "emerge", "mathematics", "face", "dilemma", "either", "theorem", "must", "ignored", "computer", "must", "used", "assist", "proofs", "remark", "also", "counter", "another", "argument", "given", "using", "automated", "theorem", "provers", "mathematician", "enjoy", "proving", "theorem", "let", "machine", "take", "away", "fun", "answer", "course", "mathematician", "even", "fun", "letting", "machine", "tedious", "menial", "task", "unworthy", "excellent", "men", "lose", "hour", "like", "slave", "labour", "calculation", "could", "safely", "relegated", "anyone", "else", "machine", "used", "g", "w", "leibniz", "new", "essay", "concerning", "human", "understanding", "still", "convinced", "consider", "sobering", "prospect", "manually", "check", "23000", "inequality", "used", "hale", "proof", "another", "reason", "given", "weak", "acceptance", "automated", "reasoning", "mathematical", "community", "program", "trusted", "since", "may", "contain", "bugssoftware", "defectsand", "hence", "may", "produce", "erroneous", "result", "formally", "verifying", "automated", "reasoning", "program", "help", "ameliorate", "particularly", "case", "proof", "checker", "proving", "program", "correct", "easy", "task", "true", "proving", "theorem", "advanced", "mathematics", "gonthier", "proved", "correct", "program", "used", "formalization", "proof", "four", "color", "theorem", "spent", "far", "effort", "formalizing", "graph", "theory", "part", "proof", "ironically", "enough", "turn", "least", "case", "surely", "others", "actually", "easier", "verify", "correctness", "program", "verify", "correctness", "penandpaper", "mathematics", "wiedijk", "2006", "theorem", "provers", "model", "finder", "complementary", "strategy", "would", "verify", "program", "result", "opposed", "program", "paraphrasing", "slaney", "1994", "matter", "mathematician", "many", "defect", "program", "may", "long", "proof", "model", "output", "correct", "onus", "verification", "result", "whether", "produced", "machine", "man", "checking", "independent", "party", "course", "effort", "may", "well", "use", "automated", "checker", "increase", "confidence", "validity", "proof", "often", "argued", "automated", "proof", "long", "detailed", "proof", "expressed", "elementary", "step", "principle", "beneficial", "since", "allows", "mathematician", "request", "proof", "assistant", "justify", "step", "term", "simpler", "one", "proof", "assistant", "also", "allow", "opposite", "namely", "abstract", "detail", "present", "result", "justification", "using", "higherlevel", "concept", "language", "notation", "mathematician", "accustomed", "exploiting", "hierarchical", "structure", "proof", "done", "denney", "2006", "step", "direction", "work", "along", "line", "needed", "proof", "assistant", "work", "desired", "level", "granularity", "provides", "opportunity", "insight", "proof", "discovery", "process", "important", "consideration", "since", "mathematician", "equally", "interested", "gaining", "understanding", "proof", "establishing", "fact", "bundy", "2011", "alludes", "deadlock", "preventing", "wider", "adoption", "theorem", "provers", "mathematical", "community", "one", "hand", "mathematician", "need", "use", "proof", "assistant", "build", "large", "formal", "library", "mathematical", "result", "hand", "want", "use", "provers", "since", "library", "previously", "proved", "result", "build", "upon", "break", "impasse", "number", "application", "proposed", "assisting", "mathematician", "search", "previously", "proved", "theorem", "particular", "promise", "history", "mathematics", "accumulated", "huge", "number", "theorem", "number", "mathematical", "result", "continues", "grow", "dramatically", "2010", "zentralblatt", "math", "covered", "120000", "new", "publication", "wegner", "2011", "clearly", "individual", "researcher", "acquainted", "mathematical", "knowledge", "increasingly", "difficult", "cope", "one", "evergrowing", "area", "specialty", "unless", "assisted", "automated", "theoremproving", "tool", "search", "intelligent", "way", "previously", "proved", "result", "interest", "alternative", "approach", "problem", "mathematician", "tap", "knowledge", "enabled", "computational", "social", "system", "like", "polymath", "mathoverflow", "integration", "automated", "reasoning", "tool", "social", "system", "would", "increase", "effectiveness", "collective", "intelligence", "supporting", "combination", "precise", "formal", "deduction", "informal", "loose", "interaction", "seen", "mathematical", "practice", "martin", "pea", "2013", "internet", "resource", "due", "real", "pressing", "need", "industry", "application", "automated", "reasoning", "pure", "applied", "mathematics", "necessity", "choice", "worked", "formalization", "elementary", "real", "analysis", "verify", "hardwarebased", "floating", "point", "trigonometric", "function", "harrison", "2006", "harrison", "2000", "mention", "need", "formalize", "pure", "mathematicsitalics", "histo", "extend", "formalization", "power", "series", "trigonometric", "function", "basic", "theorem", "diophantine", "approximation", "harrison", "find", "surprising", "extensive", "mathematical", "development", "used", "simply", "verify", "floating", "point", "tangent", "function", "satisfies", "certain", "error", "bound", "remark", "one", "would", "expect", "industrial", "application", "demand", "extensive", "formalization", "albeit", "rate", "originally", "anticipated", "automated", "reasoning", "finding", "application", "mathematics", "formal", "verification", "proof", "special", "significance", "since", "provides", "viable", "mechanism", "check", "proof", "human", "alone", "could", "also", "side", "effect", "potential", "redefine", "would", "take", "proof", "accepted", "use", "automated", "reasoning", "assistant", "becomes", "widespread", "one", "envision", "use", "following", "certain", "methodical", "order", "first", "automated", "reasoning", "tool", "used", "theory", "exploration", "discovery", "identified", "target", "problem", "practitioner", "work", "interactively", "automated", "assistant", "find", "proof", "establish", "fact", "finally", "automated", "proof", "checker", "used", "check", "correctness", "final", "proof", "prior", "submitted", "publication", "made", "available", "rest", "mathematical", "community", "via", "creation", "new", "entry", "repository", "formalized", "mathematics", "indeed", "matter", "time", "application", "automated", "proof", "assistant", "becomes", "everyday", "affair", "life", "mathematician", "grand", "challenge", "automated", "reasoning", "community", "make", "happen", "sooner", "later", "48", "artificial", "intelligence", "since", "inception", "field", "automated", "theorem", "proving", "important", "application", "larger", "field", "artificial", "intelligence", "ai", "automated", "deduction", "heart", "ai", "application", "like", "logic", "programming", "see", "section", "41", "logic", "programming", "article", "computation", "equated", "deduction", "robotics", "problem", "solving", "green", "1969", "step", "achieve", "goal", "step", "extracted", "proof", "deductive", "database", "minker", "et", "al", "2014", "factual", "knowledge", "expressed", "atomic", "clause", "inference", "rule", "new", "fact", "inferred", "deduction", "expert", "system", "giarratano", "riley", "2004", "human", "expertise", "given", "domain", "eg", "blood", "infection", "captured", "collection", "ifthen", "deduction", "rule", "conclusion", "eg", "diagnosis", "obtained", "application", "inference", "rule", "many", "others", "application", "automated", "reasoning", "ai", "bound", "deep", "philosophical", "implication", "increased", "use", "bdi", "computational", "logic", "describing", "belief", "desire", "intention", "intelligent", "agent", "multiagent", "system", "meyer", "2014", "particular", "endowing", "future", "intelligent", "system", "decisionsupport", "system", "robot", "legal", "ethical", "behaviour", "deontic", "logic", "automated", "task", "furbach", "et", "al", "2014", "given", "agreement", "universal", "system", "deontic", "logic", "ethic", "code", "designer", "need", "way", "experiment", "different", "deontic", "system", "ie", "lay", "axiom", "see", "conclusion", "follow", "help", "identify", "desired", "ethic", "code", "specific", "application", "hand", "benzm\u00fcller", "et", "al", "2018", "discus", "environment", "actual", "physical", "robot", "used", "experiment", "term", "deontic", "laboratory", "would", "quite", "descriptive", "albeit", "somewhat", "eerie", "restricting", "proof", "search", "space", "always", "key", "consideration", "implementation", "automated", "deduction", "traditional", "aiapproaches", "search", "integral", "part", "theorem", "provers", "main", "idea", "prevent", "prover", "pursuing", "unfruitful", "reasoning", "path", "dual", "aspect", "search", "try", "look", "previously", "proved", "result", "could", "useful", "completion", "current", "proof", "automatically", "identifying", "result", "easy", "task", "becomes", "le", "easy", "size", "problem", "domain", "number", "already", "established", "result", "grows", "happy", "situation", "particularly", "light", "growing", "trend", "build", "large", "library", "theorem", "mizar", "problem", "theorem", "proving", "mptp", "urban", "et", "al", "2010", "bancerek", "rudnicki", "2003", "isabellehol", "mathematical", "library", "meng", "paulson", "2008", "developing", "technique", "discovery", "evaluation", "selection", "existing", "suitable", "definition", "premise", "lemma", "large", "library", "formal", "mathematics", "discussed", "k\u00fchlwein", "et", "al", "2012", "important", "line", "research", "among", "many", "method", "stark", "contrast", "automated", "provers", "mathematician", "combine", "induction", "heuristic", "deductive", "technique", "attacking", "problem", "former", "help", "guide", "prooffinding", "effort", "latter", "allows", "close", "proof", "gap", "course", "happens", "presence", "large", "body", "knowledge", "human", "posse", "automated", "prover", "analogous", "counterpart", "mathematician", "body", "knowledge", "large", "library", "like", "mptp", "analogous", "approach", "using", "inductive", "heuristic", "would", "endow", "theorem", "prover", "inductive", "datadriven", "machine", "learning", "ability", "urban", "vyskocil", "2012", "run", "number", "experiment", "determine", "gain", "may", "result", "approach", "use", "mptp", "theorem", "provers", "like", "e", "spa", "enhanced", "symbolbased", "machine", "learning", "mechanism", "detailed", "presentation", "statistical", "result", "found", "reference", "summary", "quoting", "author", "experiment", "demonstrates", "real", "quite", "unique", "benefit", "large", "formal", "mathematical", "library", "conducting", "novel", "integration", "ai", "method", "machine", "learner", "trained", "previous", "proof", "recommends", "relevant", "premise", "large", "library", "according", "past", "experience", "useful", "proving", "new", "conjectures", "urban", "2007", "discus", "malarea", "machine", "learner", "automated", "reasoning", "metasystem", "also", "combine", "inductive", "deductive", "reasoning", "method", "malarea", "intended", "used", "large", "theory", "ie", "problem", "large", "number", "symbol", "definition", "premise", "lemma", "theorem", "system", "work", "cycle", "result", "proved", "deductively", "given", "iteration", "used", "inductive", "machinelearning", "component", "place", "restriction", "search", "space", "next", "theoremproving", "cycle", "albeit", "simple", "design", "first", "version", "malarea", "solved", "142", "problem", "252", "mptp", "challenge", "outperforming", "seasoned", "provers", "e", "89", "problem", "solved", "spa", "81", "problem", "solved", "besides", "using", "large", "mathematical", "library", "tapping", "webbased", "semantic", "ontology", "another", "possible", "source", "knowledge", "pea", "sutcliffe", "2007", "discus", "way", "making", "sumo", "ontology", "suitable", "firstorder", "theorem", "proving", "describes", "work", "translating", "sumo", "tptp", "added", "benefit", "successfully", "reasoning", "large", "semantic", "ontology", "promotes", "application", "automated", "reasoning", "field", "science", "tapping", "full", "potential", "however", "require", "closer", "alignment", "method", "automated", "reasoning", "artificial", "intelligence", "5", "conclusion", "automated", "reasoning", "growing", "field", "provides", "healthy", "interplay", "basic", "research", "application", "automated", "deduction", "conducted", "using", "multiplicity", "theoremproving", "method", "including", "resolution", "sequent", "calculus", "natural", "deduction", "matrix", "connection", "method", "term", "rewriting", "mathematical", "induction", "others", "method", "implemented", "using", "variety", "logic", "formalism", "firstorder", "logic", "type", "theory", "higherorder", "logic", "clause", "horn", "logic", "nonclassical", "logic", "automated", "reasoning", "program", "applied", "solve", "growing", "number", "problem", "formal", "logic", "mathematics", "computer", "science", "logic", "programming", "software", "hardware", "verification", "circuit", "design", "exact", "philosophy", "many", "others", "one", "result", "variety", "formalism", "automated", "deduction", "method", "proliferation", "large", "number", "theorem", "proving", "program", "test", "capability", "different", "program", "selection", "problem", "proposed", "performance", "measured", "mccharen", "overbeek", "wos", "1976", "pelletier", "1986", "tptp", "sutcliffe", "suttner", "1998", "library", "problem", "updated", "regular", "basis", "also", "competition", "among", "automated", "theorem", "provers", "held", "regularly", "cade", "conference", "pelletier", "sutcliffe", "suttner", "2002", "sutcliffe", "2016", "internet", "resource", "problem", "competition", "selected", "tptp", "library", "similar", "library", "competition", "smt", "solver", "barret", "et", "al", "2013", "initially", "computer", "used", "aid", "scientist", "complex", "often", "tedious", "numerical", "calculation", "power", "machine", "extended", "numeric", "symbolic", "domain", "infiniteprecision", "computation", "performed", "computer", "algebra", "program", "become", "everyday", "affair", "goal", "automated", "reasoning", "extend", "machine", "reach", "realm", "deduction", "used", "reasoning", "assistant", "helping", "user", "establish", "truth", "proof"]}