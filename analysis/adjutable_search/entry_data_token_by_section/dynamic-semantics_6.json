{
    "main_text": "Dynamic Predicate Logic || Specifying Dynamic Predicate Logic\n2.2 Specifying Dynamic Predicate Logic\n\nThe previous subsection gave a first glimpse into the basic aim of a\ndynamic semantic framework, which is to define a logical semantics in\nwhich statements express actions and specifically, in which\nexistential quantification has the potential to reset variables, thus\nchanging the context. We get our clue about how to do this by\nexamining the definition of existential quantification in ordinary\npredicate logic. Suppose we work with total assignments on a fixed set\nof variables \\(\\textsf{VAR}\\) over a fixed domain \\(D\\). The set of\ntotal assignments \\(\\textsf{ASSIGN}\\) is therefore the set of all\n(total) functions from \\(\\textsf{VAR}\\) to \\(D\\).\n\nLet the meaning of atomic formulas like \\(P(x)\\) be the set \\(F\\)\nof all assignments \\(\\alpha\\) such that \\(\\alpha(x)\\) is an object\nsatisfying \\(P\\).\n\nNow define: \n\n\\[\n\\alpha[x]\\beta := \\forall v \\in \\textsf{VAR}\\setminus\\{x\\}\\ (\\alpha(v) = \\beta(v)).\n\\]\n\n So [\\(x\\)] is the binary relation\n\u201cassignment \\(\\beta\\) is a result of (at most) resetting the\nvalue of the variable \\(x\\) in assignment \\(\\alpha\\)\u201d. As\nalready mentioned, this is an equivalence relation over variable\nassignments. Now the meaning \\(G\\) of \\(\\exists x P(x)\\), will be:\n\n\\[\nG := \\{\\alpha \\in \\textsf{ASSIGN } \\mid \\exists \\beta \\in F \\alpha[x]\\beta \\}.\n\\]\n\n Thus, \\(G\\) is the set of assignments that can be\nsuccessfully reset with respect to \\(x\\) and obtain an assignment\nin \\(F\\) as a result of this resetting. Viewed differently,\n\\(G\\) is the domain of the relation \\(R\\) given by\n\n\\[\\alpha R\\beta := \\alpha[x]\\beta \\textrm{ and } \\beta \\in F.\n\\]\n\n \n\nWe could say that \\(G\\) is the precondition for the resetting\naction \\(R\\). Now the idea of \\(\\textsf{DPL}\\) is to take the\nmeaning of \\(\\exists x P(x)\\) to be not the precondition \\(G\\) (as\nin classical static first order logic) but the resetting action\n\\(R\\). In this way we do not lose information since \\(G\\) can\nalways be obtained from \\(R\\). Moreover, the range of the relation\n\\(R\\) consists of assignments \\(\\beta\\) that differ from\nassignments in the precondition \\(G\\) at most with respect to the\nvalue of \\(x\\) and that are also in \\(F\\) (i.e., \\(\\beta(x)\\) is\nin the interpretation of \\(P)\\). The \\(x\\) values stored in the\nrange of the binary relation \\(R\\) are precisely the \\(x\\)\nvalues that satisfy \\(P\\), i.e., the values we were looking\nfor.\n\nMore generally, we take as \\(\\textsf{DPL}\\)-meanings binary\nrelations between assignments. Such relations can be seen as\n(modeling) resetting actions. This is an instance of an\nadmittedly simplistic but well-known and useful way of modeling\nactions: an action is viewed as a relation between the states of the\nworld before the action and the corresponding states after the\naction.\n\nHere is the full definition. Assume a non-empty domain \\(D\\), a set\nof variables \\(\\textsf{VAR}\\) and a model \\(\\mathcal{M}=\\langle D,\nI\\rangle\\) of signature \\(\\Sigma\\). Atomic conditions \\(\\pi\\) are of\nthe form \\(P(x_0 , \\ldots ,x_{n-1})\\), where \\(P\\in \\Sigma\\) is of\narity \\(n\\). Atomic resets \\(\\varepsilon\\) are of the form\n\\(\\exists v\\), where \\(v\\) is a variable. The language of predicate\nlogic for \\(\\Sigma\\) is given below (\\(\\cdot\\) is conjunction and\n\\({\\sim}\\) is negation):  \n\n\\[\n\\phi ::= \\bot \\mid \\top \\mid \\pi \\mid \\varepsilon \\mid \\phi \\cdot \\phi \\mid {\\sim}(\\phi).\n\\]\n\n\nAssignments are elements \\(\\alpha , \\beta ,\\ldots\\), of\n\\(\\textsf{ASSIGN} := D^{\\textsf{VAR}}\\). We define the\ndynamic/relational semantics for this language as follows: \n\n\\(\\alpha[\\bot]\\beta := \\alpha \\ne \\alpha\\).\n\\(\\alpha[\\top]\\beta := \\alpha = \\beta\\).\n\\(\\alpha[P(x_0 , \\ldots ,x_{n-1})]\\beta := \\alpha = \\beta\\) and\n\\(\\langle \\alpha(x_0), \\ldots ,\\alpha(x_{n-1})\\rangle \\in I(P)\\),\nwhere \\(P\\in \\Sigma\\) has arity \\(n\\).\n\\(\\alpha[\\exists v]\\beta := \\alpha[v]\\beta\\)\n\\(\\alpha[\\phi \\cdot \\psi]\\beta :=\\) there is a \\(\\gamma\\) such\nthat \\(\\alpha[\\phi]\\gamma\\) and \\(\\gamma[\\psi]\\beta\\), or\n\\(\\alpha[\\phi]\\gamma[\\psi]\\beta\\) for short.\n\\(\\alpha[{\\sim}(\\phi)]\\beta := \\alpha = \\beta\\) and there is no\n\\(\\gamma\\) such that \\(\\alpha[\\phi]\\gamma\\).\n\n\nNote that conjunction \\(\\cdot\\) is interpreted as relation\ncomposition, and negation \\({\\sim}\\) is basically interpreted as\ncomplementation with respect to the domain of the relation denoted by\nthe negated formula.\n\nTruth is defined in terms of relational meanings; we basically project\nthe binary relations between assignments onto their first\ncoordinate: \n\n\\[\\alpha \\vDash \\phi := \\exists \\beta\\ \\alpha[\\phi]\\beta.\\]\n\n\nWe can define implication \\(\\phi \\rightarrow \\psi\\) as \\({\\sim}(\\phi\n\\cdot {\\sim}\\psi)\\). Applying the truth definition to this gives:\n\n\n\\(\\alpha \\vDash \\phi \\rightarrow \\psi \\textrm{ iff } \\forall\n\\beta(\\alpha[\\phi]\\beta \\Rightarrow \\beta \\vDash \\psi)\\), i.e., any\nassignment \\(\\beta\\) that results from updating \\(\\alpha\\) with the\nantecedent \\(\\phi\\) satisfies the consequent \\(\\psi\\). \n\n\nRelational meanings also yield the following beautiful definition of\ndynamic entailment: \n\n\\[\\phi \\vDash \\psi := \\forall \\alpha , \\beta(\\alpha[\\phi]\\beta \\Rightarrow \\exists \\gamma \\beta[\\psi]\\gamma).\\]\n\n\nThis definition was first introduced by Hans Kamp in his pioneering\npaper Kamp 1981. Informally, it says that any assignment \\(\\beta\\)\nthat has incorporated the update contributed by \\(\\phi\\) is guaranteed\nto support/satisfy \\(\\psi\\).\n\nNote that \\({\\sim}\\phi\\) is equivalent to \\((\\phi \\rightarrow \\bot)\\),\nand that \\((\\phi \\rightarrow \\psi)\\) is true iff \\(\\phi \\vDash \\psi\\).\nEqually importantly, we can define \\(\\forall x (\\phi)\\) as \\((\\exists\nx \\rightarrow \\phi)\\).\n\nA possible alternative notation for \\(\\exists v\\) would be [\\(v := ?\\)] \n(random reset). This emphasizes the connection with random\nassignment in programming languages.\n\nThe interpretations of predicate symbols are conditions. They\nare subsets of the diagonal \\(\\{\\langle \\alpha , \\alpha \\rangle \\mid\n\\alpha \\in \\textsf{ASSIGN}\\}\\) (which is the meaning of \\(\\top)\\).\nSubsets of the diagonal are tests: they modify nothing and simply pass\non what is OK (satisfies the condition) and throw away what is not.\nThe mapping \\(\\textsf{diag}\\) that sends a set \\(F\\) of assignments\nto a condition \\(\\{\\langle \\alpha , \\alpha \\rangle \\mid \\alpha \\in\nF\\}\\) is the link between the classical static and the dynamic world.\nFor example, the relational composition of \\(\\textsf{diag}(F)\\) and\n\\(\\textsf{diag}(G)\\) is \\(\\textsf{diag}(F\\cap G)\\).\n\nClassical first-order logic (FOL) can be interpreted in\n\\(\\textsf{DPL}\\) as follows. We assume that the FOL language has the\nfollowing connectives and quantifiers: \\(\\top , \\bot , \\wedge ,\n\\rightarrow , \\exists x\\). We translate as follows:\n\n\\(( )^*\\) commutes with atomic formulas and with\n\\(\\rightarrow\\)\n\\((\\phi \\wedge \\psi)^* := \\phi^* \\cdot \\psi^*\\)\n\\((\\exists x(\\phi))^* := \\neg \\neg(\\exists x \\cdot \\phi^*)\\)\n\n\nWe get that \\([\\phi^*]\\) is the diagonal of the classical\ninterpretation of \\(\\phi\\). Our translation is compositional. It shows\nthat FOL can be taken as a fragment of \\(\\textsf{DPL}\\).\n\nIt is, conversely, possible to translate any \\(\\textsf{DPL}\\)-formula\n\\(\\phi\\) to a predicate logical formula \\(\\phi\\)\u00b0, such that the\ndomain of \\([\\phi]\\) is the classical interpretation of \\(\\phi\\)\u00b0.\nOne of the ways to define this translation is by means of a\nprecondition calculus, with Floyd-Hoare rules (Eijck and de Vries\n1992). The following is a variation on this. Take the language of\nstandard predicate logic, with diamond modalities \\(\\langle \\psi\n\\rangle \\phi\\) added, where \\(\\psi\\) ranges over DPL formulas and\n\\(\\alpha \\vDash \\langle \\psi \\rangle \\phi\\) iff there is an assignment\n\\(\\beta\\) with \\(\\alpha[\\psi]\\beta\\), and \\(\\beta \\vDash \\phi\\). Then\nthe following equivalences show that this extension does not increase\nexpressive power.\n\n\\(\\langle \\bot \\rangle \\phi \\leftrightarrow \\bot\\).\n\\(\\langle \\top \\rangle \\phi \\leftrightarrow \\phi\\).\n\\(\\langle P(x_1 \\ldots x_n)\\rangle \\phi \\leftrightarrow (P(x_1\n\\ldots x_n) \\wedge \\phi)\\).\n\\(\\langle \\exists v\\rangle \\phi \\leftrightarrow \\exists\nv\\phi\\).\n\\(\\langle \\psi_1 \\cdot \\psi_2\\rangle \\phi \\leftrightarrow \\langle\n\\psi_1\\rangle \\langle \\psi_2\\rangle \\phi\\).\n\\(\\langle{\\sim}(\\psi)\\rangle \\phi \\leftrightarrow(\\neg(\\langle\n\\psi \\rangle \\top) \\wedge \\phi)\\).\n\n\n So in a weak sense \u201cnothing new happens in\n\\(\\textsf{DPL}\\)\u201d. We cannot define a set that we cannot also\ndefine in FOL. The equivalences for the modalities fix a translation\n(\u00a0)\u00b0 that yields the weakest precondition for achieving a\ngiven postcondition; see the next section for an illustration of such\na translation.\n\n",
    "section_title": "2.2 Specifying Dynamic Predicate Logic",
    "entry_title": "Dynamic Semantics",
    "hierarchy_title": "Dynamic Semantics || Dynamic Predicate Logic || Specifying Dynamic Predicate Logic",
    "tokenized_text": [
        "dynamic",
        "predicate",
        "logic",
        "specifying",
        "dynamic",
        "predicate",
        "logic",
        "specifying",
        "dynamic",
        "predicate",
        "logic",
        "previous",
        "subsection",
        "gave",
        "first",
        "glimpse",
        "basic",
        "aim",
        "dynamic",
        "semantic",
        "framework",
        "define",
        "logical",
        "semantics",
        "statement",
        "express",
        "action",
        "specifically",
        "existential",
        "quantification",
        "potential",
        "reset",
        "variable",
        "thus",
        "changing",
        "context",
        "get",
        "clue",
        "examining",
        "definition",
        "existential",
        "quantification",
        "ordinary",
        "predicate",
        "logic",
        "suppose",
        "work",
        "total",
        "assignment",
        "fixed",
        "set",
        "variable",
        "textsf",
        "var",
        "fixed",
        "domain",
        "d",
        "set",
        "total",
        "assignment",
        "textsf",
        "assign",
        "therefore",
        "set",
        "total",
        "function",
        "textsf",
        "var",
        "d",
        "let",
        "meaning",
        "atomic",
        "formula",
        "like",
        "p",
        "x",
        "set",
        "f",
        "assignment",
        "alpha",
        "alpha",
        "x",
        "object",
        "satisfying",
        "p",
        "define",
        "alpha",
        "x",
        "beta",
        "forall",
        "v",
        "in",
        "textsf",
        "var",
        "setminus",
        "x",
        "alpha",
        "v",
        "beta",
        "v",
        "x",
        "binary",
        "relation",
        "assignment",
        "beta",
        "result",
        "resetting",
        "value",
        "variable",
        "x",
        "assignment",
        "alpha",
        "already",
        "mentioned",
        "equivalence",
        "relation",
        "variable",
        "assignment",
        "meaning",
        "g",
        "exists",
        "x",
        "p",
        "x",
        "g",
        "alpha",
        "in",
        "textsf",
        "assign",
        "mid",
        "exists",
        "beta",
        "in",
        "f",
        "alpha",
        "x",
        "beta",
        "thus",
        "g",
        "set",
        "assignment",
        "successfully",
        "reset",
        "respect",
        "x",
        "obtain",
        "assignment",
        "f",
        "result",
        "resetting",
        "viewed",
        "differently",
        "g",
        "domain",
        "relation",
        "r",
        "given",
        "alpha",
        "rbeta",
        "alpha",
        "x",
        "beta",
        "textrm",
        "beta",
        "in",
        "f",
        "could",
        "say",
        "g",
        "precondition",
        "resetting",
        "action",
        "r",
        "idea",
        "textsf",
        "dpl",
        "take",
        "meaning",
        "exists",
        "x",
        "p",
        "x",
        "precondition",
        "g",
        "classical",
        "static",
        "first",
        "order",
        "logic",
        "resetting",
        "action",
        "r",
        "way",
        "lose",
        "information",
        "since",
        "g",
        "always",
        "obtained",
        "r",
        "moreover",
        "range",
        "relation",
        "r",
        "consists",
        "assignment",
        "beta",
        "differ",
        "assignment",
        "precondition",
        "g",
        "respect",
        "value",
        "x",
        "also",
        "f",
        "ie",
        "beta",
        "x",
        "interpretation",
        "p",
        "x",
        "value",
        "stored",
        "range",
        "binary",
        "relation",
        "r",
        "precisely",
        "x",
        "value",
        "satisfy",
        "p",
        "ie",
        "value",
        "looking",
        "generally",
        "take",
        "textsf",
        "dpl",
        "meanings",
        "binary",
        "relation",
        "assignment",
        "relation",
        "seen",
        "modeling",
        "resetting",
        "action",
        "instance",
        "admittedly",
        "simplistic",
        "wellknown",
        "useful",
        "way",
        "modeling",
        "action",
        "action",
        "viewed",
        "relation",
        "state",
        "world",
        "action",
        "corresponding",
        "state",
        "action",
        "full",
        "definition",
        "assume",
        "nonempty",
        "domain",
        "d",
        "set",
        "variable",
        "textsf",
        "var",
        "model",
        "mathcal",
        "langle",
        "irangle",
        "signature",
        "sigma",
        "atomic",
        "condition",
        "pi",
        "form",
        "p",
        "x_",
        "ldots",
        "x_",
        "n",
        "pin",
        "sigma",
        "arity",
        "n",
        "atomic",
        "reset",
        "varepsilon",
        "form",
        "exists",
        "v",
        "v",
        "variable",
        "language",
        "predicate",
        "logic",
        "sigma",
        "given",
        "cdot",
        "conjunction",
        "sim",
        "negation",
        "phi",
        "bot",
        "mid",
        "top",
        "mid",
        "pi",
        "mid",
        "varepsilon",
        "mid",
        "phi",
        "cdot",
        "phi",
        "mid",
        "sim",
        "phi",
        "assignment",
        "element",
        "alpha",
        "beta",
        "ldots",
        "textsf",
        "assign",
        "d",
        "textsf",
        "var",
        "define",
        "dynamicrelational",
        "semantics",
        "language",
        "follows",
        "alpha",
        "bot",
        "beta",
        "alpha",
        "ne",
        "alpha",
        "alpha",
        "top",
        "beta",
        "alpha",
        "beta",
        "alpha",
        "p",
        "x_",
        "ldots",
        "x_",
        "n",
        "beta",
        "alpha",
        "beta",
        "langle",
        "alpha",
        "x_",
        "ldots",
        "alpha",
        "x_",
        "n",
        "rangle",
        "in",
        "p",
        "pin",
        "sigma",
        "arity",
        "n",
        "alpha",
        "exists",
        "v",
        "beta",
        "alpha",
        "v",
        "beta",
        "alpha",
        "phi",
        "cdot",
        "psi",
        "beta",
        "gamma",
        "alpha",
        "phi",
        "gamma",
        "gamma",
        "psi",
        "beta",
        "alpha",
        "phi",
        "gamma",
        "psi",
        "beta",
        "short",
        "alpha",
        "sim",
        "phi",
        "beta",
        "alpha",
        "beta",
        "gamma",
        "alpha",
        "phi",
        "gamma",
        "note",
        "conjunction",
        "cdot",
        "interpreted",
        "relation",
        "composition",
        "negation",
        "sim",
        "basically",
        "interpreted",
        "complementation",
        "respect",
        "domain",
        "relation",
        "denoted",
        "negated",
        "formula",
        "truth",
        "defined",
        "term",
        "relational",
        "meaning",
        "basically",
        "project",
        "binary",
        "relation",
        "assignment",
        "onto",
        "first",
        "coordinate",
        "alpha",
        "vdash",
        "phi",
        "exists",
        "beta",
        "alpha",
        "phi",
        "beta",
        "define",
        "implication",
        "phi",
        "rightarrow",
        "psi",
        "sim",
        "phi",
        "cdot",
        "sim",
        "psi",
        "applying",
        "truth",
        "definition",
        "give",
        "alpha",
        "vdash",
        "phi",
        "rightarrow",
        "psi",
        "textrm",
        "iff",
        "forall",
        "beta",
        "alpha",
        "phi",
        "beta",
        "rightarrow",
        "beta",
        "vdash",
        "psi",
        "ie",
        "assignment",
        "beta",
        "result",
        "updating",
        "alpha",
        "antecedent",
        "phi",
        "satisfies",
        "consequent",
        "psi",
        "relational",
        "meaning",
        "also",
        "yield",
        "following",
        "beautiful",
        "definition",
        "dynamic",
        "entailment",
        "phi",
        "vdash",
        "psi",
        "forall",
        "alpha",
        "beta",
        "alpha",
        "phi",
        "beta",
        "rightarrow",
        "exists",
        "gamma",
        "beta",
        "psi",
        "gamma",
        "definition",
        "first",
        "introduced",
        "han",
        "kamp",
        "pioneering",
        "paper",
        "kamp",
        "informally",
        "say",
        "assignment",
        "beta",
        "incorporated",
        "update",
        "contributed",
        "phi",
        "guaranteed",
        "supportsatisfy",
        "psi",
        "note",
        "sim",
        "phi",
        "equivalent",
        "phi",
        "rightarrow",
        "bot",
        "phi",
        "rightarrow",
        "psi",
        "true",
        "iff",
        "phi",
        "vdash",
        "psi",
        "equally",
        "importantly",
        "define",
        "forall",
        "x",
        "phi",
        "exists",
        "x",
        "rightarrow",
        "phi",
        "possible",
        "alternative",
        "notation",
        "exists",
        "v",
        "would",
        "v",
        "random",
        "reset",
        "emphasizes",
        "connection",
        "random",
        "assignment",
        "programming",
        "language",
        "interpretation",
        "predicate",
        "symbol",
        "condition",
        "subset",
        "diagonal",
        "langle",
        "alpha",
        "alpha",
        "rangle",
        "mid",
        "alpha",
        "in",
        "textsf",
        "assign",
        "meaning",
        "top",
        "subset",
        "diagonal",
        "test",
        "modify",
        "nothing",
        "simply",
        "pas",
        "ok",
        "satisfies",
        "condition",
        "throw",
        "away",
        "mapping",
        "textsf",
        "diag",
        "sends",
        "set",
        "f",
        "assignment",
        "condition",
        "langle",
        "alpha",
        "alpha",
        "rangle",
        "mid",
        "alpha",
        "in",
        "f",
        "link",
        "classical",
        "static",
        "dynamic",
        "world",
        "example",
        "relational",
        "composition",
        "textsf",
        "diag",
        "f",
        "textsf",
        "diag",
        "g",
        "textsf",
        "diag",
        "fcap",
        "g",
        "classical",
        "firstorder",
        "logic",
        "fol",
        "interpreted",
        "textsf",
        "dpl",
        "follows",
        "assume",
        "fol",
        "language",
        "following",
        "connective",
        "quantifier",
        "top",
        "bot",
        "wedge",
        "rightarrow",
        "exists",
        "x",
        "translate",
        "follows",
        "commute",
        "atomic",
        "formula",
        "rightarrow",
        "phi",
        "wedge",
        "psi",
        "phi",
        "cdot",
        "psi",
        "exists",
        "x",
        "phi",
        "neg",
        "neg",
        "exists",
        "x",
        "cdot",
        "phi",
        "get",
        "phi",
        "diagonal",
        "classical",
        "interpretation",
        "phi",
        "translation",
        "compositional",
        "show",
        "fol",
        "taken",
        "fragment",
        "textsf",
        "dpl",
        "conversely",
        "possible",
        "translate",
        "textsf",
        "dpl",
        "formula",
        "phi",
        "predicate",
        "logical",
        "formula",
        "phi",
        "domain",
        "phi",
        "classical",
        "interpretation",
        "phi",
        "one",
        "way",
        "define",
        "translation",
        "mean",
        "precondition",
        "calculus",
        "floydhoare",
        "rule",
        "eijck",
        "de",
        "vries",
        "following",
        "variation",
        "take",
        "language",
        "standard",
        "predicate",
        "logic",
        "diamond",
        "modality",
        "langle",
        "psi",
        "rangle",
        "phi",
        "added",
        "psi",
        "range",
        "dpl",
        "formula",
        "alpha",
        "vdash",
        "langle",
        "psi",
        "rangle",
        "phi",
        "iff",
        "assignment",
        "beta",
        "alpha",
        "psi",
        "beta",
        "beta",
        "vdash",
        "phi",
        "following",
        "equivalence",
        "show",
        "extension",
        "increase",
        "expressive",
        "power",
        "langle",
        "bot",
        "rangle",
        "phi",
        "leftrightarrow",
        "bot",
        "langle",
        "top",
        "rangle",
        "phi",
        "leftrightarrow",
        "phi",
        "langle",
        "p",
        "x_",
        "ldots",
        "x_n",
        "rangle",
        "phi",
        "leftrightarrow",
        "p",
        "x_",
        "ldots",
        "x_n",
        "wedge",
        "phi",
        "langle",
        "exists",
        "vrangle",
        "phi",
        "leftrightarrow",
        "exists",
        "vphi",
        "langle",
        "psi_",
        "cdot",
        "psi_rangle",
        "phi",
        "leftrightarrow",
        "langle",
        "psi_rangle",
        "langle",
        "psi_rangle",
        "phi",
        "langle",
        "sim",
        "psi",
        "rangle",
        "phi",
        "leftrightarrow",
        "neg",
        "langle",
        "psi",
        "rangle",
        "top",
        "wedge",
        "phi",
        "weak",
        "sense",
        "nothing",
        "new",
        "happens",
        "textsf",
        "dpl",
        "define",
        "set",
        "also",
        "define",
        "fol",
        "equivalence",
        "modality",
        "fix",
        "translation",
        "yield",
        "weakest",
        "precondition",
        "achieving",
        "given",
        "postcondition",
        "see",
        "next",
        "section",
        "illustration",
        "translation"
    ]
}