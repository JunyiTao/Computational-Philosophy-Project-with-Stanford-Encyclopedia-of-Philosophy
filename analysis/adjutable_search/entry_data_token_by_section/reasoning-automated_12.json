{
    "main_text": "Applications || SAT Solvers\n4.2 SAT Solvers, in this article; Blanchette et al. 2013).\nLEO-II (Benzm\u00fcller et al. 2015) is also a resolution-based\nautomated theorem prover for higher-order logic that has been applied\nin a wide array of problems, most notably in the automation of\nG\u00f6del\u2019s ontological proof of God\u2019s existence (see 4.6 Logic\nand Philosophy, in this article). \n3.2 Non-classical Logics\n\nNon-classical logics (Haack 1978) such as modal logics, intuitionsitic\nlogic, multi-valued logics, autoepistemic logics, non-monotonic\nreasoning, commonsense and default reasoning, relevance logic,\nparaconsistent logic, and so on, have been increasingly gaining the\nattention of the automated reasoning community. One of the reasons has\nbeen the natural desire to extend automated deduction techniques to\nnew domains of logic. Another reason has been the need to mechanize\nnon-classical logics as an attempt to provide a suitable foundation\nfor artificial intelligence. A third reason has been the desire to\nattack some problems that are combinatorially too large to be handled\nby paper and pencil. Indeed, some of the work in automated\nnon-classical logic provides a prime example of automated reasoning\nprograms at work. To illustrate, the Ackerman Constant Problem asks\nfor the number of non-equivalent formulas in the relevance logic R.\nThere are actually 3,088 such formulas (Slaney 1984) and the number\nwas found by \u201csandwiching\u201d it between a lower and an upper\nlimit, a task that involved constraining a vast universe of\n20400 20-element models in search of those models that\nrejected non-theorems in R. It is safe to say that this result would\nhave been impossible to obtain without the assistance of an automated\nreasoning program.\n\nThere have been three basic approaches to automate the solving of\nproblems in non-classical logic (McRobie 1991). One approach has been,\nof course, to try to mechanize the non-classical deductive calculi.\nAnother has been to simply provide an equivalent formulation of the\nproblem in first-order logic and let a classical theorem prover handle\nit. A third approach has been to formulate the semantics of the\nnon-classical logic in a first-order framework where resolution or\nconnection-matrix methods would apply. (Pelletier et al.\n2017) describes an automated reasoning system for a paraconsistent\nlogic that takes both \u201cindirect\u201d approaches, the\ntranslational and the truth-value approach, to prove its theorems.\nModal logic\n\nModal logics find extensive use in computing science as logics of\nknowledge and belief, logics of programs, and in the specification of\ndistributed and concurrent systems. Thus, a program that automates\nreasoning in a modal logic such as K, K4, T, S4, or S5 would have\nimportant applications. With the exception of S5, these logics share\nsome of the important metatheoretical results of classical logic, such\nas cut-elimination, and hence cut-free (modal) sequent calculi can be\nprovided for them, along with techniques for their automation.\nConnection methods (Andrews 1981, Bibel 1981) have played an important\nrole in helping to understand the source of redundancies in the search\nspace induced by these modal sequent calculi and have provided a\nunifying framework not only for modal logics but also for\nintuitionistic and classical logic as well (Wallen 1990). Current\nefforts to automate modal logic reasoning revolve around the\ntranslational approach mentioned above, namely to embed modal logic\ninto classical logic and then use an existing automated reasoning\nsystem for the latter to prove theorems of the former.\n(Benzm\u00fcller & Paulson 2013) shows how to embed quantified modal\nlogic into simple type theory, proves the soundness and completeness\nof the embedding, and demonstrates with simple experiments how\nexisting higher-order theorem provers can be used to automate proofs\nin modal logic. The approach can be extended to higher-order modal\nlogic as well (Benzm\u00fcller & Paleo 2015).\nIntuitionistic logic\n\nThere are different ways in which intuitionsitic logic can be\nautomated. One is to directly implement the intuitionistic versions of\nGentzen\u2019s sequent and natural deduction calculi, LJ and NJ\nrespectively. This approach inherits the stronger normalization\nresults enjoyed by these calculi allowing for a more compact\nmechanization than their classical counterparts. Another approach at\nmechanizing intuitionistic logic is to exploit its semantic\nsimilarities with the modal logic S4 and piggy back on an automated\nimplementation of S4. Automating intuitionistic logic has applications\nin software development since writing a program that meets a\nspecification corresponds to the problem of proving the specification\nwithin an intuitionistic logic (Martin-L\u00f6f 1982). A system that\nautomated the proof construction process would have important\napplications in algorithm design but also in constructive mathematics.\nNuprl (Constable et al. 1986) is a computer system supporting\na particular mathematical theory, namely constructive type theory, and\nwhose aim is to provide assistance in the proof development process.\nThe focus is on logic-based tools to support programming and on\nimplementing formal computational mathematics. Over the years the\nscope of the Nuprl project has expanded from\n\u201cproofs-as-programs\u201d to \u201csystems-as-theories\u201d.\nSimilar in spirit and based on the Curry-Howard isomorphism, the Coq\nsystem formalizes its proofs in the Calculus of Inductive\nConstructions, a \u03bb-calculus with a rich system of types\nincluding dependent types (Coquand & Huet 1988, Coquand &\nPaulin-Mohring 1988). Like Nuprl, Coq is designed to assist in the\ndevelopment of mathematical proofs as well as computer programs from\ntheir formal specifications.\n4. Applications\n4.1 Logic Programming\n\nLogic programming, particularly represented by the language\nProlog (Colmerauer et al. 1973), is probably\nthe most important and widespread application of automated theorem\nproving. During the early 1970s, it was discovered that logic could be\nused as a programming language (Kowalski 1974). What distinguishes\nlogic programming from other traditional forms of programming is that\nlogic programs, in order to solve a problem, do not explicitly state\nhow a specific computation is to be performed; instead, a\nlogic program states what the problem is and then delegates\nthe task of actually solving it to an underlying theorem prover. In\nProlog, the theorem prover is based on a refinement of resolution\nknown as SLD-resolution. SLD-resolution is a\nvariation of linear input resolution that incorporates a special rule\nfor selecting the next literal to be resolved upon; SLD-resolution\nalso takes into consideration the fact that, in the computer\u2019s memory,\nthe literals in a clause are actually ordered, that is, they form a\nsequence as opposed to a set. A Prolog program\nconsists of clauses stating known facts and rules. For example, the\nfollowing clauses make some assertions about flight connections:\n\nflight(toronto, london).\n\nflight(london,rome).\n\nflight(chicago,london).\n\nflight(X,Y) :\u2013 flight(X,Z) ,\nflight(Z,Y).\n\n\nThe clause flight(toronto, london) is a fact while\nflight(X,Y) :\u2013 flight(X,Z)\n,\nflight(Z,Y) is a rule, written by convention as a\nreversed conditional (the symbol \u201c:\u2013\u201d means\n\u201cif\u201d; the comma means \u201cand\u201d; terms starting in\nuppercase are variables). The former states that there is flight\nconnection between Toronto and London; the latter states that there is\na flight between cities X and Y if, for some city\nZ, there is a flight between X and Z and\none between Z and Y. Clauses in Prolog programs are\na special type of Horn clauses having precisely one positive literal:\nFacts are program clauses with no negative literals\nwhile rules have at least one negative literal. (Note\nthat in standard clause notation the program rule in the previous\nexample would be written as flight(X,Y) \u2228\n~flight(X,Z) \u2228 ~flight(Z,Y).)\nThe specific form of the program rules is to effectively express\nstatements of the form: \u201cIf these conditions over here are\njointly met then this other fact will follow\u201d. Finally, a\ngoal is a Horn clause with no positive literals. The\nidea is that, once a Prolog program \u03a0 has been written, we can then\ntry to determine if a new clause \u03b3, the goal, is entailed by\n\u03a0, \u03a0 \u22a8 \u03b3; the Prolog prover does this by attempting\nto derive a contradiction from \u03a0 \u222a {~\u03b3}. We should remark\nthat program facts and rules alone cannot produce a contradiction; a\ngoal must enter into the process. Like input resolution,\nSLD-resolution is not refutation complete for first-order logic but it\nis complete for the Horn logic of Prolog programs. The fundamental\ntheorem: If \u03a0 is a Prolog program and \u03b3 is the goal clause\nthen \u03a0\u00a0\u22a8\u00a0\u03b3 iff \u03a0 \u222a {~\u03b3} \u22a2\n[\u00a0] by SLD-resolution (Lloyd 1984).\n\nFor instance, to find out if there is a flight from Toronto to Rome\none asks the Prolog prover to see if the clause flight(toronto, rome)\nfollows from the given program. To do this, the prover adds\n~flight(toronto,rome) to the program clauses and attempts to derive\nthe empty clause, [\u00a0], by SLD-resolution:\n\n\n1\nflight(toronto,london)\nProgram clause \n\n2\nflight(london,rome)\nProgram clause \n\n3\nflight(chicago,london)\nProgram clause \n\n4\nflight(X,Y) \u2228\n~flight(X,Z) \u2228\n~flight(Z,Y)\nProgram clause \n\n5\n~flight(toronto,rome)\nNegated conclusion \n\n6\n~flight(toronto,Z) \u2228 ~flight(Z,rome)\nRes 5 4 \n\n7\n~flight(london,rome)\nRes 6 1 \n\n8\n[\u00a0]\nRes 7 2 \n\n\nThe conditional form of rules in Prolog programs adds to their\nreadability and also allows reasoning about the underlying refutations\nin a more friendly way: To prove that there is a flight between\nToronto and Rome, flight(toronto,rome), unify this clause with the\nconsequent flight(X,Y) of the fourth clause in the\nprogram which itself becomes provable if both\nflight(toronto,Z) and flight(Z,rome) can be proved.\nThis can be seen to be the case under the substitution {Z\n\u2190 london} since both flight(toronto,london) and\nflight(london,rome) are themselves provable. Note that the theorem\nprover not only establishes that there is a flight between Toronto and\nRome but it can also come up with an actual itinerary,\nToronto-London-Rome, by extracting it from the unifications used in\nthe proof.\n\nThere are at least two broad problems that Prolog must address in\norder to achieve the ideal of a logic programming language. Logic\nprograms consist of facts and rules describing what is true; anything\nthat is not provable from a program is deemed to be false. In regards\nto our previous example, flight(toronto,\nboston) is not true since this literal cannot be deduced from\nthe program. The identification of falsity with non-provability is\nfurther exploited in most Prolog implementations by incorporating an\noperator, not, that allows programmers to explicitly\nexpress the negation of literals (or even subclauses) within a\nprogram. By definition, not l succeeds if the literal\nl itself fails to be deduced. This mechanism, known as\nnegation-by-failure, has been the target of\ncriticism. Negation-by-failure does not fully capture the standard\nnotion of negation and there are significant logical differences\nbetween the two. Standard logic, including Horn logic, is monotonic\nwhich means that enlarging an axiom set by adding new axioms simply\nenlarges the set of theorems derivable from it; negation-by-failure,\nhowever, is non-monotonic and the addition of new\nprogram clauses to an existing Prolog program may cause some goals to\ncease from being theorems. A second issue is the control\nproblem. Currently, programmers need to provide a fair amount\nof control information if a program is to achieve acceptable levels of\nefficiency. For example, a programmer must be careful with the order\nin which the clauses are listed within a program, or how the literals\nare ordered within a clause. Failure to do a proper job can result in\nan inefficient or, worse, non-terminating program. Programmers must\nalso embed hints within the program clauses to prevent the prover from\nrevisiting certain paths in the search space (by using the\ncut operator) or to prune them altogether (by using\nfail). Last but not least, in order to improve their\nefficiency, many implementations of Prolog do not implement\nunification fully and bypass a time-consuming yet critical\ntest\u2014the so-called\noccurs-check\u2014responsible for checking the\nsuitability of the unifiers being computed. This results in an unsound\ncalculus and may cause a goal to be entailed by a Prolog program (from\na computational point of view) when in fact it should not (from a\nlogical point of view).\n\nThere are variations of Prolog intended to extend its scope. By\nimplementing a model elimination procedure, the Prolog Technology\nTheorem Prover (PTTP) (Stickel 1992) extends Prolog into full\nfirst-order logic. The implementation achieves both soundness and\ncompleteness. Moving beyond first-order logic, \u03bbProlog (Miller\n& Nadathur 1988) bases the language on higher-order constructive\nlogic.\n4.2 SAT Solvers\n\nThe problem of determining the satisfiability of logic formulas has\nreceived much attention by the automated reasoning community due to\nits important applicability in industry. A propositional formula is\nsatisfiable if there is an assignment of truth-values\nto its variables that makes the formula true. For example, the\nassignment (P \u2190 true, Q \u2190 true, R\n\u2190 false) does not make (P \u2228R) &\n~Q true but (P \u2190 true, Q \u2190 false,\nR \u2190 false) does and, hence, the formula is satisfiable.\nDetermining whether a formula is satisfiable or not is called the\nBoolean Satisfiability Problem\u2014SAT for\nshort\u2014and for a formula with n variables SAT can be\nsettled thus: Inspect each of the 2n possible\nassignments to see if there is at least one assignment that satisfies\nthe formula, i.e. makes it true. This method is clearly complete: If\nthe original formula is satisfiable then we will eventually find one\nsuch satisfying assignment; but if the formula is contradictory (i.e.\nnon-satisfiable), we will be able to determine this too. Just as\nclearly, and particularly in this latter case, this search takes an\nexponential amount of time, and the desire to conceive more efficient\nalgorithms is well justified particularly because many computing\nproblems of great practical importance such as graph-theoretic\nproblems, network design, storage and retrieval, scheduling, program\noptimization, and many others (Garey & Johnson 1979) can be\nexpressed as SAT instances, i.e. as the SAT question of some\npropositional formula representing the problem. Given that SAT is\nNP-complete (Cook 1971) it is very unlikely that a polynomial\nalgorithm exists for it; however, this does not preclude the existence\nof sufficiently efficient algorithms for particular cases of SAT\nproblems.\n\nThe Davis-Putnam-Logemann-Loveland (DPLL) algorithm\nwas one of the first SAT search algorithms (Davis & Putnam 1960;\nDavis, Logemman & Loveland 1962) and is still considered one of the\nbest complete SAT solvers; many of the complete SAT procedures in\nexistence today can be considered optimizations and generalizations of\nDPLL. In essence, DPLL search procedures proceed by considering ways\nin which assignments can be chosen to make the original formula true.\nFor example, consider the formula in CNF\n\nP & ~Q & (~P \u2228 Q \u2228\nR) & (P \u2228 ~S)\n\n\nSince P is a conjunct, but also a unit clause, P\nmust be true if the entire formula is to be true. Moreover, the value\nof ~P does not contribute to the truth of ~P \u2228\nQ \u2228 R and P \u2228 ~S is true\nregardless of S. Thus, the whole formula reduces to\n\n~Q & (Q \u2228 R)\n\n\nSimilarly, ~Q must be true and the formula further reduces\nto\n\nR\n\n\nwhich forces R to be true. From this process we can recover\nthe assignment (P \u2190 true, Q \u2190 false,\nR \u2190 true, S \u2190 false) proving that the\noriginal formula is satisfiable. A formula may cause the algorithm to\nbranch; the search through a branch reaches a dead end the moment a\nclause is deemed false\u2014a conflicting\nclause\u2014and all variations of the assignment that has\nbeen partially constructed up to this point can be discarded. To\nillustrate:\n\n\n\n1\nR & (P \u2228 Q)\n& (~P \u2228 Q) & (~P \u2228\n~Q)\nGiven \n\n2\n(P \u2228 Q) & (~P \u2228 Q)\n& (~P \u2228 ~Q)\nBy letting R \u2190 true \n\n3\nQ & ~Q\nBy letting P \u2190 true \n\n4\n?\nConflict: Q and ~Q cannot both be true\n\n\n5\n(P \u2228 Q) & (~P \u2228 Q)\n& (~P \u2228 ~Q)\nBacktrack to (2): R \u2190 true still holds \n\n6\n~P\nBy letting Q \u2190 true \n\n7\ntrue\nBy letting ~P be true, i.e., P\n\u2190 false  \n\n\nHence, the formula is satisfiable by the existence of (P\n\u2190 false, Q \u2190 true, R \u2190 true). DPLL\nalgorithms are made more efficient by strategies such as term\nindexing (ordering of the formula variables in an\nadvantageous way), chronological backtracking\n(undoing work to a previous branching point if the process leads to a\nconflicting clause), and conflict-driven learning\n(determining the information to keep and where to backtrack). The\ncombination of these strategies results in a large prune of the search\nspace; for a more extensive discussion the interested reader is\ndirected to Zhang & Malik 2002.\n\nA quick back-envelope calculation reveals the staggering computing\ntimes of (algorithms for) SAT-type problems represented by formulas\nwith as little as, say, 60 variables. To wit: A problem represented as\na Boolean formula with 10 variables that affords a linear solution\ntaking one hundredth of a second to complete would take just four\nhundredths and six hundredths of a second to complete if the formula\nhad instead 40 and 60 variables respectively. In dramatic contrast, if\nthe solution to the problem were exponential (say\n2n) then the times to complete the job for 10, 40\nand 60 variables would be respectively one thousandth of a second, 13\ndays, and 365 centuries. It is a true testament to the ingenuity of\nthe automated reasoning community and the power of current SAT-based\nsearch algorithms that real-world problems with thousands of variables\ncan be handled with reasonable efficency. K\u00fcchlin & Sinz 2000\ndiscuss a SAT application in the realm of industrial automotive\nproduct data management where 18,000 (elementary) Boolean formulas and\n17,000 variables are used to express constraints on orders placed by\ncustomers. As another example, Massacci & Marraro 2000 discuss\nan application in logical cryptanalysis, that is, the verification of\nproperties of cryptographic algorithms expressed as SAT problems. They\ndemonstrate how finding a key with a cryptographic attack is analogous\nto finding a model\u2014assignment\u2014for a Boolean formula; the\nformula in their application encodes the commercial version of the U.S\nData Encryption Standard (DES) with the encoding requiring 60,000\nclauses and 10,000 variables.\n\nAlthough SAT is conceptually very simple, its inner nature is not well\nunderstood\u2014there are no criteria that can be generally applied\nto answer as to why one SAT problem is harder than another. It should\nthen come as no surprise that algorithms that tend to do well on some\nSAT instances do not perform so well on others, and efforts are being\nspent in designing hybrid algorithmic solutions that combine the\nstrength of complementary approaches\u2014see Prasad, Biere &\nGupta 2005 for an application of this hybrid approach in the\nverification of hardware design.\n\nRecent advances in SAT hybrid strategies coupled with supercomputing\npower has allowed a team of three computing scientists to solve the\nBoolean Pythagorean Triples Problem, a long-standing open question in\nRamsey Theory: Can the set {1, 2,...} of natural numbers be divided\ninto two parts with no part containing a triple\n(a, b, c) such that a2\n+ b2 = c2? Heule, Kullmann\n& Marek 2016 proved that this cannot be done by showing that the\nset {1, 2, \u2026 , n} can be so partitioned for n\n= 7824 but that this is impossible for n \u2265\n7825. Expressing this deceptively simple question as a SAT problem\nrequired close to 38,000 clauses and 13,000 variables with about half\nof these going to represent that the problem is satisfiable when n =\n7824 and the other half to represent that it is not when n = 7825; of\nthe two, proving the latter was far more challenging since it demanded\na proof of unsatisfiability, i.e. that no such partition exists. A\nna\u00efve brute-force approach considering all 27825\npossible two-part partitions was clearly out of the question and the\nproblem was attacked by using \u201cclever\u201d algorithms within a\nmulti-stage SAT-based framework for solving hard problems in\ncombinatorics, consisting of five phases: Encode (encoding\nthe problem as SAT formulas), Transform (optimizing the\nencoding using clause elimination and symmetry breaking\ntechniques), Split (dividing the problem effectively into\nsubproblems using splitting heuristics), Solve (searching for\nsatisfying assignments or their lack thereof using fast processing),\nand Validate (validating the results of the earlier\nphases). Of special importance was the application\nof cube-and-conquer, a hybrid SAT strategy\nparticularly effective for hard combinatorial problems. The strategy\ncombines look-ahead with conflict-driven\nclause-learning (CDCL), with the former\naiming to construct small binary search trees using global heuristics\nand the latter aiming to find short refutations using local\nheuristics.\n\nAfter splitting the problem into 106 hard subproblems\n(known as \u201ccubes\u201d), these were handed down to 800 cores\nworking in parallel on a Stampede supercomputer which, after\n2 days of further splitting and CDCL clause-crunching, settled the\nquestion and delivered a 200-terabyte proof validating the work. After\ndeservedly celebrating this significant accomplishment of automated\nreasoning, and after entertaining all the new applications that the\nenhanced SAT method would afford (particularly in the areas of\nhardware and software verification), we should then ask some questions\nthat are of especial importance to mathematicians: Is there a more\ninsightful way to establish this result that would involve more\ntraditional and intellectually satisfying mathematical proof methods?\nOr, as far as increasing our understanding of a given field\n(combinatorics in this case), what is the value of settling a question\nwhen no human can inspect the proof and hence get no insight from it?\nEven the team responsible for the result admits that \u201cthe proofs\nof unsatisfiability coming from SAT solvers are, from a human point of\nview, a giant heap of random information (no direct understanding is\ninvolved)\u201d. The conjecture has been settled but we basically\nhave no underlying idea what makes 7825 so special. Perhaps the real\nvalue to be drawn from these considerations is that they lead us to\nthink about the deeper question: What is it about the structure of a\nspecific problem that makes it amenable to standard mathematical\ntreatment as opposed to requiring a mindless brute-force approach?\nWhile this question is being contemplated, SAT may provide the best line of attack on certain mathematical problems.\n\nThe DPLL search procedure has been extended to quantified logic. MACE\nis a popular program based on the DPLL algorithm that searches for\nfinite models of first-order formulas with equality. As an example\n(McCune 2001), to show that not all groups are commutative one can\ndirect MACE to look for a model of the group axioms that also\nfalsifies the commutation law or, equivalently, to look for a model\nof:\n\n\n\n(G1)\ne \u00b7 x = x\n(left identity) \n\n(G2)\ni\u2009(x) \u00b7 x =\ne\n(left inverse) \n\n(G3)\n(x \u00b7 y) \u00b7 z =\nx \u00b7 (y \u00b7 z)\n(associativity) \n\n(DC)\na \u00b7 b \u2260 b \u00b7\na\n(denial of commutativity) \n\n\n\nMACE finds a six-element model of these axioms, where \u00b7 is\ndefined as:\n\n\n\u00b7\n0\n1\n2\n3\n4\n5 \n\n0\n0\n1\n2\n3\n4\n5 \n\n1\n1\n0\n4\n5\n2\n3 \n\n2\n2\n3\n0\n1\n5\n4 \n\n3\n3\n2\n5\n4\n0\n1 \n\n4\n4\n5\n1\n0\n3\n2 \n\n5\n5\n4\n3\n2\n1\n0 \n\n\nand where i are defined as:\n\n\nx\n0\n1\n2\n3\n4\n5 \n\ni(x)\n0\n1\n2\n3\n4\n5 \n\n\nThis example also illustrates, once again, the benefits of using an automated\ndeduction system: How long would have taken the human researcher to\ncome up with the above or a similar model? For more challenging\nproblems, the program is being used as a practical complement to the\nresolution-based theorem prover Prover9 (formerly Otter), with Prover9\nsearching for proofs and MACE jointly looking for (counter) models. To\nfind such models, MACE converts the first-order problem into a set of\n\"flattened\" clauses which, for increasing model sizes, are\ninstantiated into propositional clauses and solved as a SAT problem.\nThe method has been implemented in other automated reasoning systems\nas well, most notably in the Paradox model finder where the MACE-style\napproach has been enhanced by four additional techniques resulting in\nsome significant efficiency improvements (Claessen & S\u00f6rensson\n2003): term definitions (to reduce the number of variables in\nflattened clauses), static symmetric reduction (to reduce the number\nof isomorphic models), sort inference (to apply symmetric reduction at\na finer level) and incremental SAT (to reuse search information\nbetween consecutive model sizes). The strategy of pairing the\ncomplementary capabilities of separate automated reasoning systems has\nbeen applied to higher-order logic too as exemplified by Nitpick, a\ncounterexample generator for Isabelle/HOL (Blanchette & Nipkow\n2010). Brown 2013 describes a theorem proving procedure for\nhigher-order logic that uses SAT-solving to do most of the work; the\nprocedure is a complete, cut-free, ground refutation calculus that\nincorporates restrictions on instantiations and has been implemented\nin the Satallax theorem prover (Brown 2012).\n\nAn approach of great interest at solving SAT problems in first-order\nlogic is Satisfiability Modulo Theory\n(SMT) where the interpretation of symbols in the\nproblem\u2019s formulation is constrained by a background\ntheory. For example, in linear arithmetic the function\nsymbols are restricted to + and \u2212. As another example, in the\nextensional theory of arrays (McCarthy 1962) the array function\nread(a, i) returns the value of the array\na at index i, and write(a,\ni, x) returns the array identical to a but\nwhere the value of a at i is x. More\nformally,\n\n\n\n \u2200a : Array .\n\u2200i,j : Index . \u2200x :\nValue . i = j \u2192\n\n\u00a0\u00a0read(write(a, i,\nx), j) = x (read-write\naxiom 1)  \n\n \u2200a : Array .\n\u2200i,j : Index . \u2200x :\nValue . i \u2260 j \u2192\n\n\u00a0\u00a0read(write(a, i,\nx), j) = read(a, j) (read-write\naxiom 2)  \n\n \u2200a,b : Array .\n\u2200i : Index . a = b \u2192\nread(a, i) = read(b,\ni)  \n\n(extensionality) \n\n\n\nIn the context of these axioms, an SMT solver would attempt to\nestablish the satisfiability (or, dually, the validity) of a given\nfirst-order formula, or thousands of formulas for that matter, such\nas\n\ni \u2212 j = 1 &\nf(read(write(a, i, 2),\nj + 1) = read(write(a, i,\nf(i \u2212 j + 1)), i)\n\n\n(Ganzinger et al. 2004) discusses an approach to SMT called\nDPLL(T) consisting of a general\nDPLL(X) engine that works in conjunction with a solver\nSolverT for background theory T. Bofill\net al. (2008) present the approach in the setting of the theory of\narrays, where the DPLL engine is responsible for enumerating\npropositional models for the given formula whereas\nSolverT checks whether these models are consistent\nwith the theory of arrays. Their approach is sound and complete, and\ncan be smoothly extended to multidimensional arrays.\n\nSMT is particularly successful in verification applications, most\nnotably software verification. Having improved the efficiency of SAT\nsolvers with SMT, the effort is now on designing more efficient SMT\nsolvers (de Moura 2007).\n",
    "section_title": "4.2 SAT Solvers",
    "entry_title": "Automated Reasoning",
    "hierarchy_title": "Automated Reasoning || Applications || SAT Solvers",
    "tokenized_text": [
        "application",
        "sat",
        "solver",
        "sat",
        "solver",
        "article",
        "blanchette",
        "et",
        "al",
        "leoii",
        "benzm\u00fcller",
        "et",
        "al",
        "also",
        "resolutionbased",
        "automated",
        "theorem",
        "prover",
        "higherorder",
        "logic",
        "applied",
        "wide",
        "array",
        "problem",
        "notably",
        "automation",
        "g\u00f6del",
        "ontological",
        "proof",
        "god",
        "existence",
        "see",
        "logic",
        "philosophy",
        "article",
        "nonclassical",
        "logic",
        "nonclassical",
        "logic",
        "haack",
        "modal",
        "logic",
        "intuitionsitic",
        "logic",
        "multivalued",
        "logic",
        "autoepistemic",
        "logic",
        "nonmonotonic",
        "reasoning",
        "commonsense",
        "default",
        "reasoning",
        "relevance",
        "logic",
        "paraconsistent",
        "logic",
        "increasingly",
        "gaining",
        "attention",
        "automated",
        "reasoning",
        "community",
        "one",
        "reason",
        "natural",
        "desire",
        "extend",
        "automated",
        "deduction",
        "technique",
        "new",
        "domain",
        "logic",
        "another",
        "reason",
        "need",
        "mechanize",
        "nonclassical",
        "logic",
        "attempt",
        "provide",
        "suitable",
        "foundation",
        "artificial",
        "intelligence",
        "third",
        "reason",
        "desire",
        "attack",
        "problem",
        "combinatorially",
        "large",
        "handled",
        "paper",
        "pencil",
        "indeed",
        "work",
        "automated",
        "nonclassical",
        "logic",
        "provides",
        "prime",
        "example",
        "automated",
        "reasoning",
        "program",
        "work",
        "illustrate",
        "ackerman",
        "constant",
        "problem",
        "asks",
        "number",
        "nonequivalent",
        "formula",
        "relevance",
        "logic",
        "r",
        "actually",
        "formula",
        "slaney",
        "number",
        "found",
        "sandwiching",
        "lower",
        "upper",
        "limit",
        "task",
        "involved",
        "constraining",
        "vast",
        "universe",
        "element",
        "model",
        "search",
        "model",
        "rejected",
        "nontheorems",
        "r",
        "safe",
        "say",
        "result",
        "would",
        "impossible",
        "obtain",
        "without",
        "assistance",
        "automated",
        "reasoning",
        "program",
        "three",
        "basic",
        "approach",
        "automate",
        "solving",
        "problem",
        "nonclassical",
        "logic",
        "mcrobie",
        "one",
        "approach",
        "course",
        "try",
        "mechanize",
        "nonclassical",
        "deductive",
        "calculus",
        "another",
        "simply",
        "provide",
        "equivalent",
        "formulation",
        "problem",
        "firstorder",
        "logic",
        "let",
        "classical",
        "theorem",
        "prover",
        "handle",
        "third",
        "approach",
        "formulate",
        "semantics",
        "nonclassical",
        "logic",
        "firstorder",
        "framework",
        "resolution",
        "connectionmatrix",
        "method",
        "would",
        "apply",
        "pelletier",
        "et",
        "al",
        "describes",
        "automated",
        "reasoning",
        "system",
        "paraconsistent",
        "logic",
        "take",
        "indirect",
        "approach",
        "translational",
        "truthvalue",
        "approach",
        "prove",
        "theorem",
        "modal",
        "logic",
        "modal",
        "logic",
        "find",
        "extensive",
        "use",
        "computing",
        "science",
        "logic",
        "knowledge",
        "belief",
        "logic",
        "program",
        "specification",
        "distributed",
        "concurrent",
        "system",
        "thus",
        "program",
        "automates",
        "reasoning",
        "modal",
        "logic",
        "k",
        "k",
        "s",
        "s",
        "would",
        "important",
        "application",
        "exception",
        "s",
        "logic",
        "share",
        "important",
        "metatheoretical",
        "result",
        "classical",
        "logic",
        "cutelimination",
        "hence",
        "cutfree",
        "modal",
        "sequent",
        "calculus",
        "provided",
        "along",
        "technique",
        "automation",
        "connection",
        "method",
        "andrew",
        "bibel",
        "played",
        "important",
        "role",
        "helping",
        "understand",
        "source",
        "redundancy",
        "search",
        "space",
        "induced",
        "modal",
        "sequent",
        "calculus",
        "provided",
        "unifying",
        "framework",
        "modal",
        "logic",
        "also",
        "intuitionistic",
        "classical",
        "logic",
        "well",
        "wallen",
        "current",
        "effort",
        "automate",
        "modal",
        "logic",
        "reasoning",
        "revolve",
        "around",
        "translational",
        "approach",
        "mentioned",
        "namely",
        "embed",
        "modal",
        "logic",
        "classical",
        "logic",
        "use",
        "existing",
        "automated",
        "reasoning",
        "system",
        "latter",
        "prove",
        "theorem",
        "former",
        "benzm\u00fcller",
        "paulson",
        "show",
        "embed",
        "quantified",
        "modal",
        "logic",
        "simple",
        "type",
        "theory",
        "prof",
        "soundness",
        "completeness",
        "embedding",
        "demonstrates",
        "simple",
        "experiment",
        "existing",
        "higherorder",
        "theorem",
        "provers",
        "used",
        "automate",
        "proof",
        "modal",
        "logic",
        "approach",
        "extended",
        "higherorder",
        "modal",
        "logic",
        "well",
        "benzm\u00fcller",
        "paleo",
        "intuitionistic",
        "logic",
        "different",
        "way",
        "intuitionsitic",
        "logic",
        "automated",
        "one",
        "directly",
        "implement",
        "intuitionistic",
        "version",
        "gentzen",
        "sequent",
        "natural",
        "deduction",
        "calculus",
        "lj",
        "nj",
        "respectively",
        "approach",
        "inherits",
        "stronger",
        "normalization",
        "result",
        "enjoyed",
        "calculus",
        "allowing",
        "compact",
        "mechanization",
        "classical",
        "counterpart",
        "another",
        "approach",
        "mechanizing",
        "intuitionistic",
        "logic",
        "exploit",
        "semantic",
        "similarity",
        "modal",
        "logic",
        "s",
        "piggy",
        "back",
        "automated",
        "implementation",
        "s",
        "automating",
        "intuitionistic",
        "logic",
        "application",
        "software",
        "development",
        "since",
        "writing",
        "program",
        "meet",
        "specification",
        "corresponds",
        "problem",
        "proving",
        "specification",
        "within",
        "intuitionistic",
        "logic",
        "martinl\u00f6f",
        "system",
        "automated",
        "proof",
        "construction",
        "process",
        "would",
        "important",
        "application",
        "algorithm",
        "design",
        "also",
        "constructive",
        "mathematics",
        "nuprl",
        "constable",
        "et",
        "al",
        "computer",
        "system",
        "supporting",
        "particular",
        "mathematical",
        "theory",
        "namely",
        "constructive",
        "type",
        "theory",
        "whose",
        "aim",
        "provide",
        "assistance",
        "proof",
        "development",
        "process",
        "focus",
        "logicbased",
        "tool",
        "support",
        "programming",
        "implementing",
        "formal",
        "computational",
        "mathematics",
        "year",
        "scope",
        "nuprl",
        "project",
        "expanded",
        "proofsasprograms",
        "systemsastheories",
        "similar",
        "spirit",
        "based",
        "curryhoward",
        "isomorphism",
        "coq",
        "system",
        "formalizes",
        "proof",
        "calculus",
        "inductive",
        "construction",
        "\u03bbcalculus",
        "rich",
        "system",
        "type",
        "including",
        "dependent",
        "type",
        "coquand",
        "huet",
        "coquand",
        "paulinmohring",
        "like",
        "nuprl",
        "coq",
        "designed",
        "assist",
        "development",
        "mathematical",
        "proof",
        "well",
        "computer",
        "program",
        "formal",
        "specification",
        "application",
        "logic",
        "programming",
        "logic",
        "programming",
        "particularly",
        "represented",
        "language",
        "prolog",
        "colmerauer",
        "et",
        "al",
        "probably",
        "important",
        "widespread",
        "application",
        "automated",
        "theorem",
        "proving",
        "early",
        "s",
        "discovered",
        "logic",
        "could",
        "used",
        "programming",
        "language",
        "kowalski",
        "distinguishes",
        "logic",
        "programming",
        "traditional",
        "form",
        "programming",
        "logic",
        "program",
        "order",
        "solve",
        "problem",
        "explicitly",
        "state",
        "specific",
        "computation",
        "performed",
        "instead",
        "logic",
        "program",
        "state",
        "problem",
        "delegate",
        "task",
        "actually",
        "solving",
        "underlying",
        "theorem",
        "prover",
        "prolog",
        "theorem",
        "prover",
        "based",
        "refinement",
        "resolution",
        "known",
        "sldresolution",
        "sldresolution",
        "variation",
        "linear",
        "input",
        "resolution",
        "incorporates",
        "special",
        "rule",
        "selecting",
        "next",
        "literal",
        "resolved",
        "upon",
        "sldresolution",
        "also",
        "take",
        "consideration",
        "fact",
        "computer",
        "memory",
        "literal",
        "clause",
        "actually",
        "ordered",
        "form",
        "sequence",
        "opposed",
        "set",
        "prolog",
        "program",
        "consists",
        "clause",
        "stating",
        "known",
        "fact",
        "rule",
        "example",
        "following",
        "clause",
        "make",
        "assertion",
        "flight",
        "connection",
        "flight",
        "toronto",
        "london",
        "flight",
        "london",
        "rome",
        "flight",
        "chicago",
        "london",
        "flight",
        "x",
        "flight",
        "x",
        "z",
        "flight",
        "z",
        "clause",
        "flight",
        "toronto",
        "london",
        "fact",
        "flight",
        "x",
        "flight",
        "x",
        "z",
        "flight",
        "z",
        "rule",
        "written",
        "convention",
        "reversed",
        "conditional",
        "symbol",
        "mean",
        "comma",
        "mean",
        "term",
        "starting",
        "uppercase",
        "variable",
        "former",
        "state",
        "flight",
        "connection",
        "toronto",
        "london",
        "latter",
        "state",
        "flight",
        "city",
        "x",
        "city",
        "z",
        "flight",
        "x",
        "z",
        "one",
        "z",
        "y",
        "clause",
        "prolog",
        "program",
        "special",
        "type",
        "horn",
        "clause",
        "precisely",
        "one",
        "positive",
        "literal",
        "fact",
        "program",
        "clause",
        "negative",
        "literal",
        "rule",
        "least",
        "one",
        "negative",
        "literal",
        "note",
        "standard",
        "clause",
        "notation",
        "program",
        "rule",
        "previous",
        "example",
        "would",
        "written",
        "flight",
        "x",
        "flight",
        "x",
        "z",
        "flight",
        "z",
        "specific",
        "form",
        "program",
        "rule",
        "effectively",
        "express",
        "statement",
        "form",
        "condition",
        "jointly",
        "met",
        "fact",
        "follow",
        "finally",
        "goal",
        "horn",
        "clause",
        "positive",
        "literal",
        "idea",
        "prolog",
        "program",
        "\u03c0",
        "written",
        "try",
        "determine",
        "new",
        "clause",
        "\u03b3",
        "goal",
        "entailed",
        "\u03c0",
        "\u03c0",
        "\u03b3",
        "prolog",
        "prover",
        "attempting",
        "derive",
        "contradiction",
        "\u03c0",
        "\u03b3",
        "remark",
        "program",
        "fact",
        "rule",
        "alone",
        "produce",
        "contradiction",
        "goal",
        "must",
        "enter",
        "process",
        "like",
        "input",
        "resolution",
        "sldresolution",
        "refutation",
        "complete",
        "firstorder",
        "logic",
        "complete",
        "horn",
        "logic",
        "prolog",
        "program",
        "fundamental",
        "theorem",
        "\u03c0",
        "prolog",
        "program",
        "\u03b3",
        "goal",
        "clause",
        "\u03c0",
        "\u03b3",
        "iff",
        "\u03c0",
        "\u03b3",
        "sldresolution",
        "lloyd",
        "instance",
        "find",
        "flight",
        "toronto",
        "rome",
        "one",
        "asks",
        "prolog",
        "prover",
        "see",
        "clause",
        "flight",
        "toronto",
        "rome",
        "follows",
        "given",
        "program",
        "prover",
        "add",
        "flight",
        "toronto",
        "rome",
        "program",
        "clause",
        "attempt",
        "derive",
        "empty",
        "clause",
        "sldresolution",
        "flight",
        "toronto",
        "london",
        "program",
        "clause",
        "flight",
        "london",
        "rome",
        "program",
        "clause",
        "flight",
        "chicago",
        "london",
        "program",
        "clause",
        "flight",
        "x",
        "flight",
        "x",
        "z",
        "flight",
        "z",
        "program",
        "clause",
        "flight",
        "toronto",
        "rome",
        "negated",
        "conclusion",
        "flight",
        "toronto",
        "z",
        "flight",
        "z",
        "rome",
        "re",
        "flight",
        "london",
        "rome",
        "re",
        "re",
        "conditional",
        "form",
        "rule",
        "prolog",
        "program",
        "add",
        "readability",
        "also",
        "allows",
        "reasoning",
        "underlying",
        "refutation",
        "friendly",
        "way",
        "prove",
        "flight",
        "toronto",
        "rome",
        "flight",
        "toronto",
        "rome",
        "unify",
        "clause",
        "consequent",
        "flight",
        "x",
        "fourth",
        "clause",
        "program",
        "becomes",
        "provable",
        "flight",
        "toronto",
        "z",
        "flight",
        "z",
        "rome",
        "proved",
        "seen",
        "case",
        "substitution",
        "z",
        "london",
        "since",
        "flight",
        "toronto",
        "london",
        "flight",
        "london",
        "rome",
        "provable",
        "note",
        "theorem",
        "prover",
        "establishes",
        "flight",
        "toronto",
        "rome",
        "also",
        "come",
        "actual",
        "itinerary",
        "torontolondonrome",
        "extracting",
        "unification",
        "used",
        "proof",
        "least",
        "two",
        "broad",
        "problem",
        "prolog",
        "must",
        "address",
        "order",
        "achieve",
        "ideal",
        "logic",
        "programming",
        "language",
        "logic",
        "program",
        "consist",
        "fact",
        "rule",
        "describing",
        "true",
        "anything",
        "provable",
        "program",
        "deemed",
        "false",
        "regard",
        "previous",
        "example",
        "flight",
        "toronto",
        "boston",
        "true",
        "since",
        "literal",
        "deduced",
        "program",
        "identification",
        "falsity",
        "nonprovability",
        "exploited",
        "prolog",
        "implementation",
        "incorporating",
        "operator",
        "allows",
        "programmer",
        "explicitly",
        "express",
        "negation",
        "literal",
        "even",
        "subclauses",
        "within",
        "program",
        "definition",
        "l",
        "succeeds",
        "literal",
        "l",
        "fails",
        "deduced",
        "mechanism",
        "known",
        "negationbyfailure",
        "target",
        "criticism",
        "negationbyfailure",
        "fully",
        "capture",
        "standard",
        "notion",
        "negation",
        "significant",
        "logical",
        "difference",
        "two",
        "standard",
        "logic",
        "including",
        "horn",
        "logic",
        "monotonic",
        "mean",
        "enlarging",
        "axiom",
        "set",
        "adding",
        "new",
        "axiom",
        "simply",
        "enlarges",
        "set",
        "theorem",
        "derivable",
        "negationbyfailure",
        "however",
        "nonmonotonic",
        "addition",
        "new",
        "program",
        "clause",
        "existing",
        "prolog",
        "program",
        "may",
        "cause",
        "goal",
        "cease",
        "theorem",
        "second",
        "issue",
        "control",
        "problem",
        "currently",
        "programmer",
        "need",
        "provide",
        "fair",
        "amount",
        "control",
        "information",
        "program",
        "achieve",
        "acceptable",
        "level",
        "efficiency",
        "example",
        "programmer",
        "must",
        "careful",
        "order",
        "clause",
        "listed",
        "within",
        "program",
        "literal",
        "ordered",
        "within",
        "clause",
        "failure",
        "proper",
        "job",
        "result",
        "inefficient",
        "worse",
        "nonterminating",
        "program",
        "programmer",
        "must",
        "also",
        "embed",
        "hint",
        "within",
        "program",
        "clause",
        "prevent",
        "prover",
        "revisiting",
        "certain",
        "path",
        "search",
        "space",
        "using",
        "cut",
        "operator",
        "prune",
        "altogether",
        "using",
        "fail",
        "last",
        "least",
        "order",
        "improve",
        "efficiency",
        "many",
        "implementation",
        "prolog",
        "implement",
        "unification",
        "fully",
        "bypass",
        "timeconsuming",
        "yet",
        "critical",
        "testthe",
        "socalled",
        "occurscheckresponsible",
        "checking",
        "suitability",
        "unifiers",
        "computed",
        "result",
        "unsound",
        "calculus",
        "may",
        "cause",
        "goal",
        "entailed",
        "prolog",
        "program",
        "computational",
        "point",
        "view",
        "fact",
        "logical",
        "point",
        "view",
        "variation",
        "prolog",
        "intended",
        "extend",
        "scope",
        "implementing",
        "model",
        "elimination",
        "procedure",
        "prolog",
        "technology",
        "theorem",
        "prover",
        "pttp",
        "stickel",
        "extends",
        "prolog",
        "full",
        "firstorder",
        "logic",
        "implementation",
        "achieves",
        "soundness",
        "completeness",
        "moving",
        "beyond",
        "firstorder",
        "logic",
        "\u03bbprolog",
        "miller",
        "nadathur",
        "base",
        "language",
        "higherorder",
        "constructive",
        "logic",
        "sat",
        "solver",
        "problem",
        "determining",
        "satisfiability",
        "logic",
        "formula",
        "received",
        "much",
        "attention",
        "automated",
        "reasoning",
        "community",
        "due",
        "important",
        "applicability",
        "industry",
        "propositional",
        "formula",
        "satisfiable",
        "assignment",
        "truthvalues",
        "variable",
        "make",
        "formula",
        "true",
        "example",
        "assignment",
        "p",
        "true",
        "q",
        "true",
        "r",
        "false",
        "make",
        "p",
        "r",
        "q",
        "true",
        "p",
        "true",
        "q",
        "false",
        "r",
        "false",
        "hence",
        "formula",
        "satisfiable",
        "determining",
        "whether",
        "formula",
        "satisfiable",
        "called",
        "boolean",
        "satisfiability",
        "problemsat",
        "shortand",
        "formula",
        "n",
        "variable",
        "sat",
        "settled",
        "thus",
        "inspect",
        "n",
        "possible",
        "assignment",
        "see",
        "least",
        "one",
        "assignment",
        "satisfies",
        "formula",
        "ie",
        "make",
        "true",
        "method",
        "clearly",
        "complete",
        "original",
        "formula",
        "satisfiable",
        "eventually",
        "find",
        "one",
        "satisfying",
        "assignment",
        "formula",
        "contradictory",
        "ie",
        "nonsatisfiable",
        "able",
        "determine",
        "clearly",
        "particularly",
        "latter",
        "case",
        "search",
        "take",
        "exponential",
        "amount",
        "time",
        "desire",
        "conceive",
        "efficient",
        "algorithm",
        "well",
        "justified",
        "particularly",
        "many",
        "computing",
        "problem",
        "great",
        "practical",
        "importance",
        "graphtheoretic",
        "problem",
        "network",
        "design",
        "storage",
        "retrieval",
        "scheduling",
        "program",
        "optimization",
        "many",
        "others",
        "garey",
        "johnson",
        "expressed",
        "sat",
        "instance",
        "ie",
        "sat",
        "question",
        "propositional",
        "formula",
        "representing",
        "problem",
        "given",
        "sat",
        "npcomplete",
        "cook",
        "unlikely",
        "polynomial",
        "algorithm",
        "exists",
        "however",
        "preclude",
        "existence",
        "sufficiently",
        "efficient",
        "algorithm",
        "particular",
        "case",
        "sat",
        "problem",
        "davisputnamlogemannloveland",
        "dpll",
        "algorithm",
        "one",
        "first",
        "sat",
        "search",
        "algorithm",
        "davis",
        "putnam",
        "davis",
        "logemman",
        "loveland",
        "still",
        "considered",
        "one",
        "best",
        "complete",
        "sat",
        "solver",
        "many",
        "complete",
        "sat",
        "procedure",
        "existence",
        "today",
        "considered",
        "optimization",
        "generalization",
        "dpll",
        "essence",
        "dpll",
        "search",
        "procedure",
        "proceed",
        "considering",
        "way",
        "assignment",
        "chosen",
        "make",
        "original",
        "formula",
        "true",
        "example",
        "consider",
        "formula",
        "cnf",
        "p",
        "q",
        "p",
        "q",
        "r",
        "p",
        "s",
        "since",
        "p",
        "conjunct",
        "also",
        "unit",
        "clause",
        "p",
        "must",
        "true",
        "entire",
        "formula",
        "true",
        "moreover",
        "value",
        "p",
        "contribute",
        "truth",
        "p",
        "q",
        "r",
        "p",
        "s",
        "true",
        "regardless",
        "s",
        "thus",
        "whole",
        "formula",
        "reduces",
        "q",
        "q",
        "r",
        "similarly",
        "q",
        "must",
        "true",
        "formula",
        "reduces",
        "r",
        "force",
        "r",
        "true",
        "process",
        "recover",
        "assignment",
        "p",
        "true",
        "q",
        "false",
        "r",
        "true",
        "false",
        "proving",
        "original",
        "formula",
        "satisfiable",
        "formula",
        "may",
        "cause",
        "algorithm",
        "branch",
        "search",
        "branch",
        "reach",
        "dead",
        "end",
        "moment",
        "clause",
        "deemed",
        "falsea",
        "conflicting",
        "clauseand",
        "variation",
        "assignment",
        "partially",
        "constructed",
        "point",
        "discarded",
        "illustrate",
        "r",
        "p",
        "q",
        "p",
        "q",
        "p",
        "q",
        "given",
        "p",
        "q",
        "p",
        "q",
        "p",
        "q",
        "letting",
        "r",
        "true",
        "q",
        "q",
        "letting",
        "p",
        "true",
        "conflict",
        "q",
        "q",
        "true",
        "p",
        "q",
        "p",
        "q",
        "p",
        "q",
        "backtrack",
        "r",
        "true",
        "still",
        "hold",
        "p",
        "letting",
        "q",
        "true",
        "true",
        "letting",
        "p",
        "true",
        "ie",
        "p",
        "false",
        "hence",
        "formula",
        "satisfiable",
        "existence",
        "p",
        "false",
        "q",
        "true",
        "r",
        "true",
        "dpll",
        "algorithm",
        "made",
        "efficient",
        "strategy",
        "term",
        "indexing",
        "ordering",
        "formula",
        "variable",
        "advantageous",
        "way",
        "chronological",
        "backtracking",
        "undoing",
        "work",
        "previous",
        "branching",
        "point",
        "process",
        "lead",
        "conflicting",
        "clause",
        "conflictdriven",
        "learning",
        "determining",
        "information",
        "keep",
        "backtrack",
        "combination",
        "strategy",
        "result",
        "large",
        "prune",
        "search",
        "space",
        "extensive",
        "discussion",
        "interested",
        "reader",
        "directed",
        "zhang",
        "malik",
        "quick",
        "backenvelope",
        "calculation",
        "reveals",
        "staggering",
        "computing",
        "time",
        "algorithm",
        "sattype",
        "problem",
        "represented",
        "formula",
        "little",
        "say",
        "variable",
        "wit",
        "problem",
        "represented",
        "boolean",
        "formula",
        "variable",
        "affords",
        "linear",
        "solution",
        "taking",
        "one",
        "hundredth",
        "second",
        "complete",
        "would",
        "take",
        "four",
        "hundredth",
        "six",
        "hundredth",
        "second",
        "complete",
        "formula",
        "instead",
        "variable",
        "respectively",
        "dramatic",
        "contrast",
        "solution",
        "problem",
        "exponential",
        "say",
        "n",
        "time",
        "complete",
        "job",
        "variable",
        "would",
        "respectively",
        "one",
        "thousandth",
        "second",
        "day",
        "century",
        "true",
        "testament",
        "ingenuity",
        "automated",
        "reasoning",
        "community",
        "power",
        "current",
        "satbased",
        "search",
        "algorithm",
        "realworld",
        "problem",
        "thousand",
        "variable",
        "handled",
        "reasonable",
        "efficency",
        "k\u00fcchlin",
        "sinz",
        "discus",
        "sat",
        "application",
        "realm",
        "industrial",
        "automotive",
        "product",
        "data",
        "management",
        "elementary",
        "boolean",
        "formula",
        "variable",
        "used",
        "express",
        "constraint",
        "order",
        "placed",
        "customer",
        "another",
        "example",
        "massacci",
        "marraro",
        "discus",
        "application",
        "logical",
        "cryptanalysis",
        "verification",
        "property",
        "cryptographic",
        "algorithm",
        "expressed",
        "sat",
        "problem",
        "demonstrate",
        "finding",
        "key",
        "cryptographic",
        "attack",
        "analogous",
        "finding",
        "modelassignmentfor",
        "boolean",
        "formula",
        "formula",
        "application",
        "encodes",
        "commercial",
        "version",
        "us",
        "data",
        "encryption",
        "standard",
        "de",
        "encoding",
        "requiring",
        "clause",
        "variable",
        "although",
        "sat",
        "conceptually",
        "simple",
        "inner",
        "nature",
        "well",
        "understoodthere",
        "criterion",
        "generally",
        "applied",
        "answer",
        "one",
        "sat",
        "problem",
        "harder",
        "another",
        "come",
        "surprise",
        "algorithm",
        "tend",
        "well",
        "sat",
        "instance",
        "perform",
        "well",
        "others",
        "effort",
        "spent",
        "designing",
        "hybrid",
        "algorithmic",
        "solution",
        "combine",
        "strength",
        "complementary",
        "approachessee",
        "prasad",
        "biere",
        "gupta",
        "application",
        "hybrid",
        "approach",
        "verification",
        "hardware",
        "design",
        "recent",
        "advance",
        "sat",
        "hybrid",
        "strategy",
        "coupled",
        "supercomputing",
        "power",
        "allowed",
        "team",
        "three",
        "computing",
        "scientist",
        "solve",
        "boolean",
        "pythagorean",
        "triple",
        "problem",
        "longstanding",
        "open",
        "question",
        "ramsey",
        "theory",
        "set",
        "natural",
        "number",
        "divided",
        "two",
        "part",
        "part",
        "containing",
        "triple",
        "b",
        "c",
        "a",
        "b",
        "c",
        "heule",
        "kullmann",
        "marek",
        "proved",
        "done",
        "showing",
        "set",
        "n",
        "partitioned",
        "n",
        "impossible",
        "n",
        "expressing",
        "deceptively",
        "simple",
        "question",
        "sat",
        "problem",
        "required",
        "close",
        "clause",
        "variable",
        "half",
        "going",
        "represent",
        "problem",
        "satisfiable",
        "n",
        "half",
        "represent",
        "n",
        "two",
        "proving",
        "latter",
        "far",
        "challenging",
        "since",
        "demanded",
        "proof",
        "unsatisfiability",
        "ie",
        "partition",
        "exists",
        "na\u00efve",
        "bruteforce",
        "approach",
        "considering",
        "possible",
        "twopart",
        "partition",
        "clearly",
        "question",
        "problem",
        "attacked",
        "using",
        "clever",
        "algorithm",
        "within",
        "multistage",
        "satbased",
        "framework",
        "solving",
        "hard",
        "problem",
        "combinatorics",
        "consisting",
        "five",
        "phase",
        "encode",
        "encoding",
        "problem",
        "sat",
        "formula",
        "transform",
        "optimizing",
        "encoding",
        "using",
        "clause",
        "elimination",
        "symmetry",
        "breaking",
        "technique",
        "split",
        "dividing",
        "problem",
        "effectively",
        "subproblems",
        "using",
        "splitting",
        "heuristic",
        "solve",
        "searching",
        "satisfying",
        "assignment",
        "lack",
        "thereof",
        "using",
        "fast",
        "processing",
        "validate",
        "validating",
        "result",
        "earlier",
        "phase",
        "special",
        "importance",
        "application",
        "cubeandconquer",
        "hybrid",
        "sat",
        "strategy",
        "particularly",
        "effective",
        "hard",
        "combinatorial",
        "problem",
        "strategy",
        "combine",
        "lookahead",
        "conflictdriven",
        "clauselearning",
        "cdcl",
        "former",
        "aiming",
        "construct",
        "small",
        "binary",
        "search",
        "tree",
        "using",
        "global",
        "heuristic",
        "latter",
        "aiming",
        "find",
        "short",
        "refutation",
        "using",
        "local",
        "heuristic",
        "splitting",
        "problem",
        "hard",
        "subproblems",
        "known",
        "cube",
        "handed",
        "core",
        "working",
        "parallel",
        "stampede",
        "supercomputer",
        "day",
        "splitting",
        "cdcl",
        "clausecrunching",
        "settled",
        "question",
        "delivered",
        "terabyte",
        "proof",
        "validating",
        "work",
        "deservedly",
        "celebrating",
        "significant",
        "accomplishment",
        "automated",
        "reasoning",
        "entertaining",
        "new",
        "application",
        "enhanced",
        "sat",
        "method",
        "would",
        "afford",
        "particularly",
        "area",
        "hardware",
        "software",
        "verification",
        "ask",
        "question",
        "especial",
        "importance",
        "mathematician",
        "insightful",
        "way",
        "establish",
        "result",
        "would",
        "involve",
        "traditional",
        "intellectually",
        "satisfying",
        "mathematical",
        "proof",
        "method",
        "far",
        "increasing",
        "understanding",
        "given",
        "field",
        "combinatorics",
        "case",
        "value",
        "settling",
        "question",
        "human",
        "inspect",
        "proof",
        "hence",
        "get",
        "insight",
        "even",
        "team",
        "responsible",
        "result",
        "admits",
        "proof",
        "unsatisfiability",
        "coming",
        "sat",
        "solver",
        "human",
        "point",
        "view",
        "giant",
        "heap",
        "random",
        "information",
        "direct",
        "understanding",
        "involved",
        "conjecture",
        "settled",
        "basically",
        "underlying",
        "idea",
        "make",
        "special",
        "perhaps",
        "real",
        "value",
        "drawn",
        "consideration",
        "lead",
        "u",
        "think",
        "deeper",
        "question",
        "structure",
        "specific",
        "problem",
        "make",
        "amenable",
        "standard",
        "mathematical",
        "treatment",
        "opposed",
        "requiring",
        "mindless",
        "bruteforce",
        "approach",
        "question",
        "contemplated",
        "sat",
        "may",
        "provide",
        "best",
        "line",
        "attack",
        "certain",
        "mathematical",
        "problem",
        "dpll",
        "search",
        "procedure",
        "extended",
        "quantified",
        "logic",
        "mace",
        "popular",
        "program",
        "based",
        "dpll",
        "algorithm",
        "search",
        "finite",
        "model",
        "firstorder",
        "formula",
        "equality",
        "example",
        "mccune",
        "show",
        "group",
        "commutative",
        "one",
        "direct",
        "mace",
        "look",
        "model",
        "group",
        "axiom",
        "also",
        "falsifies",
        "commutation",
        "law",
        "equivalently",
        "look",
        "model",
        "g",
        "e",
        "x",
        "x",
        "left",
        "identity",
        "g",
        "x",
        "x",
        "e",
        "left",
        "inverse",
        "g",
        "x",
        "z",
        "x",
        "z",
        "associativity",
        "dc",
        "b",
        "b",
        "denial",
        "commutativity",
        "mace",
        "find",
        "sixelement",
        "model",
        "axiom",
        "defined",
        "defined",
        "x",
        "x",
        "example",
        "also",
        "illustrates",
        "benefit",
        "using",
        "automated",
        "deduction",
        "system",
        "long",
        "would",
        "taken",
        "human",
        "researcher",
        "come",
        "similar",
        "model",
        "challenging",
        "problem",
        "program",
        "used",
        "practical",
        "complement",
        "resolutionbased",
        "theorem",
        "prover",
        "prover",
        "formerly",
        "otter",
        "prover",
        "searching",
        "proof",
        "mace",
        "jointly",
        "looking",
        "counter",
        "model",
        "find",
        "model",
        "mace",
        "convert",
        "firstorder",
        "problem",
        "set",
        "flattened",
        "clause",
        "increasing",
        "model",
        "size",
        "instantiated",
        "propositional",
        "clause",
        "solved",
        "sat",
        "problem",
        "method",
        "implemented",
        "automated",
        "reasoning",
        "system",
        "well",
        "notably",
        "paradox",
        "model",
        "finder",
        "macestyle",
        "approach",
        "enhanced",
        "four",
        "additional",
        "technique",
        "resulting",
        "significant",
        "efficiency",
        "improvement",
        "claessen",
        "s\u00f6rensson",
        "term",
        "definition",
        "reduce",
        "number",
        "variable",
        "flattened",
        "clause",
        "static",
        "symmetric",
        "reduction",
        "reduce",
        "number",
        "isomorphic",
        "model",
        "sort",
        "inference",
        "apply",
        "symmetric",
        "reduction",
        "finer",
        "level",
        "incremental",
        "sat",
        "reuse",
        "search",
        "information",
        "consecutive",
        "model",
        "size",
        "strategy",
        "pairing",
        "complementary",
        "capability",
        "separate",
        "automated",
        "reasoning",
        "system",
        "applied",
        "higherorder",
        "logic",
        "exemplified",
        "nitpick",
        "counterexample",
        "generator",
        "isabellehol",
        "blanchette",
        "nipkow",
        "brown",
        "describes",
        "theorem",
        "proving",
        "procedure",
        "higherorder",
        "logic",
        "us",
        "satsolving",
        "work",
        "procedure",
        "complete",
        "cutfree",
        "ground",
        "refutation",
        "calculus",
        "incorporates",
        "restriction",
        "instantiation",
        "implemented",
        "satallax",
        "theorem",
        "prover",
        "brown",
        "approach",
        "great",
        "interest",
        "solving",
        "sat",
        "problem",
        "firstorder",
        "logic",
        "satisfiability",
        "modulo",
        "theory",
        "smt",
        "interpretation",
        "symbol",
        "problem",
        "formulation",
        "constrained",
        "background",
        "theory",
        "example",
        "linear",
        "arithmetic",
        "function",
        "symbol",
        "restricted",
        "another",
        "example",
        "extensional",
        "theory",
        "array",
        "mccarthy",
        "array",
        "function",
        "read",
        "return",
        "value",
        "array",
        "index",
        "write",
        "x",
        "return",
        "array",
        "identical",
        "value",
        "x",
        "formally",
        "a",
        "array",
        "i",
        "j",
        "index",
        "x",
        "value",
        "j",
        "read",
        "write",
        "x",
        "j",
        "x",
        "readwrite",
        "axiom",
        "a",
        "array",
        "i",
        "j",
        "index",
        "x",
        "value",
        "j",
        "read",
        "write",
        "x",
        "j",
        "read",
        "j",
        "readwrite",
        "axiom",
        "a",
        "b",
        "array",
        "i",
        "index",
        "b",
        "read",
        "read",
        "b",
        "extensionality",
        "context",
        "axiom",
        "smt",
        "solver",
        "would",
        "attempt",
        "establish",
        "satisfiability",
        "dually",
        "validity",
        "given",
        "firstorder",
        "formula",
        "thousand",
        "formula",
        "matter",
        "j",
        "f",
        "read",
        "write",
        "j",
        "read",
        "write",
        "f",
        "j",
        "ganzinger",
        "et",
        "al",
        "discus",
        "approach",
        "smt",
        "called",
        "dpll",
        "consisting",
        "general",
        "dpll",
        "x",
        "engine",
        "work",
        "conjunction",
        "solver",
        "solvert",
        "background",
        "theory",
        "t",
        "bofill",
        "et",
        "al",
        "present",
        "approach",
        "setting",
        "theory",
        "array",
        "dpll",
        "engine",
        "responsible",
        "enumerating",
        "propositional",
        "model",
        "given",
        "formula",
        "whereas",
        "solvert",
        "check",
        "whether",
        "model",
        "consistent",
        "theory",
        "array",
        "approach",
        "sound",
        "complete",
        "smoothly",
        "extended",
        "multidimensional",
        "array",
        "smt",
        "particularly",
        "successful",
        "verification",
        "application",
        "notably",
        "software",
        "verification",
        "improved",
        "efficiency",
        "sat",
        "solver",
        "smt",
        "effort",
        "designing",
        "efficient",
        "smt",
        "solver",
        "de",
        "moura"
    ]
}