{
    "main_text": "Some Applications || Logics with Partial or Non-Strict Functions\n5.2 Logics with Partial or Non-Strict Functions\n\nSome logics employ primitive n-place function\nsymbols\u2014symbols that combine with \\(n\\) singular terms to\nform a complex singular term. Thus, for example, the plus sign\n\u2018+\u2019 is a two-place function symbol that, when placed\nbetween, say, \u20182\u2019 and \u20183\u2019, forms a complex\nsingular term, \u2018\\(2 + 3\\)\u2019 that denotes the number five.\nSimilarly, \u2018\\(^2\\)\u2019 is a one-place function symbol that,\nwhen placed after a term denoting a number, forms a complex singular\nterm that denotes that number\u2019s square. Semantically, the\nextension of a function symbol is a function whose arguments are\nmembers of the quantificational domain \\(\\bD\\), and the resulting\ncomplex term denotes the result of applying that function to the\nreferents of the \\(n\\) component singular terms, taken in the order\nlisted. Since classical logic requires every singular term (including\nthose formed by function symbols) to refer to an object in \\(\\bD\\),\nfor each such function symbol \\(f\\), it requires that:\n\n\\[ \\forall x_1 \\ldots \\forall x_n\\exists y(y = f(x_1, \\ldots, x_n)). \\]\n\n\nHence classical logic prohibits primitive function symbols whose\nextensions are partial functions\u2014functions whose value is for\nsome arguments undefined. Such, for example, is the binary division\nsign \u2018/\u2019, since when placed between two numerals the\nsecond of which is \u20180\u2019, it forms an empty singular term.\nSimilarly, the limit function symbol \u2018lim\u2019 yields an empty\nsingular term when applied to the name of a non-coverging sequence.\nClassical logic can accommodate function symbols for partial functions\nvia elaborate contextual definitions. But then (as with Russellian\ndefinite descriptions) the form in which these function symbols are\nusually written is not their logical form. Free logic provides a more\nelegant solution. Because it allows empty singular terms, symbols for\npartial functions may simply be taken as primitive.\n\nIn applications of free logic involving partial functions, the\nexistence predicate \u2018\\(\\rE!\\)\u2019 is often replaced by the\npostfix definedness predicate \u2018\\(\\downarrow\\)\u2019. For any\nsingular term \\(t, t\\downarrow\\) is true if and only if \\(t\\) has some\ndefinite value in \\(\\bD\\). Thus, for example, the formula\n\u2018\\((1/0)\\downarrow\\)\u2019 is false. While some writers (e.g.,\nFeferman (1995)) distinguish \u2018\\(\\downarrow\\)\u2019 from\n\u2018\\(\\rE!\\)\u2019, the literature as a whole does not, and\n\u2018\\(\\downarrow\\)\u2019 is often merely a syntactic variant of\n\u2018\\(\\rE!\\)\u2019.\n\nIn addition to partial functions, positive free logics can\nalso readily handle non-strict functions. A non-strict\nfunction is a function that may yield a value even if not all of its\narguments are defined. The binary function \\(f\\) such that \\(f(x,y) =\nx\\), for instance, can yield a value even if the \\(y\\)-term is empty.\nSo, for example, the formula \\(f(1, 1/0) = 1\\) can be regarded as\ntrue. Logics for non-strict functions must be positive because in a\nnegative or neutral logic empty-termed atomic formulas, such as \\(f(1,\n1/0) = 1\\), cannot be true. Free logics involving non-strict functions\nfind application in some programming languages (Gumb 2001, Gumb and\nLambert 1991). Such logics may employ a dual-domain semantics in which\nthe referents of empty functional expressions such as\n\u20181/0\u2019 are regarded as error objects\u2014objects\nthat correspond in the running of a program to error messages. Thus,\nfor example, an instruction to calculate \\(f(1, 1/0)\\) might return\nthe value 1, but an instruction to calculate \\(f(1/0, 1)\\) would\nreturn an error message.\n",
    "section_title": "5.2 Logics with Partial or Non-Strict Functions",
    "entry_title": "Free Logic",
    "hierarchy_title": "Free Logic || Some Applications || Logics with Partial or Non-Strict Functions",
    "tokenized_text": [
        "application",
        "logic",
        "partial",
        "nonstrict",
        "function",
        "logic",
        "partial",
        "nonstrict",
        "function",
        "logic",
        "employ",
        "primitive",
        "nplace",
        "function",
        "symbolssymbols",
        "combine",
        "n",
        "singular",
        "term",
        "form",
        "complex",
        "singular",
        "term",
        "thus",
        "example",
        "plus",
        "sign",
        "twoplace",
        "function",
        "symbol",
        "placed",
        "say",
        "form",
        "complex",
        "singular",
        "term",
        "denotes",
        "number",
        "five",
        "similarly",
        "oneplace",
        "function",
        "symbol",
        "placed",
        "term",
        "denoting",
        "number",
        "form",
        "complex",
        "singular",
        "term",
        "denotes",
        "number",
        "square",
        "semantically",
        "extension",
        "function",
        "symbol",
        "function",
        "whose",
        "argument",
        "member",
        "quantificational",
        "domain",
        "bd",
        "resulting",
        "complex",
        "term",
        "denotes",
        "result",
        "applying",
        "function",
        "referent",
        "n",
        "component",
        "singular",
        "term",
        "taken",
        "order",
        "listed",
        "since",
        "classical",
        "logic",
        "requires",
        "every",
        "singular",
        "term",
        "including",
        "formed",
        "function",
        "symbol",
        "refer",
        "object",
        "bd",
        "function",
        "symbol",
        "f",
        "requires",
        "forall",
        "x_",
        "ldots",
        "forall",
        "x_nexists",
        "f",
        "x_",
        "ldots",
        "x_n",
        "hence",
        "classical",
        "logic",
        "prohibits",
        "primitive",
        "function",
        "symbol",
        "whose",
        "extension",
        "partial",
        "functionsfunctions",
        "whose",
        "value",
        "argument",
        "undefined",
        "example",
        "binary",
        "division",
        "sign",
        "since",
        "placed",
        "two",
        "numeral",
        "second",
        "form",
        "empty",
        "singular",
        "term",
        "similarly",
        "limit",
        "function",
        "symbol",
        "lim",
        "yield",
        "empty",
        "singular",
        "term",
        "applied",
        "name",
        "noncoverging",
        "sequence",
        "classical",
        "logic",
        "accommodate",
        "function",
        "symbol",
        "partial",
        "function",
        "via",
        "elaborate",
        "contextual",
        "definition",
        "russellian",
        "definite",
        "description",
        "form",
        "function",
        "symbol",
        "usually",
        "written",
        "logical",
        "form",
        "free",
        "logic",
        "provides",
        "elegant",
        "solution",
        "allows",
        "empty",
        "singular",
        "term",
        "symbol",
        "partial",
        "function",
        "may",
        "simply",
        "taken",
        "primitive",
        "application",
        "free",
        "logic",
        "involving",
        "partial",
        "function",
        "existence",
        "predicate",
        "re",
        "often",
        "replaced",
        "postfix",
        "definedness",
        "predicate",
        "downarrow",
        "singular",
        "term",
        "tdownarrow",
        "true",
        "t",
        "definite",
        "value",
        "bd",
        "thus",
        "example",
        "formula",
        "downarrow",
        "false",
        "writer",
        "eg",
        "feferman",
        "distinguish",
        "downarrow",
        "re",
        "literature",
        "whole",
        "downarrow",
        "often",
        "merely",
        "syntactic",
        "variant",
        "re",
        "addition",
        "partial",
        "function",
        "positive",
        "free",
        "logic",
        "also",
        "readily",
        "handle",
        "nonstrict",
        "function",
        "nonstrict",
        "function",
        "function",
        "may",
        "yield",
        "value",
        "even",
        "argument",
        "defined",
        "binary",
        "function",
        "f",
        "f",
        "x",
        "x",
        "instance",
        "yield",
        "value",
        "even",
        "y",
        "term",
        "empty",
        "example",
        "formula",
        "f",
        "regarded",
        "true",
        "logic",
        "nonstrict",
        "function",
        "must",
        "positive",
        "negative",
        "neutral",
        "logic",
        "emptytermed",
        "atomic",
        "formula",
        "f",
        "true",
        "free",
        "logic",
        "involving",
        "nonstrict",
        "function",
        "find",
        "application",
        "programming",
        "language",
        "gumb",
        "gumb",
        "lambert",
        "logic",
        "may",
        "employ",
        "dualdomain",
        "semantics",
        "referent",
        "empty",
        "functional",
        "expression",
        "regarded",
        "error",
        "objectsobjects",
        "correspond",
        "running",
        "program",
        "error",
        "message",
        "thus",
        "example",
        "instruction",
        "calculate",
        "f",
        "might",
        "return",
        "value",
        "instruction",
        "calculate",
        "f",
        "would",
        "return",
        "error",
        "message"
    ]
}