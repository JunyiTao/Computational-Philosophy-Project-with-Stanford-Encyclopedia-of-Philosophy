{"url": "logic-dynamic", "title": "Propositional Dynamic Logic", "authorship": {"year": "Copyright \u00a9 2023", "author_text": "Nicolas Troquard\n<ntroquard@unibz.it>\nPhilippe Balbiani", "author_links": [{"http://www.inf.unibz.it/~ntroquard/": "Nicolas Troquard"}, {"mailto:ntroquard%40unibz%2eit": "ntroquard@unibz.it"}, {"http://www.irit.fr/~Philippe.Balbiani/": "Philippe Balbiani"}], "raw_html": "<div id=\"article-copyright\">\n<p>\n<a href=\"../../info.html#c\">Copyright \u00a9 2023</a> by\n\n<br/>\n<a href=\"http://www.inf.unibz.it/~ntroquard/\" target=\"other\">Nicolas Troquard</a>\n&lt;<a href=\"mailto:ntroquard%40unibz%2eit\"><em>ntroquard<abbr title=\" at \">@</abbr>unibz<abbr title=\" dot \">.</abbr>it</em></a>&gt;<br/>\n<a href=\"http://www.irit.fr/~Philippe.Balbiani/\" target=\"other\">Philippe Balbiani</a>\n</p>\n</div>"}, "pubinfo": ["First published Thu Feb 1, 2007", "substantive revision Thu Feb 16, 2023"], "preamble": "\n\nLogics of programs are modal logics arising from the idea of\nassociating a modality \\([\\alpha]\\) with each computer program\n\\(\\alpha\\) of a programming language. The formula \\([\\alpha]A\\) is\nthen to be read as: \\(A\\) is true after the execution of the program\n\\(\\alpha\\). This idea comes from the line of works by Engeler [1967],\nHoare [1969], Yanov [1959], and others who formulated and studied\nlogical languages in which the properties of program connectives can\nbe expressed. The algorithmic logic (AL) first developed by Salwicki\n[1970] and the dynamic logic (DL) elaborated by Pratt [1976] are\nproper continuations of these works. We will here concentrate on DL.\nThe numerous papers devoted to DL and its variants as well as its many\napplications in program verification and data structures show that it\nconstitutes a useful tool for studying the properties of programs.\nPratt chose to depict DL on what one might call the first-order level,\nand it was his work that triggered Fischer and Ladner [1979] to define\nthe propositional variant of DL a couple of years later. This article\npresents an introduction to PDL, the propositional variant of DL.\n", "toc": [{"#Intr": "1. Introduction"}, {"#DefiFundResu": "2. Definitions and fundamental results"}, {"#SyntSema": "2.1 Syntax and semantics"}, {"#AxioComp": "2.2 Axiomatization and completeness"}, {"#DeciComp": "2.3 Decidability and complexity"}, {"#StruProgCorrProg": "3. Structured programming and correctness of programs"}, {"#HoarCalc": "3.1 Hoare calculus"}, {"#HoarCalcPDL": "3.2 Hoare calculus and PDL"}, {"#TotaCorr": "3.3 Total correctness"}, {"#SomeVari": "4. Some variants"}, {"#PDLWithTest": "4.1 PDL without tests"}, {"#PDLConv": "4.2 PDL with converse"}, {"#PDLRepeLoop": "4.3 PDL with repeating and looping"}, {"#PDLInte": "4.4 PDL with intersection"}, {"#Conc": "5. Conclusion"}, {"#Bib": "Bibliography"}, {"#Aca": "Academic Tools"}, {"#Oth": "Other Internet Resources"}, {"#Rel": "Related Entries"}], "main_text": "\n1. Introduction\n\nDynamic Logics (DL) are modal logics for representing the states and\nthe events of dynamic systems. The language of DLs is both an\nassertion language able to express properties of computation states,\nand a programming language able to express properties of system\ntransitions between these states. DLs are logics of programs,\nand permit to talk and reason about states of affairs, processes,\nchanges, and results.\n\nPratt\u2019s original dynamic logic of programs was a\nfirst-order modal logic. Propositional Dynamic Logic\n(PDL) is the propositional counterpart of it. It was presented as a\nlogic in its own right in Fischer and Ladner [1979]. Being\npropositional, the language of PDL makes no use of terms, predicates,\nor functions. Thus in PDL, there are two syntactic categories:\npropositions and programs.\n\nTo give meaning to statements in PDL, we typically work with an\nabstract semantics in terms of Labeled Transition Systems (LTS). LTSs\ncan be seen as a generalization of Kripke models, where transitions\nbetween worlds, or states, are \u201clabeled\u201d by names of\natomic programs. A valuation indicates for every state what\npropositions are true in it. A transition labeled \\(\\pi\\)\nfrom one state \\(x\\) to a state \\(y\\)\u2014noted \\(xR(\\pi)y\\), or\n\\((x,y) \\in R(\\pi)\\)\u2014indicates that starting in \\(x\\), there is\na possible execution of the program \\(\\pi\\) that finishes in \\(y\\). If\nthe proposition \\(A\\) is true in \\(y\\), then the formula\n\\(\\langle\\pi\\rangle A\\) is true in \\(x\\): i.e., in the state \\(x\\)\nthere is a possible execution of the program \\(\\pi\\) that ends in a\nstate satisfying \\(A\\). One recognizes in \\(\\langle\\pi\\rangle\\) a\nmodality reminiscent of the modality of possibility (often noted\n\\(\\Diamond\\)) of modal logic. Unsurprisingly, there is also a\ncorresponding notion of necessity (whose modality is often noted\n\\(\\Box\\)). The formula \\([\\pi]A\\) is true in the state \\(x\\) if \\(A\\)\nis true in every state reachable from \\(x\\) by a transition labeled\n\\(\\pi\\).\n\nThe possible executions of complex programs can be next defined\ncompositionally. For instance, a program \u201cfirst \\(\\alpha\\), then\n\\(\\beta\\)\u201d is a complex program, more specifically a\nsequence. A possible execution can be represented in an LTS\nby composing a two-step transition\u2014a transition which can be\nsignified by \\(R(\\alpha;\\beta)\\)\u2014between the states \\(x\\) and\n\\(y\\): there is a possible execution in the state \\(x\\) of the program\n\\(\\alpha\\) that finishes in a state \\(z\\) and there is a possible\nexecution in \\(z\\) of the program \\(\\beta\\) that finishes in the state\n\\(y\\). If the proposition \\(A\\) is true in \\(y\\), then the formula\n\\(\\langle \\alpha;\\beta\\rangle A\\) is be true in the state \\(x\\). The\nprograms \\(\\alpha\\) and \\(\\beta\\) could be complex program themselves.\nStill more programs can be expressed with more constructs that we will\npresent in due time.\n\nA program is then seen in an extensional way: it is a binary relation\nbetween pairs of states of an LTS. Precisely, it is the set of pairs\nof the form \\((x,y)\\) such that the program can be executed in the\nstate \\(x\\) and can lead to the state \\(y\\). On the other hand, a\nproposition is a statement about a state; it is either true or false\nin a state. A proposition can thus also be seen in an extensional way:\nthe set of states of the LTS where it is true.\n\nWith the acronym PDL, we refer here precisely to the propositional\ndynamic logic with the following program constructs: sequence,\nnon-deterministic choice, unbounded iteration, and test. We present it\nin\n section 2,\n together with some properties and fundamental results. In particular,\nwe will address its axiomatization and its decidability.\n\nThe Hoare calculus from Hoare [1969] is a landmark for logics of\nprograms. It concerns the truth of statements of the form\n\\(\\{A\\}\\alpha\\{B\\}\\)\u2014meaning that with the precondition \\(A\\)\nthe program \\(\\alpha\\) always has \\(B\\) as a post-condition\u2014and\nis defined axiomatically. It comes from a want of rigorous methods to\nreason about the properties of programs, and thus giving to the\nactivity of programming a certain place in the realm of science.\nBurstall [1974] saw the analogy between modal logics and reasoning\nabout programs. But the actual work on it started with Pratt [1976]\nafter it was suggested to him by some of the students of a course he\nwas giving, specifically about logics of programs. PDL comes from\nPratt\u2019s interpretation of Hoare\u2019s calculus in the\nformalism of modal logic. An introduction to the genesis of PDL can be\nfound in Pratt [1980b]. The Hoare-triple \\(\\{A\\}\\alpha\\{B\\}\\) is\ncaptured by the PDL formula \\(A \\to [\\alpha]B\\) meaning literally that\nif \\(A\\) is true, then every successfully terminating execution of\n\\(\\alpha\\) will end with \\(B\\) being true. With this connection\nrealized, it is a routine to prove the initial rules of Hoare\u2019s\ncalculus using exclusively the axiomatization of PDL. This is\nsomething we will do in detail in\n section 3\n which concentrates on the reasoning about the correctness of\nstructured programs.\n\nAdditional topics related to PDL include results concerning\ncomparative power of expression, decidability, complexity, and\ncompleteness of a number of interesting variants obtained by extending\nor restricting PDL in various ways. Since its inception, many variants\nof PDL have received attention. These variants may consider\ndeterministic programs, restricted tests, non-regular programs,\nprograms as automata, complementation and intersection of programs,\nconverse and infinite computations, etc. We will present some of them\nin\n section 4,\n providing some pointers regarding their relative expressivity, their\naxiomatizations, and their computational complexity.\n\nWe conclude in\n section 5.\n2. Definitions and fundamental results\n\nWe present the syntax and semantics of PDL in\n section 2.1.\n The proof theory of PDL is presented in\n section 2.2\n with axiomatizations and pointers to the literature on completeness.\nWe address the problem of decidability and complexity in\n section 2.3.\n2.1 Syntax and semantics\n\nPropositional dynamic logic (PDL) is designed for representing and\nreasoning about propositional properties of programs. Its syntax is\nbased upon two sets of symbols: a countable set \\(\\Phi_0\\) of atomic\nformulas and a countable set \\(\\Pi_0\\) of atomic programs. Complex\nformulas and complex programs over this base are defined as\nfollows.\n\nEvery atomic formula is a formula.\n\\(0\\) (\u201cfalse\u201d) is a formula.\nIf \\(A\\) is a formula then \\(\\lnot A\\) (\u201cnot \\(A\\)\u201d)\nis a formula.\nIf \\(A\\) and \\(B\\) are formulas then \\((A\\lor B)\\) (\u201c\\(A\\)\nor \\(B\\)\u201d) is a formula.\nIf \\(\\alpha\\) is a program and A is a formula then\n\\([\\alpha]A\\) (\u201cevery execution of \\(\\alpha\\) from the present\nstate leads to a state where \\(A\\) is true\u201d) is a formula.\nEvery atomic program is a program.\nIf \\(\\alpha\\) and \\(\\beta\\) are programs then \\((\\alpha;\\beta)\\)\n(\u201cdo \\(\\alpha\\) followed by \\(\\beta\\)\u201d) is a program.\nIf \\(\\alpha\\) and \\(\\beta\\) are programs then\n\\((\\alpha\\cup\\beta)\\) (\u201cdo \\(\\alpha\\) or \\(\\beta\\),\nnon-deterministically\u201d) is a program.\nIf \\(\\alpha\\) is a program then \\(\\alpha^*\\) (\u201crepeat\n\\(\\alpha\\) a finite, but non-deterministically determined, number of\ntimes\u201d) is a program.\nIf \\(A\\) is a formula then \\(A?\\) (\u201cproceed if \\(A\\) is\ntrue, else fail\u201d) is a program.\n\n\nThe other Boolean connectives \\(1\\), \\(\\land\\), \\(\\to\\), and\n\\(\\leftrightarrow\\) are used as abbreviations in the standard way. In\naddition, we abbreviate \\(\\lnot[\\alpha]\\lnot A\\) to\n\\(\\langle\\alpha\\rangle A\\) (\u201csome execution of \\(\\alpha\\) from\nthe present state leads to a state where \\(A\\) is true\u201d) as in\nmodal logic. We write \\(\\alpha^n\\) for \\(\\alpha;\\ldots ;\\alpha\\) with\n\\(n\\) occurrences of \\(\\alpha\\). More formally:\n\n\\(\\alpha^0 := 1?\\)\n\\(\\alpha^{n+1} := \\alpha;\\alpha^n\\)\n Also:\n\n\n\\(\\alpha^+ := \\alpha;\\alpha^*\\)\n\n\nis often useful to represent an iteration that is unbounded but occurs\nat least once. Finally, we adopt the standard rules for omission of\nparentheses.\n\nFormulas can be used to describe the properties that hold after the\nsuccessful execution of a program. For example, the formula\n\\([\\alpha\\cup\\beta]A\\) means that whenever program \\(\\alpha\\) or\n\\(\\beta\\) is successfully executed, a state is reached where \\(A\\)\nholds, whereas the formula \\(\\langle (\\alpha;\\beta)^*\\rangle A\\) means\nthat there is a sequence of alternating executions of \\(\\alpha\\) and\n\\(\\beta\\) such that a state is reached where \\(A\\) holds. Semantically\nspeaking, formulas are interpreted by sets of states and programs are\ninterpreted by binary relations over states in a transition system.\nMore precisely, the meaning of PDL formulas and programs is\ninterpreted over Labeled Transition Systems (LTS) \\(M = (W,R,V)\\)\nwhere \\(W\\) is a nonempty set of worlds or states, \\(R\\) is a mapping\nfrom the set \\(\\Pi_0\\) of atomic programs into binary relations on\n\\(W\\) and \\(V\\) is a mapping from the set \\(\\Phi_0\\) of atomic\nformulas into subsets of \\(W\\).\n\nInformally, the mapping \\(R\\) assigns to each atomic program\n\\(\\pi\\in\\Pi_0\\) some binary relation \\(R(\\pi)\\) on \\(W\\) with the\nintended meaning that \\(xR(\\pi)y\\) iff there exists an execution of\n\\(\\pi\\) from \\(x\\) that leads to \\(y\\), whereas the mapping \\(V\\)\nassigns to each atomic formula \\(p\\in\\Phi_0\\) some subset \\(V(p)\\) of\n\\(W\\) with the intended meaning that \\(x \\in V(p)\\) iff \\(p\\) is true\nin the state \\(x\\). Given our readings of \\(0\\), \\(\\lnot A\\), \\(A\\lor\nB\\), \\([\\alpha]A\\), \\(\\alpha;\\beta\\), \\(\\alpha\\cup\\beta\\),\n\\(\\alpha^*\\) and \\(A?\\), it is clear that \\(R\\) and \\(V\\) must be\nextended inductively as follows to supply the intended meanings for\nthe complex programs and formulas:\n\n\\(xR(\\alpha;\\beta)y\\) iff there exists a world \\(z\\) such that\n\\(xR(\\alpha)z\\) and \\(zR(\\beta)y\\)\n\\(xR(\\alpha\\cup\\beta)y\\) iff \\(xR(\\alpha)y\\) or\n\\(xR(\\beta)y\\)\n\\(xR(\\alpha^*)y\\) iff there exists a non-negative integer \\(n\\)\nand there exists a sequence of states \\(z_0, \\ldots, z_n\\) such that\n\\(z_0 = x\\), \\(z_n = y\\) and for all \\(k = 1 \\ldots n\\),\n\\(z_{k-1}R(\\alpha)z_k\\)\n\\(xR(A?)y\\) iff \\(x = y\\) and \\(y \\in V(A)\\)\n\\(V(0) = \\emptyset\\)\n\\(V(\\lnot A) = W \\setminus V(A)\\)\n\\(V((A\\lor B) = V(A) \\cup V(B)\\)\n\\(V([\\alpha]A) = \\{x \\mid \\text{for all worlds } y, \\text{ if }\nxR(\\alpha)y \\text{ then } y \\in V(A)\\}\\)\n\n\nIf \\(x \\in V(A)\\) then we say that \\(A\\) is satisfied at state \\(x\\)\nin \\(M\\), or \\(\\ldquo M, x\\) sat \\(A\\rdquo\\).\n\n\n\n\n\n\n\n\nTwo Labeled Transition Systems: \\(M = (W,R,V)\\) (left) and \\(M' =\n(W',R',V')\\) (right)\n\n\nCall \\(M\\) the LTS depicted above on the left and \\(M'\\) the LTS\ndepicted on the right. Defined formally, we have \\(M = (W, R, V)\\)\nwith \\(W = \\{x_1,x_2\\}\\), \\(R(\\pi_1) = \\{(x_1,x_1)\\}\\), \\(R(\\pi_2) =\n\\{(x_1,x_2)\\}\\), \\(V(p) = \\{x_1\\}\\), \\(V(q) = \\{x_2\\}\\), and we have\n\\(M' = (W',R',V')\\) with \\(W' = \\{y_1, y_2, y_3, y_4\\}\\), \\(R'(\\pi_1)\n= \\{(y_1, y_2), (y_2, y_2)\\}\\), \\(R'(\\pi_2) = \\{(y_1, y_3), (y_2,\ny_4)\\}\\), \\(V'(p) = \\{y_1, y_2\\}\\), \\(V'(q) = \\{y_3, y_4\\}\\). We have\nfor instance:\n\n\\(M,x_1\\) sat \\(p\\)\n\\(M,x_2\\) sat \\(q\\)\n\\(M,x_1\\) sat \\(\\langle \\pi_1 \\rangle p \\land \\langle \\pi_2\n\\rangle q\\)\n\\(M,x_1\\) sat \\([\\pi_1]p \\land [\\pi^*_1]p\\)\n\\(M',y_1\\) sat \\(\\langle \\pi^*_1;\\pi_2\\rangle q\\)\n\\(M',y_2\\) sat \\([\\pi^*_1] p\\)\n\\(M',y_1\\) sat \\([\\pi_1 \\cup \\pi_2] (p \\lor q)\\)\n\\(M',y_3\\) sat \\([\\pi_1 \\cup \\pi_2] 0\\)\n\n\nNow consider a formula \\(A\\). We say that \\(A\\) is valid in \\(M\\) or\nthat \\(M\\) is a model of \\(A\\), or \u201c\\(M \\models A\\)\u201d, iff\nfor all worlds \\(x\\), \\(x \\in V(A)\\). \\(A\\) is said to be valid, or\n\u201c\\(\\models A\\)\u201d, iff for all models \\(M\\), \\(M \\models\nA\\). We say that \\(A\\) is satisfiable in \\(M\\) or that \\(M\\) satisfies\n\\(A\\), or \u201c\\(M\\) sat \\(A\\)\u201d, iff there exists a world\n\\(x\\) such that \\(x \\in V(A)\\). \\(A\\) is said to be satisfiable, or\n\u201csat \\(A\\)\u201d, iff there exists a model \\(M\\) such that\n\\(M\\) sat \\(A\\). It is notably the case that,\n\nsat \\(A\\) iff not \\(\\models \\lnot A\\)\n\n\\(\\models A\\) iff not sat \\(\\lnot A\\) \n\nSome remarkable formulas of PDL are valid. (The reader may try to\nprove them formally, or at least start convincing themselves on the\nfew examples displayed above.)\n\n\\(\\models [\\alpha ; \\beta]A \\leftrightarrow [\\alpha][\\beta]A\\)\n\n\\(\\models [\\alpha \\cup \\beta]A \\leftrightarrow [\\alpha]A \\land\n[\\beta]A\\)\n\n\\(\\models [\\alpha^*]A \\leftrightarrow A \\land [\\alpha][\\alpha^*]A\\)\n\n\\([A?]B \\leftrightarrow (A \\rightarrow B)\\) \n\nEquivalently, we can write them under their dual form.\n\n\\(\\langle\\alpha ; \\beta\\rangle A \\leftrightarrow\n\\langle\\alpha\\rangle\\langle\\beta\\rangle A\\)\n\n\\(\\langle\\alpha \\cup \\beta\\rangle A \\leftrightarrow\n\\langle\\alpha\\rangle A \\lor \\langle\\beta\\rangle A\\)\n\n\\(\\langle\\alpha^*\\rangle A \\leftrightarrow A \\lor \\langle\\alpha\\rangle\n\\langle\\alpha^*\\rangle A\\)\n\n\\(\\langle A?\\rangle B \\leftrightarrow A \\land B\\) \n\nOne interesting notion concerns the information, expressed with PDL\nformulas, that is contained in an LTS. The behavior of a system\ndescribed as an LTS is indeed often slightly hidden in its form. For\ninstance, on simple inspection, it is easy to convince oneself that\nthe two LTSs depicted above have the same behavior, and satisfy the\nsame PDL formulas. To finish this section on syntax and semantics we\ngive the theoretical foundation of these claims.\n\nGiven two LTSs, one may ask whether they satisfy the same formulas.\nThe notion of bisimulation has become the standard measure for\nequivalence of Kripke models and Labeled Transition Systems. A\nbisimulation between the LTSs \\(M = (W,R,V)\\) and \\(M' =\n(W',R',V')\\) is a binary relation \\(Z\\) between their set of states\nsuch that for all worlds \\(x\\) in \\(W\\) and for all worlds \\(x'\\) in\n\\(W'\\), if \\(xZx'\\) then,\n\nfor all atomic formulas \\(p\\in \\Phi_0\\), we have \\(x\\in V(p)\\) iff\n\\(x' \\in V'(p)\\),\nfor all atomic programs \\(\\pi \\in \\Pi_0\\) and for all worlds \\(y\n\\in W\\), we have that if \\(x R(\\pi)y\\) then there exists a world \\(y'\n\\in W'\\) such that \\(yZy'\\) and \\(x' R'(\\pi)y'\\),\nfor all atomic programs \\(\\pi \\in \\Pi_0\\) and for all worlds \\(y'\n\\in W'\\), we have that if \\(x' R'(\\pi)y'\\) then there exists a world\n\\(y \\in W\\) such that \\(yZy'\\) and \\(x R(\\pi)y\\).\n\n\nWe say that two LTSs are bisimilar when there exists a\nbisimulation between them.\n\nIt is the case that in two bisimilar LTSs \\(M = (W,R,V)\\) and \\(M' =\n(W',R',V')\\), for all worlds \\(x\\) in \\(W\\) and for all worlds \\(x'\\)\nin \\(W'\\), if \\(xZx'\\) then for all PDL formulas \\(A\\), \\(x \\in V(A)\\)\niff \\(x' \\in V'(A)\\). Thus when two LTSs are bisimilar under the\ndefinition of bisimulation above, it is the case that, if \\(xZx'\\)\nthen\n\nfor all programs \\(\\alpha\\) and for all worlds \\(y \\in W\\), we\nhave that if \\(x R(\\alpha)y\\) then there exists a world \\(y' \\in W'\\)\nsuch that \\(yZy'\\) and \\(x' R'(\\alpha)y'\\),\nfor all programs \\(\\alpha\\) and for all worlds \\(y' \\in W'\\), we\nhave that if \\(x' R'(\\alpha)y'\\) then there exists a world \\(y \\in W\\)\nsuch that \\(yZy'\\) and \\(x R(\\alpha)y\\).\n\n\nHence one can simply compare the behaviors of two LTSs by inspecting\nsolely the atomic programs and safely extrapolate on the comparative\nbehavior of these LTSs even for complex programs. We say that the\nprogram constructs of PDL are safe for bisimulation. See Van\nBenthem [1998] for precise characterizations of program constructs\nthat are safe for bisimulation.\n\nIt is readily seen that the two instances of LTSs above are bisimilar.\nA bisimulation \\(Z\\) between the two models \\(M\\) and \\(M'\\) depicted\nin the figures above can be given as: \\(Z = \\{(x_1,y_1), (x_1,y_2),\n(x_2, y_3), (x_2, y_4)\\}\\). The states \\(x_1\\) and \\(y_1\\) satisfy\nexactly the same PDL formulas. So do the states \\(x_1\\) and \\(y_2\\),\netc.\n2.2 Axiomatization and completeness\n\nThe purpose of the proof theory is to provide the characterization of\nvalidity\u2014the property \\(\\models A\\)\u2014in terms of axioms and\nrules of inference. In this section, we define a deducibility\npredicate \\(\\vdash\\) inductively by operations on formulas that depend\nonly on their syntactic structure in such a way that for all formulas\n\\(A\\),\n\n\\(\\vdash A\\) iff \\(\\models A\\). \n\nOf course, PDL is an extension of classical propositional logic. We\nfirst expect that all propositional tautologies hold, and all\npropositional reasoning is allowed. In particular, modus ponens is a\nvalid rule: from \\(A\\) and \\(A \\rightarrow B\\) infer \\(B\\). For any\nprogram \\(\\alpha\\), restricting an LTS to the relation \\(R(\\alpha)\\)\nwe obtain a Kripke model in which the logic of the modality\n\\([\\alpha]\\) is the weakest propositional normal modal logic, namely,\nthe logic K. Thus, PDL contains every instance of the familiar\ndistribution axiom schema\n\n(K)\n\\([\\alpha](A \\rightarrow B) \\rightarrow ([\\alpha]A \\rightarrow\n[\\alpha]B)\\)\n\n\nand it is closed under the following rule of inference\n(necessitation rule)\n\n(N)\nfrom \\(A\\) infer \\([\\alpha]A\\)\n\n\nA modal logic is normal if it obeys (K) and (N). An important property\nof normal modal logics is the distributivity over the\nconjunction \\(\\land\\): the formula \\([\\alpha](A \\land B)\n\\leftrightarrow ([\\alpha]A \\land [\\alpha]B)\\) can be proven using (K),\n(N), and propositional reasoning. The rule of monotony can\nalso be proven using (K), (N), and propositional reasoning: from \\(A\n\\rightarrow B\\) infer \\([\\alpha]A \\rightarrow [\\alpha]B\\).\n\nPDL is the least normal modal logic containing every instance of the\nfollowing axiom schemas\n\n(A1)\n\\([\\alpha;\\beta]A \\leftrightarrow [\\alpha][\\beta]A\\)\n(A2)\n\\([\\alpha \\cup \\beta]A \\leftrightarrow [\\alpha]A \\land\n[\\beta]A\\)\n(A3)\n\\([\\alpha^*]A \\leftrightarrow A \\land [\\alpha][\\alpha^*]A\\)\n(A4)\n\\([A?]B \\leftrightarrow (A \\rightarrow B)\\)\n\n\nand closed under the following rule of inference (loop\ninvariance rule):\n\n(I)\nfrom \\(A \\rightarrow [\\alpha]A\\) infer \\(A \\rightarrow\n[\\alpha^*]A\\)\n\n\nIf \\(X\\) is a set of formulas and \\(A\\) is a formula then we say that\n\\(A\\) is \\(\\vdash\\)-deducible from \\(X\\), or \u201c\\(X \\vdash\nA\\)\u201d, if there exists a sequence \\(A_0, A_1, \\ldots A_n\\) of\nformulas such that \\(A_n = A\\) and for all \\(i \\leq n\\), \\(A_i\\) is an\ninstance of an axiom schema, or a formula of \\(X\\), or comes from\nearlier formulas of the sequence by a rule of inference. Further,\n\\(\\vdash A\\) iff \\(\\emptyset \\vdash A\\); in this case we say that\n\\(A\\) is \\(\\vdash\\)-deducible. \\(X\\) is said to be\n\\(\\vdash\\)-consistent iff not \\(X \\vdash 0\\). It is easy to establish\nthat the rule (I) can be replaced by the following axiom schema\n(induction axiom schema):\n\n(A5)\n\\(A \\land [\\alpha^*](A \\rightarrow [\\alpha]A) \\rightarrow\n[\\alpha^*]A\\)\n\n\nLet us first establish that (I) is a derived rule of the proof system\nbased on (A1), (A2), (A3), (A4) and (A5):\n\n\n\n1.\n\\(A \\rightarrow [\\alpha]A\\)\npremise \n\n2.\n\\([\\alpha^*](A \\rightarrow [\\alpha]A)\\)\nfrom 1 using (N) \n\n3.\n\\(A \\land [\\alpha^*](A \\rightarrow [\\alpha]A) \\rightarrow\n[\\alpha^*]A\\)\naxiom schema (A5) \n\n4.\n\\([\\alpha^*](A \\rightarrow [\\alpha]A) \\rightarrow (A \\rightarrow\n[\\alpha^*]A)\\)\nfrom 3 using propositional reasoning \n\n5.\n\\(A \\rightarrow [\\alpha^*]A\\)\nfrom 2 and 4 using modus ponens  \n\n\nLet us next establish that (A5) is \\(\\vdash\\)-deducible:\n\n\n\n1.\n\\([\\alpha^*](A \\rightarrow [\\alpha]A)\\ \\leftrightarrow\\ \\) \\((A\n\\rightarrow [\\alpha]A) \\land [\\alpha][\\alpha^*](A \\rightarrow\n[\\alpha]A)\\)\naxiom schema (A3) \n\n2.\n\\(A \\land [\\alpha^*](A \\rightarrow [\\alpha]A)\\ \\rightarrow\\ \\)\n\\([\\alpha](A \\land [\\alpha^*](A \\rightarrow [\\alpha]A))\\)\nfrom 1 using propositional reasoning and distributivity of\n\\([\\alpha]\\) over \\(\\land\\) \n\n3.\n\\(A \\land [\\alpha^*](A \\rightarrow [\\alpha]A)\\ \\rightarrow\\ \\)\n\\([\\alpha^*](A \\land [\\alpha^*](A \\rightarrow [\\alpha]A))\\)\nfrom 2 using (I) \n\n4.\n\\([\\alpha^*](A \\rightarrow [\\alpha]A) \\rightarrow (A \\rightarrow\n[\\alpha^*]A)\\)\nfrom 3 using propositional reasoning and distributivity of\n\\([\\alpha^*]\\) over \\(\\land\\) \n\n5.\n\\(A \\land [\\alpha^*](A \\rightarrow [\\alpha]A) \\rightarrow\n[\\alpha^*]A\\)\nfrom 4 using propositional reasoning  \n\n\nThe axiomatization of PDL based on axiom schemas (A1), (A2), (A3),\n(A4) and (A5) has been proposed in Segerberg [1977]. It is immediate\nfrom the definitions above that \\(\\vdash\\) is sound with respect to\n\\(\\models\\), i.e.,\n\nfor all formulas \\(A\\), if \\(\\vdash A\\), then \\(\\models A\\). \n\nThe proof proceeds by induction on the length of \\(A\\)\u2019s\ndeduction in \\(\\vdash\\). The question of the completeness of\n\\(\\vdash\\) with respect to \\(\\models\\), i.e.,\n\nfor all formulas \\(A\\), if \\(\\models A\\), then \\(\\vdash A\\), \n\nwas pursued by several logicians. The line of reasoning presented in\nSegerberg [1977] was the first attempt to prove the completeness of\n\\(\\vdash\\). Soon, Parikh came up with a proof, too. When early 1978\nSegerberg found a flaw in his argument (which he repaired eventually),\nParikh published what can be considered the first proof of the\ncompleteness of \\(\\vdash\\) in Parikh [1978]. Different proofs of\ncompleteness of \\(\\vdash\\) have been published since, e.g. Kozen and\nParikh [1981]. More details can be found in Pratt [2017].\n\nDifferent alternative proof theories of PDL have also been sought\nafter. Even early on, notably in Pratt [1978]. Let us then also\nmention the completeness of related theories by Nishimura [1979] and\nVakarelov [1983].\n\nAn alternative formulation of a deducibility predicate for PDL\nexploits an infinitary rule of inference, as for instance in Goldblatt\n[1992a]. (An infinitary rule of inference takes an infinite number of\npremises.) Let \\(\\vdash'\\) be the deducibility predicate corresponding\nin the language of propositional dynamic logic to the least normal\nmodal logic containing every instance of the axiom schemas (A1), (A2),\n(A3) and (A4) and closed under the following infinitary rule of\ninference:\n\n(I\u2032)\nfrom \\(\\{[\\beta][\\alpha^n]A : n\\geq 0\\}\\) infer\n\\([\\beta][\\alpha^*]A\\)\n\n\nIt can be proved that \\(\\vdash'\\) is both sound and complete with\nrespect \\(\\models\\), i.e.,\n\nfor all formulas \\(A\\), \\(\\vdash' A\\) iff \\(\\models A\\). \n\nIn other words, as far as generating the set of all valid formulas is\nconcerned, the proof systems \\(\\vdash\\) and \\(\\vdash'\\) are\nequivalent.\n2.3 Decidability and complexity\n\nThe aim of the complexity theory is to establish the computability of\nthe property sat \\(A\\) in terms of resources of time or space. The\ncomplexity of a logic \\(\\mathcal{L}\\) is often identified with the\nproblem of deciding the satisfiability of its formulas, defined\nas:\n\n(L-SAT)\nGiven a formula \\(A\\) of \\(\\mathcal{L}\\), is \\(A\\)\nsatisfiable?\n\n\nIn this section, we investigate the complexity of the following\ndecision problem:\n\n(PDL-SAT)\nGiven a formula \\(A\\) of PDL, is \\(A\\) satisfiable?\n\n\nThe complete axiomatization of PDL is a recursive definition of the\nset of valid PDL formulas, or in other words, of the set of formulas\nwhose negation is not satisfiable. Hence, concerning the problem\n(PDL-SAT), we have a sub-procedure that would answer \u201cno\u201d\nif the PDL formula \\(A\\) were not satisfiable. The sub-procedure (SP1)\nconsists in enumerating all the formulas \\(\\vdash\\)-deducible,\nstarting from the axioms and inferring other theorems with the help of\nthe inference rules. Given enough time, if a formula is\n\\(\\vdash\\)-deducible, the sub-procedure would find it eventually.\nThus, if \\(A\\) is not satisfiable, (SP1) must eventually find \\(\\lnot\nA\\), and answer \u201cno\u201d when it does.\n\nHowever, if the formula \\(A\\) is satisfiable, then (SP1) would never\nfind \\(\\lnot A\\). It would run forever, and one could not be sure\nabout it at any time. But there is a way out of this uncertainty. We\ncan also think of a second sub-procedure that answers\n\u201cyes\u201d if a PDL formula is satisfiable. Indeed, one of the\nearliest results on PDL was the proof that PDL has the finite\nmodel property, i.e.,\n\nFor all formulas \\(A\\), if sat \\(A\\) then there exists a finite model\n\\(M\\) such that \\(M\\) sat \\(A\\). \n\nThe finite model property offers a basis for a sub-procedure (SP2)\nthat consists in enumerating one by one the finite models of PDL and\ntesting whether one of them satisfies the formula. (For all formulas\n\\(A\\) and for all finite models \\(M\\), it is easy to test if \\(M\\) sat\n\\(A\\) by applying the definition of \\(V(A)\\).) Thus, if \\(A\\) is\nsatisfiable, it must eventually find a model \\(M\\) such that \\(M\\) sat\n\\(A\\), and answer \u201cyes\u201d when it does. Symmetrically to the\nfirst sub-procedure (SP1), if the formula \\(A\\) is not satisfiable,\nthen (SP2) will never find a model satisfying it, it will run forever,\nand one could not be sure about it at any time.\n\nNow, combining (SP1) and (SP2) together we have a way of deciding\nwhether a PDL formula \\(A\\) is satisfiable. It suffices to run them in\nparallel: if \\(A\\) is satisfiable then (SP2) will eventually answer\n\u201cyes\u201d, if \\(A\\) is not satisfiable then (SP1) will\neventually answer \u201cno\u201d. The procedure halts when either\n(SP1) or (SP2) provides an answer.\n\nIf the procedure that is obtained is sufficient to conclude that the\nproblem (PDL-SAT) is decidable, it is very inefficient in practice.\nThere is a result\u2014due to Fischer and Ladner [1979] and Kozen and\nParikh [1981]\u2014 stronger than the finite model property, that is\nsmall model property:\n\nFor all formulas \\(A\\), if sat \\(A\\) then there exists a finite model\n\\(M\\) of size exponential in \\(A\\) such that \\(M\\) sat \\(A\\). \n\nThis means that we would now know when to stop looking for a model\nsatisfying a formula in the procedure (SP2). Hence, we can use (SP2)\nto test whether a formula is satisfiable, but once we have exhausted\nall small models, we can conclude that the formula is not satisfiable.\nThis yields a procedure that runs non-deterministically in exponential\ntime (NEXPTIME): guess a model of size at most singly exponential, and\ncheck whether it satisfies the formula. But the key results in the\ncomplexity theory of PDL come from Fischer and Ladner [1979] and Pratt\n[1980a]. Observing that a formula of PDL can efficiently describe the\ncomputation of a linear space bounded alternating Turing machine,\nFischer and Ladner [1979] first established the lower bound of\nexponential time of (PDL-SAT). The EXPTIME upper bound of (PDL-SAT)\nhas been obtained by Pratt [1980a], who adapted the method of semantic\ntableaux to PDL. Thus, (PDL-SAT) is EXPTIME-complete. (An algorithm\nmore efficient in practice, although still running in deterministic\nexponential time in the worst case, is proposed in De Giacomo and\nMassacci [2000].)\n3. Structured programming and correctness of programs\n\nHistorically, logics of programs stem from the work in the late 1960s\nof computer scientists interested in assigning meaning to programming\nlanguages and finding a rigorous standard for proofs about the\nprograms. For example such proofs may be about the correctness of a\nprogram with respect to an expected behavior, or about the termination\nof a program. A seminal paper is Floyd [1967] which presents an\nanalysis of the properties of structured computer programs using\nflowcharts. Some early work such as Yanov [1959] or Engeler\n[1967] had advanced and studied formal languages in which the\nproperties of program connectives can be expressed. The formalism of\nHoare [1969] was a milestone in the advent of PDL. It was proposed as\na rigorous axiomatic interpretation of Floyd\u2019s flowcharts. We\noften talk about Hoare logic, or Floyd-Hoare logic, or Hoare calculus\nwhen referring to this formalism. Hoare calculus is concerned with the\ntruth of statements (\u201cHoare triples\u201d), such as\n\\(\\{A\\}\\alpha\\{B\\}\\) which establishes a connection between a\nprecondition \\(A\\), a program \\(\\alpha\\), and a post-condition \\(B\\).\nIt indicates that whenever \\(A\\) holds as a precondition of the\nexecution of \\(\\alpha\\), then \\(B\\) holds as a post-condition after\nthe successful execution of \\(\\alpha\\).\n\nIt was true some decades ago, and it is still the case: validating a\nprogram is more often than not done by testing it on a reasonable\nvariety of inputs. When an input does not yield the expected output,\nthe \u201cbug\u201d is fixed. If eventually for every tested input\nwe obtain the expected output, one has a reasonable belief that the\nprogram has no error. However, this is a time consuming method of\nvalidation, and it leaves place for untested inputs that could fail.\nFinding these errors after the program has been implemented and gone\ninto use is even more costly in resources. Reasoning about program\ncorrectness with formal methods is crucial for critical systems since\nit offers a way of proving exhaustively that a program has no\nerrors.\n3.1 Hoare calculus\n\nTo illustrate the sort of principles of programs captured by the rules\nin the Hoare calculus it is enough to consult some of them. (N.B.: the\nrules mean that if all the statements above the rule line\nhold\u2014the premises\u2014then also the statement under the rule\nline\u2014the conclusion\u2014 holds.) \n\\[\n\\frac{\\{A\\}\\alpha_1 \\{B\\}\\quad\\{B\\} \\alpha_2\\{C\\}}\n    {\\{A\\} \\alpha_1;\\alpha_2\\{C\\}}\n\\text{ (rule of composition)}\n\\]\n\n\nThe rule of composition captures the elementary sequential composition\nof programs. As premises, we have two assumptions about the partial\ncorrectness of two programs \\(\\alpha_1\\) and \\(\\alpha_2\\). The first\nassumption is that when \\(\\alpha_1\\) is executed in a state satisfying\n\\(A\\), then it will finish in a state satisfying \\(B\\), whenever it\nhalts. The second assumption is that when \\(\\alpha_2\\) is executed in\na state satisfying \\(B\\), then it will finish in a state satisfying\n\\(C\\), whenever it halts. The conclusion of the rule is about the\npartial correctness of the program \\(\\alpha_1;\\alpha_2\\) (i.e.,\n\\(\\alpha_1\\) sequentially composed with \\(\\alpha_2\\)), that follows\nfrom the two assumptions. Namely, we can conclude that if\n\\(\\alpha_1;\\alpha_2\\) is executed in a state satisfying \\(A\\), then it\nfinishes in a state satisfying \\(C\\), whenever it halts.\n\nThe rule of iteration is an important one because it captures the\nessential ability of programs to execute some portion of code\nrepeatedly until a certain condition ceases to hold. \n\\[\n\\frac{\\{A \\land B\\}\\alpha\\{A\\}}\n     {\\{A\\} \\mathsf{while}~B~\\mathsf{do}~\\alpha \\{\\lnot B \\land A\\}}\n \\text{ (rule of iteration)}\n\\]\n\n\nFinally, the two rules of consequence are fundamental to give a formal\nbasis to intuitively clear reasoning involving weaker post-conditions\nand stronger preconditions respectively. \n\\[\n\\frac{\\{A\\}\\alpha\\{B\\}\\quad B \\rightarrow C}\n     {\\{A\\} \\alpha \\{C\\}}\n \\text{ (rule of consequence 1)}\n\\]\n \n\\[\n\\frac{C\\rightarrow A\\quad \\{A\\}\\alpha\\{B\\}}\n     {\\{C\\}\\alpha\\{B\\}}\n \\text{ (rule of consequence 2)}\n\\]\n\n\nFrom the formalism presented in Hoare [1969], we leave out its axiom\nschemas as it would require a first-order language. Finally, in\nsubsequent work on Hoare logic, more rules are also often added. See\nApt [1979] for an early overview.\n3.2 Hoare calculus and PDL\n\nDynamic logics come from Pratt\u2019s interpretation of Hoare triples\nand Hoare calculus in the formalism of modal logic. With the modality\n\\([\\alpha]\\), we can express formally that all states reachable by\nexecuting the program \\(\\alpha\\) satisfy the formula \\(A\\). This is\ndone by writing \\([\\alpha]A\\). Thus, the Hoare triple\n\\(\\{A\\}\\alpha\\{B\\}\\) is simply captured by the PDL formula\n\n\\(A \\rightarrow [\\alpha]B\\). \n\nIn addition, important programming constructs are easily introduced in\nPDL by definitional abbreviation:\n\n\\(\\mathsf{if}~ A ~\\mathsf{then}~ \\alpha ~\\mathsf{else}~ \\beta :=\n((A?;\\alpha) \\cup (\\lnot A?;\\beta))\\)\n\\(\\mathsf{while}~ A ~\\mathsf{do}~ \\alpha := ((A?;\\alpha)^*;\\lnot\nA?)\\)\n\\(\\mathsf{repeat}~ \\alpha ~\\mathsf{until}~ A := (\\alpha;((\\lnot\nA;\\alpha)^*;A?))\\)\n\\(\\mathsf{abort} := 0?\\)\n\\(\\mathsf{skip} := 1?\\)\n\n\nThus, it seems that with PDL we are well-equipped to logically prove\nthe correctness of structured programs. Beyond this rather hand-waving\nconnection between PDL and Hoare calculus, perhaps it is not yet clear\nhow they relate formally. PDL is in fact a generalization of Hoare\ncalculus in the sense that all the rules of the Hoare calculus can be\nproven in the axiomatic system of PDL. (Rigorously, the Hoare calculus\ncontains axioms that would require the extended language of\nfirst-order Dynamic Logic.) This is quite remarkable, so we will show\nhow they can be derived.\n\nThe proofs start by assuming the premises of the rules. Then by using\nthese assumptions, axioms and rules of PDL, and nothing else, the\nobjective is to establish that the conclusion of the rules logically\nfollows. Hence, for the rule of composition, we start by assuming\n\\(\\{A\\}\\alpha_1\\{B\\}\\), that is \\(A \\rightarrow [\\alpha_1]B\\) in its\nPDL formulation, and by assuming \\(\\{B\\}\\alpha_2\\{C\\}\\), that is \\(B\n\\rightarrow [\\alpha_2]C\\). The objective is to prove that\n\\(\\{A\\}\\alpha_1;\\alpha_2\\{C\\}\\). Precisely, we want to establish that\n\\(A \\rightarrow [\\alpha_1;\\alpha_2]C\\) is \\(\\vdash\\)-deducible from\nthe set of formulas \\(\\{A \\rightarrow [\\alpha_1]B, B \\rightarrow\n[\\alpha_2]C\\}\\).\n\n\n\n1.\n\\(A \\rightarrow [\\alpha_1]B\\)\nassumption \\(\\{A\\}\\alpha_1\\{B\\}\\) \n\n2.\n\\(B \\rightarrow [\\alpha_2]C\\)\nassumption \\(\\{B\\}\\alpha_2\\{C\\}\\) \n\n3.\n\\([\\alpha_1]B \\rightarrow [\\alpha_1][\\alpha_2]C\\)\nfrom 2 using monotony of \\([\\alpha_1]\\) \n\n4.\n\\(A \\rightarrow [\\alpha_1][\\alpha_2]C\\)\nfrom 1 and 3 using propositional reasoning \n\n5.\n\\([\\alpha_1;\\alpha_2]C \\leftrightarrow\n[\\alpha_1][\\alpha_2]C\\)\naxiom schema (A1) \n\n6.\n\\(A \\rightarrow [\\alpha_1;\\alpha_2]C\\)\nfrom 4 and 5 using propositional reasoning \n\n\u2014\n\\(\\{A\\}\\alpha_1;\\alpha_2\\{C\\}\\)\n   \n\n\nThe proof of the rule of iteration is slightly more involved.\n\n\n\n1.\n\\(A\\land B \\rightarrow [\\alpha ]A\\)\nassumption \\(\\{A \\land B\\}\\alpha \\{A\\}\\)\n\n\n2.\n\\(A \\rightarrow (B \\rightarrow [\\alpha ]A)\\)\nfrom 1 using propositional reasoning \n\n3.\n\\([B?][\\alpha ]A \\leftrightarrow (B \\rightarrow [\\alpha\n]A)\\)\naxiom schema (A4) \n\n4.\n\\(A \\rightarrow [B?][\\alpha ]A\\)\nfrom 2 and 3 using propositional reasoning \n\n5.\n\\([B? ; \\alpha ]A \\leftrightarrow [B?][\\alpha ]A\\)\naxiom schema (A1) \n\n6.\n\\(A \\rightarrow [B?;\\alpha ]A\\)\nfrom 4 and 5 using propositional reasoning \n\n7.\n\\(A \\rightarrow [(B?;\\alpha )^*]A\\)\nfrom 6 using (I) \n\n8.\n\\(A \\rightarrow (\\lnot B \\rightarrow (\\lnot B\\land A))\\)\npropositional tautology \n\n9.\n\\(A \\rightarrow [(B?;\\alpha )^*](\\lnot B \\rightarrow (\\lnot\nB\\land A))\\)\nfrom 7 and 8 using monotony of \\([(B?;\\alpha )^*]\\) and\npropositional reasoning \n\n10.\n\\([\\lnot B?](\\lnot B\\land A)\\ \\leftrightarrow\\ \\) \\((\\lnot B\n\\rightarrow (\\lnot B\\land A))\\)\naxiom schema (A4) \n\n11.\n\\(A \\rightarrow [(B?;\\alpha )^*][\\lnot B?](\\lnot B\\land\nA)\\)\nfrom 9 and 10 using monotony of \\([(B?;\\alpha )^*]\\) and\npropositional reasoning \n\n12.\n\\([(B?;\\alpha )^* ; \\lnot B?](\\lnot B\\land A)\\ \\leftrightarrow\\\n\\) \\([(B?;\\alpha )^*][\\lnot B?](\\lnot B\\land A)\\)\naxiom schema (A1) \n\n13.\n\\(A \\rightarrow [(B?;\\alpha )^* ; \\lnot B?](\\lnot B\\land\nA)\\)\nfrom 12 using propositional reasoning \n\n\u2014\n\\(\\{A\\}\\mathsf{while}~ B ~\\mathsf{do}~ \\alpha \\{\\lnot B\\land\nA\\}\\)\n   \n\n\nIn the context of PDL, the two rules of consequence are in fact\nspecial cases of the rule of composition. To obtain the first rule,\nsubstitute \\(\\alpha_1\\) with \\(\\alpha\\) and \\(\\alpha_2\\) with\n\\(\\mathsf{skip}\\). To obtain the second rule, substitute \\(\\alpha_1\\)\nwith \\(\\mathsf{skip}\\) and \\(\\alpha_2\\) with \\(\\alpha\\). It suffices\nto apply the axiom schema (A4), and to remark that\n\\([\\alpha;\\mathsf{skip}]A \\leftrightarrow [\\alpha]A\\) and\n\\([\\mathsf{skip};\\alpha]A \\leftrightarrow [\\alpha]A\\) are also\n\\(\\vdash\\)-deducible for all \\(A\\) and all \\(\\alpha\\).\n3.3 Total correctness\n\nBy Hoare\u2019s own admission in Hoare [1979], his original calculus\nwas merely a starting point and suffered quite a few limitations.\nParticularly, it only allows one to reason about partial\ncorrectness. That is, the truth of a statement \\(\\{A\\}\\alpha\\{B\\}\\)\nonly makes sure that all executions of \\(\\alpha\\) starting in a state\nsatisfying \\(A\\) will end in a state satisfying \\(B\\), or will not\nhalt. That is, a partially correct program may have\nnon-terminating executions. (In fact, a program that has no\nterminating execution will always be partially correct. This is the\ncase for example of the program \\(\\mathsf{while}~ 1 ~\\mathsf{do}~\n\\mathsf{skip}\\). The formula \\(A \\rightarrow [\\mathsf{while}~1\n~\\mathsf{do} ~\\mathsf{skip}] B\\) is deducible for all formulas \\(A\\)\nand \\(B\\).) The calculus offers no basis for a proof that a program\nterminates. It can be modified so as to account for total\ncorrectness of programs: partial correctness plus termination. It is\nachieved by amending the rule of iteration. We do not present it here\nand refer the interested reader to Apt [1981].\n\nLet us first observe that for deterministic programs, one can\nalready capture total correctness via formulas of the kind\n\n\\(A \\rightarrow \\langle\\alpha\\rangle B\\). \n\nThe expression \\(\\langle\\alpha\\rangle B\\) means that there is an\nexecution of \\(\\alpha\\) that terminates in a state that satisfies\n\\(B\\). Moreover, if \\(\\alpha\\) is deterministic, this possible\nterminating execution is the unique execution of \\(\\alpha\\). Thus, if\none first manages to prove that a program is deterministic, this trick\nworks well enough to prove its total correctness.\n\nA general solution to the problem of total correctness exists in the\nrealm of PDL. But we need to extend it a little. Pratt had already\nalluded in Pratt [1980b] that PDL is not expressive enough to capture\nthe infinite looping of programs. In reaction, PDL with repeating\n(RPDL) was introduced by Streett [1982]. It contains, for all programs\n\\(\\alpha\\), the expression \\(\\Delta\\alpha\\) standing for a new\nproposition with semantics:\n\n\n\\(V(\\Delta\\alpha) = \\{x: \\) there exists an infinite sequence\n\\(z_0, z_1, \\ldots\\) of states such that \\(z_0 = x\\) and for all \\(n\n\\geq 0, z_n R(\\alpha) z_{n+1}\\}\\).\n\n\n\nStreett [1982] conjectured that RPDL can be axiomatized by adding to\nthe proof system of PDL precisely the following axiom schemas.\n\n(A6)\n\\(\\Delta\\alpha \\rightarrow \\langle\\alpha\\rangle\n\\Delta\\alpha\\)\n(A7)\n\\([\\alpha^*](A \\rightarrow \\langle\\alpha\\rangle A) \\rightarrow (A\n\\rightarrow \\Delta\\alpha)\\)\n\n\nThe proof of the conjecture was provided in Sakalauskaite and Valiev\n[1990]. (A version of the conjecture in the variant of combinatory PDL\nwas also proved in Gargov and Passy [1988].)\n\nIt is easy to see that in the Hoare calculus presented above, non\ntermination can only come from the rule of iteration. Analogously, non\ntermination of a PDL program can only come from the use of the\nunbounded iteration. The expression \\(\\Delta\\alpha\\) indicates that\n\\(\\alpha^*\\) can diverge, and this is just the kind of notion we need.\nWe can now inductively define a predicate \\(\\infty\\) such that for a\nprogram \\(\\alpha\\), the formula \\(\\infty(\\alpha)\\) will be true\nexactly when \\(\\alpha\\) can enter a non-terminating computation.\n\n\\(\\infty(\\pi) := 0\\) where \\(\\pi\\in\\Pi_0\\)\n\n\\(\\infty(A?) := 0\\)\n\n\\(\\infty(\\alpha \\cup \\beta) := \\infty(\\alpha)\\ \\lor \\infty(\\beta)\\)\n\n\\(\\infty(\\alpha ; \\beta) := \\infty(\\alpha) \\lor \\langle\\alpha\\rangle\n\\infty(\\beta)\\)\n\n\\(\\infty(\\alpha^*) := \\Delta\\alpha \\lor \\langle\\alpha^*\\rangle\n\\infty(\\alpha)\\) \n\nFinally, the total correctness of a program can be expressed via\nformulas of the kind\n\n\\(A \\rightarrow (\\lnot \\infty(\\alpha) \\land [\\alpha]B)\\), \n\nwhich means literally that if \\(A\\) is the case, then the program\n\\(\\alpha\\) cannot run forever, and every successful execution of\n\\(\\alpha\\) will end in a state satisfying \\(B\\).\n4. Some variants\n\nResults concerning comparative power of expression, decidability,\ncomplexity, axiomatization and completeness of a number of variants of\nPDL obtained by extending or restricting its syntax and its semantics\nconstitute the subject of a wealth of literature. We can only say so\nmuch and we will address just a few of these variants leaving out big\nchunks of otherwise important work in dynamic logic.\n4.1 PDL without tests\n\nThe axiom schema \\([A?]B \\leftrightarrow (A \\rightarrow B)\\) seems to\nindicate that for every formula \\(C\\), there exists an equivalent\ntest-free formula \\(C'\\)\u2014i.e., there is a test-free formula\n\\(C'\\) such that \\(\\models C \\leftrightarrow C'\\). It is interesting\nto observe that this assertion is untrue. Let PDL0 be the\nrestriction of PDL to test-free regular programs, i.e., programs which\ndo not contain tests. Berman and Paterson [1981] considered the PDL\nformula \\(\\langle (p?;\\pi)^*;\\lnot p?;\\pi;p?\\rangle 1\\), which is\n\n\\(\\langle \\mathsf{while}~ p~ \\mathsf{do}~ \\pi \\rangle \\langle \\pi\n\\rangle p\\), \n\nand proved that there is no PDL0 formula equivalent to it.\nHence, PDL has more expressive power than PDL0. Their\nargument actually can be generalized as follows. For all \\(n \\geq 0\\),\nlet PDLn+1 be the subset of PDL in which programs\ncan contain tests \\(A?\\) only if \\(A\\) is a PDLn\nformula. For all \\(n \\geq 0\\), Berman and Paterson considered the\nPDLn+1 formula \\(A_{n+1}\\) defined by\n\n\\(\\langle \\mathsf{while}~ A_n~ \\mathsf{do}~ \\pi_n\\rangle \\langle\n\\pi_n\\rangle A_n\\), \n\nwhere \\(A_0 = p\\) and \\(\\pi_0 = \\pi\\) and proved that for all \\(n \\geq\n0\\), there is no PDLn formula equivalent to\n\\(A_{n+1}\\). Hence, for all \\(n \\geq 0\\), PDLn+1\nhas more expressive power than PDLn.\n4.2 PDL with converse\n\nCPDL is the extension of PDL with converse. It is a construct that has\nbeen considered since the beginning of PDL. For all programs\n\\(\\alpha\\), let \\(\\alpha^{-1}\\) stand for a new program with\nsemantics\n\n\\(xR(\\alpha^{-1})y\\) iff \\(yR(\\alpha)x\\). \n\nThe converse construct allows us to express facts about states\npreceding the current one and to reason backward about programs. For\ninstance, \\([\\alpha^{-1}]A\\) means that before executing \\(\\alpha\\),\n\\(A\\) had to hold. We have\n\n\\(\\models A \\rightarrow [\\alpha]\\langle \\alpha ^{-1}\\rangle A\\)\n\n\\(\\models A \\rightarrow [\\alpha ^{-1}]\\langle \\alpha \\rangle A\\) \n\nThe addition of the converse construct does not change the\ncomputational properties of PDL in any significant way. By adding\nevery instance of the following axiom schemas\n\n(A8)\n\\(A \\rightarrow [\\alpha ]\\langle \\alpha^{-1}\\rangle A\\)\n(A9)\n\\(A \\rightarrow [\\alpha^{-1}]\\langle \\alpha \\rangle A\\)\n\n\nto the proof system of PDL, we obtain a sound and complete\ndeducibility predicate in the extended language. See Parikh [1978] for\ndetails. CPDL has the small model property and (CPDL-SAT) is\nEXPTIME-complete.\n\nIt is easy to notice that CPDL has more expressive power than PDL. To\nsee this, consider the CPDL formula \\(\\langle \\pi^{-1}\\rangle 1\\) and\nthe LTSs \\(M = (W, R, V)\\) and \\(M' = (W', R', V')\\) where \\(W =\n\\{x,y\\}\\), \\(R(\\pi) = \\{(x,y)\\}\\), \\(W' = \\{y'\\}\\), \\(R'(\\pi) =\n\\emptyset\\) and \\(V(x) = V(y) = V'(y') = \\emptyset\\). Since \\(M, y\\)\nsat \\(\\langle \\pi^{-1}\\rangle 1\\), not \\(M', y'\\) sat \\(\\langle \\pi\n^{-1}\\rangle 1\\), and because for all PDL formulas \\(A\\) it is the\ncase that \\(M, y\\) sat \\(A\\) iff \\(M', y'\\) sat \\(A\\), then it is\nclear that no PDL formula is equivalent to \\(\\langle \\pi^{-1}\\rangle\n1\\).\n4.3 PDL with repeating and looping\n\nWe have already exposed the power of repeating in\n section 3.3\n by introducing RPDL. Here, we summarize more results about RPDL and\nits connection with other variations on the notion of repeating\nprograms.\n\nConcerning the complexity theory of RPDL, Streett [1982] had already\nestablished that RPDL had the finite model property; precisely that\nevery RPDL satisfiable formula A is satisfiable in a model of\nsize at most triply exponential in the length of A. An\nautomata-theoretic argument permitted to conclude that the problem\n(RPDL-SAT) can be solved in deterministic triple exponential time\n(3-EXPTIME). The gap between this upper bound for deciding (RPDL-SAT)\nand the simple exponential-time lower bound for deciding (PDL-SAT) was\nthus open. The problem found itself greatly connected to the growing\ninterest of computer scientists in establishing the complexity of\ntemporal logics, and more specifically of the (propositional) modal\n\\(\\mu\\)-calculus (MMC) due to Kozen [1983], because RPDL has a linear\nblow-up translation to MMC. In Vardi and Stockmeyer [1985], an upper\nbound in non-deterministic exponential time was shown. In Emerson and\nJutla [1988] and in its final form in Emerson and Jutla [1999], it was\nshown that (MMC-SAT) and (RPDL-SAT) are EXPTIME-complete. If we add\nthe converse operator of\n section 4.2\n one obtains CRPDL. The complexity of (CRPDL-SAT) remained open for a\nfew years but it can be shown to be EXPTIME-complete, too. This is\nachieved by combining the techniques of Emerson and Jutla [1988] and\nVardi [1985], as in Vardi [1998].\n\nIn\n section 3.3\n we have defined a predicate \\(\\infty\\), where \\(\\infty(\\alpha)\\)\nmeans that the program \\(\\alpha\\) can have a non-terminating\ncomputation. We call LPDL the logic obtained by augmenting PDL with\nthe predicate \\(\\infty\\). Clearly, RPDL is at least as expressive as\nLPDL; The inductive definition of \\(\\infty(\\alpha)\\) in the language\nof RPDL is the witness of it. RPDL is in fact strictly more expressive\nthan LPDL. This was shown in Harel and Sherman [1982]. As it can be\nsuspected, both RPDL and LPDL have more expressive power than PDL. It\nis established by proving that some formulas of RPDL and of LPDL have\nno equivalent expression in PDL. The proof involves the technique of\nfiltration which is designed to collapse an LTS to a finite\nmodel while leaving invariant the truth or falsity of certain\nformulas. For some set of PDL formulas \\(X\\), it consists in grouping\ninto equivalence classes the states of an LTS that satisfy exactly the\nsame formulas in \\(X\\). The set of equivalence classes of states thus\nobtained becomes the set of states of the filtrate model, and a\ntransition is built appropriately over them.\n\nWith a carefully chosen set \\(FL(A)\\) that depends on a PDL formula\n\\(A\\) (the so-called Fischer-Ladner closure of the set of sub-formulas\nof \\(A\\)), a filtration of an LTS \\(M\\) yields a finite filtrate model\n\\(M'\\), such that \\(A\\) is satisfiable at a world \\(u\\) in \\(M\\) if\nand only if it is satisfiable in the equivalence class containing\n\\(u\\) in the filtrate. (See Fischer and Ladner [1979].)\n\nWe can now consider the filtration of the LTS \\(M=(W,R,V)\\) such\nthat\n\n\\(W = \\{(i,j) : j \\text{ and } i \\text{ integers}, 1 \\leq j \\leq\ni\\} \\cup \\{ u \\}\\)\n\\((i,j)R(\\pi )(i,j-1)\\) when \\(1 \\leq j \\leq i\\)\n\\(uR(\\pi )(i,i)\\) for every \\(i\\)\n\\(V(p) = \\emptyset\\) for every \\(p \\in \\Phi_0\\)\n\n\nIn one sentence, what goes on in \\(M\\) is that from the world \\(u\\),\nthere is an infinite number of finite \\(\\pi\\)-paths of growing length.\nWe have both \\(M, u\\) sat \\(\\lnot\\Delta\\pi\\) and \\(M, u\\) sat\n\\(\\lnot\\infty(\\pi^*)\\). Yet, for every PDL formula \\(A\\), we will have\nboth \\(\\Delta\\pi\\) and \\(\\infty(\\pi^*)\\) that are satisfied at the\nequivalence class of \\(u\\) in the model obtained by filtration of\n\\(M\\) with \\(FL(A)\\). Indeed, the filtration must collapse some states\nof \\(M\\) and create some loops. Thus, there exists no PDL formula that\ncan express \\(\\Delta\\pi\\) and there exists no PDL formula that can\nexpress \\(\\infty(\\pi^*)\\).\n\nThere are other ways of making possible the assertion that a program\ncan execute forever. For instance, Danecki [1984a] proposed a\npredicate \\(\\mathsf{sloop}\\) to qualify programs that can enter in\nstrong loops, that is:\n\n\\(V(\\mathsf{sloop}(\\alpha)) = \\{x: xR(\\alpha)x\\}\\). \n\nLet us call SLPDL the logic obtained by augmenting PDL with formulas\n\\(\\mathsf{sloop}(\\alpha)\\). RPDL and SLPDL are essentially\nincomparable: the predicate \\(\\Delta\\) is not definable in SLPDL, and\nthe predicate \\(\\mathsf{sloop}\\) is not definable in RPDL. SLPDL does\nnot possess the finite model property. For example, the formula\n\n\\([\\pi^*](\\langle\\pi\\rangle 1 \\land \\lnot\\mathsf{sloop}(\\pi^+))\\) \n\nis satisfiable in infinite LTSs only. Nonetheless, Danecki [1984a]\nestablished the decidability of (SLPDL-SAT) formulas in deterministic\nexponential time.\n4.4 PDL with intersection\n\nAnother construct has been studied: the intersection of programs. By\nadding intersection of programs to PDL, we obtain the logic IPDL. In\nIPDL, for all programs \\(\\alpha\\), \\(\\beta\\), the expression \\(\\alpha\n\\cap \\beta\\) stands for a new program with semantics\n\n\\(xR(\\alpha \\cap \\beta )y\\) iff \\(xR(\\alpha)y\\) and \\(xR(\\beta)y\\).\n\n\nFor instance, the intended reading of \\(\\langle \\alpha \\cap \\beta\n\\rangle A\\) is that if we execute \\(\\alpha\\) and \\(\\beta\\) in the\npresent state then there exists a state reachable by both programs\nwhich satisfies \\(A\\). As a result, we have\n\n\\(\\models \\langle \\alpha \\cap \\beta \\rangle A \\rightarrow \\langle\n\\alpha \\rangle A \\land \\langle \\beta \\rangle A\\), \n\nbut, in general, we have\n\nnot \\(\\models \\langle \\alpha \\rangle A \\land \\langle \\beta \\rangle A\n\\rightarrow \\langle \\alpha \\cap \\beta \\rangle A\\). \n\nAlthough the intersection of programs is important in various\napplications of PDL to artificial intelligence and computer science\n(e.g., in the context of concurrency), the proof theory and the\ncomplexity theory of PDL with intersection remained unexplored for\nseveral years. Concerning the complexity theory of IPDL, difficulties\nappear when one considers the finite model property. In fact the\nconstruct \\(\\mathsf{sloop}(\\alpha)\\) can be expressed in IPDL. In\npropositional dynamic logic with intersection it is equivalent to\n\\(\\langle \\alpha \\cap 1?\\rangle 1\\). We can thus adapt the formula of\nSLPDL of\n section 4.3,\n and we have that\n\n\\([\\pi^*](\\langle \\pi \\rangle 1 \\land [\\pi^+ \\cap 1?]0)\\) \n\nis satisfiable in infinite LTSs only. In other words, IPDL does not\npossess the finite model property. Danecki [1984b] investigated the\ncomplexity theory of IPDL and showed that deciding (IPDL-SAT) can be\ndone in deterministic double exponential time. (A modern proof is\npresented in G\u00f6ller, Lohrey and Lutz [2007].) The complexity gap\nbetween this double exponential-time upper bound for deciding\n(IPDL-SAT) and the simple exponential-time lower bound for deciding\n(PDL-SAT) obtained by Fischer and Ladner [1979] remained open for more\nthan twenty years. In 2004, Lange [2005] established the lower bound\nof exponential space of (IPDL-SAT). In 2006, Lange and Lutz [2005]\ngave a proof of a double exponential-time lower bound of the\nsatisfiability problem for IPDL without tests by a reduction from the\nword problem of exponentially space-bounded alternating Turing\nmachines. In this reduction, the role of the iteration construct is\nessential since, according to Massacci [2001], the satisfiability\nproblem for iteration-free IPDL without tests is only PSPACE-complete.\nAdding the converse construct to IPDL, we obtain ICPDL. The\nsatisfiability problem of ICPDL has been proved to be\n2-EXPTIME-complete by G\u00f6ller, Lohrey and Lutz [2007].\n\nConcerning the proof theory of IPDL, difficulties appear when we\nrealize that no axiom schema, in the language of PDL with\nintersection, \u201ccorresponds\u201d to the semantics \\(xR(\\alpha\n\\cap \\beta)y\\) iff \\(xR(\\alpha)y\\) and \\(xR(\\beta)y\\) of the program\n\\(\\alpha \\cap \\beta\\). That is, not in the same way for example, that\nthe axiom schemas (A1) and (A2) \u201ccorrespond\u201d to the\nsemantics of the programs \\(\\alpha;\\beta\\) and \\(\\alpha \\cup \\beta\\),\nrespectively. For this reason, the axiomatization of PDL with\nintersection was open until the complete proof system developed in\nBalbiani and Vakarelov [2003].\n\nIn another variant of PDL, due to Peleg [1987] and further studied by\nGoldblatt [1992b], the expression \\(\\alpha \\cap \\beta\\) is interpreted\n\u201cdo \\(\\alpha\\) and \\(\\beta\\) in parallel\u201d. In this\ncontext, the binary relations \\(R(\\alpha)\\) and \\(R(\\beta)\\) are no\nlonger sets of pairs of the form \\((x,y)\\) with \\(x\\) and \\(y\\)\nworlds, but rather sets of pairs of the form \\((x, Y)\\) with \\(x\\) a\nworld and \\(Y\\) a set of worlds. It was inspired by the Game Logic of\nParikh [1985], an intepretation of PDL with \u201cprograms as\ngames\u201d. Game Logic provides an additional program construct that\ndualizes programs, thus permitting to define the intersection of\nprograms as the dual of the non-deterministic choice between\nprograms.\n5. Conclusion\n\nThis article has focused on propositional dynamic logic and some of\nits significant variants. There are by now a number of\nbooks\u2014Goldblatt [1982], Goldblatt [1992a], Harel [1979] and\nHarel, Kozen and Tiuryn [2000]\u2014and survey papers\u2014Harel\n[1984], Kozen and Tiuryn [1990], Parikh [1983] \u2014treating PDL and\nrelated formalisms. Pratt offers in Pratt [2017] an informal and\npersonal perspective on the development of dynamics logics which also\nhas a historical value. The body of research on PDL is certainly\ninstrumental in developing many logical theories of system dynamics.\nHowever, these theories are arguably out of the scope of the present\narticle. Van Eijck and Stokhof [2006] is a more recent overview of\ntopics making use of dynamic logic, addressing various themes that are\nof certain interest for philosophers: e.g., dynamics of communication,\nor natural language semantics. Recent books are going in much details\non newer topics, such as dynamic logic of knowledge (dynamic epistemic\nlogic) in Van Ditmarsch, Van Der Hoek and Kooi [2007], and the dynamic\nlogic of continuous and hybrid systems (differential dynamic logic) in\nPlatzer [2010]. PDL was conceived primarily for reasoning about\nprograms. There are many other applications of modal logic to the\nreasoning about programs. Algorithmic logic is closer to PDL since it\nallows one to talk explicitly about programs. The reader is invited to\nconsult the work presented in Mirkowska and Salwicki [1987]. Temporal\nlogics are now the chief logics in theoretical computer science and\nhave a close connection with logics of programs. They allow one to\nexpress the temporal behavior of transition systems with a language\nthat abstracts away from the labels (hence the programs). See for\ninstance Schneider [2004] for an overview of the foundations in this\nresearch area.\n", "bibliography": {"categories": [], "cat_ref_text": {"ref_list": ["Apt, K., 1981, \u201cTen years of Hoare\u2019s logic: A survey\n\u2014 Part I\u201d, <em>ACM Transactions on Programming Languages\nand Systems</em>, 3(4): 431\u2013483.", "Balbiani, P., and D. Vakarelov, 2003, \u201cPDL with intersection\nof programs: a complete axiomatization\u201d, <em>Journal of Applied\nNon-Classical Logics</em>, 13: 231-276.", "van Benthem, J., 1998, \u201cProgram constructions that are safe\nfor bisimulation\u201d, <em>Studia Logica</em>, 60:\n311\u2013330.", "Berman, F., and M. Paterson, 1981, \u201cPropositional dynamic\nlogic is weaker without tests\u201d, <em>Theoretical Computer\nScience</em>, 16: 321\u2013328.", "Burstall, R., 1974, \u201cProgram Proving as Hand Simulation with\na Little Induction\u201d, <em>Information Processing 74: Proceedings\nof IFIP Congress 74</em>, Amsterdam: North Holland Publishing Company,\n308\u2013312.", "Danecki, R., 1984a, \u201cPropositional dynamic logic with strong\nloop predicate\u201d, in M. Chytil and V. Koubek, <em>Mathematical\nFoundations of Computer Science</em>, Berlin: Springer-Verlag,\n573-581.", "\u2013\u2013\u2013, 1984b, \u201cNondeterministic\npropositional dynamic logic with intersection is decidable\u201d, in\nA. Skowron (ed.), <em>Computation Theory</em>, Berlin:\nSpringer-Verlag, 34-53.", "De Giacomo, G., and F. Massacci, 2000, \u201cCombining deduction\nand model checking into tableaux and algorithms for\nconverse-PDL\u201d, <em>Information and Computation</em>, 160:\n109\u2013169.", "van Ditmarsch, H., W. van Der Hoek, and B. Kooi, 2007, <em>Dynamic\nepistemic logic</em>, Dordrecht: Springer-Verlag.", "van Eijck, J., and M. Stokhof, 2006, \u201cThe Gamut of Dynamic\nLogics\u201d, in D. Gabbay and J. Woods (eds.), <em>The Handbook of\nHistory of Logic</em>, Volume 7\u2014<em>Logic and the Modalities in\nthe Twentieth Century</em>, Amsterdam: Elsevier, 499\u2013600.", "Emerson, E., and Jutla, C., 1988, \u201cThe Complexity of Tree\nAutomata and Logics of Programs (Extended Abstract)\u201d, in\n<em>Proceedings of the 29th Annual Symposium on Foundations of\nComputer Science</em>, Los Alamitos, CA: IEEE Computer Society,\n328\u2013337.", "\u2013\u2013\u2013, 1999, \u201cThe Complexity of Tree\nAutomata and Logics of Programs\u201d, in <em>SIAM Journal of\nComputing</em>, 29: 132\u2013158.", "Engeler, E., 1967, \u201cAlgorithmic properties of\nstructures\u201d, <em>Mathematical Systems Theory</em>, 1:\n183\u2013195.", "Fischer, M., and R. Ladner, 1979, \u201cPropositional dynamic\nlogic of regular programs\u201d, <em>Journal of Computer and System\nSciences</em>, 18: 194\u2013211.", "Floyd, R., 1967, \u201cAssigning meaning to programs\u201d,\n<em>Proceedings of the American Mathematical Society Symposia on\nApplied Mathematics</em> (Volume 19), Providence, RI: American\nMathematical Society, 19\u201331.", "Gargov, G., and S. Passy, 1988, \u201cDeterminism and looping in\ncombinatory PDL\u201d, <em>Theoretical Computer Science</em>,\nAmsterdam: Elsevier, 259\u2013277.", "Goldblatt, R., 1982, <em>Axiomatising the Logic of Computer\nProgramming</em>, Berlin: Springer-Verlag.", "\u2013\u2013\u2013, 1992a, <em>Logics of Time and\nComputation</em>, Stanford: Center for the Study of Language and\nInformation Publications.", "\u2013\u2013\u2013, 1992b, \u201cParallel Action: Concurrent\nDynamic Logic with Independent Modalities\u201d, <em>Studia\nLogica</em>, 51: 551\u2013578.", "G\u00f6ller, S., M. Lohrey, and C. Lutz, 2007, \u201cPDL with\nintersection and converse is 2EXP-complete\u201d, <em>Foundations of\nSoftware Science and Computational Structures</em>, Berlin: Springer,\n198\u2013212.", "Harel, D., 1979, <em>First-Order Dynamic Logic</em>, Berlin:\nSpringer-Verlag.", "\u2013\u2013\u2013, 1983, \u201cRecurring dominoes: making the\nhighly undecidable highly understandable\u201d, in M. Karpinski\n(ed.), <em>Foundations of Computation Theory</em>, Berlin:\nSpringer-Verlag, 177\u2013194.", "\u2013\u2013\u2013, 1984, \u201cDynamic logic\u201d, in D.\nGabbay and F. Guenthner (eds.), <em>Handbook of Philosophical\nLogic</em> (Volume II), Dordrecht: D. Reidel, 497\u2013604.", "Harel, D., D. Kozen, and J. Tiuryn, 2000, <em>Dynamic Logic</em>,\nCambridge, MA: MIT Press.", "Harel, D. and Sherman, R., 1982, \u201cLooping vs. Repeating in\nDynamic Logic\u201d, <em>Information and Control</em>, 55:\n175\u2013192.", "Hoare, C., 1969, \u201cAn axiomatic basis for computer\nprogramming\u201d, <em>Communications of the Association of Computing\nMachinery</em>, 12: 576\u2013580.", "Kozen, D., 1983, \u201cResults on the Propositional\n\u03bc-Calculus\u201d, <em>Theoretical Computer Science</em>, 27:\n333\u2013354.", "Kozen, D., and R. Parikh, 1981, \u201cAn elementary proof of the\ncompleteness of PDL\u201d, <em>Theoretical Computer Science</em>, 14:\n113\u2013118.", "Kozen, D., and J. Tiuryn, 1990, \u201cLogics of programs\u201d,\nin J. Van Leeuwen (ed.), <em>Handbook of Theoretical Computer\nScience</em> (Volume B), Amsterdam: Elsevier, 789\u2013840.", "Lange, M., 2005, \u201cA lower complexity bound for propositional\ndynamic logic with intersection\u201d, in R. Schmidt, I.\nPratt-Hartmann, M. Reynolds and H. Wansing (eds.), <em>Advances in\nModal Logic</em> (Volume 5), London: King\u2019s College\nPublications, 133\u2013147.", "Lange, M., and C. Lutz, 2005, \u201c2-EXPTIME lower bounds for\npropositional dynamic logics with intersection\u201d, <em>Journal of\nSymbolic Logic</em>, 70: 1072\u20131086.", "Lutz, C., 2005, \u201cPDL with intersection and converse is\ndecidable\u201d. In L. Ong (ed.), <em>Computer Science Logic</em>,\nBerlin: Springer-Verlag, 413-427.", "Massacci, F., 2001, \u201cDecision procedures for expressive\ndescription logics with intersection, composition, converse of roles\nand role identity\u201d, in B. Nebel (ed.), <em>17th International\nJoint Conference on Artificial Intelligence</em>, San Francisco:\nMorgan Kaufmann, 193\u2013198.", "Mirkowska, G., and A. Salwicki, 1987, <em>Algorithmic Logic</em>,\nDordrecht: D. Reidel.", "Nishimura, H., 1979, \u201cSequential method in propositional\ndynamic logic\u201d, <em>Acta Informatica</em>, 12:\n377\u2013400.", "Parikh, R., 1978, \u201cThe completeness of propositional dynamic\nlogic\u201d, in J. Winkowski (ed.), <em>Mathematical Foundations of\nComputer Science</em>, Berlin: Springer-Verlag, 1978, 403-415.", "\u2013\u2013\u2013, 1983, \u201cPropositional logics of\nprograms: new directions\u201d, in M. Karpinski (ed.),\n<em>Foundations of Computation Theory</em>, Berlin: Springer-Verlag,\n347-359.", "\u2013\u2013\u2013, 1985, \u201cThe logic of games and its\napplications\u201d, <em>Annals of Discrete Mathematics</em>, 24:\n111\u2013140.", "Peleg, D., 1987, \u201cConcurrent dynamic logic\u201d,\n<em>Journal of the Association of Computing Machinery</em>, 34:\n450\u2013479.", "Platzer, A., 2010, <em>Logical Analysis of Hybrid Systems: Proving\nTheorems for Complex Dynamics</em>, Berlin: Springer, 2010.", "Pratt, V., 1976, \u201cSemantical considerations on Floyd-Hoare\nlogic\u201d, in <em>Proceedings of the 17th IEEE Symposium on\nFoundations of Computer Science</em>, Los Alamitos, CA: IEEE Computer\nSociety, 109\u2013121.", "\u2013\u2013\u2013, 1978, \u201cA practical decision method\nfor propositional dynamic logic\u201d, in <em>Proceedings of the 10th\nAnnual ACM Symposium on Theory of Computing</em>, New York, NY: ACM,\n326\u2013337.", "\u2013\u2013\u2013, 1980a, \u201cA near-optimal method for\nreasoning about action\u201d, <em>Journal of Computer and System\nSciences</em>, 20: 231\u2013254.", "\u2013\u2013\u2013, 1980b, \u201cApplication of Modal Logic to\nProgramming\u201d, <em>Studia Logica</em>, 39: 257\u2013274.", "\u2013\u2013\u2013, 2017, \u201cDynamic Logic: A Personal\nPerspective\u201d, <em>Lecture Notes in Computer Science</em> (Volume\n10669), Cham: Springer, 153\u2013170.", "Sakalauskaite, J., and M. Valiev, 1990, \u201cCompleteness of\npropositional dynamic logic with infinite repeating\u201d, in P.\nPetkov (ed.), <em>Mathematical Logic</em>, New York: Plenum Press,\n339\u2013349.", "Salwicki, A., 1970, \u201cFormalized algorithmic\nlanguages\u201d, <em>Bulletin de l\u2019Academie Polonaise des\nSciences, Serie des sciences mathematiques, astronomiques et\nphysiques</em>, 18: 227\u2013232.", "Segerberg, K., 1977, \u201cA completeness theorem in the modal\nlogic of programs\u201d, <em>Notices of the American Mathematical\nSociety</em>, 24: 522.", "Schneider, K., 2004, <em>Verification of Reactive Systems</em>,\nBerlin: Springer-Verlag.", "Streett, R., 1982, \u201cPropositional dynamic logic of looping\nand converse is elementary decidable\u201d, <em>Information and\nControl</em>, 54: 121\u2013141.", "Vakarelov, D., 1983, \u201cFiltration theorem for dynamic\nalgebras with tests and inverse operator\u201d, in A. Salwicki (ed.),\n<em>Logics of Programs and their Applications</em>, Berlin:\nSpringer-Verlag, 314\u2013324.", "Vardi, M., 1985, \u201cThe Taming of Converse: Reasoning about\nTwo-way Computations\u201d, in <em>Lecture Notes in Computer\nScience</em> (Volume 193), Berlin-Heidelberg: Springer,\n413\u2013423.", "\u2013\u2013\u2013, 1998, \u201cReasoning about the past with\ntwo-way automata\u201d, in <em>Lecture Notes in Computer Science</em>\n(Volume 1443), Berlin-Heidelberg: Springer, 628\u2013641.", "Vardi, M., and Stockmeyer, L., 1985, \u201cImproved Upper and\nLower Bounds for Modal Logics of Programs: Preliminary Report\u201d,\nin <em>Proceedings of the 17th Annual ACM Symposium on Theory of\nComputing</em>, New York, NY: ACM, 240\u2013251.", "Yanov, J., 1959, \u201cOn equivalence of operator schemes\u201d,\n<em>Problems of Cybernetic</em>, 1: 1\u2013100."]}, "raw_text": "<div id=\"bibliography\">\n<h2 id=\"Bib\">Bibliography</h2>\n<ul class=\"hanging\">\n<li>Apt, K., 1981, \u201cTen years of Hoare\u2019s logic: A survey\n\u2014 Part I\u201d, <em>ACM Transactions on Programming Languages\nand Systems</em>, 3(4): 431\u2013483.</li>\n<li>Balbiani, P., and D. Vakarelov, 2003, \u201cPDL with intersection\nof programs: a complete axiomatization\u201d, <em>Journal of Applied\nNon-Classical Logics</em>, 13: 231-276.</li>\n<li>van Benthem, J., 1998, \u201cProgram constructions that are safe\nfor bisimulation\u201d, <em>Studia Logica</em>, 60:\n311\u2013330.</li>\n<li>Berman, F., and M. Paterson, 1981, \u201cPropositional dynamic\nlogic is weaker without tests\u201d, <em>Theoretical Computer\nScience</em>, 16: 321\u2013328.</li>\n<li>Burstall, R., 1974, \u201cProgram Proving as Hand Simulation with\na Little Induction\u201d, <em>Information Processing 74: Proceedings\nof IFIP Congress 74</em>, Amsterdam: North Holland Publishing Company,\n308\u2013312.</li>\n<li>Danecki, R., 1984a, \u201cPropositional dynamic logic with strong\nloop predicate\u201d, in M. Chytil and V. Koubek, <em>Mathematical\nFoundations of Computer Science</em>, Berlin: Springer-Verlag,\n573-581.</li>\n<li>\u2013\u2013\u2013, 1984b, \u201cNondeterministic\npropositional dynamic logic with intersection is decidable\u201d, in\nA. Skowron (ed.), <em>Computation Theory</em>, Berlin:\nSpringer-Verlag, 34-53.</li>\n<li>De Giacomo, G., and F. Massacci, 2000, \u201cCombining deduction\nand model checking into tableaux and algorithms for\nconverse-PDL\u201d, <em>Information and Computation</em>, 160:\n109\u2013169.</li>\n<li>van Ditmarsch, H., W. van Der Hoek, and B. Kooi, 2007, <em>Dynamic\nepistemic logic</em>, Dordrecht: Springer-Verlag.</li>\n<li>van Eijck, J., and M. Stokhof, 2006, \u201cThe Gamut of Dynamic\nLogics\u201d, in D. Gabbay and J. Woods (eds.), <em>The Handbook of\nHistory of Logic</em>, Volume 7\u2014<em>Logic and the Modalities in\nthe Twentieth Century</em>, Amsterdam: Elsevier, 499\u2013600.</li>\n<li>Emerson, E., and Jutla, C., 1988, \u201cThe Complexity of Tree\nAutomata and Logics of Programs (Extended Abstract)\u201d, in\n<em>Proceedings of the 29th Annual Symposium on Foundations of\nComputer Science</em>, Los Alamitos, CA: IEEE Computer Society,\n328\u2013337.</li>\n<li>\u2013\u2013\u2013, 1999, \u201cThe Complexity of Tree\nAutomata and Logics of Programs\u201d, in <em>SIAM Journal of\nComputing</em>, 29: 132\u2013158.</li>\n<li>Engeler, E., 1967, \u201cAlgorithmic properties of\nstructures\u201d, <em>Mathematical Systems Theory</em>, 1:\n183\u2013195.</li>\n<li>Fischer, M., and R. Ladner, 1979, \u201cPropositional dynamic\nlogic of regular programs\u201d, <em>Journal of Computer and System\nSciences</em>, 18: 194\u2013211.</li>\n<li>Floyd, R., 1967, \u201cAssigning meaning to programs\u201d,\n<em>Proceedings of the American Mathematical Society Symposia on\nApplied Mathematics</em> (Volume 19), Providence, RI: American\nMathematical Society, 19\u201331.</li>\n<li>Gargov, G., and S. Passy, 1988, \u201cDeterminism and looping in\ncombinatory PDL\u201d, <em>Theoretical Computer Science</em>,\nAmsterdam: Elsevier, 259\u2013277.</li>\n<li>Goldblatt, R., 1982, <em>Axiomatising the Logic of Computer\nProgramming</em>, Berlin: Springer-Verlag.</li>\n<li>\u2013\u2013\u2013, 1992a, <em>Logics of Time and\nComputation</em>, Stanford: Center for the Study of Language and\nInformation Publications.</li>\n<li>\u2013\u2013\u2013, 1992b, \u201cParallel Action: Concurrent\nDynamic Logic with Independent Modalities\u201d, <em>Studia\nLogica</em>, 51: 551\u2013578.</li>\n<li>G\u00f6ller, S., M. Lohrey, and C. Lutz, 2007, \u201cPDL with\nintersection and converse is 2EXP-complete\u201d, <em>Foundations of\nSoftware Science and Computational Structures</em>, Berlin: Springer,\n198\u2013212.</li>\n<li>Harel, D., 1979, <em>First-Order Dynamic Logic</em>, Berlin:\nSpringer-Verlag.</li>\n<li>\u2013\u2013\u2013, 1983, \u201cRecurring dominoes: making the\nhighly undecidable highly understandable\u201d, in M. Karpinski\n(ed.), <em>Foundations of Computation Theory</em>, Berlin:\nSpringer-Verlag, 177\u2013194.</li>\n<li>\u2013\u2013\u2013, 1984, \u201cDynamic logic\u201d, in D.\nGabbay and F. Guenthner (eds.), <em>Handbook of Philosophical\nLogic</em> (Volume II), Dordrecht: D. Reidel, 497\u2013604.</li>\n<li>Harel, D., D. Kozen, and J. Tiuryn, 2000, <em>Dynamic Logic</em>,\nCambridge, MA: MIT Press.</li>\n<li>Harel, D. and Sherman, R., 1982, \u201cLooping vs. Repeating in\nDynamic Logic\u201d, <em>Information and Control</em>, 55:\n175\u2013192.</li>\n<li>Hoare, C., 1969, \u201cAn axiomatic basis for computer\nprogramming\u201d, <em>Communications of the Association of Computing\nMachinery</em>, 12: 576\u2013580.</li>\n<li>Kozen, D., 1983, \u201cResults on the Propositional\n\u03bc-Calculus\u201d, <em>Theoretical Computer Science</em>, 27:\n333\u2013354.</li>\n<li>Kozen, D., and R. Parikh, 1981, \u201cAn elementary proof of the\ncompleteness of PDL\u201d, <em>Theoretical Computer Science</em>, 14:\n113\u2013118.</li>\n<li>Kozen, D., and J. Tiuryn, 1990, \u201cLogics of programs\u201d,\nin J. Van Leeuwen (ed.), <em>Handbook of Theoretical Computer\nScience</em> (Volume B), Amsterdam: Elsevier, 789\u2013840.</li>\n<li>Lange, M., 2005, \u201cA lower complexity bound for propositional\ndynamic logic with intersection\u201d, in R. Schmidt, I.\nPratt-Hartmann, M. Reynolds and H. Wansing (eds.), <em>Advances in\nModal Logic</em> (Volume 5), London: King\u2019s College\nPublications, 133\u2013147.</li>\n<li>Lange, M., and C. Lutz, 2005, \u201c2-EXPTIME lower bounds for\npropositional dynamic logics with intersection\u201d, <em>Journal of\nSymbolic Logic</em>, 70: 1072\u20131086.</li>\n<li>Lutz, C., 2005, \u201cPDL with intersection and converse is\ndecidable\u201d. In L. Ong (ed.), <em>Computer Science Logic</em>,\nBerlin: Springer-Verlag, 413-427.</li>\n<li>Massacci, F., 2001, \u201cDecision procedures for expressive\ndescription logics with intersection, composition, converse of roles\nand role identity\u201d, in B. Nebel (ed.), <em>17th International\nJoint Conference on Artificial Intelligence</em>, San Francisco:\nMorgan Kaufmann, 193\u2013198.</li>\n<li>Mirkowska, G., and A. Salwicki, 1987, <em>Algorithmic Logic</em>,\nDordrecht: D. Reidel.</li>\n<li>Nishimura, H., 1979, \u201cSequential method in propositional\ndynamic logic\u201d, <em>Acta Informatica</em>, 12:\n377\u2013400.</li>\n<li>Parikh, R., 1978, \u201cThe completeness of propositional dynamic\nlogic\u201d, in J. Winkowski (ed.), <em>Mathematical Foundations of\nComputer Science</em>, Berlin: Springer-Verlag, 1978, 403-415.</li>\n<li>\u2013\u2013\u2013, 1983, \u201cPropositional logics of\nprograms: new directions\u201d, in M. Karpinski (ed.),\n<em>Foundations of Computation Theory</em>, Berlin: Springer-Verlag,\n347-359.</li>\n<li>\u2013\u2013\u2013, 1985, \u201cThe logic of games and its\napplications\u201d, <em>Annals of Discrete Mathematics</em>, 24:\n111\u2013140.</li>\n<li>Peleg, D., 1987, \u201cConcurrent dynamic logic\u201d,\n<em>Journal of the Association of Computing Machinery</em>, 34:\n450\u2013479.</li>\n<li>Platzer, A., 2010, <em>Logical Analysis of Hybrid Systems: Proving\nTheorems for Complex Dynamics</em>, Berlin: Springer, 2010.</li>\n<li>Pratt, V., 1976, \u201cSemantical considerations on Floyd-Hoare\nlogic\u201d, in <em>Proceedings of the 17th IEEE Symposium on\nFoundations of Computer Science</em>, Los Alamitos, CA: IEEE Computer\nSociety, 109\u2013121.</li>\n<li>\u2013\u2013\u2013, 1978, \u201cA practical decision method\nfor propositional dynamic logic\u201d, in <em>Proceedings of the 10th\nAnnual ACM Symposium on Theory of Computing</em>, New York, NY: ACM,\n326\u2013337.</li>\n<li>\u2013\u2013\u2013, 1980a, \u201cA near-optimal method for\nreasoning about action\u201d, <em>Journal of Computer and System\nSciences</em>, 20: 231\u2013254.</li>\n<li>\u2013\u2013\u2013, 1980b, \u201cApplication of Modal Logic to\nProgramming\u201d, <em>Studia Logica</em>, 39: 257\u2013274.</li>\n<li>\u2013\u2013\u2013, 2017, \u201cDynamic Logic: A Personal\nPerspective\u201d, <em>Lecture Notes in Computer Science</em> (Volume\n10669), Cham: Springer, 153\u2013170.</li>\n<li>Sakalauskaite, J., and M. Valiev, 1990, \u201cCompleteness of\npropositional dynamic logic with infinite repeating\u201d, in P.\nPetkov (ed.), <em>Mathematical Logic</em>, New York: Plenum Press,\n339\u2013349.</li>\n<li>Salwicki, A., 1970, \u201cFormalized algorithmic\nlanguages\u201d, <em>Bulletin de l\u2019Academie Polonaise des\nSciences, Serie des sciences mathematiques, astronomiques et\nphysiques</em>, 18: 227\u2013232.</li>\n<li>Segerberg, K., 1977, \u201cA completeness theorem in the modal\nlogic of programs\u201d, <em>Notices of the American Mathematical\nSociety</em>, 24: 522.</li>\n<li>Schneider, K., 2004, <em>Verification of Reactive Systems</em>,\nBerlin: Springer-Verlag.</li>\n<li>Streett, R., 1982, \u201cPropositional dynamic logic of looping\nand converse is elementary decidable\u201d, <em>Information and\nControl</em>, 54: 121\u2013141.</li>\n<li>Vakarelov, D., 1983, \u201cFiltration theorem for dynamic\nalgebras with tests and inverse operator\u201d, in A. Salwicki (ed.),\n<em>Logics of Programs and their Applications</em>, Berlin:\nSpringer-Verlag, 314\u2013324.</li>\n<li>Vardi, M., 1985, \u201cThe Taming of Converse: Reasoning about\nTwo-way Computations\u201d, in <em>Lecture Notes in Computer\nScience</em> (Volume 193), Berlin-Heidelberg: Springer,\n413\u2013423.</li>\n<li>\u2013\u2013\u2013, 1998, \u201cReasoning about the past with\ntwo-way automata\u201d, in <em>Lecture Notes in Computer Science</em>\n(Volume 1443), Berlin-Heidelberg: Springer, 628\u2013641.</li>\n<li>Vardi, M., and Stockmeyer, L., 1985, \u201cImproved Upper and\nLower Bounds for Modal Logics of Programs: Preliminary Report\u201d,\nin <em>Proceedings of the 17th Annual ACM Symposium on Theory of\nComputing</em>, New York, NY: ACM, 240\u2013251.</li>\n<li>Yanov, J., 1959, \u201cOn equivalence of operator schemes\u201d,\n<em>Problems of Cybernetic</em>, 1: 1\u2013100.</li>\n</ul>\n</div>"}, "related_entries": {"entry_list": ["computability and complexity", "computer science, philosophy of", "logic: action", "logic: and information", "logic: modal", "logic: temporal"], "entry_link": [{"../computability/": "computability and complexity"}, {"../computer-science/": "computer science, philosophy of"}, {"../logic-action/": "logic: action"}, {"../logic-information/": "logic: and information"}, {"../logic-modal/": "logic: modal"}, {"../logic-temporal/": "logic: temporal"}]}, "academic_tools": {"listed_text": ["<img alt=\"sep man icon\" src=\"../../symbols/sepman-icon.jpg\"/>", "<a href=\"https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=logic-dynamic\" target=\"other\">How to cite this entry</a>.", "<img alt=\"sep man icon\" src=\"../../symbols/sepman-icon.jpg\"/>", "<a href=\"https://leibniz.stanford.edu/friends/preview/logic-dynamic/\" target=\"other\">Preview the PDF version of this entry</a> at the\n <a href=\"https://leibniz.stanford.edu/friends/\" target=\"other\">Friends of the SEP Society</a>.", "<img alt=\"inpho icon\" src=\"../../symbols/inpho.png\"/>", "<a href=\"https://www.inphoproject.org/entity?sep=logic-dynamic&amp;redirect=True\" target=\"other\">Look up topics and thinkers related to this entry</a>\n at the Internet Philosophy Ontology Project (InPhO).", "<img alt=\"phil papers icon\" src=\"../../symbols/pp.gif\"/>", "<a href=\"https://philpapers.org/sep/logic-dynamic/\" target=\"other\">Enhanced bibliography for this entry</a>\nat <a href=\"https://philpapers.org/\" target=\"other\">PhilPapers</a>, with links to its database."], "listed_links": [{"https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=logic-dynamic": "How to cite this entry"}, {"https://leibniz.stanford.edu/friends/preview/logic-dynamic/": "Preview the PDF version of this entry"}, {"https://leibniz.stanford.edu/friends/": "Friends of the SEP Society"}, {"https://www.inphoproject.org/entity?sep=logic-dynamic&redirect=True": "Look up topics and thinkers related to this entry"}, {"https://philpapers.org/sep/logic-dynamic/": "Enhanced bibliography for this entry"}, {"https://philpapers.org/": "PhilPapers"}]}, "other_internet_resources": {"listed_text": [], "listed_links": []}, "tokenized_text": ["1", "introduction", "dynamic", "logic", "dl", "modal", "logic", "representing", "state", "event", "dynamic", "system", "language", "dl", "assertion", "language", "able", "express", "property", "computation", "state", "programming", "language", "able", "express", "property", "system", "transition", "state", "dl", "logic", "program", "permit", "talk", "reason", "state", "affair", "process", "change", "result", "pratt", "original", "dynamic", "logic", "program", "firstorder", "modal", "logic", "propositional", "dynamic", "logic", "pdl", "propositional", "counterpart", "presented", "logic", "right", "fischer", "ladner", "1979", "propositional", "language", "pdl", "make", "use", "term", "predicate", "function", "thus", "pdl", "two", "syntactic", "category", "proposition", "program", "give", "meaning", "statement", "pdl", "typically", "work", "abstract", "semantics", "term", "labeled", "transition", "system", "lts", "ltss", "seen", "generalization", "kripke", "model", "transition", "world", "state", "labeled", "name", "atomic", "program", "valuation", "indicates", "every", "state", "proposition", "true", "transition", "labeled", "pi", "one", "state", "x", "state", "y", "noted", "xr", "pi", "y", "x", "in", "r", "pi", "indicates", "starting", "x", "possible", "execution", "program", "pi", "finish", "y", "proposition", "a", "true", "y", "formula", "langlepirangle", "a", "true", "x", "ie", "state", "x", "possible", "execution", "program", "pi", "end", "state", "satisfying", "a", "one", "recognizes", "langlepirangle", "modality", "reminiscent", "modality", "possibility", "often", "noted", "diamond", "modal", "logic", "unsurprisingly", "also", "corresponding", "notion", "necessity", "whose", "modality", "often", "noted", "box", "formula", "pi", "a", "true", "state", "x", "a", "true", "every", "state", "reachable", "x", "transition", "labeled", "pi", "possible", "execution", "complex", "program", "next", "defined", "compositionally", "instance", "program", "first", "alpha", "beta", "complex", "program", "specifically", "sequence", "possible", "execution", "represented", "lts", "composing", "twostep", "transitiona", "transition", "signified", "r", "alpha", "beta", "between", "state", "x", "y", "possible", "execution", "state", "x", "program", "alpha", "finish", "state", "z", "possible", "execution", "z", "program", "beta", "finish", "state", "y", "proposition", "a", "true", "y", "formula", "langle", "alpha", "betarangle", "a", "true", "state", "x", "program", "alpha", "beta", "could", "complex", "program", "still", "program", "expressed", "construct", "present", "due", "time", "program", "seen", "extensional", "way", "binary", "relation", "pair", "state", "lts", "precisely", "set", "pair", "form", "x", "program", "executed", "state", "x", "lead", "state", "y", "hand", "proposition", "statement", "state", "either", "true", "false", "state", "proposition", "thus", "also", "seen", "extensional", "way", "set", "state", "lts", "true", "acronym", "pdl", "refer", "precisely", "propositional", "dynamic", "logic", "following", "program", "construct", "sequence", "nondeterministic", "choice", "unbounded", "iteration", "test", "present", "section", "2", "together", "property", "fundamental", "result", "particular", "address", "axiomatization", "decidability", "hoare", "calculus", "hoare", "1969", "landmark", "logic", "program", "concern", "truth", "statement", "form", "a", "alpha", "b", "meaning", "precondition", "a", "program", "alpha", "always", "b", "postconditionand", "defined", "axiomatically", "come", "want", "rigorous", "method", "reason", "property", "program", "thus", "giving", "activity", "programming", "certain", "place", "realm", "science", "burstall", "1974", "saw", "analogy", "modal", "logic", "reasoning", "program", "actual", "work", "started", "pratt", "1976", "suggested", "student", "course", "giving", "specifically", "logic", "program", "pdl", "come", "pratt", "interpretation", "hoare", "calculus", "formalism", "modal", "logic", "introduction", "genesis", "pdl", "found", "pratt", "1980b", "hoaretriple", "a", "alpha", "b", "captured", "pdl", "formula", "to", "alpha", "b", "meaning", "literally", "a", "true", "every", "successfully", "terminating", "execution", "alpha", "end", "b", "true", "connection", "realized", "routine", "prove", "initial", "rule", "hoare", "calculus", "using", "exclusively", "axiomatization", "pdl", "something", "detail", "section", "3", "concentrate", "reasoning", "correctness", "structured", "program", "additional", "topic", "related", "pdl", "include", "result", "concerning", "comparative", "power", "expression", "decidability", "complexity", "completeness", "number", "interesting", "variant", "obtained", "extending", "restricting", "pdl", "various", "way", "since", "inception", "many", "variant", "pdl", "received", "attention", "variant", "may", "consider", "deterministic", "program", "restricted", "test", "nonregular", "program", "program", "automaton", "complementation", "intersection", "program", "converse", "infinite", "computation", "etc", "present", "section", "4", "providing", "pointer", "regarding", "relative", "expressivity", "axiomatizations", "computational", "complexity", "conclude", "section", "5", "2", "definition", "fundamental", "result", "present", "syntax", "semantics", "pdl", "section", "21", "proof", "theory", "pdl", "presented", "section", "22", "axiomatizations", "pointer", "literature", "completeness", "address", "problem", "decidability", "complexity", "section", "23", "21", "syntax", "semantics", "propositional", "dynamic", "logic", "pdl", "designed", "representing", "reasoning", "propositional", "property", "program", "syntax", "based", "upon", "two", "set", "symbol", "countable", "set", "phi_0", "atomic", "formula", "countable", "set", "pi_0", "atomic", "program", "complex", "formula", "complex", "program", "base", "defined", "follows", "every", "atomic", "formula", "formula", "0", "false", "formula", "a", "formula", "lnot", "a", "a", "formula", "a", "b", "formula", "alor", "b", "a", "b", "formula", "alpha", "program", "formula", "alpha", "a", "every", "execution", "alpha", "present", "state", "lead", "state", "a", "true", "formula", "every", "atomic", "program", "program", "alpha", "beta", "program", "alpha", "beta", "alpha", "followed", "beta", "program", "alpha", "beta", "program", "alphacupbeta", "alpha", "beta", "nondeterministically", "program", "alpha", "program", "alpha", "repeat", "alpha", "finite", "nondeterministically", "determined", "number", "time", "program", "a", "formula", "proceed", "a", "true", "else", "fail", "program", "boolean", "connective", "1", "land", "to", "leftrightarrow", "used", "abbreviation", "standard", "way", "addition", "abbreviate", "lnot", "alpha", "lnot", "a", "langlealpharangle", "a", "execution", "alpha", "present", "state", "lead", "state", "a", "true", "modal", "logic", "write", "alphan", "alpha", "ldots", "alpha", "n", "occurrence", "alpha", "formally", "alpha0", "1", "alpha", "n1", "alpha", "alphan", "also", "alpha", "alpha", "alpha", "often", "useful", "represent", "iteration", "unbounded", "occurs", "least", "finally", "adopt", "standard", "rule", "omission", "parenthesis", "formula", "used", "describe", "property", "hold", "successful", "execution", "program", "example", "formula", "alphacupbeta", "a", "mean", "whenever", "program", "alpha", "beta", "successfully", "executed", "state", "reached", "a", "hold", "whereas", "formula", "langle", "alpha", "beta", "rangle", "a", "mean", "sequence", "alternating", "execution", "alpha", "beta", "state", "reached", "a", "hold", "semantically", "speaking", "formula", "interpreted", "set", "state", "program", "interpreted", "binary", "relation", "state", "transition", "system", "precisely", "meaning", "pdl", "formula", "program", "interpreted", "labeled", "transition", "system", "lts", "w", "r", "v", "w", "nonempty", "set", "world", "state", "r", "mapping", "set", "pi_0", "atomic", "program", "binary", "relation", "w", "v", "mapping", "set", "phi_0", "atomic", "formula", "subset", "w", "informally", "mapping", "r", "assigns", "atomic", "program", "piinpi_0", "binary", "relation", "r", "pi", "w", "intended", "meaning", "xr", "pi", "y", "iff", "exists", "execution", "pi", "x", "lead", "y", "whereas", "mapping", "v", "assigns", "atomic", "formula", "pinphi_0", "subset", "v", "p", "w", "intended", "meaning", "x", "in", "v", "p", "iff", "p", "true", "state", "x", "given", "reading", "0", "lnot", "a", "alor", "b", "alpha", "a", "alpha", "beta", "alphacupbeta", "alpha", "clear", "r", "v", "must", "extended", "inductively", "follows", "supply", "intended", "meaning", "complex", "program", "formula", "xr", "alpha", "beta", "y", "iff", "exists", "world", "z", "xr", "alpha", "z", "zr", "beta", "y", "xr", "alphacupbeta", "y", "iff", "xr", "alpha", "y", "xr", "beta", "y", "xr", "alpha", "y", "iff", "exists", "nonnegative", "integer", "n", "exists", "sequence", "state", "z_0", "ldots", "z_n", "z_0", "x", "z_n", "y", "k", "1", "ldots", "n", "z_", "k1", "r", "alpha", "z_k", "xr", "y", "iff", "x", "y", "in", "v", "v", "0", "emptyset", "v", "lnot", "w", "setminus", "v", "v", "alor", "b", "v", "cup", "v", "b", "v", "alpha", "x", "mid", "text", "world", "text", "xr", "alpha", "text", "in", "v", "x", "in", "v", "say", "a", "satisfied", "state", "x", "m", "ldquo", "x", "sat", "ardquo", "two", "labeled", "transition", "system", "w", "r", "v", "left", "w", "r", "v", "right", "call", "m", "lts", "depicted", "left", "m", "lts", "depicted", "right", "defined", "formally", "w", "r", "v", "w", "x_1", "x_2", "r", "pi_1", "x_1", "x_1", "r", "pi_2", "x_1", "x_2", "v", "p", "x_1", "v", "q", "x_2", "w", "r", "v", "w", "y_1", "y_2", "y_3", "y_4", "r", "pi_1", "y_1", "y_2", "y_2", "y_2", "r", "pi_2", "y_1", "y_3", "y_2", "y_4", "v", "p", "y_1", "y_2", "v", "q", "y_3", "y_4", "instance", "x_1", "sat", "p", "x_2", "sat", "q", "x_1", "sat", "langle", "pi_1", "rangle", "p", "land", "langle", "pi_2", "rangle", "q", "x_1", "sat", "pi_1", "p", "land", "pi", "_1", "p", "y_1", "sat", "langle", "pi", "_1", "pi_2rangle", "q", "y_2", "sat", "pi", "_1", "p", "y_1", "sat", "pi_1", "cup", "pi_2", "p", "lor", "q", "y_3", "sat", "pi_1", "cup", "pi_2", "0", "consider", "formula", "a", "say", "a", "valid", "m", "m", "model", "a", "models", "a", "iff", "world", "x", "x", "in", "v", "a", "said", "valid", "models", "a", "iff", "model", "m", "models", "a", "say", "a", "satisfiable", "m", "m", "satisfies", "a", "m", "sat", "a", "iff", "exists", "world", "x", "x", "in", "v", "a", "said", "satisfiable", "sat", "a", "iff", "exists", "model", "m", "m", "sat", "a", "notably", "case", "sat", "a", "iff", "models", "lnot", "a", "models", "a", "iff", "sat", "lnot", "a", "remarkable", "formula", "pdl", "valid", "reader", "may", "try", "prove", "formally", "least", "start", "convincing", "example", "displayed", "models", "alpha", "beta", "leftrightarrow", "alpha", "beta", "a", "models", "alpha", "cup", "beta", "leftrightarrow", "alpha", "land", "beta", "a", "models", "alpha", "leftrightarrow", "land", "alpha", "alpha", "a", "b", "leftrightarrow", "rightarrow", "b", "equivalently", "write", "dual", "form", "langlealpha", "betarangle", "leftrightarrow", "langlealpharanglelanglebetarangle", "a", "langlealpha", "cup", "betarangle", "leftrightarrow", "langlealpharangle", "lor", "langlebetarangle", "a", "langlealpha", "rangle", "leftrightarrow", "lor", "langlealpharangle", "langlealpha", "rangle", "a", "langle", "rangle", "b", "leftrightarrow", "land", "b", "one", "interesting", "notion", "concern", "information", "expressed", "pdl", "formula", "contained", "lts", "behavior", "system", "described", "lts", "indeed", "often", "slightly", "hidden", "form", "instance", "simple", "inspection", "easy", "convince", "oneself", "two", "ltss", "depicted", "behavior", "satisfy", "pdl", "formula", "finish", "section", "syntax", "semantics", "give", "theoretical", "foundation", "claim", "given", "two", "ltss", "one", "may", "ask", "whether", "satisfy", "formula", "notion", "bisimulation", "become", "standard", "measure", "equivalence", "kripke", "model", "labeled", "transition", "system", "bisimulation", "ltss", "w", "r", "v", "w", "r", "v", "binary", "relation", "z", "set", "state", "world", "x", "w", "world", "x", "w", "xzx", "atomic", "formula", "pin", "phi_0", "xin", "v", "p", "iff", "x", "in", "v", "p", "atomic", "program", "pi", "in", "pi_0", "world", "in", "w", "x", "r", "pi", "y", "exists", "world", "in", "w", "yzy", "x", "r", "pi", "y", "atomic", "program", "pi", "in", "pi_0", "world", "in", "w", "x", "r", "pi", "y", "exists", "world", "in", "w", "yzy", "x", "r", "pi", "y", "say", "two", "ltss", "bisimilar", "exists", "bisimulation", "case", "two", "bisimilar", "ltss", "w", "r", "v", "w", "r", "v", "world", "x", "w", "world", "x", "w", "xzx", "pdl", "formula", "a", "x", "in", "v", "iff", "x", "in", "v", "thus", "two", "ltss", "bisimilar", "definition", "bisimulation", "case", "xzx", "program", "alpha", "world", "in", "w", "x", "r", "alpha", "y", "exists", "world", "in", "w", "yzy", "x", "r", "alpha", "y", "program", "alpha", "world", "in", "w", "x", "r", "alpha", "y", "exists", "world", "in", "w", "yzy", "x", "r", "alpha", "y", "hence", "one", "simply", "compare", "behavior", "two", "ltss", "inspecting", "solely", "atomic", "program", "safely", "extrapolate", "comparative", "behavior", "ltss", "even", "complex", "program", "say", "program", "construct", "pdl", "safe", "bisimulation", "see", "van", "benthem", "1998", "precise", "characterization", "program", "construct", "safe", "bisimulation", "readily", "seen", "two", "instance", "ltss", "bisimilar", "bisimulation", "z", "two", "model", "m", "m", "depicted", "figure", "given", "z", "x_1", "y_1", "x_1", "y_2", "x_2", "y_3", "x_2", "y_4", "state", "x_1", "y_1", "satisfy", "exactly", "pdl", "formula", "state", "x_1", "y_2", "etc", "22", "axiomatization", "completeness", "purpose", "proof", "theory", "provide", "characterization", "validitythe", "property", "models", "a", "in", "term", "axiom", "rule", "inference", "section", "define", "deducibility", "predicate", "vdash", "inductively", "operation", "formula", "depend", "syntactic", "structure", "way", "formula", "a", "vdash", "a", "iff", "models", "a", "course", "pdl", "extension", "classical", "propositional", "logic", "first", "expect", "propositional", "tautology", "hold", "propositional", "reasoning", "allowed", "particular", "modus", "ponens", "valid", "rule", "a", "rightarrow", "b", "infer", "b", "program", "alpha", "restricting", "lts", "relation", "r", "alpha", "obtain", "kripke", "model", "logic", "modality", "alpha", "weakest", "propositional", "normal", "modal", "logic", "namely", "logic", "k", "thus", "pdl", "contains", "every", "instance", "familiar", "distribution", "axiom", "schema", "k", "alpha", "rightarrow", "b", "rightarrow", "alpha", "rightarrow", "alpha", "b", "closed", "following", "rule", "inference", "necessitation", "rule", "n", "a", "infer", "alpha", "a", "modal", "logic", "normal", "obeys", "k", "n", "important", "property", "normal", "modal", "logic", "distributivity", "conjunction", "land", "formula", "alpha", "land", "b", "leftrightarrow", "alpha", "land", "alpha", "b", "proven", "using", "k", "n", "propositional", "reasoning", "rule", "monotony", "also", "proven", "using", "k", "n", "propositional", "reasoning", "rightarrow", "b", "infer", "alpha", "rightarrow", "alpha", "b", "pdl", "least", "normal", "modal", "logic", "containing", "every", "instance", "following", "axiom", "schema", "a1", "alpha", "beta", "leftrightarrow", "alpha", "beta", "a", "a2", "alpha", "cup", "beta", "leftrightarrow", "alpha", "land", "beta", "a", "a3", "alpha", "leftrightarrow", "land", "alpha", "alpha", "a", "a4", "b", "leftrightarrow", "rightarrow", "b", "closed", "following", "rule", "inference", "loop", "invariance", "rule", "rightarrow", "alpha", "a", "infer", "rightarrow", "alpha", "a", "x", "set", "formula", "a", "formula", "say", "a", "vdash", "deducible", "x", "x", "vdash", "a", "exists", "sequence", "a_0", "a_1", "ldots", "a_n", "formula", "a_n", "a", "leq", "n", "a_i", "instance", "axiom", "schema", "formula", "x", "come", "earlier", "formula", "sequence", "rule", "inference", "vdash", "a", "iff", "emptyset", "vdash", "a", "case", "say", "a", "vdash", "deducible", "x", "said", "vdash", "consistent", "iff", "x", "vdash", "0", "easy", "establish", "rule", "replaced", "following", "axiom", "schema", "induction", "axiom", "schema", "a5", "land", "alpha", "rightarrow", "alpha", "rightarrow", "alpha", "a", "let", "u", "first", "establish", "derived", "rule", "proof", "system", "based", "a1", "a2", "a3", "a4", "a5", "1", "rightarrow", "alpha", "a", "premise", "2", "alpha", "rightarrow", "alpha", "1", "using", "n", "3", "land", "alpha", "rightarrow", "alpha", "rightarrow", "alpha", "a", "axiom", "schema", "a5", "4", "alpha", "rightarrow", "alpha", "rightarrow", "rightarrow", "alpha", "3", "using", "propositional", "reasoning", "5", "rightarrow", "alpha", "a", "2", "4", "using", "modus", "ponens", "let", "u", "next", "establish", "a5", "vdash", "deducible", "1", "alpha", "rightarrow", "alpha", "leftrightarrow", "rightarrow", "alpha", "land", "alpha", "alpha", "rightarrow", "alpha", "axiom", "schema", "a3", "2", "land", "alpha", "rightarrow", "alpha", "rightarrow", "alpha", "land", "alpha", "rightarrow", "alpha", "1", "using", "propositional", "reasoning", "distributivity", "alpha", "land", "3", "land", "alpha", "rightarrow", "alpha", "rightarrow", "alpha", "land", "alpha", "rightarrow", "alpha", "2", "using", "4", "alpha", "rightarrow", "alpha", "rightarrow", "rightarrow", "alpha", "3", "using", "propositional", "reasoning", "distributivity", "alpha", "land", "5", "land", "alpha", "rightarrow", "alpha", "rightarrow", "alpha", "a", "4", "using", "propositional", "reasoning", "axiomatization", "pdl", "based", "axiom", "schema", "a1", "a2", "a3", "a4", "a5", "proposed", "segerberg", "1977", "immediate", "definition", "vdash", "sound", "respect", "models", "ie", "formula", "a", "vdash", "a", "models", "a", "proof", "proceeds", "induction", "length", "a", "deduction", "vdash", "question", "completeness", "vdash", "respect", "models", "ie", "formula", "a", "models", "a", "vdash", "a", "pursued", "several", "logician", "line", "reasoning", "presented", "segerberg", "1977", "first", "attempt", "prove", "completeness", "vdash", "soon", "parikh", "came", "proof", "early", "1978", "segerberg", "found", "flaw", "argument", "repaired", "eventually", "parikh", "published", "considered", "first", "proof", "completeness", "vdash", "parikh", "1978", "different", "proof", "completeness", "vdash", "published", "since", "eg", "kozen", "parikh", "1981", "detail", "found", "pratt", "2017", "different", "alternative", "proof", "theory", "pdl", "also", "sought", "even", "early", "notably", "pratt", "1978", "let", "u", "also", "mention", "completeness", "related", "theory", "nishimura", "1979", "vakarelov", "1983", "alternative", "formulation", "deducibility", "predicate", "pdl", "exploit", "infinitary", "rule", "inference", "instance", "goldblatt", "1992a", "infinitary", "rule", "inference", "take", "infinite", "number", "premise", "let", "vdash", "deducibility", "predicate", "corresponding", "language", "propositional", "dynamic", "logic", "least", "normal", "modal", "logic", "containing", "every", "instance", "axiom", "schema", "a1", "a2", "a3", "a4", "closed", "following", "infinitary", "rule", "inference", "i", "beta", "alphan", "ngeq", "0", "infer", "beta", "alpha", "a", "proved", "vdash", "sound", "complete", "respect", "models", "ie", "formula", "a", "vdash", "a", "iff", "models", "a", "word", "far", "generating", "set", "valid", "formula", "concerned", "proof", "system", "vdash", "vdash", "equivalent", "23", "decidability", "complexity", "aim", "complexity", "theory", "establish", "computability", "property", "sat", "a", "term", "resource", "time", "space", "complexity", "logic", "mathcal", "l", "often", "identified", "problem", "deciding", "satisfiability", "formula", "defined", "lsat", "given", "formula", "a", "mathcal", "l", "a", "satisfiable", "section", "investigate", "complexity", "following", "decision", "problem", "pdlsat", "given", "formula", "a", "pdl", "a", "satisfiable", "complete", "axiomatization", "pdl", "recursive", "definition", "set", "valid", "pdl", "formula", "word", "set", "formula", "whose", "negation", "satisfiable", "hence", "concerning", "problem", "pdlsat", "subprocedure", "would", "answer", "pdl", "formula", "a", "satisfiable", "subprocedure", "sp1", "consists", "enumerating", "formula", "vdash", "deducible", "starting", "axiom", "inferring", "theorem", "help", "inference", "rule", "given", "enough", "time", "formula", "vdash", "deducible", "subprocedure", "would", "find", "eventually", "thus", "a", "satisfiable", "sp1", "must", "eventually", "find", "lnot", "a", "answer", "however", "formula", "a", "satisfiable", "sp1", "would", "never", "find", "lnot", "a", "would", "run", "forever", "one", "could", "sure", "time", "way", "uncertainty", "also", "think", "second", "subprocedure", "answer", "yes", "pdl", "formula", "satisfiable", "indeed", "one", "earliest", "result", "pdl", "proof", "pdl", "finite", "model", "property", "ie", "formula", "a", "sat", "a", "exists", "finite", "model", "m", "m", "sat", "a", "finite", "model", "property", "offer", "basis", "subprocedure", "sp2", "consists", "enumerating", "one", "one", "finite", "model", "pdl", "testing", "whether", "one", "satisfies", "formula", "formula", "a", "finite", "model", "m", "easy", "test", "m", "sat", "a", "applying", "definition", "v", "thus", "a", "satisfiable", "must", "eventually", "find", "model", "m", "m", "sat", "a", "answer", "yes", "symmetrically", "first", "subprocedure", "sp1", "formula", "a", "satisfiable", "sp2", "never", "find", "model", "satisfying", "run", "forever", "one", "could", "sure", "time", "combining", "sp1", "sp2", "together", "way", "deciding", "whether", "pdl", "formula", "a", "satisfiable", "suffices", "run", "parallel", "a", "satisfiable", "sp2", "eventually", "answer", "yes", "a", "satisfiable", "sp1", "eventually", "answer", "procedure", "halt", "either", "sp1", "sp2", "provides", "answer", "procedure", "obtained", "sufficient", "conclude", "problem", "pdlsat", "decidable", "inefficient", "practice", "resultdue", "fischer", "ladner", "1979", "kozen", "parikh", "1981", "stronger", "finite", "model", "property", "small", "model", "property", "formula", "a", "sat", "a", "exists", "finite", "model", "m", "size", "exponential", "a", "m", "sat", "a", "mean", "would", "know", "stop", "looking", "model", "satisfying", "formula", "procedure", "sp2", "hence", "use", "sp2", "test", "whether", "formula", "satisfiable", "exhausted", "small", "model", "conclude", "formula", "satisfiable", "yield", "procedure", "run", "nondeterministically", "exponential", "time", "nexptime", "guess", "model", "size", "singly", "exponential", "check", "whether", "satisfies", "formula", "key", "result", "complexity", "theory", "pdl", "come", "fischer", "ladner", "1979", "pratt", "1980a", "observing", "formula", "pdl", "efficiently", "describe", "computation", "linear", "space", "bounded", "alternating", "turing", "machine", "fischer", "ladner", "1979", "first", "established", "lower", "bound", "exponential", "time", "pdlsat", "exptime", "upper", "bound", "pdlsat", "obtained", "pratt", "1980a", "adapted", "method", "semantic", "tableau", "pdl", "thus", "pdlsat", "exptimecomplete", "algorithm", "efficient", "practice", "although", "still", "running", "deterministic", "exponential", "time", "worst", "case", "proposed", "de", "giacomo", "massacci", "2000", "3", "structured", "programming", "correctness", "program", "historically", "logic", "program", "stem", "work", "late", "1960s", "computer", "scientist", "interested", "assigning", "meaning", "programming", "language", "finding", "rigorous", "standard", "proof", "program", "example", "proof", "may", "correctness", "program", "respect", "expected", "behavior", "termination", "program", "seminal", "paper", "floyd", "1967", "present", "analysis", "property", "structured", "computer", "program", "using", "flowchart", "early", "work", "yanov", "1959", "engeler", "1967", "advanced", "studied", "formal", "language", "property", "program", "connective", "expressed", "formalism", "hoare", "1969", "milestone", "advent", "pdl", "proposed", "rigorous", "axiomatic", "interpretation", "floyd", "flowchart", "often", "talk", "hoare", "logic", "floydhoare", "logic", "hoare", "calculus", "referring", "formalism", "hoare", "calculus", "concerned", "truth", "statement", "hoare", "triple", "a", "alpha", "b", "establishes", "connection", "precondition", "a", "program", "alpha", "postcondition", "b", "indicates", "whenever", "a", "hold", "precondition", "execution", "alpha", "b", "hold", "postcondition", "successful", "execution", "alpha", "true", "decade", "ago", "still", "case", "validating", "program", "often", "done", "testing", "reasonable", "variety", "input", "input", "yield", "expected", "output", "bug", "fixed", "eventually", "every", "tested", "input", "obtain", "expected", "output", "one", "reasonable", "belief", "program", "error", "however", "time", "consuming", "method", "validation", "leaf", "place", "untested", "input", "could", "fail", "finding", "error", "program", "implemented", "gone", "use", "even", "costly", "resource", "reasoning", "program", "correctness", "formal", "method", "crucial", "critical", "system", "since", "offer", "way", "proving", "exhaustively", "program", "error", "31", "hoare", "calculus", "illustrate", "sort", "principle", "program", "captured", "rule", "hoare", "calculus", "enough", "consult", "nb", "rule", "mean", "statement", "rule", "line", "holdthe", "premisesthen", "also", "statement", "rule", "linethe", "conclusion", "hold", "frac", "a", "alpha_1", "b", "quad", "b", "alpha_2", "c", "a", "alpha_1", "alpha_2", "c", "text", "rule", "composition", "rule", "composition", "capture", "elementary", "sequential", "composition", "program", "premise", "two", "assumption", "partial", "correctness", "two", "program", "alpha_1", "alpha_2", "first", "assumption", "alpha_1", "executed", "state", "satisfying", "a", "finish", "state", "satisfying", "b", "whenever", "halt", "second", "assumption", "alpha_2", "executed", "state", "satisfying", "b", "finish", "state", "satisfying", "c", "whenever", "halt", "conclusion", "rule", "partial", "correctness", "program", "alpha_1", "alpha_2", "ie", "alpha_1", "sequentially", "composed", "alpha_2", "follows", "two", "assumption", "namely", "conclude", "alpha_1", "alpha_2", "executed", "state", "satisfying", "a", "finish", "state", "satisfying", "c", "whenever", "halt", "rule", "iteration", "important", "one", "capture", "essential", "ability", "program", "execute", "portion", "code", "repeatedly", "certain", "condition", "cease", "hold", "frac", "land", "b", "alpha", "a", "a", "mathsf", "bmathsf", "alpha", "lnot", "b", "land", "a", "text", "rule", "iteration", "finally", "two", "rule", "consequence", "fundamental", "give", "formal", "basis", "intuitively", "clear", "reasoning", "involving", "weaker", "postconditions", "stronger", "precondition", "respectively", "frac", "a", "alpha", "b", "quad", "b", "rightarrow", "c", "a", "alpha", "c", "text", "rule", "consequence", "1", "frac", "crightarrow", "aquad", "a", "alpha", "b", "c", "alpha", "b", "text", "rule", "consequence", "2", "formalism", "presented", "hoare", "1969", "leave", "axiom", "schema", "would", "require", "firstorder", "language", "finally", "subsequent", "work", "hoare", "logic", "rule", "also", "often", "added", "see", "apt", "1979", "early", "overview", "32", "hoare", "calculus", "pdl", "dynamic", "logic", "come", "pratt", "interpretation", "hoare", "triple", "hoare", "calculus", "formalism", "modal", "logic", "modality", "alpha", "express", "formally", "state", "reachable", "executing", "program", "alpha", "satisfy", "formula", "a", "done", "writing", "alpha", "a", "thus", "hoare", "triple", "a", "alpha", "b", "simply", "captured", "pdl", "formula", "rightarrow", "alpha", "b", "addition", "important", "programming", "construct", "easily", "introduced", "pdl", "definitional", "abbreviation", "mathsf", "mathsf", "alpha", "mathsf", "else", "beta", "alpha", "cup", "lnot", "beta", "mathsf", "mathsf", "alpha", "alpha", "lnot", "mathsf", "repeat", "alpha", "mathsf", "alpha", "lnot", "alpha", "mathsf", "abort", "0", "mathsf", "skip", "1", "thus", "seems", "pdl", "wellequipped", "logically", "prove", "correctness", "structured", "program", "beyond", "rather", "handwaving", "connection", "pdl", "hoare", "calculus", "perhaps", "yet", "clear", "relate", "formally", "pdl", "fact", "generalization", "hoare", "calculus", "sense", "rule", "hoare", "calculus", "proven", "axiomatic", "system", "pdl", "rigorously", "hoare", "calculus", "contains", "axiom", "would", "require", "extended", "language", "firstorder", "dynamic", "logic", "quite", "remarkable", "show", "derived", "proof", "start", "assuming", "premise", "rule", "using", "assumption", "axiom", "rule", "pdl", "nothing", "else", "objective", "establish", "conclusion", "rule", "logically", "follows", "hence", "rule", "composition", "start", "assuming", "a", "alpha_1", "b", "rightarrow", "alpha_1", "b", "pdl", "formulation", "assuming", "b", "alpha_2", "c", "b", "rightarrow", "alpha_2", "c", "objective", "prove", "a", "alpha_1", "alpha_2", "c", "precisely", "want", "establish", "rightarrow", "alpha_1", "alpha_2", "c", "vdash", "deducible", "set", "formula", "rightarrow", "alpha_1", "b", "b", "rightarrow", "alpha_2", "c", "1", "rightarrow", "alpha_1", "b", "assumption", "a", "alpha_1", "b", "2", "b", "rightarrow", "alpha_2", "c", "assumption", "b", "alpha_2", "c", "3", "alpha_1", "b", "rightarrow", "alpha_1", "alpha_2", "c", "2", "using", "monotony", "alpha_1", "4", "rightarrow", "alpha_1", "alpha_2", "c", "1", "3", "using", "propositional", "reasoning", "5", "alpha_1", "alpha_2", "c", "leftrightarrow", "alpha_1", "alpha_2", "c", "axiom", "schema", "a1", "6", "rightarrow", "alpha_1", "alpha_2", "c", "4", "5", "using", "propositional", "reasoning", "a", "alpha_1", "alpha_2", "c", "proof", "rule", "iteration", "slightly", "involved", "1", "aland", "b", "rightarrow", "alpha", "a", "assumption", "land", "b", "alpha", "a", "2", "rightarrow", "b", "rightarrow", "alpha", "1", "using", "propositional", "reasoning", "3", "b", "alpha", "leftrightarrow", "b", "rightarrow", "alpha", "axiom", "schema", "a4", "4", "rightarrow", "b", "alpha", "a", "2", "3", "using", "propositional", "reasoning", "5", "b", "alpha", "leftrightarrow", "b", "alpha", "a", "axiom", "schema", "a1", "6", "rightarrow", "b", "alpha", "a", "4", "5", "using", "propositional", "reasoning", "7", "rightarrow", "b", "alpha", "a", "6", "using", "8", "rightarrow", "lnot", "b", "rightarrow", "lnot", "bland", "propositional", "tautology", "9", "rightarrow", "b", "alpha", "lnot", "b", "rightarrow", "lnot", "bland", "7", "8", "using", "monotony", "b", "alpha", "propositional", "reasoning", "10", "lnot", "b", "lnot", "bland", "leftrightarrow", "lnot", "b", "rightarrow", "lnot", "bland", "axiom", "schema", "a4", "11", "rightarrow", "b", "alpha", "lnot", "b", "lnot", "bland", "9", "10", "using", "monotony", "b", "alpha", "propositional", "reasoning", "12", "b", "alpha", "lnot", "b", "lnot", "bland", "leftrightarrow", "b", "alpha", "lnot", "b", "lnot", "bland", "axiom", "schema", "a1", "13", "rightarrow", "b", "alpha", "lnot", "b", "lnot", "bland", "12", "using", "propositional", "reasoning", "a", "mathsf", "b", "mathsf", "alpha", "lnot", "bland", "a", "context", "pdl", "two", "rule", "consequence", "fact", "special", "case", "rule", "composition", "obtain", "first", "rule", "substitute", "alpha_1", "alpha", "alpha_2", "mathsf", "skip", "obtain", "second", "rule", "substitute", "alpha_1", "mathsf", "skip", "alpha_2", "alpha", "suffices", "apply", "axiom", "schema", "a4", "remark", "alpha", "mathsf", "skip", "leftrightarrow", "alpha", "a", "mathsf", "skip", "alpha", "leftrightarrow", "alpha", "a", "also", "vdash", "deducible", "a", "alpha", "33", "total", "correctness", "hoare", "admission", "hoare", "1979", "original", "calculus", "merely", "starting", "point", "suffered", "quite", "limitation", "particularly", "allows", "one", "reason", "partial", "correctness", "truth", "statement", "a", "alpha", "b", "make", "sure", "execution", "alpha", "starting", "state", "satisfying", "a", "end", "state", "satisfying", "b", "halt", "partially", "correct", "program", "may", "nonterminating", "execution", "fact", "program", "terminating", "execution", "always", "partially", "correct", "case", "example", "program", "mathsf", "1", "mathsf", "mathsf", "skip", "formula", "rightarrow", "mathsf", "1", "mathsf", "mathsf", "skip", "b", "deducible", "formula", "a", "b", "calculus", "offer", "basis", "proof", "program", "terminates", "modified", "account", "total", "correctness", "program", "partial", "correctness", "plus", "termination", "achieved", "amending", "rule", "iteration", "present", "refer", "interested", "reader", "apt", "1981", "let", "u", "first", "observe", "deterministic", "program", "one", "already", "capture", "total", "correctness", "via", "formula", "kind", "rightarrow", "langlealpharangle", "b", "expression", "langlealpharangle", "b", "mean", "execution", "alpha", "terminates", "state", "satisfies", "b", "moreover", "alpha", "deterministic", "possible", "terminating", "execution", "unique", "execution", "alpha", "thus", "one", "first", "manages", "prove", "program", "deterministic", "trick", "work", "well", "enough", "prove", "total", "correctness", "general", "solution", "problem", "total", "correctness", "exists", "realm", "pdl", "need", "extend", "little", "pratt", "already", "alluded", "pratt", "1980b", "pdl", "expressive", "enough", "capture", "infinite", "looping", "program", "reaction", "pdl", "repeating", "rpdl", "introduced", "streett", "1982", "contains", "program", "alpha", "expression", "deltaalpha", "standing", "new", "proposition", "semantics", "v", "deltaalpha", "x", "exists", "infinite", "sequence", "z_0", "z_1", "ldots", "state", "z_0", "x", "n", "geq", "0", "z_n", "r", "alpha", "z_", "n1", "streett", "1982", "conjectured", "rpdl", "axiomatized", "adding", "proof", "system", "pdl", "precisely", "following", "axiom", "schema", "a6", "deltaalpha", "rightarrow", "langlealpharangle", "deltaalpha", "a7", "alpha", "rightarrow", "langlealpharangle", "rightarrow", "rightarrow", "deltaalpha", "proof", "conjecture", "provided", "sakalauskaite", "valiev", "1990", "version", "conjecture", "variant", "combinatory", "pdl", "also", "proved", "gargov", "passy", "1988", "easy", "see", "hoare", "calculus", "presented", "non", "termination", "come", "rule", "iteration", "analogously", "non", "termination", "pdl", "program", "come", "use", "unbounded", "iteration", "expression", "deltaalpha", "indicates", "alpha", "diverge", "kind", "notion", "need", "inductively", "define", "predicate", "infty", "program", "alpha", "formula", "infty", "alpha", "true", "exactly", "alpha", "enter", "nonterminating", "computation", "infty", "pi", "0", "piinpi_0", "infty", "0", "infty", "alpha", "cup", "beta", "infty", "alpha", "lor", "infty", "beta", "infty", "alpha", "beta", "infty", "alpha", "lor", "langlealpharangle", "infty", "beta", "infty", "alpha", "deltaalpha", "lor", "langlealpha", "rangle", "infty", "alpha", "finally", "total", "correctness", "program", "expressed", "via", "formula", "kind", "rightarrow", "lnot", "infty", "alpha", "land", "alpha", "b", "mean", "literally", "a", "case", "program", "alpha", "run", "forever", "every", "successful", "execution", "alpha", "end", "state", "satisfying", "b", "4", "variant", "result", "concerning", "comparative", "power", "expression", "decidability", "complexity", "axiomatization", "completeness", "number", "variant", "pdl", "obtained", "extending", "restricting", "syntax", "semantics", "constitute", "subject", "wealth", "literature", "say", "much", "address", "variant", "leaving", "big", "chunk", "otherwise", "important", "work", "dynamic", "logic", "41", "pdl", "without", "test", "axiom", "schema", "b", "leftrightarrow", "rightarrow", "b", "seems", "indicate", "every", "formula", "c", "exists", "equivalent", "testfree", "formula", "c", "ie", "testfree", "formula", "c", "models", "c", "leftrightarrow", "c", "interesting", "observe", "assertion", "untrue", "let", "pdl0", "restriction", "pdl", "testfree", "regular", "program", "ie", "program", "contain", "test", "berman", "paterson", "1981", "considered", "pdl", "formula", "langle", "p", "pi", "lnot", "p", "pi", "p", "rangle", "1", "langle", "mathsf", "p", "mathsf", "pi", "rangle", "langle", "pi", "rangle", "p", "proved", "pdl0", "formula", "equivalent", "hence", "pdl", "expressive", "power", "pdl0", "argument", "actually", "generalized", "follows", "n", "geq", "0", "let", "pdln1", "subset", "pdl", "program", "contain", "test", "a", "pdln", "formula", "n", "geq", "0", "berman", "paterson", "considered", "pdln1", "formula", "a_", "n1", "defined", "langle", "mathsf", "a_n", "mathsf", "pi_nrangle", "langle", "pi_nrangle", "a_n", "a_0", "p", "pi_0", "pi", "proved", "n", "geq", "0", "pdln", "formula", "equivalent", "a_", "n1", "hence", "n", "geq", "0", "pdln1", "expressive", "power", "pdln", "42", "pdl", "converse", "cpdl", "extension", "pdl", "converse", "construct", "considered", "since", "beginning", "pdl", "program", "alpha", "let", "alpha", "1", "stand", "new", "program", "semantics", "xr", "alpha", "1", "y", "iff", "yr", "alpha", "x", "converse", "construct", "allows", "u", "express", "fact", "state", "preceding", "current", "one", "reason", "backward", "program", "instance", "alpha", "1", "a", "mean", "executing", "alpha", "a", "hold", "models", "rightarrow", "alpha", "langle", "alpha", "1", "rangle", "a", "models", "rightarrow", "alpha", "1", "langle", "alpha", "rangle", "a", "addition", "converse", "construct", "change", "computational", "property", "pdl", "significant", "way", "adding", "every", "instance", "following", "axiom", "schema", "a8", "rightarrow", "alpha", "langle", "alpha", "1", "rangle", "a", "a9", "rightarrow", "alpha", "1", "langle", "alpha", "rangle", "a", "proof", "system", "pdl", "obtain", "sound", "complete", "deducibility", "predicate", "extended", "language", "see", "parikh", "1978", "detail", "cpdl", "small", "model", "property", "cpdlsat", "exptimecomplete", "easy", "notice", "cpdl", "expressive", "power", "pdl", "see", "consider", "cpdl", "formula", "langle", "pi", "1", "rangle", "1", "ltss", "w", "r", "v", "w", "r", "v", "w", "x", "y", "r", "pi", "x", "w", "y", "r", "pi", "emptyset", "v", "x", "v", "v", "emptyset", "since", "y", "sat", "langle", "pi", "1", "rangle", "1", "y", "sat", "langle", "pi", "1", "rangle", "1", "pdl", "formula", "a", "case", "y", "sat", "a", "iff", "y", "sat", "a", "clear", "pdl", "formula", "equivalent", "langle", "pi", "1", "rangle", "1", "43", "pdl", "repeating", "looping", "already", "exposed", "power", "repeating", "section", "33", "introducing", "rpdl", "summarize", "result", "rpdl", "connection", "variation", "notion", "repeating", "program", "concerning", "complexity", "theory", "rpdl", "streett", "1982", "already", "established", "rpdl", "finite", "model", "property", "precisely", "every", "rpdl", "satisfiable", "formula", "satisfiable", "model", "size", "triply", "exponential", "length", "a", "automatatheoretic", "argument", "permitted", "conclude", "problem", "rpdlsat", "solved", "deterministic", "triple", "exponential", "time", "3exptime", "gap", "upper", "bound", "deciding", "rpdlsat", "simple", "exponentialtime", "lower", "bound", "deciding", "pdlsat", "thus", "open", "problem", "found", "greatly", "connected", "growing", "interest", "computer", "scientist", "establishing", "complexity", "temporal", "logic", "specifically", "propositional", "modal", "mu", "calculus", "mmc", "due", "kozen", "1983", "rpdl", "linear", "blowup", "translation", "mmc", "vardi", "stockmeyer", "1985", "upper", "bound", "nondeterministic", "exponential", "time", "shown", "emerson", "jutla", "1988", "final", "form", "emerson", "jutla", "1999", "shown", "mmcsat", "rpdlsat", "exptimecomplete", "add", "converse", "operator", "section", "42", "one", "obtains", "crpdl", "complexity", "crpdlsat", "remained", "open", "year", "shown", "exptimecomplete", "achieved", "combining", "technique", "emerson", "jutla", "1988", "vardi", "1985", "vardi", "1998", "section", "33", "defined", "predicate", "infty", "infty", "alpha", "mean", "program", "alpha", "nonterminating", "computation", "call", "lpdl", "logic", "obtained", "augmenting", "pdl", "predicate", "infty", "clearly", "rpdl", "least", "expressive", "lpdl", "inductive", "definition", "infty", "alpha", "language", "rpdl", "witness", "rpdl", "fact", "strictly", "expressive", "lpdl", "shown", "harel", "sherman", "1982", "suspected", "rpdl", "lpdl", "expressive", "power", "pdl", "established", "proving", "formula", "rpdl", "lpdl", "equivalent", "expression", "pdl", "proof", "involves", "technique", "filtration", "designed", "collapse", "lts", "finite", "model", "leaving", "invariant", "truth", "falsity", "certain", "formula", "set", "pdl", "formula", "x", "consists", "grouping", "equivalence", "class", "state", "lts", "satisfy", "exactly", "formula", "x", "set", "equivalence", "class", "state", "thus", "obtained", "becomes", "set", "state", "filtrate", "model", "transition", "built", "appropriately", "carefully", "chosen", "set", "fl", "depends", "pdl", "formula", "a", "socalled", "fischerladner", "closure", "set", "subformulas", "a", "filtration", "lts", "m", "yield", "finite", "filtrate", "model", "m", "a", "satisfiable", "world", "u", "m", "satisfiable", "equivalence", "class", "containing", "u", "filtrate", "see", "fischer", "ladner", "1979", "consider", "filtration", "lts", "m", "w", "r", "v", "w", "j", "j", "text", "text", "integer", "1", "leq", "j", "leq", "i", "cup", "u", "j", "r", "pi", "j1", "1", "leq", "j", "leq", "i", "ur", "pi", "every", "i", "v", "p", "emptyset", "every", "p", "in", "phi_0", "one", "sentence", "go", "m", "world", "u", "infinite", "number", "finite", "pi", "paths", "growing", "length", "u", "sat", "lnotdeltapi", "u", "sat", "lnotinfty", "pi", "yet", "every", "pdl", "formula", "a", "deltapi", "infty", "pi", "satisfied", "equivalence", "class", "u", "model", "obtained", "filtration", "m", "fl", "indeed", "filtration", "must", "collapse", "state", "m", "create", "loop", "thus", "exists", "pdl", "formula", "express", "deltapi", "exists", "pdl", "formula", "express", "infty", "pi", "way", "making", "possible", "assertion", "program", "execute", "forever", "instance", "danecki", "1984a", "proposed", "predicate", "mathsf", "sloop", "qualify", "program", "enter", "strong", "loop", "v", "mathsf", "sloop", "alpha", "x", "xr", "alpha", "x", "let", "u", "call", "slpdl", "logic", "obtained", "augmenting", "pdl", "formula", "mathsf", "sloop", "alpha", "rpdl", "slpdl", "essentially", "incomparable", "predicate", "delta", "definable", "slpdl", "predicate", "mathsf", "sloop", "definable", "rpdl", "slpdl", "posse", "finite", "model", "property", "example", "formula", "pi", "langlepirangle", "1", "land", "lnotmathsf", "sloop", "pi", "satisfiable", "infinite", "ltss", "nonetheless", "danecki", "1984a", "established", "decidability", "slpdlsat", "formula", "deterministic", "exponential", "time", "44", "pdl", "intersection", "another", "construct", "studied", "intersection", "program", "adding", "intersection", "program", "pdl", "obtain", "logic", "ipdl", "ipdl", "program", "alpha", "beta", "expression", "alpha", "cap", "beta", "stand", "new", "program", "semantics", "xr", "alpha", "cap", "beta", "y", "iff", "xr", "alpha", "y", "xr", "beta", "y", "instance", "intended", "reading", "langle", "alpha", "cap", "beta", "rangle", "a", "execute", "alpha", "beta", "present", "state", "exists", "state", "reachable", "program", "satisfies", "a", "result", "models", "langle", "alpha", "cap", "beta", "rangle", "rightarrow", "langle", "alpha", "rangle", "land", "langle", "beta", "rangle", "a", "general", "models", "langle", "alpha", "rangle", "land", "langle", "beta", "rangle", "rightarrow", "langle", "alpha", "cap", "beta", "rangle", "a", "although", "intersection", "program", "important", "various", "application", "pdl", "artificial", "intelligence", "computer", "science", "eg", "context", "concurrency", "proof", "theory", "complexity", "theory", "pdl", "intersection", "remained", "unexplored", "several", "year", "concerning", "complexity", "theory", "ipdl", "difficulty", "appear", "one", "considers", "finite", "model", "property", "fact", "construct", "mathsf", "sloop", "alpha", "expressed", "ipdl", "propositional", "dynamic", "logic", "intersection", "equivalent", "langle", "alpha", "cap", "1", "rangle", "1", "thus", "adapt", "formula", "slpdl", "section", "43", "pi", "langle", "pi", "rangle", "1", "land", "pi", "cap", "1", "0", "satisfiable", "infinite", "ltss", "word", "ipdl", "posse", "finite", "model", "property", "danecki", "1984b", "investigated", "complexity", "theory", "ipdl", "showed", "deciding", "ipdlsat", "done", "deterministic", "double", "exponential", "time", "modern", "proof", "presented", "g\u00f6ller", "lohrey", "lutz", "2007", "complexity", "gap", "double", "exponentialtime", "upper", "bound", "deciding", "ipdlsat", "simple", "exponentialtime", "lower", "bound", "deciding", "pdlsat", "obtained", "fischer", "ladner", "1979", "remained", "open", "twenty", "year", "2004", "lange", "2005", "established", "lower", "bound", "exponential", "space", "ipdlsat", "2006", "lange", "lutz", "2005", "gave", "proof", "double", "exponentialtime", "lower", "bound", "satisfiability", "problem", "ipdl", "without", "test", "reduction", "word", "problem", "exponentially", "spacebounded", "alternating", "turing", "machine", "reduction", "role", "iteration", "construct", "essential", "since", "according", "massacci", "2001", "satisfiability", "problem", "iterationfree", "ipdl", "without", "test", "pspacecomplete", "adding", "converse", "construct", "ipdl", "obtain", "icpdl", "satisfiability", "problem", "icpdl", "proved", "2exptimecomplete", "g\u00f6ller", "lohrey", "lutz", "2007", "concerning", "proof", "theory", "ipdl", "difficulty", "appear", "realize", "axiom", "schema", "language", "pdl", "intersection", "corresponds", "semantics", "xr", "alpha", "cap", "beta", "y", "iff", "xr", "alpha", "y", "xr", "beta", "y", "program", "alpha", "cap", "beta", "way", "example", "axiom", "schema", "a1", "a2", "correspond", "semantics", "program", "alpha", "beta", "alpha", "cup", "beta", "respectively", "reason", "axiomatization", "pdl", "intersection", "open", "complete", "proof", "system", "developed", "balbiani", "vakarelov", "2003", "another", "variant", "pdl", "due", "peleg", "1987", "studied", "goldblatt", "1992b", "expression", "alpha", "cap", "beta", "interpreted", "alpha", "beta", "parallel", "context", "binary", "relation", "r", "alpha", "r", "beta", "longer", "set", "pair", "form", "x", "x", "y", "world", "rather", "set", "pair", "form", "x", "x", "world", "y", "set", "world", "inspired", "game", "logic", "parikh", "1985", "intepretation", "pdl", "program", "game", "game", "logic", "provides", "additional", "program", "construct", "dualizes", "program", "thus", "permitting", "define", "intersection", "program", "dual", "nondeterministic", "choice", "program", "5", "conclusion", "article", "focused", "propositional", "dynamic", "logic", "significant", "variant", "number", "booksgoldblatt", "1982", "goldblatt", "1992a", "harel", "1979", "harel", "kozen", "tiuryn", "2000", "and", "survey", "papersharel", "1984", "kozen", "tiuryn", "1990", "parikh", "1983", "treating", "pdl", "related", "formalism", "pratt", "offer", "pratt", "2017", "informal", "personal", "perspective", "development", "dynamic", "logic", "also", "historical", "value", "body", "research", "pdl", "certainly", "instrumental", "developing", "many", "logical", "theory", "system", "dynamic", "however", "theory", "arguably", "scope", "present", "article", "van", "eijck", "stokhof", "2006", "recent", "overview", "topic", "making", "use", "dynamic", "logic", "addressing", "various", "theme", "certain", "interest", "philosopher", "eg", "dynamic", "communication", "natural", "language", "semantics", "recent", "book", "going", "much", "detail", "newer", "topic", "dynamic", "logic", "knowledge", "dynamic", "epistemic", "logic", "van", "ditmarsch", "van", "der", "hoek", "kooi", "2007", "dynamic", "logic", "continuous", "hybrid", "system", "differential", "dynamic", "logic", "platzer", "2010", "pdl", "conceived", "primarily", "reasoning", "program", "many", "application", "modal", "logic", "reasoning", "program", "algorithmic", "logic", "closer", "pdl", "since", "allows", "one", "talk", "explicitly", "program", "reader", "invited", "consult", "work", "presented", "mirkowska", "salwicki", "1987", "temporal", "logic", "chief", "logic", "theoretical", "computer", "science", "close", "connection", "logic", "program", "allow", "one", "express", "temporal", "behavior", "transition", "system", "language", "abstract", "away", "label", "hence", "program", "see", "instance", "schneider", "2004", "overview", "foundation", "research", "area"]}