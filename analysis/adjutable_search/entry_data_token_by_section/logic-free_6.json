{
    "main_text": "Formal Systems || Tree Rules\n2.3 Tree Rules\n\nJeffrey-style tree rules (Jeffrey 1991) for PFL can be obtained by\nreplacing the classical rules for existentially and universally\nquantified formulas with the following:\n\n\nExistential Rule: If \\(\\exists xA\\) appears\nunchecked on an open path, check it, and\n\nif \\(x\\) is free in \\(A\\), choose a new individual constant \\(t\\)\nand list both \\(\\rE!t\\) and \\(A(t/x)\\) at the bottom of every open\npath beneath \\(\\exists xA\\), and\nif \\(x\\) is not free in \\(A\\), write \\(A\\) at the bottom of every\nopen path beneath \\(\\exists xA\\).\n\n\nUniversal Rule: If \\(\\forall xA\\) appears on\nan open path, then\n\nif \\(x\\) is free in \\(A\\), then where \\(t\\) is an individual\nconstant that occurs in a formula on that path, or a new individual\nconstant if there are none on the path, split the bottom of every open\npath beneath \\(\\forall xA\\) into two branches, writing \\({\\sim}\\rE!t\\)\nat the bottom of the first branch and \\(A(t/x)\\) at the bottom of the\nsecond, and\nif \\(x\\) is not free in \\(A\\), write \\(A\\) at the bottom of every\nopen path beneath \\(\\forall xA\\).\n\n\n\nFor languages that do not allow vacuous quantification, clause (ii)\ncan in each case be omitted. Non-inclusive free logic needs an\nadditional rule that introduces \\(\\rE!t\\) for some new individual\nconstant \\(t\\) if a path does not already contain a formula of this\nform.\n",
    "section_title": "2.3 Tree Rules",
    "entry_title": "Free Logic",
    "hierarchy_title": "Free Logic || Formal Systems || Tree Rules",
    "tokenized_text": [
        "formal",
        "system",
        "tree",
        "rule",
        "tree",
        "rule",
        "jeffreystyle",
        "tree",
        "rule",
        "jeffrey",
        "pfl",
        "obtained",
        "replacing",
        "classical",
        "rule",
        "existentially",
        "universally",
        "quantified",
        "formula",
        "following",
        "existential",
        "rule",
        "exists",
        "xa",
        "appears",
        "unchecked",
        "open",
        "path",
        "check",
        "x",
        "free",
        "a",
        "choose",
        "new",
        "individual",
        "constant",
        "t",
        "list",
        "re",
        "t",
        "tx",
        "bottom",
        "every",
        "open",
        "path",
        "beneath",
        "exists",
        "xa",
        "x",
        "free",
        "a",
        "write",
        "a",
        "bottom",
        "every",
        "open",
        "path",
        "beneath",
        "exists",
        "xa",
        "universal",
        "rule",
        "forall",
        "xa",
        "appears",
        "open",
        "path",
        "x",
        "free",
        "a",
        "t",
        "individual",
        "constant",
        "occurs",
        "formula",
        "path",
        "new",
        "individual",
        "constant",
        "none",
        "path",
        "split",
        "bottom",
        "every",
        "open",
        "path",
        "beneath",
        "forall",
        "xa",
        "two",
        "branch",
        "writing",
        "sim",
        "re",
        "t",
        "bottom",
        "first",
        "branch",
        "tx",
        "bottom",
        "second",
        "x",
        "free",
        "a",
        "write",
        "a",
        "bottom",
        "every",
        "open",
        "path",
        "beneath",
        "forall",
        "xa",
        "language",
        "allow",
        "vacuous",
        "quantification",
        "clause",
        "ii",
        "case",
        "omitted",
        "noninclusive",
        "free",
        "logic",
        "need",
        "additional",
        "rule",
        "introduces",
        "re",
        "t",
        "new",
        "individual",
        "constant",
        "t",
        "path",
        "already",
        "contain",
        "formula",
        "form"
    ]
}