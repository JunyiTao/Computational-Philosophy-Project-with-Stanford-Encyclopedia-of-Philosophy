{
    "main_text": "Generalized Quantifiers and Computation\n9. Generalized Quantifiers and Computation\n\nIn addition to the truth conditions associated with generalized\nquantifiers, one may study the computations required to establish the\ntruth of a quantified statement in a model. Indeed, generalized\nquantifiers turn up in various places in the part of computer science\nthat studies computational complexity. In this context, we\nrestrict attention to finite universes, and assume Isom\nthroughout. So a quantifier is essentially a\nset of finite models; by Isom we can assume\nthat models of cardinality m all have the same domain \\(M =\n\\{1,\\ldots,m\\}\\). Such models can be coded as words,\ni.e.\u00a0finite strings of symbols. For example, a model \\((M,A)\\) of\ntype \\({\\langle}1{\\rangle}\\) can be seen as a binary word \\(a_1\\ldots\na_m\\), where \\(a_i\\) is 1 if \\(i\\in A\\) and 0 otherwise. Thus \\(|A|\\)\nis the number of 1\u2019s and \\(|M\\!-\\!A|\\) the number of 0\u2019s;\nby Isom, the order in the string doesn\u2019t\nmatter. So Q becomes a set \\(W_Q\\) of words, that is, a\nformal language: a subset of the set of all finite strings of\ncoding\n symbols.[15]\n\nWe can now ask what it takes to recognize that a word belongs to\n\\(W_Q\\). The abstract notion of an automaton gives an answer;\nautomata are machines that accept or reject words,\nand they are classified according to the complexity of the operations\nthey perform. The language recognized by an automaton is the\nset of words it\n accepts.[16]\n\nA finite automaton has a finite number of states,\nincluding a start state and at least one accepting state. It starts\nscanning a word at the leftmost symbol in the start state, and at each\nstep it moves one symbol to the right and enters a (possibly) new\nstate, according to a given transition function. If it can\nmove along the whole word ending in an accepting state, the word is\naccepted. The application of automata theory to generalized\nquantifiers was initiated in van Benthem\n(1986) (Ch.\u00a07, \u201cSemantic automata\u201d). It is\neasy to construct a finite automaton recognizing \\(\\forall\\) (or\n\\(\\forall{^{\\text{rel}}}=\\) all), i.e., checking that\nw consists only of 1\u2019s: just remain in the start state =\naccepting state as long as 1\u2019s are encountered, but go to a\nrejecting state as soon as a 0 is scanned, and remain there whatever\nis encountered afterwards. A slightly more complex automaton\nrecognizes \\(Q_{\\text{even}}\\): again there are two states, a start\nstate = the accepting state and a rejecting state, and this time\nremain in the same state when 0\u2019s are scanned, but go to the\nother state when a 1 is scanned. To end in the accepting\nstate it is then necessary and sufficient that there are an even\nnumber of 1\u2019s. This machine essentially uses cycles of\nlength 2, whereas the first example had only 1-cycles. Call an\nautomaton of the latter kind acyclic. Van Benthem showed that\nthe FO-definable quantifiers are exactly the ones accepted by\nfinite automata that are acyclic and permutation\n closed.[17]\n\nA slightly more complex automaton, the pushdown automaton,\nhas rudimentary memory resources in the form a of stack of symbols\nthat can be pushed or popped from the top, enabling it to keep track\nto some extent of what went on at earlier steps. Another result by van\nBenthem is that the type \\({\\langle}1{\\rangle}\\) quantifiers accepted\nby pushdown automata are precisely those for which the corresponding\nbinary relation between numbers is definable (with first-order means)\nin additive arithmetic, i.e., in the model \\((N,+)\\), where\n\\(N = \\{0,1,2,\\ldots\\}\\). An example is \\(Q^R\\) (or its relativization\nmost): we have \\(Q^R(m,n) \\Leftrightarrow m < n\\), and the\nright hand side is definable in \\((N,+)\\) by \\(\\exists x (x \\neq 0\n\\wedge m + x =\n n)\\).[18]\n\nThus, an algorithmic characterization is matched with a logical one.\nThis is one prominent direction in the study of algorithmic\ncomplexity. Consider now the most general abstract automata or\ncomputational devices, i.e., Turing machines. One (of many)\ninteresting complexity classes is PTIME: a problem, identified with\nits corresponding set of words, is PTIME if there is a polynomial\n\\(p(x)\\) and a Turing machine accepting W such that whenever\n\\(w \\in W\\) has length n, the accepting computation takes at\nmost \\(p(n)\\) steps. PTIME problems are usually considered\n\u201ctractable\u201d, whereas more complex problems are\n\u201cintractable\u201d, such as EXPTIME ones, where the number of\nsteps required may grow exponentially. An early result by Immerman and\nVardi is that the PTIME sets of (words coding) finite models are\nprecisely those describable by single sentences in \\(\\FO(\\LFP)\\),\nwhich is FO logic with an added mechanism for forming\nleast\n fixed-points.[19]\n Here we need to represent not just monadic models but arbitrary ones.\nFor example, a binary relation on the universe \\(\\{1,\\ldots,m\\}\\) can\nbe represented by a word \\(w_{11}\\cdots w_{1m}\\# \\ldots \\#w_{m1}\\cdots\nw_{mm}\\), where the relation holds of \\((i,j)\\) iff \\(w_{ij} = 1\\).\nBut this time the order does seem to matter, and in fact the Immerman\nand Vardi result just mentioned only holds for models with a given\nlinear order and a binary predicate symbol standing for that\norder.\n\nLogics like \\(\\FO(\\LFP)\\) can be recast as logics of the form\n\\(\\FO(Q_1,Q_2,\\ldots)\\). Here infinitely many quantifiers may be\nrequired, but in some cases a single one suffices. As to\n\\(\\FO(\\LFP)\\), it suffices to add all the resumptions (see the end of\n section 5\n above) of a single quantifier. More generally, let\n\\(\\FO^*(Q_1,Q_2,\\ldots)\\) be like \\(\\FO(Q_1,Q_2,\\ldots)\\) but with\nmechanisms for making relativizations\n (section 7)\n and for resuming each \\(Q_i\\) to k-tuples for each k.\nThen there is a single quantifier Q such that \\(\\FO(\\LFP) =\n\\FO^*(Q)\\).\n\nSo generalized quantifiers remain a simple and versatile way of adding\nexpressive power to FO. One natural question was if the\nlogical characterization of PTIME mentioned above could be improved\nusing generalized quantifiers, in particular if one could remove the\nrestriction to ordered structures in this way. The answer, however,\nturned out to be negative, since Hella\n(1989) proved that the PTIME computable properties of arbitrary\nfinite structures cannot be characterized by adding a finite number of\ngeneralized quantifiers to FO, or even to \\(\\FO(\\LFP)\\). The\nquestion of whether PTIME can be characterized by a logic of the form\n\\(\\FO^*(Q)\\) remains open, however (indeed, solving it would be a\nmajor breakthrough in complexity theory).\n",
    "section_title": "9. Generalized Quantifiers and Computation",
    "entry_title": "Generalized Quantifiers",
    "hierarchy_title": "Generalized Quantifiers || Generalized Quantifiers and Computation",
    "tokenized_text": [
        "generalized",
        "quantifier",
        "computation",
        "generalized",
        "quantifier",
        "computation",
        "addition",
        "truth",
        "condition",
        "associated",
        "generalized",
        "quantifier",
        "one",
        "may",
        "study",
        "computation",
        "required",
        "establish",
        "truth",
        "quantified",
        "statement",
        "model",
        "indeed",
        "generalized",
        "quantifier",
        "turn",
        "various",
        "place",
        "part",
        "computer",
        "science",
        "study",
        "computational",
        "complexity",
        "context",
        "restrict",
        "attention",
        "finite",
        "universe",
        "assume",
        "isom",
        "throughout",
        "quantifier",
        "essentially",
        "set",
        "finite",
        "model",
        "isom",
        "assume",
        "model",
        "cardinality",
        "domain",
        "ldots",
        "m",
        "model",
        "coded",
        "word",
        "ie",
        "finite",
        "string",
        "symbol",
        "example",
        "model",
        "type",
        "langle",
        "rangle",
        "seen",
        "binary",
        "word",
        "a_ldots",
        "a_m",
        "a_i",
        "iin",
        "a",
        "otherwise",
        "thus",
        "a",
        "number",
        "m",
        "a",
        "number",
        "isom",
        "order",
        "string",
        "matter",
        "q",
        "becomes",
        "set",
        "w_q",
        "word",
        "formal",
        "language",
        "subset",
        "set",
        "finite",
        "string",
        "coding",
        "symbol",
        "ask",
        "take",
        "recognize",
        "word",
        "belongs",
        "w_q",
        "abstract",
        "notion",
        "automaton",
        "give",
        "answer",
        "automaton",
        "machine",
        "accept",
        "reject",
        "word",
        "classified",
        "according",
        "complexity",
        "operation",
        "perform",
        "language",
        "recognized",
        "automaton",
        "set",
        "word",
        "accepts",
        "finite",
        "automaton",
        "finite",
        "number",
        "state",
        "including",
        "start",
        "state",
        "least",
        "one",
        "accepting",
        "state",
        "start",
        "scanning",
        "word",
        "leftmost",
        "symbol",
        "start",
        "state",
        "step",
        "move",
        "one",
        "symbol",
        "right",
        "enters",
        "possibly",
        "new",
        "state",
        "according",
        "given",
        "transition",
        "function",
        "move",
        "along",
        "whole",
        "word",
        "ending",
        "accepting",
        "state",
        "word",
        "accepted",
        "application",
        "automaton",
        "theory",
        "generalized",
        "quantifier",
        "initiated",
        "van",
        "benthem",
        "ch",
        "semantic",
        "automaton",
        "easy",
        "construct",
        "finite",
        "automaton",
        "recognizing",
        "forall",
        "forall",
        "text",
        "rel",
        "ie",
        "checking",
        "w",
        "consists",
        "remain",
        "start",
        "state",
        "accepting",
        "state",
        "long",
        "encountered",
        "go",
        "rejecting",
        "state",
        "soon",
        "scanned",
        "remain",
        "whatever",
        "encountered",
        "afterwards",
        "slightly",
        "complex",
        "automaton",
        "recognizes",
        "q_",
        "text",
        "even",
        "two",
        "state",
        "start",
        "state",
        "accepting",
        "state",
        "rejecting",
        "state",
        "time",
        "remain",
        "state",
        "scanned",
        "go",
        "state",
        "scanned",
        "end",
        "accepting",
        "state",
        "necessary",
        "sufficient",
        "even",
        "number",
        "machine",
        "essentially",
        "us",
        "cycle",
        "length",
        "whereas",
        "first",
        "example",
        "cycles",
        "call",
        "automaton",
        "latter",
        "kind",
        "acyclic",
        "van",
        "benthem",
        "showed",
        "fodefinable",
        "quantifier",
        "exactly",
        "one",
        "accepted",
        "finite",
        "automaton",
        "acyclic",
        "permutation",
        "closed",
        "slightly",
        "complex",
        "automaton",
        "pushdown",
        "automaton",
        "rudimentary",
        "memory",
        "resource",
        "form",
        "stack",
        "symbol",
        "pushed",
        "popped",
        "top",
        "enabling",
        "keep",
        "track",
        "extent",
        "went",
        "earlier",
        "step",
        "another",
        "result",
        "van",
        "benthem",
        "type",
        "langle",
        "rangle",
        "quantifier",
        "accepted",
        "pushdown",
        "automaton",
        "precisely",
        "corresponding",
        "binary",
        "relation",
        "number",
        "definable",
        "firstorder",
        "mean",
        "additive",
        "arithmetic",
        "ie",
        "model",
        "n",
        "n",
        "ldots",
        "example",
        "qr",
        "relativization",
        "qr",
        "n",
        "leftrightarrow",
        "n",
        "right",
        "hand",
        "side",
        "definable",
        "n",
        "exists",
        "x",
        "x",
        "neq",
        "wedge",
        "x",
        "n",
        "thus",
        "algorithmic",
        "characterization",
        "matched",
        "logical",
        "one",
        "one",
        "prominent",
        "direction",
        "study",
        "algorithmic",
        "complexity",
        "consider",
        "general",
        "abstract",
        "automaton",
        "computational",
        "device",
        "ie",
        "turing",
        "machine",
        "one",
        "many",
        "interesting",
        "complexity",
        "class",
        "ptime",
        "problem",
        "identified",
        "corresponding",
        "set",
        "word",
        "ptime",
        "polynomial",
        "p",
        "x",
        "turing",
        "machine",
        "accepting",
        "w",
        "whenever",
        "w",
        "in",
        "w",
        "length",
        "n",
        "accepting",
        "computation",
        "take",
        "p",
        "n",
        "step",
        "ptime",
        "problem",
        "usually",
        "considered",
        "tractable",
        "whereas",
        "complex",
        "problem",
        "intractable",
        "exptime",
        "one",
        "number",
        "step",
        "required",
        "may",
        "grow",
        "exponentially",
        "early",
        "result",
        "immerman",
        "vardi",
        "ptime",
        "set",
        "word",
        "coding",
        "finite",
        "model",
        "precisely",
        "describable",
        "single",
        "sentence",
        "fo",
        "lfp",
        "fo",
        "logic",
        "added",
        "mechanism",
        "forming",
        "least",
        "fixedpoints",
        "need",
        "represent",
        "monadic",
        "model",
        "arbitrary",
        "one",
        "example",
        "binary",
        "relation",
        "universe",
        "ldots",
        "m",
        "represented",
        "word",
        "w_",
        "cdots",
        "w_",
        "m",
        "ldots",
        "w_",
        "m",
        "cdots",
        "w_",
        "mm",
        "relation",
        "hold",
        "j",
        "iff",
        "w_",
        "ij",
        "time",
        "order",
        "seem",
        "matter",
        "fact",
        "immerman",
        "vardi",
        "result",
        "mentioned",
        "hold",
        "model",
        "given",
        "linear",
        "order",
        "binary",
        "predicate",
        "symbol",
        "standing",
        "order",
        "logic",
        "like",
        "fo",
        "lfp",
        "recast",
        "logic",
        "form",
        "fo",
        "q_",
        "q_",
        "ldots",
        "infinitely",
        "many",
        "quantifier",
        "may",
        "required",
        "case",
        "single",
        "one",
        "suffices",
        "fo",
        "lfp",
        "suffices",
        "add",
        "resumption",
        "see",
        "end",
        "section",
        "single",
        "quantifier",
        "generally",
        "let",
        "fo",
        "q_",
        "q_",
        "ldots",
        "like",
        "fo",
        "q_",
        "q_",
        "ldots",
        "mechanism",
        "making",
        "relativizations",
        "section",
        "resuming",
        "q_i",
        "ktuples",
        "k",
        "single",
        "quantifier",
        "q",
        "fo",
        "lfp",
        "fo",
        "q",
        "generalized",
        "quantifier",
        "remain",
        "simple",
        "versatile",
        "way",
        "adding",
        "expressive",
        "power",
        "fo",
        "one",
        "natural",
        "question",
        "logical",
        "characterization",
        "ptime",
        "mentioned",
        "could",
        "improved",
        "using",
        "generalized",
        "quantifier",
        "particular",
        "one",
        "could",
        "remove",
        "restriction",
        "ordered",
        "structure",
        "way",
        "answer",
        "however",
        "turned",
        "negative",
        "since",
        "hella",
        "proved",
        "ptime",
        "computable",
        "property",
        "arbitrary",
        "finite",
        "structure",
        "characterized",
        "adding",
        "finite",
        "number",
        "generalized",
        "quantifier",
        "fo",
        "even",
        "fo",
        "lfp",
        "question",
        "whether",
        "ptime",
        "characterized",
        "logic",
        "form",
        "fo",
        "q",
        "remains",
        "open",
        "however",
        "indeed",
        "solving",
        "would",
        "major",
        "breakthrough",
        "complexity",
        "theory"
    ]
}