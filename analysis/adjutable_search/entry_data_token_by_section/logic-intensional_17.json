{
    "main_text": "Sense as Algorithm || Denotation\n4.3 Denotation\nWe have been discussing sentences and more generally formulas with\nfree variables. The familiar Tarskian semantics provides a basis for\nunderstanding here, but we need modifications and extensions to deal\nwith the construct.\nA partial function on a space \\(S\\) is a function that\nassigns values to some, but not necessarily to all, members of\n\\(S\\). Said otherwise, it is a function whose domain is a subset of\n\\(S\\). For a partial function \\(f\\), \\(f(x)\\simeq y\\) means \\(x\\) is\nin the domain of \\(f\\) and \\(f(x) = y\\). (Finally we have a proper\naccounting of our use of \\(\\simeq\\) in the examples\nearlier.) Partial relations are partial functions from\n\\(k\\)-tuples to \\(\\{{\\textsf{t}}, {\\textsf{f}}\\}\\). The given\nrelations of our structures are relations in the usual sense, but it\nis partial relations that we may find ourselves defining.\nAssume we have a structure \\(\\langle\\bD, \\bR_1,\n\\ldots, \\bR_n\\rangle\\), and suppose we have an LPCR language\nassociated with it. A valuation \\(v\\) in this structure is a\nmapping from individual variables to members of \\(\\bD\\) and\nfrom auxiliary relation symbols to partial relations on\n\\(\\bD\\). We would like to associate with each valuation \\(v\\) a\nmapping \\(T_v\\) from formulas of LPCR to truth values but since things\nlike the liar sentence are formulable, \\(T_v\\) must be a partial\nfunction, and so we must be careful even about familiar things like\npropositional connectives. Various three valued logics have been\ndeveloped; perhaps the most common is Kleene\u2019s strong\nthree-valued logic, motivated by recursion theory and familiar from\nmuch work on the Theory of Truth. The following table says how\nconnectives and quantifiers behave. Cases that are not explicitly\ncovered are understood to be those for which a truth valuation is left\nundefined. (For instance, if the truth value of \\(X\\) is undefined,\nthe same is the case for \\(\\lnot X\\).)\n\n\\[\\begin{array}{rc@{\\mbox{if\\ \\ }}l}\nT_v(\\lnot X) \\simeq {\\textsf{t}}&& T_v(X) \\simeq {\\textsf{f}}\\\\\nT_v(\\lnot X) \\simeq {\\textsf{f}}&& T_v(X) \\simeq {\\textsf{t}}\\\\\nT_v(X \\land Y) \\simeq {\\textsf{t}}&& T_v(X) \\simeq {\\textsf{t}}\\mbox{ and } T_v(Y) \\simeq {\\textsf{t}}\\\\\nT_v(X \\land Y) \\simeq {\\textsf{f}}&& T_v(X) \\simeq {\\textsf{f}}\\mbox{ or } T_v(Y) \\simeq {\\textsf{f}}\\\\\nT_v(X \\lor Y) \\simeq {\\textsf{t}}&& T_v(X) \\simeq {\\textsf{t}}\\mbox{ or } T_v(Y) \\simeq {\\textsf{t}}\\\\\nT_v(X \\lor Y) \\simeq {\\textsf{f}}&& T_v(X) \\simeq {\\textsf{f}}\\mbox{ and } T_v(Y) \\simeq {\\textsf{f}}\\\\\nT_v((\\forall x)X) \\simeq {\\textsf{t}}&& T_{v'}(X) \\simeq {\\textsf{t}}\\mbox{ for all \\(x\\)-variants \\(v'\\) of \\(v\\)}\\\\\nT_v((\\forall x)X) \\simeq {\\textsf{f}}&& T_{v'}(X) \\simeq {\\textsf{f}}\\mbox{ for some \\(x\\)-variant \\(v'\\) of \\(v\\)}\\\\\nT_v((\\exists x)X) \\simeq {\\textsf{t}}&& T_{v'}(X) \\simeq {\\textsf{t}}\\mbox{ for some \\(x\\)-variant \\(v'\\) of \\(v\\)}\\\\\nT_v((\\exists x)X) \\simeq {\\textsf{f}}&& T_{v'}(X) \\simeq {\\textsf{f}}\\mbox{ for all \\(x\\)-variants \\(v'\\) of \\(v\\)}\n\\end{array}\\]\n\nThis still leaves formulas to deal with. Suppose we have the following.\n\n\\[\\tag{23}\\label{Eexample}\n\\phi_0 \\textsf{ where } \\{ P_1(\\bx_1) \\simeq \\phi_1, \\ldots, P_k(\\bx_k) \\simeq \\phi_k\\}\\] \n\nWe make two simplifying assumptions to keep our discussion from\nbeing too intricate. We assume no \\(\\phi_i\\) contains a nested\n\\(\\textsf{ where }\\) clause. The basic ideas are amply illustrated with this condition\nimposed, but everything extends to the general case without too much\ndifficulty. It is a general requirement that the variables in\n\\(\\bx_i\\) are \u2018local\u2019 to \\(P_i(\\bx_i) \\simeq\n\\phi_i\\), that is, they are considered to be bound in this formula. To\nthis we add another simplifying assumption: the variables in\n\\(\\bx_i\\) are the only variables that may occur free\nin \\(\\phi_i\\). Roughly this means that we have no parameters, only\nlocal variables. This serves to allow us to discuss things with less\nclutter. Again, everything extends to the more general case with no\nfundamental changes.\nContinuing with \\eqref{Eexample}, consider the following associated set\n\\(E\\) of equations.\n\n\\[\\tag{24}\\label{equationsE}\n\\begin{align}\nP_1(\\bx_1) &\\simeq \\phi_1\\\\\nP_2(\\bx_2) &\\simeq \\phi_2\\\\\n&\\vdots\\\\\nP_k(\\bx_k) &\\simeq \\phi_k\n\\end{align}\\] \n\nThe difficulty, of course, is that each \\(P_i\\) is allowed to occur\nin one or more \\(\\phi_j\\), possibly even in \\(\\phi_i\\), and so \\(E\\)\nis self-referential. In many computer programming languages one sees\nthings like \\(x = x+1\\). It is explained to beginning programmers that\nthis takes the current value of \\(x\\), adds 1, and calls the result\n\\(x\\) again. Occurrences of \\(x\\) on the right have\n\u2018before\u2019 values, occurrences on the left have\n\u2018after\u2019 values. Analogously, let us think of the members\nof \\(E\\) as (simultaneous) assignment statements. Occurrences of\n\\(P_i\\) on the right of \\(\\simeq\\) are current values, occurrences on\nthe left are next values. Taking all of \\(P_1\\), \u2026, \\(P_k\\)\ninto account, we can think of \\(E\\) as defining a functional that maps\n\\(k\\)-tuples of partial relations (\u2018before\u2019 values of\nthese relation symbols) to \\(k\\)-tuples of partial relations\n(\u2018after\u2019 values of these relation symbols). Now here are\nthe details a bit more formally.\nSuppose we have a \\(k\\)-tuple \\(\\langle\\bP_1, \\ldots,\n\\bP_k\\rangle\\) of partial relations, where for each \\(i\\) the\narity of \\(\\bP_i\\) matches that of the partial relation\nvariable \\(P_i\\). This is our input (\u2018before\u2019 values). For\neach \\(i\\) we want to define an output partial relation which we call\n\\(\\bP'_i\\), of the same arity as \\(\\bP_i\\), so that\n\\(\\langle\\bP'_1, \\ldots, \\bP'_k\\rangle\\) serves as our\noverall output (\u2018after\u2019 values). To do this we must say\nwhen \\(\\bP'_i(\\bd)\\) maps to \\({\\textsf{t}}\\), when it\nmaps to \\({\\textsf{f}}\\), and when it is undefined, for each\n\\(\\bd\\) with components from \\(\\bD\\). Well, take \\(v\\)\nto be a valuation assigning to each auxiliary relation symbol \\(P_i\\)\nthe corresponding partial relation \\(\\bP_i\\) (this is how\n\u2018before\u2019 values for our partial relation symbols come in),\nand assigning to the variables in \\(\\bx_i\\) the corresponding\nmembers of \\(\\bd\\). Now, simply let\n\\(\\bP'_i(\\bd)\\simeq T_v(\\phi_i)\\). In this way a new\npartial relation \\(\\bP'_i\\) is specified, and more generally a\nvector of them, \\(\\langle\\bP'_1, \\ldots,\n\\bP'_k\\rangle\\). The set of equations \\(E\\) can be thought of\nas specifying a functional transforming \\(k\\)-tuple\n\\(\\langle\\bP_1, \\ldots, \\bP_k\\rangle\\) into\n\\(\\langle\\bP'_1, \\ldots, \\bP'_k\\rangle\\). Let us call\nthis functional \\([E]\\), and write \\([E](\\langle\\bP_1, \\ldots,\n\\bP_k\\rangle) = \\langle\\bP'_1, \\ldots,\n\\bP'_k\\rangle\\).\nIf we are to have equations \\(E\\) behave well in a logic setting,\neach \\(P_i\\) should have the same valuation no matter where we see\nit\u2014there should be no distinction between what we have been\ncalling left and right sides; \\(\\bP_i\\) and \\(\\bP'_i\\)\nshould be the same. In other words, we would like to have partial\nrelations \\(\\bP_1\\), \u2026, \\(\\bP_k\\) to interpret\n\\(P_1\\), \u2026, \\(P_k\\) so that \\([E](\\langle\\bP_1, \\ldots,\n\\bP_k\\rangle) = \\langle\\bP_1, \\ldots,\n\\bP_k\\rangle\\)\u2014\u2018before\u2019 and\n\u2018after\u2019 values agree. This is called a fixed\npoint of \\([E]\\). So, we need to know that \\([E]\\) has a fixed\npoint, and if it has more than one then there is a plausible candidate\nwe can choose as the best one.\nIf \\(f\\) and \\(g\\) are two partial functions from a space \\(S\\) to\n\\(R\\), one writes \\(f\\subseteq g\\) to mean that whenever \\(f(x)\\simeq\nw\\) then also \\(g(x)\\simeq w\\). Then for two partial relations\n\\(\\bP\\) and \\(\\bQ\\) of the same arity,\n\\(\\bP\\subseteq\\bQ\\) means that whenever\n\\(\\bP(\\bd)\\) is defined, so is\n\\(\\bQ(\\bd)\\), and both have the same truth value. We can\nextend this to \\(k\\)-tuples by setting \\(\\langle\\bP_1, \\ldots,\n\\bP_k\\rangle\\subseteq\\langle\\bQ_1, \\ldots,\n\\bQ_k\\rangle\\) if \\(\\bP_i\\subseteq\\bQ_i\\) for\neach \\(i\\). It is not terribly difficult to show that the functional\n\\([E]\\) defined above, and based on \\eqref{Eexample}, has\nthe monotonicity property: if \\(\\langle\\bP_1, \\ldots,\n\\bP_k\\rangle\\subseteq\\langle\\bQ_1, \\ldots,\n\\bQ_k\\rangle\\) then \\([E](\\langle\\bP_1, \\ldots,\n\\bP_k\\rangle)\\subseteq[E](\\langle\\bQ_1, \\ldots,\n\\bQ_k\\rangle)\\). There is a very general theory of monotone\nmappings like this, from which it follows that \\([E]\\) does have a\nfixed point. Moreover, if there are more than one then there is a\nunique one that is least, in the sense that it is in the \\(\\subseteq\\)\nrelation to any other. This least fixed point is precisely the best\ncandidate we mentioned above. It contains the information that any\nfixed point must have.\nNow we finish saying how to evaluate the formula\n\\eqref{Eexample}. First, construct the associated set of equations,\n\\(E\\). Next, construct the functional \\([E]\\). There is a least fixed\npoint for \\([E]\\), let us say it is \\(\\langle\\bF_1, \\ldots,\n\\bF_k\\rangle\\). Finally, evaluate \\(\\phi_0\\) using\n\\(\\bF_i\\) to interpret \\(P_i\\) for each \\(i\\). The resulting\ntruth value, or undefined, is the value (denotation) associated with\n\\eqref{Eexample}.\nWe have now said how to associate a truth value, or undefined, with\nevery formula of LPCR (under our simplifying assumptions). We have\n(partial) denotations.\n",
    "section_title": "4.3 Denotation",
    "entry_title": "Intensional Logic",
    "hierarchy_title": "Intensional Logic || Sense as Algorithm || Denotation",
    "tokenized_text": [
        "sense",
        "algorithm",
        "denotation",
        "denotation",
        "discussing",
        "sentence",
        "generally",
        "formula",
        "free",
        "variable",
        "familiar",
        "tarskian",
        "semantics",
        "provides",
        "basis",
        "understanding",
        "need",
        "modification",
        "extension",
        "deal",
        "construct",
        "partial",
        "function",
        "space",
        "s",
        "function",
        "assigns",
        "value",
        "necessarily",
        "member",
        "s",
        "said",
        "otherwise",
        "function",
        "whose",
        "domain",
        "subset",
        "s",
        "partial",
        "function",
        "f",
        "f",
        "x",
        "simeq",
        "y",
        "mean",
        "x",
        "domain",
        "f",
        "f",
        "x",
        "y",
        "finally",
        "proper",
        "accounting",
        "use",
        "simeq",
        "example",
        "earlier",
        "partial",
        "relation",
        "partial",
        "function",
        "k",
        "tuples",
        "textsf",
        "textsf",
        "f",
        "given",
        "relation",
        "structure",
        "relation",
        "usual",
        "sense",
        "partial",
        "relation",
        "may",
        "find",
        "defining",
        "assume",
        "structure",
        "langlebd",
        "br_",
        "ldots",
        "br_nrangle",
        "suppose",
        "lpcr",
        "language",
        "associated",
        "valuation",
        "v",
        "structure",
        "mapping",
        "individual",
        "variable",
        "member",
        "bd",
        "auxiliary",
        "relation",
        "symbol",
        "partial",
        "relation",
        "bd",
        "would",
        "like",
        "associate",
        "valuation",
        "v",
        "mapping",
        "t_v",
        "formula",
        "lpcr",
        "truth",
        "value",
        "since",
        "thing",
        "like",
        "liar",
        "sentence",
        "formulable",
        "t_v",
        "must",
        "partial",
        "function",
        "must",
        "careful",
        "even",
        "familiar",
        "thing",
        "like",
        "propositional",
        "connective",
        "various",
        "three",
        "valued",
        "logic",
        "developed",
        "perhaps",
        "common",
        "kleene",
        "strong",
        "threevalued",
        "logic",
        "motivated",
        "recursion",
        "theory",
        "familiar",
        "much",
        "work",
        "theory",
        "truth",
        "following",
        "table",
        "say",
        "connective",
        "quantifier",
        "behave",
        "case",
        "explicitly",
        "covered",
        "understood",
        "truth",
        "valuation",
        "left",
        "undefined",
        "instance",
        "truth",
        "value",
        "x",
        "undefined",
        "case",
        "lnot",
        "x",
        "begin",
        "array",
        "rc",
        "mbox",
        "if",
        "l",
        "t_v",
        "lnot",
        "x",
        "simeq",
        "textsf",
        "t_v",
        "x",
        "simeq",
        "textsf",
        "f",
        "t_v",
        "lnot",
        "x",
        "simeq",
        "textsf",
        "f",
        "t_v",
        "x",
        "simeq",
        "textsf",
        "t_v",
        "x",
        "land",
        "simeq",
        "textsf",
        "t_v",
        "x",
        "simeq",
        "textsf",
        "mbox",
        "t_v",
        "simeq",
        "textsf",
        "t_v",
        "x",
        "land",
        "simeq",
        "textsf",
        "f",
        "t_v",
        "x",
        "simeq",
        "textsf",
        "f",
        "mbox",
        "t_v",
        "simeq",
        "textsf",
        "f",
        "t_v",
        "x",
        "lor",
        "simeq",
        "textsf",
        "t_v",
        "x",
        "simeq",
        "textsf",
        "mbox",
        "t_v",
        "simeq",
        "textsf",
        "t_v",
        "x",
        "lor",
        "simeq",
        "textsf",
        "f",
        "t_v",
        "x",
        "simeq",
        "textsf",
        "f",
        "mbox",
        "t_v",
        "simeq",
        "textsf",
        "f",
        "t_v",
        "forall",
        "x",
        "x",
        "simeq",
        "textsf",
        "t_",
        "v",
        "x",
        "simeq",
        "textsf",
        "mbox",
        "x",
        "variants",
        "v",
        "v",
        "t_v",
        "forall",
        "x",
        "x",
        "simeq",
        "textsf",
        "f",
        "t_",
        "v",
        "x",
        "simeq",
        "textsf",
        "f",
        "mbox",
        "x",
        "variant",
        "v",
        "v",
        "t_v",
        "exists",
        "x",
        "x",
        "simeq",
        "textsf",
        "t_",
        "v",
        "x",
        "simeq",
        "textsf",
        "mbox",
        "x",
        "variant",
        "v",
        "v",
        "t_v",
        "exists",
        "x",
        "x",
        "simeq",
        "textsf",
        "f",
        "t_",
        "v",
        "x",
        "simeq",
        "textsf",
        "f",
        "mbox",
        "x",
        "variants",
        "v",
        "v",
        "end",
        "array",
        "still",
        "leaf",
        "formula",
        "deal",
        "suppose",
        "following",
        "tag",
        "label",
        "eexample",
        "phi_",
        "textsf",
        "p_",
        "bx_",
        "simeq",
        "phi_",
        "ldots",
        "p_k",
        "bx_k",
        "simeq",
        "phi_k",
        "make",
        "two",
        "simplifying",
        "assumption",
        "keep",
        "discussion",
        "intricate",
        "assume",
        "phi_i",
        "contains",
        "nested",
        "textsf",
        "clause",
        "basic",
        "idea",
        "amply",
        "illustrated",
        "condition",
        "imposed",
        "everything",
        "extends",
        "general",
        "case",
        "without",
        "much",
        "difficulty",
        "general",
        "requirement",
        "variable",
        "bx_i",
        "local",
        "p_i",
        "bx_i",
        "simeq",
        "phi_i",
        "considered",
        "bound",
        "formula",
        "add",
        "another",
        "simplifying",
        "assumption",
        "variable",
        "bx_i",
        "variable",
        "may",
        "occur",
        "free",
        "phi_i",
        "roughly",
        "mean",
        "parameter",
        "local",
        "variable",
        "serf",
        "allow",
        "u",
        "discus",
        "thing",
        "le",
        "clutter",
        "everything",
        "extends",
        "general",
        "case",
        "fundamental",
        "change",
        "continuing",
        "eqref",
        "eexample",
        "consider",
        "following",
        "associated",
        "set",
        "e",
        "equation",
        "tag",
        "label",
        "equationse",
        "begin",
        "align",
        "p_",
        "bx_",
        "simeq",
        "phi_",
        "p_",
        "bx_",
        "simeq",
        "phi_",
        "vdots",
        "p_k",
        "bx_k",
        "simeq",
        "phi_k",
        "end",
        "align",
        "difficulty",
        "course",
        "p_i",
        "allowed",
        "occur",
        "one",
        "phi_j",
        "possibly",
        "even",
        "phi_i",
        "e",
        "selfreferential",
        "many",
        "computer",
        "programming",
        "language",
        "one",
        "see",
        "thing",
        "like",
        "x",
        "x",
        "explained",
        "beginning",
        "programmer",
        "take",
        "current",
        "value",
        "x",
        "add",
        "call",
        "result",
        "x",
        "occurrence",
        "x",
        "right",
        "value",
        "occurrence",
        "left",
        "value",
        "analogously",
        "let",
        "u",
        "think",
        "member",
        "e",
        "simultaneous",
        "assignment",
        "statement",
        "occurrence",
        "p_i",
        "right",
        "simeq",
        "current",
        "value",
        "occurrence",
        "left",
        "next",
        "value",
        "taking",
        "p_",
        "p_k",
        "account",
        "think",
        "e",
        "defining",
        "functional",
        "map",
        "k",
        "tuples",
        "partial",
        "relation",
        "value",
        "relation",
        "symbol",
        "k",
        "tuples",
        "partial",
        "relation",
        "value",
        "relation",
        "symbol",
        "detail",
        "bit",
        "formally",
        "suppose",
        "k",
        "tuple",
        "langlebp_",
        "ldots",
        "bp_krangle",
        "partial",
        "relation",
        "i",
        "arity",
        "bp_i",
        "match",
        "partial",
        "relation",
        "variable",
        "p_i",
        "input",
        "value",
        "i",
        "want",
        "define",
        "output",
        "partial",
        "relation",
        "call",
        "bp_i",
        "arity",
        "bp_i",
        "langlebp_",
        "ldots",
        "bp_krangle",
        "serf",
        "overall",
        "output",
        "value",
        "must",
        "say",
        "bp_i",
        "bd",
        "map",
        "textsf",
        "map",
        "textsf",
        "f",
        "undefined",
        "bd",
        "component",
        "bd",
        "well",
        "take",
        "v",
        "valuation",
        "assigning",
        "auxiliary",
        "relation",
        "symbol",
        "p_i",
        "corresponding",
        "partial",
        "relation",
        "bp_i",
        "value",
        "partial",
        "relation",
        "symbol",
        "come",
        "assigning",
        "variable",
        "bx_i",
        "corresponding",
        "member",
        "bd",
        "simply",
        "let",
        "bp_i",
        "bd",
        "simeq",
        "t_v",
        "phi_i",
        "way",
        "new",
        "partial",
        "relation",
        "bp_i",
        "specified",
        "generally",
        "vector",
        "langlebp_",
        "ldots",
        "bp_krangle",
        "set",
        "equation",
        "e",
        "thought",
        "specifying",
        "functional",
        "transforming",
        "k",
        "tuple",
        "langlebp_",
        "ldots",
        "bp_krangle",
        "langlebp_",
        "ldots",
        "bp_krangle",
        "let",
        "u",
        "call",
        "functional",
        "e",
        "write",
        "e",
        "langlebp_",
        "ldots",
        "bp_krangle",
        "langlebp_",
        "ldots",
        "bp_krangle",
        "equation",
        "e",
        "behave",
        "well",
        "logic",
        "setting",
        "p_i",
        "valuation",
        "matter",
        "see",
        "itthere",
        "distinction",
        "calling",
        "left",
        "right",
        "side",
        "bp_i",
        "bp_i",
        "word",
        "would",
        "like",
        "partial",
        "relation",
        "bp_",
        "bp_k",
        "interpret",
        "p_",
        "p_k",
        "e",
        "langlebp_",
        "ldots",
        "bp_krangle",
        "langlebp_",
        "ldots",
        "bp_krangle",
        "value",
        "agree",
        "called",
        "fixed",
        "point",
        "e",
        "need",
        "know",
        "e",
        "fixed",
        "point",
        "one",
        "plausible",
        "candidate",
        "choose",
        "best",
        "one",
        "f",
        "g",
        "two",
        "partial",
        "function",
        "space",
        "s",
        "r",
        "one",
        "writes",
        "fsubseteq",
        "g",
        "mean",
        "whenever",
        "f",
        "x",
        "simeq",
        "w",
        "also",
        "g",
        "x",
        "simeq",
        "w",
        "two",
        "partial",
        "relation",
        "bp",
        "bq",
        "arity",
        "bpsubseteqbq",
        "mean",
        "whenever",
        "bp",
        "bd",
        "defined",
        "bq",
        "bd",
        "truth",
        "value",
        "extend",
        "k",
        "tuples",
        "setting",
        "langlebp_",
        "ldots",
        "bp_kranglesubseteqlanglebq_",
        "ldots",
        "bq_krangle",
        "bp_isubseteqbq_i",
        "i",
        "terribly",
        "difficult",
        "show",
        "functional",
        "e",
        "defined",
        "based",
        "eqref",
        "eexample",
        "monotonicity",
        "property",
        "langlebp_",
        "ldots",
        "bp_kranglesubseteqlanglebq_",
        "ldots",
        "bq_krangle",
        "e",
        "langlebp_",
        "ldots",
        "bp_krangle",
        "subseteq",
        "e",
        "langlebq_",
        "ldots",
        "bq_krangle",
        "general",
        "theory",
        "monotone",
        "mapping",
        "like",
        "follows",
        "e",
        "fixed",
        "point",
        "moreover",
        "one",
        "unique",
        "one",
        "least",
        "sense",
        "subseteq",
        "relation",
        "least",
        "fixed",
        "point",
        "precisely",
        "best",
        "candidate",
        "mentioned",
        "contains",
        "information",
        "fixed",
        "point",
        "must",
        "finish",
        "saying",
        "evaluate",
        "formula",
        "eqref",
        "eexample",
        "first",
        "construct",
        "associated",
        "set",
        "equation",
        "e",
        "next",
        "construct",
        "functional",
        "e",
        "least",
        "fixed",
        "point",
        "e",
        "let",
        "u",
        "say",
        "langlebf_",
        "ldots",
        "bf_krangle",
        "finally",
        "evaluate",
        "phi_",
        "using",
        "bf_i",
        "interpret",
        "p_i",
        "i",
        "resulting",
        "truth",
        "value",
        "undefined",
        "value",
        "denotation",
        "associated",
        "eqref",
        "eexample",
        "said",
        "associate",
        "truth",
        "value",
        "undefined",
        "every",
        "formula",
        "lpcr",
        "simplifying",
        "assumption",
        "partial",
        "denotation"
    ]
}