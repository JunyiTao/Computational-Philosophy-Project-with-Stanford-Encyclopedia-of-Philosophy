{
    "main_text": "Semantics of \\(\\lambda\\)-calculus || \\(\\lambda\\)-Models\n7.1 \\(\\lambda\\)-Models\n\nIt turns out that there are multiple, essentially equivalent, ways of\ndefining the notion of a model for the \\(\\lambda\\)-calculus; see\n(Barendregt, 1985, chapter 5) or (Hindley and Seldin, 2008, chapter\n15). In the following, we\u2019ll discuss what we consider the most\npalatable notion for philosophers familiar with the standard semantics\nfor first-order logic (see, e.g., the entry on\n Classical Logic ),\n the so-called syntactical\n\\(\\lambda\\)-models. These models first appear in the\nwork of (Hindley and Longo, 1980), (Koymans, 1982), and (Meyer 1982).\nThey derive their name from the fact that their clauses closely\ncorrespond to the syntactic rules of the calculus\n\\(\\boldsymbol{\\lambda}\\). This is somewhat unsatisfactory and\nmotivates \u2018syntax-free\u2019 definitions (see below). At the\nsame time, the syntactical \\(\\lambda\\)-models provide a fairly\ntransparent and accessible route into the world of \\(\\lambda\\)-models.\nIn addition, despite their conceptual shortcomings, syntactical models\nhave proven a technically useful tool in the semantical study of the\n\\(\\lambda\\)-calculus.\n\nIn order to avoid the set-theoretic problems mentioned above, most\ndefinitions of \\(\\lambda\\)-models use so-called\napplicative structures. The idea is to treat\nthe denotations of \\(\\lambda\\)-terms not as set-theoretic functions,\nbut as unanalyzed, first-order \u2018function-objects\u2019,\ninstead. Correspondingly, then, we treat function application as an\nunanalyzed binary operation on these function-objects:\n\n\nDefinition An applicative structure is a\npair \\((D,\\cdot)\\), where \\(D\\) is some set and \\(\\cdot\\) a binary\noperation on \\(D\\). To avoid trivial models, we usually assume that\n\\(D\\) has at least two elements.\n\n\nApplicative structures are, in a sense, first-order models of function\nspaces that satisfy the problematic equation \\(X\\cong X^X\\).\n\\(\\lambda\\)-models, in turn, are defined over them.\n\nFor the definition of our \\(\\lambda\\)-models, we work with\nvaluations\u2014a concept familiar from\nfirst-order semantics. Valuations assign denotations to the variables\nand are used primarily in the semantic clauses for the\n\\(\\lambda\\)-operator. Additionally, they can be used to express\ngeneral claims over the domain, in a way that is familiar from the\nsemantics for the first-order quantifiers \\(\\exists x\\) and \\(\\forall\nx\\).\n\n\nDefinition A valuation in an applicative\nstructure \\((D,\\cdot)\\) is a function \\(\\rho\\) that assigns an element\n\\(\\rho(x)\\in D\\) to every variable \\(x\\).\n\n\nAs a useful piece of notation, for \\(\\rho\\) a valuation in some\napplicative structure \\((D,\\cdot)\\), \\(x\\) a variable, and \\(d\\in D\\)\nan object, we define the valuation \\(\\rho[x\\mapsto d]\\) by saying\nthat: \n\\[\\rho[x\\mapsto d](y)=\\begin{cases} d & \\text{ if }y=x\\\\\n  \\rho(y) & \\text{otherwise}\\end{cases}\\]\n That is, \\(\\rho[x\\mapsto d]\\) is the result of\nchanging the value of \\(x\\) to be \\(d\\), while leaving all other other\nvalues under \\(\\rho\\) unchanged.\n\n\nDefinition A syntactical \\(\\lambda\\)-model\nis a triple \\(\\mathfrak{M}=(D,\\cdot,\\llbracket \\ \\rrbracket)\\), where\n\\((D,\\cdot)\\) is an applicative structure and \\(\\llbracket \\\n\\rrbracket\\) is a function that assigns to every \\(\\lambda\\)-term M\nand valuation \\(\\rho\\) a denotation \\(\\llbracket M\\rrbracket_\\rho\\in\nD\\) subject to the following constraints:\n\n\\(\\llbracket x\\rrbracket_\\rho=\\rho(x)\\)\n\\(\\llbracket MN\\rrbracket_\\rho=\\llbracket M\\rrbracket_\\rho\\cdot\n\\llbracket N\\rrbracket_\\rho\\)\n\\(\\llbracket \\lambda xM\\rrbracket_\\rho\\cdot d=\\llbracket\nM\\rrbracket_{\\rho[x\\mapsto d]}\\), for all \\(d\\in D\\)\n\\(\\llbracket \\lambda xM\\rrbracket_\\rho = \\llbracket \\lambda\nxN\\rrbracket_\\rho\\), whenever for all \\(d\\in D\\), we have \\(\\llbracket\nM\\rrbracket_{\\rho[x\\mapsto d]}=\\llbracket N\\rrbracket_{\\rho[x\\mapsto\nd]}\\)\n\\(\\llbracket M\\rrbracket_\\rho=\\llbracket M\\rrbracket_\\sigma\\),\nwhenever \\(\\rho(x)=\\sigma(x)\\) for all \\(x\\in \\mathbf{FV}(M)\\)\n\n\n\nIntuitively, in a model \\(\\mathfrak{M}\\), \\(\\llbracket\nM\\rrbracket_\\rho\\) is the function-object denoted by the\n\\(\\lambda\\)-term \\(M\\) under the valuation \\(\\rho\\).\n\nIt is now straight-forward to define what it means for a\n\\(\\lambda\\)-model \\(\\mathfrak{M}\\) to satisfy an equation \\(M=N\\),\nsymbolically \\(\\mathfrak{M}\\vDash M=N\\):\n\n\nDefinition (satisfaction). \n\\[\\mathfrak{M}\\vDash M=N\\text{ iff for all }\\rho\\text{, we have }\n\\llbracket M\\rrbracket_\\rho=\\llbracket N\\rrbracket_\\rho\\]\n\n\n\nIn words: an equation \\(M=N\\) holds in a model \\(\\mathfrak{M}\\) just\nin case the \\(\\lambda\\)-terms \\(M\\) and \\(N\\) have the same denotation\nunder every valuation in the underlying applicative structure.\n\nNote that clauses 3. and 4. from the definition of a syntactical\n\\(\\lambda\\)-model directly mirror the \\(\\boldsymbol{\\lambda}\\)-rules\n\\(\\boldsymbol{\\beta}\\) and \\(\\boldsymbol{\\xi}\\), respectively (see\nsection\n 5.1\n above). This is the \u2018syntactic\u2019 nature of our models.\nWhile this might be semantically unsatisfactory (see below), it makes\nit relatively straight-forward to prove a soundness theorem for the\nsemantics provided by the syntactical \\(\\lambda\\)-models; see\n(Barendregt, 1985, Theorem 5.3.4) and (Hindley and Seldin, 2008.\nTheorem 15.12):\n\nTheorem For all terms \\(M,N\\), if \\(M=N\\) is\nderivable in \\(\\boldsymbol{\\lambda}\\), then for all syntactical\n\\(\\lambda\\)-models \\(\\mathfrak{M}\\), we have that \\(\\mathfrak{M}\\vDash\nM=N\\). \n\nThis theorem provides a first \u2018sanity-check\u2019 for the\nsemantics. But note that, so far, we haven\u2019t shown that there\nexist any syntactical \\(\\lambda\\)-models at all.\n\nThis worry is addressed by constructing so-called \u2018term\nmodels\u2019, which are not unlike the well-known Henkin\nconstructions from first-order semantics. In order to define these\nmodels, we first need the notion of a\n\\(\\boldsymbol{\\lambda}\\)-equivalence class for a given\n\\(\\lambda\\)-term \\(M\\). This class contains precisely the terms that\n\\(\\boldsymbol{\\lambda}\\) proves identical to \\(M\\):  \n\\[\n[M]_{\\boldsymbol{\\lambda}}=\\{N:\\boldsymbol{\\lambda}\\text{ proves }M=N\\}\n\\]\n\n\nWe then define the term model for\n\\(\\boldsymbol{\\lambda}\\), \\(\\mathfrak{T}\\), by setting:\n\n\\(D=\\{[M]_\\boldsymbol{\\lambda}:M\\text{ is a\n}\\lambda\\text{-term}\\}\\)\n\\([M]_\\boldsymbol{\\lambda}\\cdot\n[N]_\\boldsymbol{\\lambda}=[MN]_\\boldsymbol{\\lambda}\\) \n \\(\\llbracket\nM\\rrbracket_\\rho=[M[x_1:=N_1]\\ldots[x_n:=N_n]]_\\boldsymbol{\\lambda}\\),\nwhere \\(\\mathbf{FV}(M)=\\{x_1,\\ldots,x_n\\}\\) and \\(\\rho(x_1)=N_1,\n\\ldots,\\rho(x_n)=N_n\\) \n\n\nIt is easily seen that this indeed defines a syntactical\n\\(\\lambda\\)-model. In fact, it is easily checked that in the term\nmodel for \\(\\boldsymbol{\\lambda}\\), we have that: \n\\[ \\mathfrak{T}\\vDash M=N\\text{ iff\n}\\boldsymbol{\\lambda}\\text{ derives }M=N. \\]\n\n\nThis paves a way for a very simple completeness proof for\n\\(\\boldsymbol{\\lambda}\\) with respect to the class of syntactical\n\\(\\lambda\\)-models; see (Meyer, 1982, 98\u201399) for one of the few\nexplicit mentions of this kind of result in the literature:\n\nTheorem For all terms \\(M,N\\), if for all syntactical\n\\(\\lambda\\)-models \\(\\mathfrak{M}\\), we have that \\(\\mathfrak{M}\\vDash\nM=N\\), then \\(M=N\\) is derivable in \\(\\boldsymbol{\\lambda}\\). \n\nThe proof is a simple proof by contraposition, which uses the term\nmodel \\(\\mathfrak{T}\\) as a countermodel to any non-derivable identity\nin \\(\\boldsymbol{\\lambda}\\).\n\nBut there are reasons to be dissatisfied with the syntactical\n\\(\\lambda\\)-models as a semantics for the \\(\\lambda\\)-calculus. For\none, by virtue of clauses 3. and 4. mirroring rules\n\\(\\boldsymbol{\\beta}\\) and \\(\\boldsymbol{\\xi}\\), the soundness result\nis \u2018baked into\u2019 the semantics, as it were. This is\nunsatisfactory from a semantic perspective since it means that via the\nsyntactical \\(\\lambda\\)-models, we don\u2019t really learn anything\ndirectly about what conditions an applicative structure needs to\nsatisfy in order to adequately model the \\(\\lambda\\)-calculus.\n\nA related worry is that the clauses 3. and 4. are not\nrecursive in nature. That is, they don\u2019t allow us to\ncompute the denotation of a complex \\(\\lambda\\)-term from the\ndenotations of its parts and information about the syntactic operation\nused to combine them. In our syntax (see section\n 2),\n there are two ways of constructing complex \\(\\lambda\\)-terms:\napplication terms of the form \\(MN\\) and abstraction terms of the form\n\\((\\lambda x[M])\\). Clause 1. of our syntactical \\(\\lambda\\)-models is\na recursive clause for the syntactical application operation, but we\ndon\u2019t have a recursive clause for the syntactical operation of\n\\(\\lambda\\)-abstraction. Clauses 3. and 4. are rather conditions on\nthe denotation function \\(\\llbracket \\ \\rrbracket\\) than recursive\nclauses. This is unsatisfactory since it means that we\u2019re not\nreally given a compositional semantics for the \\(\\lambda\\)-operator by\nthe syntactical \\(\\lambda\\)-models.\n\nThese worries are taken care of in the development of\nsyntax-free \\(\\lambda\\)-models. A\ncomprehensive discussion of syntax-free models goes beyond the scope\nof this entry; but see (Barendregt, 1985, chapter 5.2) and (Hinley and\nSeldin, 2008, chapter 15B) for the details. Suffice it to say that the\ndefinition of syntax-free \\(\\lambda\\)-models involves determining\nprecisely under which conditions an applicative structure is suitable\nfor interpreting the \\(\\lambda\\)-calculus. The resulting\n\\(\\lambda\\)-models, then, indeed provide (something much closer to) a\nrecursive, compositional semantics, where the syntactical operation of\n\\(\\lambda\\)-abstraction is interepreted by a corresponding semantic\noperation on applicative structures.\n\nIt is worth noting, however, that syntactical \\(\\lambda\\)-models and\nthe syntax-free \\(\\lambda\\)-models are, in a certain sense,\nequivalent: every syntactical \\(\\lambda\\)-model defines a syntax-free\n\\(\\lambda\\)-model and vice versa; see (Barendregt, 1985, theorem\n5.3.6) and (Hinley and Seldin, 2008, theorem 15.20) for the details.\nFrom a technical perspective, this result allows us to freely move\nbetween the different presentations of \\(\\lambda\\)-models and to use,\nin a given context, the notion of a model that is most expedient. At\nthe same time, there may be philosophical reasons to prefer\none presentation over the other, such as the semantic worries about\nsyntactical \\(\\lambda\\)-models mentioned above.\n\nBefore moving to model constructions, let us briefly mention that\nthere are various ways of approaching \\(\\lambda\\)-models. One\nparticularly interesting approach we\u2019ve neglected so far is from\nthe perspective of category theory and categorical logic. There are\nwell-known model descriptions using so-called \u2018Cartesian closed\ncategories\u2019; see (Koymans, 1982). Covering these model\ndescriptions goes beyond the scope of the present entry since it\nrequires a familiarity with a wide range of concepts from category\ntheory; see the entry\n Category Theory\n for a sense of the machinery involved. For the details of these model\ndescriptions, instead, (Barendregt, 1985, sections 5.4\u20136). In recent\nyears, there has been a renewed interest in categorical approaches to\nthe \\(\\lambda\\)-calculus, which have mainly focused on typed versions\nof the \\(\\lambda\\)-calculus (see sections\n 8.2\n and\n 9.1.2\n below) but also include the untyped \\(\\lambda\\)-calculus discussed in\nthis article. See, for example, (Hyland, 2017) for a recent\ndiscussion.\n",
    "section_title": "7.1 \\(\\lambda\\)-Models",
    "entry_title": "The Lambda Calculus",
    "hierarchy_title": "The Lambda Calculus || Semantics of \\(\\lambda\\)-calculus || \\(\\lambda\\)-Models",
    "tokenized_text": [
        "semantics",
        "lambda",
        "calculus",
        "lambda",
        "models",
        "lambda",
        "models",
        "turn",
        "multiple",
        "essentially",
        "equivalent",
        "way",
        "defining",
        "notion",
        "model",
        "lambda",
        "calculus",
        "see",
        "barendregt",
        "chapter",
        "hindley",
        "seldin",
        "chapter",
        "following",
        "discus",
        "consider",
        "palatable",
        "notion",
        "philosopher",
        "familiar",
        "standard",
        "semantics",
        "firstorder",
        "logic",
        "see",
        "eg",
        "entry",
        "classical",
        "logic",
        "socalled",
        "syntactical",
        "lambda",
        "models",
        "model",
        "first",
        "appear",
        "work",
        "hindley",
        "longo",
        "koymans",
        "meyer",
        "derive",
        "name",
        "fact",
        "clause",
        "closely",
        "correspond",
        "syntactic",
        "rule",
        "calculus",
        "boldsymbol",
        "lambda",
        "somewhat",
        "unsatisfactory",
        "motivates",
        "syntaxfree",
        "definition",
        "see",
        "time",
        "syntactical",
        "lambda",
        "models",
        "provide",
        "fairly",
        "transparent",
        "accessible",
        "route",
        "world",
        "lambda",
        "models",
        "addition",
        "despite",
        "conceptual",
        "shortcoming",
        "syntactical",
        "model",
        "proven",
        "technically",
        "useful",
        "tool",
        "semantical",
        "study",
        "lambda",
        "calculus",
        "order",
        "avoid",
        "settheoretic",
        "problem",
        "mentioned",
        "definition",
        "lambda",
        "models",
        "use",
        "socalled",
        "applicative",
        "structure",
        "idea",
        "treat",
        "denotation",
        "lambda",
        "terms",
        "settheoretic",
        "function",
        "unanalyzed",
        "firstorder",
        "functionobjects",
        "instead",
        "correspondingly",
        "treat",
        "function",
        "application",
        "unanalyzed",
        "binary",
        "operation",
        "functionobjects",
        "definition",
        "applicative",
        "structure",
        "pair",
        "cdot",
        "d",
        "set",
        "cdot",
        "binary",
        "operation",
        "d",
        "avoid",
        "trivial",
        "model",
        "usually",
        "assume",
        "d",
        "least",
        "two",
        "element",
        "applicative",
        "structure",
        "sense",
        "firstorder",
        "model",
        "function",
        "space",
        "satisfy",
        "problematic",
        "equation",
        "xcong",
        "xx",
        "lambda",
        "models",
        "turn",
        "defined",
        "definition",
        "lambda",
        "models",
        "work",
        "valuationsa",
        "concept",
        "familiar",
        "firstorder",
        "semantics",
        "valuation",
        "assign",
        "denotation",
        "variable",
        "used",
        "primarily",
        "semantic",
        "clause",
        "lambda",
        "operator",
        "additionally",
        "used",
        "express",
        "general",
        "claim",
        "domain",
        "way",
        "familiar",
        "semantics",
        "firstorder",
        "quantifier",
        "exists",
        "x",
        "forall",
        "x",
        "definition",
        "valuation",
        "applicative",
        "structure",
        "cdot",
        "function",
        "rho",
        "assigns",
        "element",
        "rho",
        "x",
        "in",
        "d",
        "every",
        "variable",
        "x",
        "useful",
        "piece",
        "notation",
        "rho",
        "valuation",
        "applicative",
        "structure",
        "cdot",
        "x",
        "variable",
        "din",
        "d",
        "object",
        "define",
        "valuation",
        "rho",
        "xmapsto",
        "saying",
        "rho",
        "xmapsto",
        "begin",
        "case",
        "text",
        "yx",
        "rho",
        "text",
        "otherwise",
        "end",
        "case",
        "rho",
        "xmapsto",
        "result",
        "changing",
        "value",
        "x",
        "d",
        "leaving",
        "value",
        "rho",
        "unchanged",
        "definition",
        "syntactical",
        "lambda",
        "model",
        "triple",
        "mathfrak",
        "cdot",
        "llbracket",
        "rrbracket",
        "cdot",
        "applicative",
        "structure",
        "llbracket",
        "rrbracket",
        "function",
        "assigns",
        "every",
        "lambda",
        "term",
        "valuation",
        "rho",
        "denotation",
        "llbracket",
        "mrrbracket_rhoin",
        "d",
        "subject",
        "following",
        "constraint",
        "llbracket",
        "xrrbracket_rhorho",
        "x",
        "llbracket",
        "mnrrbracket_rhollbracket",
        "mrrbracket_rhocdot",
        "llbracket",
        "nrrbracket_rho",
        "llbracket",
        "lambda",
        "xmrrbracket_rhocdot",
        "dllbracket",
        "mrrbracket_",
        "rho",
        "xmapsto",
        "din",
        "d",
        "llbracket",
        "lambda",
        "xmrrbracket_rho",
        "llbracket",
        "lambda",
        "xnrrbracket_rho",
        "whenever",
        "din",
        "d",
        "llbracket",
        "mrrbracket_",
        "rho",
        "xmapsto",
        "llbracket",
        "nrrbracket_",
        "rho",
        "xmapsto",
        "llbracket",
        "mrrbracket_rhollbracket",
        "mrrbracket_sigma",
        "whenever",
        "rho",
        "x",
        "sigma",
        "x",
        "xin",
        "mathbf",
        "fv",
        "intuitively",
        "model",
        "mathfrak",
        "llbracket",
        "mrrbracket_rho",
        "functionobject",
        "denoted",
        "lambda",
        "term",
        "m",
        "valuation",
        "rho",
        "straightforward",
        "define",
        "mean",
        "lambda",
        "model",
        "mathfrak",
        "satisfy",
        "equation",
        "mn",
        "symbolically",
        "mathfrak",
        "vdash",
        "mn",
        "definition",
        "satisfaction",
        "mathfrak",
        "vdash",
        "mntext",
        "iff",
        "rhotext",
        "llbracket",
        "mrrbracket_rhollbracket",
        "nrrbracket_rho",
        "word",
        "equation",
        "mn",
        "hold",
        "model",
        "mathfrak",
        "case",
        "lambda",
        "terms",
        "m",
        "n",
        "denotation",
        "every",
        "valuation",
        "underlying",
        "applicative",
        "structure",
        "note",
        "clause",
        "definition",
        "syntactical",
        "lambda",
        "model",
        "directly",
        "mirror",
        "boldsymbol",
        "lambda",
        "rules",
        "boldsymbol",
        "beta",
        "boldsymbol",
        "xi",
        "respectively",
        "see",
        "section",
        "syntactic",
        "nature",
        "model",
        "might",
        "semantically",
        "unsatisfactory",
        "see",
        "make",
        "relatively",
        "straightforward",
        "prove",
        "soundness",
        "theorem",
        "semantics",
        "provided",
        "syntactical",
        "lambda",
        "models",
        "see",
        "barendregt",
        "theorem",
        "hindley",
        "seldin",
        "theorem",
        "theorem",
        "term",
        "n",
        "mn",
        "derivable",
        "boldsymbol",
        "lambda",
        "syntactical",
        "lambda",
        "models",
        "mathfrak",
        "mathfrak",
        "vdash",
        "mn",
        "theorem",
        "provides",
        "first",
        "sanitycheck",
        "semantics",
        "note",
        "far",
        "shown",
        "exist",
        "syntactical",
        "lambda",
        "models",
        "worry",
        "addressed",
        "constructing",
        "socalled",
        "term",
        "model",
        "unlike",
        "wellknown",
        "henkin",
        "construction",
        "firstorder",
        "semantics",
        "order",
        "define",
        "model",
        "first",
        "need",
        "notion",
        "boldsymbol",
        "lambda",
        "equivalence",
        "class",
        "given",
        "lambda",
        "term",
        "m",
        "class",
        "contains",
        "precisely",
        "term",
        "boldsymbol",
        "lambda",
        "prof",
        "identical",
        "m",
        "_",
        "boldsymbol",
        "lambda",
        "n",
        "boldsymbol",
        "lambda",
        "text",
        "prof",
        "mn",
        "define",
        "term",
        "model",
        "boldsymbol",
        "lambda",
        "mathfrak",
        "setting",
        "d",
        "_boldsymbol",
        "lambda",
        "mtext",
        "lambdatext",
        "term",
        "_boldsymbol",
        "lambda",
        "cdot",
        "n",
        "_boldsymbol",
        "lambda",
        "mn",
        "_boldsymbol",
        "lambda",
        "llbracket",
        "mrrbracket_rho",
        "x_",
        "n_",
        "ldots",
        "x_n",
        "n_n",
        "_boldsymbol",
        "lambda",
        "mathbf",
        "fv",
        "x_",
        "ldots",
        "x_n",
        "rho",
        "x_",
        "n_",
        "ldots",
        "rho",
        "x_n",
        "n_n",
        "easily",
        "seen",
        "indeed",
        "defines",
        "syntactical",
        "lambda",
        "model",
        "fact",
        "easily",
        "checked",
        "term",
        "model",
        "boldsymbol",
        "lambda",
        "mathfrak",
        "vdash",
        "mntext",
        "iff",
        "boldsymbol",
        "lambda",
        "text",
        "derives",
        "mn",
        "pave",
        "way",
        "simple",
        "completeness",
        "proof",
        "boldsymbol",
        "lambda",
        "respect",
        "class",
        "syntactical",
        "lambda",
        "models",
        "see",
        "meyer",
        "one",
        "explicit",
        "mention",
        "kind",
        "result",
        "literature",
        "theorem",
        "term",
        "n",
        "syntactical",
        "lambda",
        "models",
        "mathfrak",
        "mathfrak",
        "vdash",
        "mn",
        "mn",
        "derivable",
        "boldsymbol",
        "lambda",
        "proof",
        "simple",
        "proof",
        "contraposition",
        "us",
        "term",
        "model",
        "mathfrak",
        "countermodel",
        "nonderivable",
        "identity",
        "boldsymbol",
        "lambda",
        "reason",
        "dissatisfied",
        "syntactical",
        "lambda",
        "models",
        "semantics",
        "lambda",
        "calculus",
        "one",
        "virtue",
        "clause",
        "mirroring",
        "rule",
        "boldsymbol",
        "beta",
        "boldsymbol",
        "xi",
        "soundness",
        "result",
        "baked",
        "semantics",
        "unsatisfactory",
        "semantic",
        "perspective",
        "since",
        "mean",
        "via",
        "syntactical",
        "lambda",
        "models",
        "really",
        "learn",
        "anything",
        "directly",
        "condition",
        "applicative",
        "structure",
        "need",
        "satisfy",
        "order",
        "adequately",
        "model",
        "lambda",
        "calculus",
        "related",
        "worry",
        "clause",
        "recursive",
        "nature",
        "allow",
        "u",
        "compute",
        "denotation",
        "complex",
        "lambda",
        "term",
        "denotation",
        "part",
        "information",
        "syntactic",
        "operation",
        "used",
        "combine",
        "syntax",
        "see",
        "section",
        "two",
        "way",
        "constructing",
        "complex",
        "lambda",
        "terms",
        "application",
        "term",
        "form",
        "mn",
        "abstraction",
        "term",
        "form",
        "lambda",
        "x",
        "clause",
        "syntactical",
        "lambda",
        "models",
        "recursive",
        "clause",
        "syntactical",
        "application",
        "operation",
        "recursive",
        "clause",
        "syntactical",
        "operation",
        "lambda",
        "abstraction",
        "clause",
        "rather",
        "condition",
        "denotation",
        "function",
        "llbracket",
        "rrbracket",
        "recursive",
        "clause",
        "unsatisfactory",
        "since",
        "mean",
        "really",
        "given",
        "compositional",
        "semantics",
        "lambda",
        "operator",
        "syntactical",
        "lambda",
        "models",
        "worry",
        "taken",
        "care",
        "development",
        "syntaxfree",
        "lambda",
        "models",
        "comprehensive",
        "discussion",
        "syntaxfree",
        "model",
        "go",
        "beyond",
        "scope",
        "entry",
        "see",
        "barendregt",
        "chapter",
        "hinley",
        "seldin",
        "chapter",
        "b",
        "detail",
        "suffice",
        "say",
        "definition",
        "syntaxfree",
        "lambda",
        "models",
        "involves",
        "determining",
        "precisely",
        "condition",
        "applicative",
        "structure",
        "suitable",
        "interpreting",
        "lambda",
        "calculus",
        "resulting",
        "lambda",
        "models",
        "indeed",
        "provide",
        "something",
        "much",
        "closer",
        "recursive",
        "compositional",
        "semantics",
        "syntactical",
        "operation",
        "lambda",
        "abstraction",
        "interepreted",
        "corresponding",
        "semantic",
        "operation",
        "applicative",
        "structure",
        "worth",
        "noting",
        "however",
        "syntactical",
        "lambda",
        "models",
        "syntaxfree",
        "lambda",
        "models",
        "certain",
        "sense",
        "equivalent",
        "every",
        "syntactical",
        "lambda",
        "model",
        "defines",
        "syntaxfree",
        "lambda",
        "model",
        "vice",
        "versa",
        "see",
        "barendregt",
        "theorem",
        "hinley",
        "seldin",
        "theorem",
        "detail",
        "technical",
        "perspective",
        "result",
        "allows",
        "u",
        "freely",
        "move",
        "different",
        "presentation",
        "lambda",
        "models",
        "use",
        "given",
        "context",
        "notion",
        "model",
        "expedient",
        "time",
        "may",
        "philosophical",
        "reason",
        "prefer",
        "one",
        "presentation",
        "semantic",
        "worry",
        "syntactical",
        "lambda",
        "models",
        "mentioned",
        "moving",
        "model",
        "construction",
        "let",
        "u",
        "briefly",
        "mention",
        "various",
        "way",
        "approaching",
        "lambda",
        "models",
        "one",
        "particularly",
        "interesting",
        "approach",
        "neglected",
        "far",
        "perspective",
        "category",
        "theory",
        "categorical",
        "logic",
        "wellknown",
        "model",
        "description",
        "using",
        "socalled",
        "cartesian",
        "closed",
        "category",
        "see",
        "koymans",
        "covering",
        "model",
        "description",
        "go",
        "beyond",
        "scope",
        "present",
        "entry",
        "since",
        "requires",
        "familiarity",
        "wide",
        "range",
        "concept",
        "category",
        "theory",
        "see",
        "entry",
        "category",
        "theory",
        "sense",
        "machinery",
        "involved",
        "detail",
        "model",
        "description",
        "instead",
        "barendregt",
        "section",
        "recent",
        "year",
        "renewed",
        "interest",
        "categorical",
        "approach",
        "lambda",
        "calculus",
        "mainly",
        "focused",
        "typed",
        "version",
        "lambda",
        "calculus",
        "see",
        "section",
        "also",
        "include",
        "untyped",
        "lambda",
        "calculus",
        "discussed",
        "article",
        "see",
        "example",
        "hyland",
        "recent",
        "discussion"
    ]
}