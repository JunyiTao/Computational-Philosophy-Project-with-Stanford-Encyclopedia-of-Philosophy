{
    "main_text": "Syntax || Axioms and Rules of Inference\n1.3 Axioms and Rules of Inference\n1.3.1 Rules of Inference\n\nAlphabetic Change of Bound Variables\n\\((\\alpha\\)-conversion). To replace any well-formed part\n\\(\\lambda \\bx_{\\beta}\\bA_{\\alpha}\\) of a wff by \\(\\lambda \\by_{\\beta}\n\\textsf{Sub}(\\by_{\\beta},\\bx_{\\beta},\\bA_{\\alpha})\\), provided that\n\\(\\by_{\\beta}\\) does not occur in \\(\\bA_{\\alpha}\\) and \\(\\bx_{\\beta}\\)\nis not bound in \\(\\bA_{\\alpha}\\).\n\u03b2-contraction. To replace any well-formed part\n\\([\\lambda \\bx_{\\alpha}\\bB_{\\beta}] \\bA_{\\alpha}\\) of a wff by\n\\(\\textsf{Sub}(\\bA_{\\alpha},\\bx_{\\alpha},\\bB_{\\beta})\\), provided that\nthe bound variables of \\(\\bB_{\\beta}\\) are distinct both from\n\\(\\bx_{\\alpha}\\) and from the free variables of \\(\\bA_{\\alpha}\\).\n\u03b2-expansion. To infer \\(\\bC\\) from \\(\\bD\\) if\n\\(\\bD\\) can be inferred from \\(\\bC\\) by a single application of\n\u03b2-contraction.\nSubstitution. From \\(\\bF_{({o}\\alpha)}\\bx_{\\alpha}\\), to\ninfer \\(\\bF_{({o}\\alpha)}\\bA_{\\alpha}\\), provided that\n\\(\\bx_{\\alpha}\\) is not a free variable of \\(\\bF_{({o}\\alpha)}\\).\nModus Ponens. From \\([\\bA_{{o}} \\supset \\bB_{{o}}]\\) and\n\\(\\bA_{{o}}\\), to infer \\(\\bB_{{o}}\\).\nGeneralization. From \\(\\bF_{({o}\\alpha)}\\bx_{\\alpha}\\) to\ninfer \\(\\Pi_{{o}({o}\\alpha)}\\bF_{({o}\\alpha)}\\), provided that\n\\(\\bx_{\\alpha}\\) is not a free variable of \\(\\bF_{({o}\\alpha)}\\).\n\n1.3.2 Elementary Type Theory\n\nWe start by listing the axioms for what we shall call elementary\ntype theory.  \n\n\\[\\begin{align}\n     [p_{{o}} \\lor p_{{o}}] & \\supset          p_{{o}} \\tag{1}\\\\\n      p_{{o}} & \\supset [p_{{o}} \\lor q_{{o}}] \\tag{2}\\\\\n      [p_{{o}} \\lor q_{{o}}] & \\supset [q_{{o}} \\lor p_{{o}}] \\tag{3}\\\\\n      [p_{{o}} \\supset q_{{o}}] & \\supset [[r_{{o}} \\lor p_{{o}}] \\supset [r_{{o}} \\lor q_{{o}}]] \\tag{4}\\\\\n    \\Pi_{{o}({o}\\alpha)}f_{({o}\\alpha)} & \\supset f_{({o}\\alpha)}x_{\\alpha} \\tag{\\(5^{\\alpha}\\)} \\\\\n    \\forall x_{\\alpha}[p_{{o}} \\lor f_{({o}\\alpha)}x_{\\alpha}] & \\supset \\left[p_{{o}} \\lor \\Pi_{{o}({o}\\alpha)}f_{({o}\\alpha)}\\right]  \\tag{\\(6^{\\alpha}\\)}\n\\end{align}\\]\n\n\nThe theorems of elementary type theory are those theorems which can be\nderived, using the rules of inference, from Axioms\n(1)\u2013\\((6^{\\alpha})\\) (for all type symbols \\(\\alpha)\\). We shall\nsometimes refer to elementary type theory as \\(\\cT\\). It embodies the\nlogic of propositional connectives, quantifiers, and\n\u03bb-conversion in the context of type theory.\n\nTo illustrate the rules and axioms introduced above, we give a short\nand trivial proof in \\(\\cT\\). Following each wff of the proof, we\nindicate how it was inferred. (The proof is actually quite\ninefficient, since line 3 is not used later, and line 7 can be derived\ndirectly from line 5 without using line 6. The additional proof lines\nhave been inserted to illustrate some relevant aspects. For the sake\nof readability, many brackets have been deleted from the formulas in\nthis proof. The diligent reader should be able to restore them.) \n\n\\[\\begin{alignat}{2}\n    \\forall x_{\\imath}\\left[p_{{o}} \\lor f_{{o}\\imath}x_{\\imath}\\right]  \\supset\\left[p_{{o}} \\lor \\Pi_{{o}({o}\\imath)} f_{{o}\\imath}\\right]\n    && \\text{Axiom \\(6^{\\imath}\\)}  \\tag{1}\\\\\n%\n      \\bigg[\\lambda f_{{o}\\imath}\\bigg[\\forall x_{\\imath}[p_{{o}} \\lor  f_{{o}\\imath}x_{\\imath}]\n  \\supset \\bigg[p_{{o}} \\lor \\Pi_{{o}({o}\\imath)}f_{{o}\\imath}\\bigg]\\bigg]\\bigg] f_{{o}\\imath} \n&& \\text{\u03b2-expansion: 1} \\tag{2}\\\\\n%\n   \\Pi_{{o}({o}({o}\\imath))}\\bigg[\\lambda f_{{o}\\imath}\\bigg[\\forall x_{\\imath}[p_{{o}} \\lor f_{{o}\\imath}x_{\\imath}]  \\supset \\bigg[p_{{o}} \\lor \\Pi_{{o}({o}\\imath)}f_{{o}\\imath}\\bigg]\\bigg]\\bigg]\n    && \\text{Generalization: 2} \\tag{3}\\\\\n%\n    \\bigg[\\lambda f_{{o}\\imath}\\bigg[\\forall x_{\\imath}[p_{{o}}\\lor f_{{o}\\imath}x_{\\imath}]  \\supset \\bigg[p_{{o}} \\lor \\Pi_{{o}({o}\\imath)}f_{{o}\\imath}\\bigg]\\bigg]\\bigg] [\\lambda x_{\\imath}r_{{o}\\imath}x_{\\imath}]\n    && \\text{Substitution: 2} \\tag{4}\\\\\n%\n    \\forall x_{\\imath}[p_{{o}} \\lor [\\lambda x_{\\imath}r_{{o}\\imath}x_{\\imath}]x_{\\imath}]  \\supset \\left[p_{{o}} \\lor \\Pi_{{o}({o}\\imath)}\\left[\\lambda x_{\\imath}r_{{o}\\imath}x_{\\imath}\\right]\\right]\n    && \\text{\u03b2-contraction: 4} \\tag{5}\\\\\n%\n   \\forall x_{\\imath}[p_{{o}} \\lor [\\lambda y_{\\imath} r_{{o}\\imath} y_{\\imath}] x_{\\imath}]  \\supset \\left[p_{{o}} \\lor \\Pi_{{o}({o}\\imath)}\\left[\\lambda x_{\\imath}r_{{o}\\imath}x_{\\imath}\\right]\\right]\n    && \\text{\u03b1-conversion: 5} \\tag{6}\\\\\n%\n   \\forall x_{\\imath}\\left[p_{{o}} \\lor r_{{o}\\imath}x_{\\imath}\\right]  \\supset \\left[p_{{o}} \\lor \\Pi_{{o}({o}\\imath)}\\left[\\lambda x_{\\imath}r_{{o}\\imath}x_{\\imath}\\right]\\right]\n    && \\text{\u03b2-contraction: 6} \\tag{7}\n  \\end{alignat}\\]\n\n\nNote that (3) can be written as  \n\n\\[\n       \\forall f_{{o}\\imath} [\\forall x_{\\imath} [p_{{o}}\n             \\lor f_{{o}\\imath}x_{\\imath}] \\supset [p_{{o}} \\lor\n             [\\forall x_{\\imath} f_{{o}\\imath} x_{\\imath}]\n                          ]] \n\\tag{\\(3'\\)}\n\\]\n\n\nand (7) can be written as  \n\n\\[\n     \\forall x_{\\imath}[p_{{o}} \\lor r_{{o}\\imath}x_{\\imath}] \\supset [p_{{o}} \\lor \\forall\n      x_{\\imath}r_{{o}\\imath}x_{\\imath}]  \\tag{\\(7'\\)}\n\\]\n\n\nWe have thus derived a well known law of quantification theory. We\nillustrate one possible interpretation of the wff \\((7')\\) (which\nis closely related to Axiom 6) by considering a situation in which a\nrancher puts some horses in a corral and leaves for the night. Later,\nhe cannot remember whether he closed the gate to the corral. While\nreflecting on the situation, he comes to a conclusion which can be\nexpressed by \\((7')\\) if we take the horses to be the elements of\ntype \\(\\imath\\), interpret \\(p_{{o}}\\) to mean \u201cthe gate was\nclosed\u201d, and interpret \\(r_{{o}\\imath}\\) so that\n\\(r_{{o}\\imath}x_{\\imath}\\) asserts \u201c\\(x_{\\imath}\\) left the\ncorral\u201d. With this interpretation, \\((7')\\) says \n\n\nIf it is true of every horse that the gate was closed or that the\nhorse left the corral, then the gate was closed or every horse left\nthe corral.\n\n\nTo the axioms listed above we add the axioms below to obtain\nChurch\u2019s type theory.\n1.3.3 Axioms of Extensionality\n\nThe axioms of boolean and functional extensionality are the following:\n \n\n\\[\\begin{align}\n                        [x_{{o}} \\equiv y_{{o}}] & \\supset                  x_{{o}} = y_{{o}}  \\tag{\\(7^{o}\\)} \\\\\n    \\forall x_{\\beta}[f_{\\alpha \\beta}x_{\\beta} = g_{\\alpha \\beta}x_{\\beta}] & \\supset f_{\\alpha \\beta} = g_{\\alpha \\beta}\\tag{\\(7^{\\alpha \\beta}\\)}\n\\end{align}\\]\n\n\nChurch did not include Axiom \\(7^{{o}}\\) in his list of axioms in\nChurch 1940, but he mentioned the possibility of including it. Henkin\ndid include it in Henkin 1950.\n1.3.4 Descriptions\n\nThe expression  \n\n\\[\\exists_1\\bx_{\\alpha}\\bA_{{o}}\\]\n\n\nstands for  \n\n\\[[\\lambda p_{{o}\\alpha}\\exists y_{\\alpha}[p_{{o}\\alpha}y_{\\alpha} \\land \\forall z_{\\alpha}[p_{{o}\\alpha}z_{\\alpha} \\supset z_{\\alpha} = y_{\\alpha}]]]\\, [\\lambda\n\\bx_{\\alpha}\\bA_{{o}}]\\]\n\n\nFor example,  \n\n\\[\\exists_1 x_{\\alpha}P_{{o}\\alpha}x_{\\alpha}\\]\n\n\nstands for  \n\n\\[[\\lambda p_{{o}\\alpha}\\exists y_{\\alpha}[p_{{o}\\alpha}y_{\\alpha} \\land \\forall z_{\\alpha}[p_{{o}\\alpha}z_{\\alpha} \\supset z_{\\alpha} = y_{\\alpha}]]]\\, [\\lambda\nx_{\\alpha}P_{{o}\\alpha}x_{\\alpha}]\\]\n\n\nBy \u03bb-conversion, this is equivalent to  \n\n\\[\\exists y_{\\alpha}[[\\lambda x_{\\alpha}P_{{o}\\alpha}x_{\\alpha}]y_{\\alpha} \\land \\forall z_{\\alpha}[[\\lambda\nx_{\\alpha}P_{{o}\\alpha}x_{\\alpha}] z_{\\alpha} \\supset z_{\\alpha}\n= y_{\\alpha}]]\\]\n\n\nwhich reduces by \u03bb-conversion to  \n\n\\[\\exists y_{\\alpha}[P_{{o}\\alpha}y_{\\alpha} \\land \\forall\nz_{\\alpha}[P_{{o}\\alpha}z_{\\alpha} \\supset z_{\\alpha} =\ny_{\\alpha}]]\\]\n\n\nThis asserts that there is a unique element which has the property\n\\(P_{{o}\\alpha}\\). From this example we can see that in general,\n\\(\\exists_1\\bx_{\\alpha}\\bA_{{o}}\\) expresses the assertion that\n\u201cthere is a unique \\(\\bx_{\\alpha}\\) such that\n\\(\\bA_{{o}}\\)\u201d.\n\nWhen there is a unique such element \\(\\bx_{\\alpha}\\), it is convenient\nto have the notation \\(\\atoi\\bx_{\\alpha}\\bA_{{o}}\\) to represent the\nexpression \u201cthe \\(\\bx_{\\alpha}\\) such that \\(\\bA_{{o}}\\)\u201d.\nRussell showed in Whitehead & Russell 1927b how to provide\ncontextual definitions for such notations in his formulation of type\ntheory. In Church\u2019s type theory \\(\\atoi\\bx_{\\alpha}\\bA_{{o}}\\)\nis defined as \\(\\iota_{\\alpha({o}\\alpha)}[\\lambda\n\\bx_{\\alpha}\\bA_{{o}}]\\). Thus, \\(\\atoi\\) behaves like a\nvariable-binding operator, but it is defined in terms of \u03bb with\nthe aid of the constant \\(\\iota_{\\alpha({o}\\alpha)}\\). Thus, \u03bb\nis still the only variable-binding operator that is needed.\n\nSince \\(\\bA_{{o}}\\) describes \\(\\bx_{\\alpha},\n\\iota_{\\alpha({o}\\alpha)}\\) is called a description operator.\nAssociated with this notation is the following:\nAxiom of Descriptions: \n\n\\[\n   \\exists_1 x_{\\alpha}[p_{{o}\\alpha}x_{\\alpha}]\n                   \\supset p_{{o}\\alpha} [\\iota_{\\alpha({o}\\alpha)}p_{{o}\\alpha}] \\tag{\\(8^{\\alpha}\\)}\n\n\\]\n\n\nThis says that when the set \\(p_{{o}\\alpha}\\) has a unique member,\nthen \\(\\iota_{\\alpha({o}\\alpha)}p_{{o}\\alpha}\\) is in\n\\(p_{{o}\\alpha}\\), and therefore is that unique member. Thus, this\naxiom asserts that \\(\\iota_{\\alpha({o}\\alpha)}\\) maps one-element sets\nto their unique members.\n\nIf from certain hypotheses one can prove  \n\n\\[\\exists_1\\bx_{\\alpha}\\bA_{{o}}\\]\n\n\nthen by using Axiom \\(8^{\\alpha}\\) one can derive  \n\n\\[[\\lambda\n  \\bx_{\\alpha}\\bA_{{o}}] [\\iota_{\\alpha({o}\\alpha)}[\\lambda \\bx_{\\alpha}\\bA_{{o}}]]\\]\n\n\nwhich can also be written as  \n\n\\[[\\lambda\n\\bx_{\\alpha}\\bA_{{o}}]\n{[\\atoi\\bx_{\\alpha}\\bA_{{o}}]}\\]\n\n\nWe illustrate the usefulness of the description operator with a small\nexample. Suppose we have formalized the theory of real numbers, and\nour theory has constants \\(1_{\\varrho}\\) and \\(\\times_{\\varrho \\varrho\n\\varrho}\\) to represent the number 1 and the multiplication function,\nrespectively. (Here \\(\\varrho\\) is the type of real numbers.) To\nrepresent the multiplicative inverse function, we can define the wff\n\\(\\textrm{INV}_{\\varrho \\varrho}\\) as  \n\n\\[{\\lambda z_{\\varrho} \\atoi x_{\\varrho} [\\times_{\\varrho \\varrho\n     \\varrho}z_{\\varrho}x_{\\varrho} = 1_{\\varrho}]}\\]\n\n\nOf course, in traditional mathematical notation we would not write the\ntype symbols, and we would write \\(\\times_{\\varrho \\varrho\n\\varrho}z_{\\varrho}x_{\\varrho}\\) as \\(z \\times x\\) and write\n\\(\\textrm{INV}_{\\varrho \\varrho}z\\) as \\(z^{-1}\\). Thus \\(z^{-1}\\) is\ndefined to be that x such that \\(z \\times x = 1\\). When\nZ is provably not 0, we will be able to prove \\(\\exists_1\nx_{\\varrho}[\\times_{\\varrho \\varrho \\varrho} \\textrm{Z x}_{\\varrho} =\n1_{\\varrho}]\\) and \\(Z \\times Z^{-1} = 1\\), but if we cannot establish\nthat Z is not 0, nothing significant about \\(Z^{-1}\\) will be\nprovable.\n1.3.5 Axiom of Choice\n\nThe Axiom of Choice can be expressed as follows in Church\u2019s type\ntheory:  \n\n\\[\n    \\exists x_{\\alpha}p_{{o}\\alpha}x_{\\alpha}\n                   \\supset p_{{o}\\alpha}[\\iota_{\\alpha({o}\\alpha)}p_{{o}\\alpha}] \\tag{\\(9^{\\alpha}\\)}\n\\]\n\n\n\\((9^{\\alpha})\\) says that the choice function\n\\(\\iota_{\\alpha({o}\\alpha)}\\) chooses from every nonempty set\n\\(p_{{o}\\alpha}\\) an element, designated as\n\\(\\iota_{\\alpha({o}\\alpha)}p_{{o}\\alpha}\\), of that set. When this\nform of the Axiom of Choice is included in the list of axioms,\n\\(\\iota_{\\alpha({o}\\alpha)}\\) is called a selection operator instead\nof a description operator, and \\(\\atoi\\bx_{\\alpha} \\bA_{{o}}\\) means\n\u201can \\(\\bx_{\\alpha}\\) such that \\(\\bA_{{o}}\\)\u201d when there\nis some such element \\(\\bx_{\\alpha}\\). These selection operators have\nthe same meaning as Hilbert\u2019s \\(\\epsilon\\)-operator (Hilbert\n1928). However, we here provide one such operator for each type\n\u03b1.\n\nIt is natural to call \\(\\atoi\\) a definite description operator in\ncontexts where \\(\\atoi\\bx_{\\alpha}\\bA_{{o}}\\) means \u201cthe\n\\(\\bx_{\\alpha}\\) such that \\(\\bA_{{o}}\\)\u201d, and to call it an\nindefinite description operator in contexts where\n\\(\\atoi\\bx_{\\alpha}\\bA_{{o}}\\) means \u201can \\(\\bx_{\\alpha}\\) such\nthat \\(\\bA_{{o}}\\)\u201d.\n\nClearly the Axiom of Choice implies the Axiom of Descriptions, but\nsometimes formulations of type theory are used which include the Axiom\nof Descriptions, but not the Axiom of Choice.\n\nAnother formulation of the Axiom of Choice simply asserts the\nexistence of a choice function without explicitly naming it: \n\n\\[\n     \\exists j_{\\alpha ({o}\\alpha)}\\forall\n                           p_{{o}\\alpha}[\\exists x_{\\alpha}p_{{o}\\alpha}x_{\\alpha} \\supset p_{{o}\\alpha}[j_{\\alpha({o}\\alpha)}p_{{o}\\alpha}]]\n\\tag{\\(\\text{AC}^{\\alpha}\\)}\n\\]\n\n\nNormally when one assumes the Axiom of Choice in type theory, one\nassumes it as an axiom schema, and asserts AC\\(^{\\alpha}\\) for each\ntype symbol \u03b1. A similar remark applies to the axioms for\nextensionality and description. However, modern proof systems for\nChurch\u2019s type theory, which are, e.g., based on resolution, do\nin fact avoid the addition of such axiom schemata for reasons as\nfurther explained in\n Sections 3.4\n and\n 4\n below. They work with more constrained, goal-directed proof rules\ninstead.\n\nBefore proceeding, we need to introduce some terminology. \\(\\cQ_0\\) is\nan alternative formulation of Church\u2019s type theory which will be\ndescribed in\n Section 1.4\n and is equivalent to the system described above using Axioms\n(1)\u2013(8). A type symbol is propositional if the only symbols\nwhich occur in it are \\({o}\\) and parentheses.\n\nYasuhara (1975) defined the relation \u201c\\(\\ge\\)\u201d between\ntypes as the reflexive transitive closure of the minimal relation such\nthat \\((\\alpha \\beta) \\ge \\alpha\\) and \\((\\alpha \\beta) \\ge \\beta\\).\nHe established that:\n\nIf \\(\\alpha \\ge \\beta\\), then \\(\\cQ_0 \\vdash\\) AC\\(^{\\alpha}\n\\supset\\) AC\\(^{\\beta}\\).\nGiven a set S of types, none of which is propositional,\nthere is a model of \\(\\cQ_0\\) in which AC\\(^{\\alpha}\\) fails if and\nonly if \\(\\alpha \\ge \\beta\\) for some \u03b2 in S.\n\n\nThe existence of a choice functions for \u201chigher\u201d types\nthus entails the existence of choice functions for \u201clower\u201d\ntypes, the opposite is generally not the case though.\n\nB\u00fcchi (1953) has shown that while the schemas expressing the\nAxiom of Choice and Zorn\u2019s Lemma can be derived from each other,\nthe relationships between the particular types involved are\ncomplex.\n1.3.6 Axioms of Infinity\n\nOne can define the natural numbers (and therefore other basic\nmathematical structures such as the real and complex numbers) in type\ntheory, but to prove that they have the required properties (such as\nPeano\u2019s Postulates), one needs an Axiom of Infinity. There are\nmany viable possibilities for such an axiom, such as those discussed\nin Church 1940, section 57 of Church 1956, and section 60 of Andrews\n2002.\n1.4 A Formulation Based on Equality\n\nIn\n Section 1.2.1,\n \\(\\nsim_{({o}{o})}, \\lor_{(({o}{o}){o})}\\), and the\n\\(\\Pi_{({o}({o}\\alpha))}\\)\u2019s were taken as primitive\nconstants, and the wffs \\(\\sfQ_{{o}\\alpha \\alpha}\\) which denote\nequality relations at type \u03b1 were defined in terms of these. We\nnow present an alternative formulation \\(\\cQ_0\\) of Church\u2019s\ntype theory in which there are primitive constants \\(\\sfQ_{{o}\\alpha\n\\alpha}\\) denoting equality, and \\(\\nsim_{({o}{o})},\n\\lor_{(({o}{o}){o})}\\), and the \\(\\Pi_{({o}({o}\\alpha))}\\)\u2019s\nare defined in terms of the \\(\\sfQ_{{o}\\alpha \\alpha}\\)\u2019s.\n\nTarski (1923) noted that in the context of higher-order logic, one can\ndefine propositional connectives in terms of logical equivalence and\nquantifiers. Quine (1956) showed how both quantifiers and connectives\ncan be defined in terms of equality and the abstraction operator\n\u03bb in the context of Church\u2019s type theory. Henkin (1963)\nrediscovered these definitions, and developed a formulation of\nChurch\u2019s type theory based on equality in which he restricted\nattention to propositional types. Andrews (1963) simplified the axioms\nfor this system.\n\n\\(\\cQ_0\\) is based on these ideas, and can be shown to be equivalent\nto a formulation of Church\u2019s type theory using Axioms\n(1)\u2013(8) of the preceding sections. This section thus provides an\nalternative to the material in the preceding Sections\n1.2.1\u20131.3.4. More details about \\(\\cQ_0\\) can be found in\nAndrews 2002.\n1.4.1 Definitions\n\nType symbols, improper symbols, and variables of \\(\\cQ_0\\) are\ndefined as in\n Section 1.2.1.\nThe logical constants of \\(\\cQ_0\\) are\n\\(\\sfQ_{(({o}\\alpha)\\alpha)}\\) and \\(\\iota_{(\\imath({o}\\imath))}\\)\n(for each type symbol \u03b1).\nWffs of \\(\\cQ_0\\) are defined as in\n Section 1.2.1.\n\nAbbreviations:\n\n\\(\\bA_{\\alpha} = \\bB_{\\alpha}\\) stands for \\(\\sfQ_{{o}\\alpha\n\\alpha}\\bA_{\\alpha}\\bB_{\\alpha}\\)\n\\(\\bA_{{o}} \\equiv \\bB_{{o}}\\) stands for\n\\(\\sfQ_{{o}{o}{o}}\\)A\\(_{{o}}\\)B\\(_{{o}}\\)\n\\(T_{{o}}\\) stands for \\(\\sfQ_{{o}{o}{o}} =\n\\sfQ_{{o}{o}{o}}\\)\n\\(F_{{o}}\\) stands for \\([\\lambda x_{{o}}T_{{o}}] = [\\lambda\nx_{{o}}x_{{o}}]\\)\n\\(\\Pi_{{o}({o}\\alpha)}\\) stands for\n\\(\\sfQ_{{o}({o}\\alpha)({o}\\alpha)}[\\lambda x_{\\alpha}T_{{o}}]\\)\n\\(\\forall \\bx_{\\alpha}\\bA\\) stands for\n\\(\\Pi_{{o}({o}\\alpha)}[\\lambda \\bx_{\\alpha}\\bA]\\)\n\\(\\land_{{o}{o}{o}}\\) stands for \\(\\lambda x_{{o}}\\lambda\ny_{{o}}[[\\lambda g_{{o}{o}{o}}[g_{{o}{o}{o}}T_{{o}}T_{{o}}]] =\n[\\lambda g_{{o}{o}{o}}[g_{{o}{o}{o}}x_{{o}}y_{{o}}]]]\\)\n\\(\\bA_{{o}} \\land \\bB_{{o}}\\) stands for \\(\\land_{{o}{o}{o}}\n\\bA_{{o}} \\bB_{{o}}\\)\n\\(\\nsim_{{o}{o}}\\) stands for \\(\\sfQ_{{o}{o}{o}}F_{{o}}\\)\n\n\n\\(T_{{o}}\\) denotes truth. The meaning of \\(\\Pi_{{o}({o}\\alpha)}\\)\nwas discussed in\n Section 1.1.\n To see that this definition of \\(\\Pi_{{o}({o}\\alpha)}\\) is\nappropriate, note that \\(\\lambda x_{\\alpha}T\\) denotes the set of all\nelements of type \u03b1, and that\n\\(\\Pi_{{o}({o}\\alpha)}s_{{o}\\alpha}\\) stands for\n\\(\\sfQ_{{o}({o}\\alpha)({o}\\alpha)}[\\lambda x_{\\alpha}T]\ns_{{o}\\alpha}\\), respectively for \\([\\lambda x_{\\alpha}T] =\ns_{{o}\\alpha}\\). Therefore \\(\\Pi_{{o}({o}\\alpha)}s_{{o}\\alpha}\\)\nasserts that \\(s_{{o}\\alpha}\\) is the set of all elements of type\n\u03b1, so \\(s_{{o}\\alpha}\\) contains all elements of type \u03b1.\nIt can be seen that \\(F_{{o}}\\) can also be written as \\(\\forall\nx_{{o}}x_{{o}}\\), which asserts that everything is true. This is\nfalse, so \\(F_{{o}}\\) denotes falsehood. The expression \\(\\lambda\ng_{{o}{o}{o}}[g_{{o}{o}{o}}x_{{o}}y_{{o}}]\\) can be used to represent\nthe ordered pair \\(\\langle x_{{o}},y_{{o}}\\rangle\\), and the\nconjunction \\(x_{{o}} \\land y_{{o}}\\) is true iff \\(x_{{o}}\\) and\n\\(y_{{o}}\\) are both true, i.e., iff \\(\\langle T_{{o}},T_{{o}}\\rangle\n= \\langle x_{{o}},y_{{o}}\\rangle\\). Hence \\(x_{{o}} \\land y_{{o}}\\)\ncan be expressed by the formula \\([\\lambda\ng_{{o}{o}{o}}[g_{{o}{o}{o}}T_{{o}}T_{{o}}]] = [\\lambda\ng_{{o}{o}{o}}[g_{{o}{o}{o}}x_{{o}}y_{{o}}]]\\).\n\nOther propositional connectives and the existential quantifier are\neasily defined. By using \\(\\iota_{(\\imath({o}\\imath))}\\), one can\ndefine description operators \\(\\iota_{\\alpha({o}\\alpha)}\\) for all\ntypes \u03b1.\n1.4.2 Axioms and Rules of Inference\n\n\\(\\cQ_0\\) has a single rule of inference.\n\nRule R: From \\(\\bC\\) and \\(\\bA_{\\alpha} =\n\\bB_{\\alpha}\\), to infer the result of replacing one occurrence of\n\\(\\bA_{\\alpha}\\) in \\(\\bC\\) by an occurrence of \\(\\bB_{\\alpha}\\),\nprovided that the occurrence of \\(\\bA_{\\alpha}\\) in \\(\\bC\\) is not (an\noccurrence of a variable) immediately preceded by \u03bb.\n\nThe axioms for \\(\\cQ_0\\) are the following: \n\n\\[\\begin{align}\n  [g_{{o}{o}}T_{{o}} \\land g_{{o}{o}}F_{{o}}] &= \\forall x_{{o}}[g_{{o}{o}}x_{{o}}] \\tag{1}\\\\\n  [x_{\\alpha} = y_{\\alpha}] & \\supset  [h_{{o}\\alpha}x_{\\alpha} = h_{{o}\\alpha}y_{\\alpha}] \\tag{\\(2^{\\alpha)}\\)}\\\\\n  [f_{\\alpha \\beta} = g_{\\alpha \\beta}] & = \\forall x_{\\beta}[f_{\\alpha \\beta}x_{\\beta} = g_{\\alpha  \\beta}x_{\\beta}] \\tag{\\(3^{\\alpha \\beta}\\)}\\\\\n%\n        [\\lambda \\bx_{\\alpha}\\bB_{\\beta}]\\bA_{\\alpha} & = \\textsf{SubFree}(\\bA_{\\alpha},\\bx_{\\alpha},\\bB_{\\beta}), \\tag{4}\\\\\n &\\quad \\text{ provided } \\bA_{\\alpha} \\text{ is free for } \\bx \\text{ in } \\bB_{\\beta}\\\\\n%\n        \\iota_{\\imath({o}\\imath)}[\\sfQ_{{o}\\imath\\imath}y_{\\imath}] &= y_{\\imath} \\tag{5}\n\\end{align}\\]\n\n2. Semantics\n\nIt is natural to compare the semantics of type theory with the\nsemantics of first-order logic, where the theorems are precisely the\nwffs which are valid in all interpretations. From an intuitive point\nof view, the natural interpretations of type theory are standard\nmodels, which are defined below. However, it is a consequence of\nG\u00f6del\u2019s Incompleteness Theorem (G\u00f6del 1931) that\naxioms (1)\u2013(9) do not suffice to derive all wffs which are valid in\nall standard models, and there is no consistent recursively\naxiomatized extension of these axioms which suffices for this purpose.\nNevertheless, experience shows that these axioms are sufficient for\nmost purposes, and Leon Henkin considered the problem of clarifying in\nwhat sense they are complete. The definitions and theorem below\nconstitute Henkin\u2019s (1950) solution to this problem, which is\noften referred to as general semantics or Henkin\nsemantics.\n\nA frame is a collection \\(\\{\\cD_{\\alpha}\\}_{\\alpha}\\) of\nnonempty domains (sets) \\(\\cD_{\\alpha}\\), one for each type symbol\n\u03b1, such that \\(\\cD_{{o}} = \\{\\sfT,\\sfF\\}\\) (where \\(\\sfT\\)\nrepresents truth and \\(\\sfF\\) represents falsehood), and \\(\\cD_{\\alpha\n\\beta}\\) is some collection of functions mapping \\(\\cD_{\\beta}\\) into\n\\(\\cD_{\\alpha}\\). The members of \\(\\cD_{\\imath}\\) are called\nindividuals.\n\nAn interpretation \\(\\langle \\{\\cD_{\\alpha}\\}_{\\alpha},\n\\frI\\rangle\\) consists of a frame and a function \\(\\frI\\) which maps\neach constant C of type \u03b1 to an appropriate element of\n\\(\\cD_{\\alpha}\\), which is called the denotation of C.\nThe logical constants are given their standard denotations.\n\nAn assignment of values in the frame\n\\(\\{\\cD_{\\alpha}\\}_{\\alpha}\\) to variables is a function \\(\\phi\\) such\nthat \\(\\phi \\bx_{\\alpha} \\in \\cD_{\\alpha}\\) for each variable\n\\(\\bx_{\\alpha}\\). (Notation: The assignment \\(\\phi[a/x]\\) maps\nvariable x to value a and it is identical with \\(\\phi\\)\nfor all other variable symbols different from x.)\n\nAn interpretation \\(\\cM = \\langle \\{\\cD_{\\alpha}\\}_{\\alpha},\n\\frI\\rangle\\) is a general model (aka Henkin model)\niff there is a binary function \\(\\cV\\) such that\n\\(\\cV_{\\phi}\\bA_{\\alpha} \\in \\cD_{\\alpha}\\) for each assignment\n\\(\\phi\\) and wff \\(\\bA_{\\alpha}\\), and the following conditions are\nsatisfied for all assignments and all wffs:\n\n\\(\\cV_{\\phi}\\bx_{\\alpha} = \\phi \\bx_{\\alpha}\\) for each variable\n\\(\\bx_{\\alpha}\\).\n\\(\\cV_{\\phi}A_{\\alpha} = \\frI A_{\\alpha}\\) if \\(A_{\\alpha}\\) is a\nprimitive constant.\n\\(\\cV_{\\phi}[\\bA_{\\alpha \\beta}\\bB_{\\beta}] =\n(\\cV_{\\phi}\\bA_{\\alpha \\beta})(\\cV_{\\phi}\\bB_{\\beta})\\) (the value of\na function \\(\\cV_{\\phi}\\bA_{\\alpha \\beta}\\) at the argument\n\\(\\cV_{\\phi}\\bB_{\\beta})\\).\n\\(\\cV_{\\phi}[\\lambda \\bx_{\\alpha}\\bB_{\\beta}] =\\) that function\nfrom \\(\\cD_{\\alpha}\\) into \\(\\cD_{\\beta}\\) whose value for each\nargument \\(z \\in \\cD_{\\alpha}\\) is \\(\\cV_{\\psi}\\bB_{\\beta}\\), where\n\\(\\psi\\) is that assignment such that \\(\\psi \\bx_{\\alpha} = z\\) and\n\\(\\psi \\by_{\\beta} = \\phi \\by_{\\beta}\\) if \\(\\by_{\\beta} \\ne\n\\bx_{\\alpha}\\).\n\n\nIf an interpretation \\(\\cM\\) is a general model, the function \\(\\cV\\)\nis uniquely determined. \\(\\cV_{\\phi}\\bA_{\\alpha}\\) is called the\nvalue of \\(\\bA_{\\alpha}\\) in \\(\\cM\\) with respect to\n\\(\\phi\\).\n\nOne can easily show that the following statements hold in all general\nmodels \\(\\cM\\) for all assignments \\(\\phi\\) and all wffs \\(\\bA\\) and\n\\(\\bB\\):\n\n\\(\\cV_{\\phi} T_{{o}} = \\sfT\\) and \\(\\cV_{\\phi} F_{{o}} =\n\\sfF\\)\n\\(\\cV_{\\phi} [\\nsim_{{o}{o}} \\bA_{{o}}] = \\sfT\\) iff \\(\\cV_{\\phi}\n\\bA_{{o}} = \\sfF\\)\n\\(\\cV_{\\phi} [ \\bA_{{o}} \\lor \\bB_{{o}} ] = \\sfT\\) iff\n\\(\\cV_{\\phi} \\bA_{{o}} = \\sfT\\) or \\(\\cV_{\\phi} \\bB_{{o}} =\n\\sfT\\)\n\\(\\cV_{\\phi} [ \\bA_{{o}} \\land \\bB_{{o}} ] = \\sfT\\) iff\n\\(\\cV_{\\phi} \\bA_{{o}} = \\sfT\\) and \\(\\cV_{\\phi} \\bB_{{o}} =\n\\sfT\\)\n\\(\\cV_{\\phi} [ \\bA_{{o}} \\supset \\bB_{{o}} ] = \\sfT\\) iff\n\\(\\cV_{\\phi} \\bA_{{o}} = \\sfF\\) or \\(\\cV_{\\phi} \\bB_{{o}} =\n\\sfT\\)\n\\(\\cV_{\\phi} [ \\bA_{{o}} \\equiv \\bB_{{o}} ] = \\sfT\\) iff\n\\(\\cV_{\\phi} \\bA_{{o}} = \\cV_{\\phi} \\bB_{{o}}\\)\n\\(\\cV_{\\phi} [\\forall \\bx_{\\alpha}\\bA] = \\sfT\\) iff\n\\(\\cV_{\\phi[a/x]} \\bA= \\sfT\\) for all \\(a \\in \\cD_{\\alpha}\\)\n\\(\\cV_{\\phi} [\\exists \\bx_{\\alpha}\\bA] = \\sfT\\) iff there exists\nan \\(a \\in \\cD_{\\alpha}\\) such that \\(\\cV_{\\phi[a/x]} \\bA= \\sfT\\)\n\n\nThe semantics of general models is thus as expected. However, there is\na subtlety to note regarding the following condition for arbitrary\ntypes \u03b1:\n\n[equality] \\(\\cV_{\\phi} [ \\bA_{\\alpha} = \\bB_{\\alpha} ] = \\sfT\\)\niff \\(\\cV_{\\phi} \\bA_{\\alpha} = \\cV_{\\phi} \\bB_{\\alpha}\\)\n\n\nWhen the definitions of\n Section 1.2.1\n are employed, where equality has been defined in terms of\nLeibniz\u2019 principle, then this statement is not implied for all\ntypes \u03b1. It only holds if we additionally require that the\ndomains \\(\\cD_{{o}\\alpha}\\) contain all the unit sets of objects of\ntype \u03b1, or, alternatively, that the domains\n\\(\\cD_{{o}\\alpha\\alpha}\\) contain the respective identity relations on\nobjects of type \u03b1 (which entails the former). The need for this\nadditional requirement, which is not included in the original work of\nHenkin (1950), has been demonstrated in Andrews 1972a.\n\nWhen instead the alternative definitions of\n Section 1.4\n are employed, then this requirement is obviously met due to the\npresence of the logical constants \\(\\sfQ_{{o}\\alpha \\alpha}\\) in the\nsignature, which by definition denote the respective identity\nrelations on the objects of type \u03b1 and therefore trivially\nensure their existence in each general model \\(\\cM\\). It is therefore\na natural option to always assume primitive equality constants (for\neach type \u03b1) in a concrete choice of base system for\nChurch\u2019s type theory, just as realized in Andrews\u2019 system\n\\(\\cQ_0\\).\n\nAn interpretation \\(\\langle \\{\\cD_{\\alpha}\\}_{\\alpha}, \\frI\\rangle\\)\nis a standard model iff for all \u03b1 and \\(\\beta ,\n\\cD_{\\alpha \\beta}\\) is the set of all functions from \\(\\cD_{\\beta}\\)\ninto \\(\\cD_{\\alpha}\\). Clearly a standard model is a general\nmodel.\n\nWe say that a wff \\(\\bA\\) is valid in a model \\(\\cM\\) iff\n\\(\\cV_{\\phi}\\bA = \\sfT\\) for every assignment \\(\\phi\\) into \\(\\cM\\). A\nmodel for a set \\(\\cH\\) of wffs is a model in which each wff of\n\\(\\cH\\) is valid.\n\nA wff \\(\\bA\\) is valid in the general [standard]\nsense iff \\(\\bA\\) is valid in every general [standard] model.\nClearly a wff which is valid in the general sense is valid in the\nstandard sense, but the converse of this statement is false.\n\nCompleteness and Soundness Theorem (Henkin 1950):\nA wff is a theorem if and only if it is valid in the general\nsense.\n\nNot all frames belong to interpretations, and not all interpretations\nare general models. In order to be a general model, an interpretation\nmust have a frame satisfying certain closure conditions which are\ndiscussed further in Andrews 1972b. Basically, in a general model\nevery wff must have a value with respect to each assignment.\n\nA model is said to be finite iff its domain of individuals is\nfinite. Every finite model for \\(\\cQ_0\\) is standard (Andrews 2002,\nTheorem 5404), but every set of sentences of \\(\\cQ_0\\) which has\ninfinite models also has nonstandard models (Andrews2002, Theorem\n5506).\n\nAn understanding of the distinction between standard and nonstandard\nmodels can clarify many phenomena. For example, it can be shown that\nthere is a model \\(\\cM = \\langle \\{\\cD_{\\alpha}\\}_{\\alpha},\n\\frI\\rangle\\) in which \\(\\cD_{\\imath}\\) is infinite, and all the\ndomains \\(\\cD_{\\alpha}\\) are countable. Thus \\(\\cD_{\\imath}\\) and\n\\(\\cD_{{o}\\imath}\\) are both countably infinite, so there must be a\nbijection h between them. However, Cantor\u2019s Theorem\n(which is provable in type theory and therefore valid in all models)\nsays that \\(\\cD_{\\imath}\\) has more subsets than members. This\nseemingly paradoxical situation is called Skolem\u2019s Paradox. It\ncan be resolved by looking carefully at Cantor\u2019s Theorem, i.e.,\n\\(\\nsim \\exists g_{{o}\\imath\\imath}\\forall f_{{o}\\imath}\\exists\nj_{\\imath}[g_{{o}\\imath\\imath}j_{\\imath} = f_{{o}\\imath}]\\), and\nconsidering what it means in a model. The theorem says that there is\nno function \\(g \\in \\cD_{{o}\\imath\\imath}\\) from \\(\\cD_{\\imath}\\) into\n\\(\\cD_{{o}\\imath}\\) which has every set \\(f_{{o}\\imath} \\in\n\\cD_{{o}\\imath}\\) in its range. The usual interpretation of the\nstatement is that \\(\\cD_{{o}\\imath}\\) is bigger (in cardinality) than\n\\(\\cD_{\\imath}\\). However, what it actually means in this model is\nthat h cannot be in \\(\\cD_{{o}\\imath\\imath}\\). Of course,\n\\(\\cM\\) must be nonstandard.\n\nWhile the Axiom of Choice is presumably true in all standard models,\nthere is a nonstandard model for \\(\\cQ_0\\) in which AC\\(^{\\imath}\\) is\nfalse (Andrews 1972b). Thus, AC\\(^{\\imath}\\) is not provable in\n\\(\\cQ_0\\).\n\nThus far, investigations of model theory for Church\u2019s type\ntheory have been far less extensive than for first-order logic.\nNevertheless, there has been some work on methods of constructing\nnonstandard models of type theory and models in which various forms of\nextensionality fail, models for theories with arbitrary (possibly\nincomplete) sets of logical constants, and on developing general\nmethods of establishing completeness of various systems of axioms with\nrespect to various classes of models. Relevant papers include Andrews\n1971, 1972a,b, and Henkin 1975. Further related work can be found in\nBenzm\u00fcller et al. 2004, Brown 2004, 2007, and Muskens 2007.\n3. Metatheory\n3.1 Lambda-Conversion\n\nThe first three rules of inference in\n Section 1.3.1\n are called rules of \u03bb-conversion. If \\(\\bD\\) and\n\\(\\bE\\) are wffs, we write \\(\\bD \\conv \\bE\\) to indicate that \\(\\bD\\)\ncan be converted to \\(\\bE\\) by applications of these rules. This is an\nequivalence relation between wffs. A wff \\(\\bD\\) is in\n\u03b2-normal form iff it has no well-formed parts of the\nform \\([[\\lambda \\bx_{\\alpha}\\bB_{\\beta}]\\bA_{\\alpha}]\\). Every wff is\nconvertible to one in \u03b2-normal form. Indeed, every sequence of\ncontractions (applications of rule 2, combined as necessary with\nalphabetic changes of bound variables) of a wff is finite; obviously,\nif such a sequence cannot be extended, it terminates with a wff in\n\u03b2-normal form. (This is called the strong normalization theorem.)\nBy the Church-Rosser Theorem, this wff in \u03b2-normal form is unique\nmodulo alphabetic changes of bound variables. For each wff \\(\\bA\\) we\ndenote by \\({\\downarrow}\\bA\\) the first wff (in some enumeration) in\n\u03b2-normal form such that \\(\\bA \\conv {\\downarrow} \\bA\\). Then \\(\\bD\n\\conv \\bE\\) if and only if \\({\\downarrow} \\bD = {\\downarrow} \\bE\\).\n\nBy using the Axiom of Extensionality one can obtain the following\nderived rule of inference:\n\n\n\\(\\eta\\)-Contraction. Replace a well-formed part \\([\\lambda\n\\by_{\\beta}[\\bB_{\\alpha \\beta}\\by_{\\beta}]]\\) of a wff by\n\\(\\bB_{\\alpha \\beta}\\), provided \\(\\by_{\\beta}\\) does not occur free\nin \\(\\bB_{\\alpha \\beta}\\).\n\n\nThis rule and its inverse (which is called\n\\(\\eta\\)-Expansion) are sometimes used as additional rules of\n\u03bb-conversion. See Church 1941, Stenlund 1972, Barendregt 1984,\nand Barendregt et al. 2013 for more information about\n\u03bb-conversion.\n\nIt is worth mentioning (again) that \u03bb-abstraction replaces the\nneed for comprehension axioms in Church\u2019s type theory.\n3.2 Higher-Order Unification\n\nThe challenges in higher-order unification are outlined very briefly.\nMore details on the topic are given in Dowek 2001; its utilization in\nhigher-order theorem provers is also discussed in Benzm\u00fcller\n& Miller 2014.\n\nDefinition. A higher-order unifier for a\npair \\(\\langle \\bA,\\bB\\rangle\\) of wffs is a substitution \\(\\theta\\)\nfor free occurrences of variables such that \\(\\theta \\bA\\) and\n\\(\\theta \\bB\\) have the same \u03b2-normal form. A higher-order\nunifier for a set of pairs of wffs is a unifier for each of the pairs\nin the set.\n\nHigher-order unification differs from first-order unification (Baader\n& Snyder 2001) in a number of important respects. In\nparticular:\n\nEven when a unifier for a pair of wffs exists, there may be no\nmost general unifier (Gould 1966).\nHigher-order unification is undecidable (Huet 1973b), even in the\n\u201csecond-order\u201d case (Goldfarb 1981).\n\n\nHowever, an algorithm has been devised (Huet 1975, Jensen &\nPietrzykowski 1976), called pre-unification, which will find\na unifier for a set of pairs of wffs if one exists. The pre-unifiers\ncomputed by Huet\u2019s procedure are substitutions that can reduce\nthe original unification problem to one involving only so called\nflex-flex unification pairs. Flex-flex pairs have variable\nhead symbols in both terms to be unified and they are known to always\nhave a solution. The concrete computation of these solutions can thus\nbe postponed or omitted. Pre-unification is utilized in all the\nresolution based theorem provers mentioned in\n Section 4.\n \n\nPattern unification refers a small subset of unification\nproblems, first studied by Miller 1991, whose identification has been\nimportant for the construction of practical systems. In a pattern\nunification problem every occurrence of an existentially quantified\nvariable is applied to a list of arguments that are all distinct\nvariables bound by either a \u03bb-binder or a universal quantifier\nin the scope of the existential quantifier. Thus, existentially\nquantified variables cannot be applied to general terms but a very\nrestricted set of bound variables. Pattern unification, like\nfirst-order unification, is decidable and most general unifiers exist\nfor solvable problems. This is why pattern unification is preferably\nemployed (when applicable) in some state-of-the-art theorem provers\nfor Church\u2019s type theory. \n3.3 A Unifying Principle\n\nThe Unifying Principle was introduced in Smullyan 1963 (see\nalso Smullyan 1995) as a tool for deriving a number of basic\nmetatheorems about first-order logic in a uniform way. The principle\nwas extended to elementary type theory by Andrews (1971) and to\nextensional type theory, that is, Henkin\u2019s general semantics\nwithout description or choice, by Benzm\u00fcller, Brown and Kohlhase\n(2004). We outline these extensions in some more detail below.\n3.3.1 Elementary Type Theory\n\nThe Unifying Principle was extended to elementary type theory (the\nsystem \\(\\cT\\) of\n Section 1.3.2)\n in Andrews 1971 by applying ideas in Takahashi 1967. This Unifying\nPrinciple for \\(\\cT\\) has been used to establish cut-elimination for\n\\(\\cT\\) in Andrews 1971 and completeness proofs for various systems of\ntype theory in Huet 1973a, Kohlhase 1995, and Miller 1983. We first\ngive a definition and then state the principle.\n\nDefinition. A property \\(\\Gamma\\) of finite sets of\nwffs\\(_{{o}}\\) is an abstract consistency property iff for\nall finite sets \\(\\cS\\) of wffs\\(_{{o}}\\), the following properties\nhold (for all wffs A, B):\n\nIf \\(\\Gamma(\\cS)\\), then there is no atom \\(\\bA\\) such that \\(\\bA\n\\in \\cS\\) and \\([\\nsim \\bA] \\in \\cS\\).\nIf \\(\\Gamma(\\cS \\cup \\{\\bA\\})\\), then \\(\\Gamma(\\cS \\cup {\\downarrow}\n\\bA\\})\\).\nIf \\(\\Gamma(\\cS \\cup \\{\\nsim \\nsim \\bA\\})\\), then \\(\\Gamma(\\cS\n\\cup \\{\\bA\\})\\).\nIf \\(\\Gamma(\\cS \\cup \\{\\bA \\lor \\bB\\})\\), then \\(\\Gamma(\\cS \\cup\n\\{\\bA\\})\\) or \\(\\Gamma(\\cS \\cup \\{\\bB\\})\\).\nIf \\(\\Gamma(\\cS \\cup \\{\\nsim[\\bA \\lor \\bB]\\})\\), then \\(\\Gamma(\\cS\n\\cup \\{\\nsim \\bA,\\nsim \\bB\\})\\).\nIf \\(\\Gamma(\\cS \\cup \\{\\Pi_{{o}({o}\\alpha)}\\bA_{{o}\\alpha}\\})\\),\nthen \\(\\Gamma(\\cS \\cup \\{\\Pi_{{o}({o}\\alpha)}\\bA_{{o}\\alpha},\n\\bA_{{o}\\alpha}\\bB_{\\alpha}\\})\\) for each wff \\(\\bB_{\\alpha}\\).\nIf \\(\\Gamma(\\cS \\cup \\{\\nsim\n\\Pi_{{o}({o}\\alpha)}\\bA_{{o}\\alpha}\\})\\), then \\(\\Gamma(\\cS \\cup\n\\{\\nsim \\bA_{{o}\\alpha}\\bc_{\\alpha}\\})\\), for any variable or\nparameter \\(\\bc_{\\alpha}\\) which does not occur free in\n\\(\\bA_{{o}\\alpha}\\) or any wff in \\(\\cS\\).\n\n\nNote that consistency is an abstract consistency\nproperty.\n\nUnifying Principle for \\(\\cT\\). If \\(\\Gamma\\) is an\nabstract consistency property and \\(\\Gamma(\\cS)\\), then \\(\\cS\\) is\nconsistent in \\(\\cT\\).\n\nHere is a typical application of the Unifying Principle. Suppose there\nis a procedure \\(\\cM\\) which can be used to refute sets of sentences,\nand we wish to show it is complete for \\(\\cT\\). For any set of\nsentences, let \\(\\Gamma(\\cS)\\) mean that \\(\\cS\\) is not refutable by\n\\(\\cM\\), and show that \\(\\Gamma\\) is an abstract consistency property.\nNow suppose that \\(\\bA\\) is a theorem of \\(\\cT\\). Then \\(\\{\\nsim\n\\bA\\}\\) is inconsistent in \\(\\cT\\), so by the Unifying Principle not\n\\(\\Gamma(\\{\\nsim \\bA\\})\\), so \\(\\{\\nsim \\bA\\}\\) is refutable by\n\\(\\cM\\).\n3.3.2 Extensional Type Theory\n\nExtensions of the above Unifying principle towards Church\u2019s type\ntheory with general semantics were studied since the mid nineties. A\nprimary motivation was to support (refutational) completeness\ninvestigations for the proof calculi underlying the emerging\nhigher-order automated theorem provers (see\n Section 4\n below). The initial interest was on a fragment of Church\u2019s type\ntheory, called extensional type theory, that includes the\nextensionality axioms, but excludes \\(\\iota_{(\\alpha({o}\\alpha))}\\)\nand the axioms for it (description and choice were largely neglected\nin the automated theorem provers at the time). Analogous to before, a\ndistinction has been made between extensional type theory with\ndefined equality (as in\n Section 1.2.1,\n where equality is defined via Leibniz\u2019 principle) and\nextensional type theory with primitive equality (e.g., system\n\\(\\cQ_0\\) as in\n Section 1.4,\n or, alternatively, a system based on logical constants\n\\(\\nsim_{({o}{o})}, \\lor_{(({o}{o}){o})}\\), and the\n\\(\\Pi_{({o}({o}\\alpha))}\\)\u2019s as in\n Section 1.2.1,\n but with additional primitive logical constants\n\\(=_{{o}\\alpha\\alpha}\\) added).\n\nA first attempt towards a Unifying Principle for extensional type\ntheory with primitive equality is presented in Kohlhase 1993. The\nconditions given there, which are still\n incomplete[1],\n were subsequently modified and complemented as follows:\n\n\n\nTo obtain a Unifying Principle for extensional type theory with\ndefined equality, Benzm\u00fcller & Kohlhase 1997 added the\nfollowing conditions for boolean extensionality, functional\nextensionality and saturation to the above conditions 1.-7. for\n\\(\\cT\\) (their presentation has been adapted here; for technical reasons,\nthey also employ a slightly stronger variant for condition 2. based on\n\u03b2-conversion rather than \u03b2-normalization):\n\nIf \\(\\Gamma(\\cS \\cup \\{ \\bA_{{o}} = \\bB_{{o}} \\})\\), then\n\\(\\Gamma(\\cS \\cup \\{ \\bA_{{o}}, \\bB_{{o}} \\})\\) or \\(\\Gamma(\\cS \\cup \\{ \\nsim \\bA_{{o}}, \\nsim \\bB_{{o}} \\})\\)\nIf \\(\\Gamma(\\cS \\cup \\{ \\bA_{\\alpha\\beta} = \\bB_{\\alpha\\beta}\n\\})\\), then \\(\\Gamma(\\cS \\cup \\{ \\bA_{\\alpha\\beta} \\bc_\\beta =\n\\bB_{\\alpha\\beta} \\bc_\\beta \\})\\) for any parameter \\(\\bc_{\\beta}\\)\nwhich does not occur free in \\(\\cS\\).\n\\(\\Gamma(\\cS \\cup \\{ \\bA_{{o}} \\})\\) or \\(\\Gamma(\\cS \\cup \\{ \\nsim\n\\bA_{{o}} \\})\\)\n\n\nThe saturation condition 10. was required to properly establish the\nprinciple. However, since this condition is related to the proof\ntheoretic notion of cut-elimination, it limits the utility of the\nprinciple in completeness proofs for machine-oriented calculi. The\nprinciple was nevertheless used in Benzm\u00fcller & Kohlhase\n1998a and Benzm\u00fcller 1999a,b to obtain a completeness proof for a\nsystem of extensional higher-order resolution. The principle was also\napplied in Kohlhase 1998 to study completeness for a related\nextensional higher-order tableau\n calculus,[2]\n in which the extensionality rules for Leibniz equality were adapted\nfrom Benzm\u00fcller & Kohlhase 1998a, respectively\nBenzm\u00fcller 1997.\n\n\nDifferent options for achieving a Unifying Principle for extensional\ntype theory with primitive equality are presented in Benzm\u00fcller\n1999a (in this work primitive logical constants\n\\(=_{{o}\\alpha\\alpha}\\) were used in addition to \\(\\nsim_{({o}{o})},\n\\lor_{(({o}{o}){o})}\\), and the \\(\\Pi_{({o}({o}\\alpha))}\\)\u2019s;\nsuch a redundant choice of logical constants is not rare in\nhigher-order theorem provers). One option is to introduce a\nreflexivity and substitutivity condition. An alternative is to combine\na reflexivity condition with a condition connecting primitive with\ndefined equality, so that the substitutivity condition follows. Note\nthat introducing a defined notion of equality based on the Leibniz\nprinciple is, of course, still possible in this context (defined\nequality is denoted in the remainder of this section by \\(\\doteq\\) to\nproperly distinguish it from primitive equality \\(=\\)):\n\nNot \\(\\Gamma(\\cS \\cup \\{ \\nsim [\\bA_{\\alpha} = \\bA_{\\alpha}]\n\\})\\)\nIf \\(\\Gamma(\\cS \\cup \\{ \\bA_{\\alpha} = \\bA_{\\alpha} \\})\\), then\n\\(\\Gamma(\\cS \\cup \\{ \\bA_{\\alpha} \\doteq \\bA_{\\alpha} \\})\\)\n\\(\\Gamma(\\cS \\cup \\{ \\bA_{{o}} \\})\\) or \\(\\Gamma(\\cS \\cup \\{ \\nsim\n\\bA_{{o}} \\})\\)\n\n\nThe saturation condition 10. still has to be added independent of\nwhich option is considered. The principle was applied in\nBenzm\u00fcller 1999a,b to\nprove completeness for the extensional higher-order\n RUE-resolution[3]\n calculus underlying the higher-order automated theorem prover LEO and\nits successor LEO-II.\n\n\nIn Benzm\u00fcller et al. 2004 the principle is presented in a very\ngeneral way which allows for various possibilities concerning the\ntreatment of extensionality and equality in the range between\nelementary type theory and extensional type theory. The principle is\napplied to obtain completeness proofs for an associated range of\nnatural deduction calculi. The saturation condition is still used in\nthis work.\n\n\nBased on insights from Brown\u2019s (2004, 2007) thesis, a solution\nfor replacing the undesirable saturation condition by two weaker\nconditions is presented in Benzm\u00fcller, Brown, and Kohlhase 2009;\nthis work also further studies the relation between saturation and\ncut-elimination. The two weaker conditions, termed mating and\ndecomposition, are easier to demonstrate than saturation in\ncompleteness proofs for machine-oriented calculi. They are (omitting\nsome type information in the second one and abusing notation):\n\nIf \\(\\Gamma(\\cS \\cup \\{ \\nsim \\bA_{{o}}, \\bB_{{o}} \\})\\) for atoms\n\\(\\bA_{{o}}\\) and \\(\\bB_{{o}}\\), then \\(\\Gamma(\\cS \\cup \\{ \\nsim [\\bA_{{o}} \\doteq \\bB_{{o}}] \\})\\)\nIf \\(\\Gamma(\\cS \\cup \\{ \\nsim [h \\overline{\\bA^n_{\\alpha^n}}\n\\doteq h \\overline{\\bB^n_{\\alpha^n}} ] \\})\\), where head symbol\n\\(h_{\\beta\\overline{\\alpha^n}}\\) is a parameter, then there is an \\(i\\\n(1 \\leq i \\leq n)\\) such that \\(\\Gamma(\\cS \\cup \\{ \\nsim [\\bA^i_{\\alpha^i} \\doteq \\bB^i_{\\alpha^i}]\n\\})\\).\n\n\nThe modified principle is applied in Benzm\u00fcller et al. 2009 to\nshow completeness for a sequent calculus for extensional type theory\nwith defined equality.\n\n\nA further extended Unifying Principle for extensional type theory with\nprimitive equality is presented and used in Backes & Brown 2011 to\nprove the completeness of a tableau calculus for type theory which\nincorporates the axiom of choice.\n\n\nA closely related and further simplified principle has also been\npresented and studied in Steen 2018, where it was applied for showing\ncompleteness of the paramodulation calculus (Steen 2018) that is\nunderlying the theorem prover Leo-III (Steen & Benzm\u00fcller\n2018).\n\n3.4 Cut-Elimination and Cut-Simulation\n\nCut-elimination proofs (see also the SEP entry on\n proof theory)\n for Church\u2019s type theory, which are often closely related to\nsuch proofs (Takahashi 1967, 1970; Prawitz 1968; Mints 1999) for other\nformulations of type theory, may be found in Andrews 1971, Dowek &\nWerner 2003, and Brown 2004. In Benzm\u00fcller et al. 2009 it is\nshown how certain wffs\\(_{{o}}\\), such as axioms of extensionality,\ndescriptions, choice (see\n Sections 1.3.3\n to\n 1.3.5),\n and induction, can be used to justify cuts in cut-free sequent\ncalculi for elementary type theory. Moreover, the notions of\ncut-simulation and cut-strong axioms are introduced\nin this work, and the need for omitting defined equality and for\neliminating cut-strong axioms such as extensionality,\ndescription, choice and induction in machine-oriented calculi (e.g.,\nby replacing them with more constrained, goal-directed rules) in order\nto reduce cut-simulation effects are discussed as a major\nchallenge for higher-order automated theorem proving. In other words,\nincluding cut-strong axioms in a machine-oriented proof calculus for\nChurch\u2019s type theory is essentially as bad as including a cut\nrule, since the cut rule can be mimicked by them.\n3.5 Expansion Proofs\n\nAn expansion proof is a generalization of the notion of a\nHerbrand expansion of a theorem of first-order logic; it provides a\nvery elegant, concise, and nonredundant representation of the\nrelationship between the theorem and a tautology which can be obtained\nfrom it by appropriate instantiations of quantifiers and which\nunderlies various proofs of the theorem. Miller (1987) proved that a\nwff \\(\\bA\\) is a theorem of elementary type theory if and only if\n\\(\\bA\\) has an expansion proof.\n\nIn Brown 2004 and 2007, this concept is generalized to that of an\nextensional expansion proof to obtain an analogous theorem\ninvolving type theory with extensionality.\n3.6 The Decision Problem\n\nSince type theory includes first-order logic, it is no surprise that\nmost systems of type theory are undecidable. However, one may look for\nsolvable special cases of the decision problem. For example, the\nsystem \\(\\cQ_{0}^1\\) obtained by adding to \\(\\cQ_0\\) the additional\naxiom \\(\\forall x_{\\imath}\\forall y_{\\imath}[x_{\\imath}=y_{\\imath}]\\)\nis decidable.\n\nAlthough the system \\(\\cT\\) of elementary type theory is analogous to\nfirst-order logic in certain respects, it is a considerably more\ncomplex language, and special cases of the decision problem for\nprovability in \\(\\cT\\) seem rather intractable for the most part.\nInformation about some very special cases of this decision problem may\nbe found in Andrews 1974, and we now summarize this.\n\nA wff of the form \\(\\exists \\bx^1 \\ldots \\exists \\bx^n [\\bA=\\bB]\\) is\na theorem of \\(\\cT\\) iff there is a substitution \\(\\theta\\) such that\n\\(\\theta \\bA \\conv \\theta \\bB\\). In particular, \\(\\vdash \\bA=\\bB\\) iff\n\\(\\bA \\conv \\bB\\), which solves the decision problem for wffs of the\nform \\([\\bA=\\bB]\\). Naturally, the circumstance that only trivial\nequality formulas are provable in \\(\\cT\\) changes drastically when\naxioms of extensionality are added to \\(\\cT\\). \\(\\vdash \\exists\n\\bx_{\\beta}[\\bA=\\bB]\\) iff there is a wff \\(\\bE_{\\beta}\\) such that\n\\(\\vdash[\\lambda \\bx_{\\beta}[\\bA=\\bB]]\\bE_{\\beta}\\), but the decision\nproblem for the class of wffs of the form \\(\\exists\n\\bx_{\\beta}[\\bA=\\bB]\\) is unsolvable.\n\nA wff of the form \\(\\forall \\bx^1 \\ldots \\forall \\bx^n\\bC\\), where\n\\(\\bC\\) is quantifier-free, is provable in \\(\\cT\\) iff \\({\\downarrow}\n\\bC\\) is tautologous. On the other hand, the decision problem for wffs\nof the form \\(\\exists \\bz\\bC\\), where \\(\\bC\\) is quantifier-free, is\nunsolvable. (By contrast, the corresponding decision problem in\nfirst-order logic with function symbols is known to be solvable\n(Maslov 1967).) Since irrelevant or vacuous quantifiers can always be\nintroduced, this shows that the only solvable classes of wffs of\n\\(\\cT\\) in prenex normal form defined solely by the structure of the\nprefix are those in which no existential quantifiers occur.\n4. Automation\n4.1 Machine-Oriented Proof Calculi\n\nThe development, respectively improvement, of machine-oriented proof\ncalculi for Church\u2019s type theory is still a challenge research\ntopic. Compared, e.g., to the theoretical and practical maturity\nachieved in first-order automated theorem proving, the area is still\nin its infancy. Obviously, the challenges are also much bigger than in\nfirst-order logic. The practically way more expressive nature of the\nterm-language of Church\u2019s type theory causes a larger, bushier\nand more difficult to traverse proof search space than in first-order\nlogic. Moreover, remember that unification, which constitutes a very\nimportant control and filter mechanism in first-order theorem proving,\nis undecidable (in general) in type theory; see\n Section 3.2.\n On the positive side, however, there is a chance to find\nsignificantly shorter proofs than in first-order logic. This is well\nillustrated with a small, concrete example in Boolos 1987. Clearly,\nmuch further progress is needed to further leverage the practical\nrelevance of existing calculi for Church\u2019s type theory and their\nimplementations (see\n Section 4.3).\n The challenges include\n\nan appropriate handling of the impredicative nature of\nChurch\u2019s type theory (some form of blind guessing cannot\ngenerally be avoided in a complete proof procedure, but must be\nintelligently guided),\nthe elimination/reduction of cut-simulation effects (see\n Section 3.4)\n caused by defined equality or cut-strong axioms (e.g.,\nextensionality, description, choice, induction) in the search\nspace,\nthe general undecidability of unification, rendering it a rather\nproblematic filter mechanism for controlling proof search,\nthe invention of suitable heuristics for traversing the search\nspace,\nthe provision of suitable term-orderings and their effective\nexploitation in term rewriting procedures,\nand the development of efficient data structures in combination\nwith strong technical support for essential operations such\n\u03bb-conversion, substitution and rewriting.\n\n\nIt is planned that future editions of this article further elaborate\non machine-oriented proof calculi for Church\u2019s type theory. For\nthe time being, however, we provide only a selection of historical and\nmore recent references for the interested reader (see also\n Section 5 below):\n\nSequent calculi: Sch\u00fctte 1960; Takahashi\n1970; Takeuti 1987; Mints 1999; Brown 2004, 2007; Benzm\u00fcller et\nal. 2009.\nMating method: Andrews 1981; Bibel 1981; Bishop\n1999.\nResolution calculi: Andrews 1971; Huet 1973a;\nJensen & Pietrzykowski 1976; Benzm\u00fcller 1997, 1999a;\nBenzm\u00fcller & Kohlhase 1998a. \nTableau method:\n Kohlhase[4]\n 1995, 1998; Brown & Smolka 2010; Backes & Brown 2011.\nParamodulation calculi: Benzm\u00fcller 1999a,b;\nSteen 2018.\n\n4.2 Early Proof Assistants\n\nEarly computer systems for proving theorems of Church\u2019s type\ntheory (or extensions of it) include HOL (Gordon 1988; Gordon &\nMelham 1993), TPS (Andrews et al. 1996; Andrews & Brown 2006),\nIsabelle (Paulson 1988, 1990), PVS (Owre et al. 1996; Shankar 2001),\nIMPS (Farmer et al. 1993), HOL\nLight (Harrison 1996), OMEGA (Siekmann et al. 2006), and \u03bbClam\n(Richardson et al. 1998). See\n Other Internet References\n section below for links to further info on these and other provers\nmentioned later. \n\nThe majority of the above systems focused (at least initially) on\ninteractive proof and provided rather limited support for additional\nproof automation. Full proof automation was pioneered, in particular,\nby the TPS project. Progress was made in the nineties, when other\nprojects started similar activities, respectively, enforced theirs.\nHowever, the resource investments and achievements were lacking much\nbehind those seen in first-order theorem proving. Significant progress\nwas fostered only later, in particular, through the development of a\ncommonly supported syntax for Church\u2019s type theory, called TPTP\nTHF (Sutcliffe & Benzm\u00fcller 2010), and the inclusion, from\n2009 onwards, of a TPTP THF division in the yearly CASC competitions\n(kind of world championships for automated theorem proving; see\nSutcliffe 2016 for further details).\n4.3 Automated Theorem Provers\n\nAn selection of theorem provers for Church\u2019s type theory is\npresented. The focus is on systems that have successfully participated\nin TPTP THF CASC competitions in the past. The latest editions of most\nmentioned systems can be accessed online via the SystemOnTPTP\ninfrastructure (Sutcliffe 2017). Nearly all mentioned systems produce\nverifiable proof certificates in the TPTP TSTP syntax. Further details\non the automation of Church\u2019s type theory are given in\nBenzm\u00fcller & Miller 2014.\n\nThe TPS prover (Andrews et al. 1996, Andrews & Brown 2006) can be\nused to prove theorems of elementary type theory or extensional type\ntheory automatically, interactively, or semi-automatically. When\nsearching for a proof automatically, TPS first searches for an\nexpansion proof (Miller 1987) or an extensional expansion proof (Brown\n2004, 2007) of the theorem. Part of this process involves searching\nfor acceptable matings (Andrews 1981, Bishop 1999). The behavior of\nTPS is controlled by sets of flags, also called modes. A simple\nscheduling mechanism is employed in the latest versions of TPS to\nsequentially run a about fifty modes for a limited amount of time. TPS\nwas the winner of the first THF CASC competition in 2009.\n\nThe LEO-II prover (Benzm\u00fcller et al. 2015) is the successor of\nLEO (Benzm\u00fcller & Kohlhase 1998b, which was hardwired with\nthe OMEGA proof assistant (LEO stands for Logical Engine of OMEGA).\nThe provers are based on the RUE-resolution calculi developed in\nBenzm\u00fcller 1999a,b. LEO\nwas the first prover to implement calculus rules for extensionality to\navoid cut-simulation effects. LEO-II inherits and adapts them, and\nprovides additional calculus rules for description and choice. The\nprover, which internally collaborates with first-order provers\n(preferably E) and SAT solvers, has pioneered cooperative\nhigher-order/first-order proof automation. Since the prover is often\ntoo weak to find a refutation among the steadily growing set of\nclauses on its own, some of the clauses in LEO-II\u2019s search space\nattain a special status: they are first-order clauses modulo the\napplication of an appropriate transformation function. Therefore,\nLEO-II progressively launches time limited calls with these clauses to\na first-order theorem prover, and when the first-order prover reports\na refutation, LEO-II also terminates. Parts of these ideas were\nalready implemented in the predecessor LEO. Communication between\nLEO-II and the cooperating first-order theorem provers uses the TPTP\nlanguage and standards. LEO-II was the winner of the second THF CASC\ncompetition in 2010.\n\nThe Satallax prover (Brown 2012) is based on a complete ground tableau\ncalculus for Church\u2019s type theory with choice (Backes &\nBrown 2011). An initial tableau branch is formed from the assumptions\nof a conjecture and negation of its conclusion. From that point on,\nSatallax tries to determine unsatisfiability or satisfiability of this\nbranch. Satallax progressively generates higher-order formulas and\ncorresponding propositional clauses. Satallax uses the SAT solver\nMiniSat as an engine to test the current set of propositional clauses\nfor unsatisfiability. If the clauses are unsatisfiable, the original\nbranch is unsatisfiable. Satallax provides calculus rules for\nextensionality, description and choice. If there are no quantifiers at\nfunction types, the generation of higher-order formulas and\ncorresponding clauses may terminate. In that case, if MiniSat reports\nthe final set of clauses as satisfiable, then the original set of\nhigher-order formulas is satisfiable (by a standard model in which all\ntypes are interpreted as finite sets). Satallax was the winner of the\nTHF CASC competition in 2011 and since 2013. \n\nThe Isabelle/HOL system (Nipkow, Wenzel, & Paulson 2002) has\noriginally been designed as an interactive prover. However, in order\nto ease user interaction several automatic proof tactics have been\nadded over the years. By appropriately scheduling a subset of these\nproof tactics, some of which are quite powerful, Isabelle/HOL has\nsince about 2011 been turned also into an automatic theorem prover for\nTPTP THF (and other TPTP syntax formats), that can be run from a\ncommand shell like other provers. The most powerful proof tactics that\nare scheduled by Isabelle/HOL include the Sledgehammer tool\n(Blanchette et al. 2013),\nwhich invokes a sequence of external first-order and higher-order\ntheorem provers, the model finder Nitpick (Blanchette &\nNipkow 2010), the equational reasoner simp, the untyped\ntableau prover blast, the simplifier and classical reasoners\nauto, force, and fast, and the best-first\nsearch procedure best. In contrast to all other automated\ntheorem provers mentioned above, the TPTP incarnation of Isabelle/HOL\ndoes not yet output proof certificates. Isabelle/HOL was the winner of\nthe THF CASC competition in 2012. \n\nThe agsyHOL prover is based on a generic lazy narrowing proof search\nalgorithm. Backtracking is employed and a comparably small search\nstate is maintained. The prover outputs proof terms in sequent style\nwhich can be verified in the Agda system. \n\ncoqATP implements (the non-inductive) part of the calculus of\nconstructions (Bertot & Cast\u00e9ran 2004). The system outputs\nproof terms which are accepted as proofs (after the addition of a few\ndefinitions) by the Coq proof assistant. The prover employs axioms for\nfunctional extensionality, choice, and excluded middle. Boolean\nextensionality is not supported. In addition to axioms, a small\nlibrary of basic lemmas is employed. \n\nThe Leo-III prover implements a paramodulation calculus for\nChurch\u2019s type theory (Steen 2018). The system, which is a\ndescendant of LEO and LEO-II, provides calculus rules for\nextensionality, description and choice. The system has put an emphasis\non the implementation of an efficient set of underlying data\nstructures, on simplification routines and on heuristic rewriting. In\nthe tradition of its predecessors, Leo-III cooperates with first-order\nreasoning tools using translations to many-sorted first-order logic.\nThe prover accepts every common TPTP syntax dialect and is thus very\nwidely applicable. Recently, the prover has also been extended to\nnatively supports almost every normal higher-order modal logic.\n\nZipperposition (Bentkamp et al. 2018) is new and inspiring\nhigher-order theorem prover which, at the current state of\ndevelopment, is still working for a comparably weak fragment of\nChurch\u2019s type theory, called lambda-free higher-order\nlogic (a comprehension-free higher-order logic,\nwhich is nevertheless supporting \u03bb-notation). The system, which\nis based on superposition calculi, is developed bottom up, and it is\nprogressively extended towards stronger fragments of Church\u2019s\ntype theory and to support other relevant extensions such datatypes,\nrecursive functions and arithmetic. \n\nVarious so called proof hammers, in the spirit of\nIsabelle\u2019s Sledgehammer tool, have recently been developed and\nintegrated with modern proof assistants. Prominent examples include\nHOL(y)Hammer (Kaliszyk & Urban 2015) for HOL Light and a similar\nhammer (Czaika & Kaliszyk 2018) for the proof assistant Coq. \n4.4 (Counter-)Model Finding\n\nSupport for finding finite models or countermodels for formulas of\nChurch\u2019s type theory was implemented already in the\ntableau-based prover HOT (Konrad 1998). Restricted (counter-)model\nfinding capabilities are also implemented in the provers Satallax,\nLEO-II and LEO-III. The most advanced (finite) model finding support\nis currently realized in the systems Nitpick, Nunchaku and Refute. These tools\nhave been integrated with the Isabelle proof assistant. Nitpick is\nalso available as a standalone tool that accepts TPTP THF syntax. The\nsystems are particularly valuable for exposing errors and\nmisconceptions in problem encodings, and for revealing bugs in the THF\ntheorem provers.\n5. Applications\n5.1 Semantics of Natural Language\n\nChurch\u2019s type theory plays an important role in the study of the\nformal semantics of natural language. Pioneering work on this was done\nby Richard Montague. See his papers \u201cEnglish as a formal\nlanguage\u201d, \u201cUniversal grammar\u201d, and \u201cThe\nproper treatment of quantification in ordinary English\u201d, which\nare reprinted in Montague 1974. A crucial component of\nMontague\u2019s analysis of natural language is the definition of a\ntensed intensional logic (Montague 1974: 256), which is an enhancement\nof Church\u2019s type theory. Montague Grammar had a huge impact, and\nhas since been developed in many further directions, not least in\nTypelogical/Categorical Grammar. Further related work on intensional\nand higher-order modal logic is presented in Gallin 1975 and Muskens\n2006.\n5.2 Mathematics and Computer Science\n\nProof assistants based on Church\u2019s Type Theory, including\nIsabelle/HOL, HOL Light, HOL4, and PVS, have been successfully\nutilized in a broad range of application in computer science and\nmathematics.\n\nApplications in computer science include the verification of hardware,\nsoftware and security protocols. A prominent example is the\nL4.verified project in which Isabelle/HOL was used to formally prove\nthat the seL4 operating system kernel implements an abstract,\nmathematical model specifying of what the kernel is supposed to do\n(Klein et al. 2018). \n\nIn mathematics proof assistants have been applied for the development\nof libraries mathematical theories and the verification of challenge\ntheorems. An early example is the mathematical library that was\ndeveloped since the eighties in the TPS project. A exemplary list of\ntheorems that were proved automatically with TPS is given in Andrews\net al. 1996. A very prominent recent example is Hales Flyspeck in\nwhich HOL Light was employed to develop a formal proof for\nKepler\u2019s conjecture (Hales et al. 2017). An example that\nstrongly exploits automation support in Isabelle/HOL with Sledgehammer\nand Nitpick is presented in Benzm\u00fcller & Scott forthcoming.\nIn this work different axiom systems for category theory were explored\nand compared. \n\nA solid overview on past and ongoing formalization projects can be\nobtained by consulting respective sources such as Isabelle\u2019s\nArchive of Formal Proofs, the Journal of Formalized Reasoning, or the\nTHF entries in Sutcliffe\u2019s TPTP problem library. \n\nFurther improving proof automation within these proof\nassistants\u2014based on proof hammering tools or on other forms of\nprover integration\u2014is relevant for minimizing interaction effort\nin future applications. \n5.3 Computational Metaphysics and Artificial Intelligence\n\nChurch\u2019s type theory is a Classical logic, but topical\napplications in philosophy and artificial intelligence often require\nexpressive non-classical logics. In order to support such applications\nwith reasoning tools for Church\u2019s type theory, the shallow\nsemantical embedding technique (see also\n Section 1.2.2)\n has been developed that generalizes and extends the ideas underlying\nthe well known standard translation of modal logics to first-order\nlogic. The technique was applied for the assessment of modern variants\nof the ontological argument with a range of higher-order theorem\nprovers, including LEO-II, Satallax, Nitpick and Isabelle/HOL. In the\ncourse of experiments, LEO-II detected an inconsistency in the\npremises of G\u00f6del\u2019s argument, while the provers succeeded\nin automatically proving Scott\u2019s emendation of it and to confirm\nthe consistency of the emended premises. More details on this work are\npresented in a related SEP entry on\n automated reasoning\n (see Section 4.6 on Logic and Philosophy). The semantical embedding\napproach has been adapted and further extended for a range of other\nnon-classical logics and related applications. In philosophy this\nincludes the encoding and formal assessment of ambitious ethical and\nmetaphysical theories, and in artificial intelligence this includes\nthe mechanization of deontic logics and normative reasoning as well as\nan automatic proof of the\n muddy children puzzle (see Appendix B of dynamic epistemic logic),\n which is a famous puzzle in epistemic reasoning, respectively dynamic\nepistemic reasoning.",
    "section_title": "1.3 Axioms and Rules of Inference",
    "entry_title": "Church\u2019s Type Theory",
    "hierarchy_title": "Church\u2019s Type Theory || Syntax || Axioms and Rules of Inference",
    "tokenized_text": [
        "syntax",
        "axiom",
        "rule",
        "inference",
        "axiom",
        "rule",
        "inference",
        "rule",
        "inference",
        "alphabetic",
        "change",
        "bound",
        "variable",
        "alpha",
        "conversion",
        "replace",
        "wellformed",
        "part",
        "lambda",
        "bx_",
        "beta",
        "ba_",
        "alpha",
        "wff",
        "lambda",
        "by_",
        "beta",
        "textsf",
        "sub",
        "by_",
        "beta",
        "bx_",
        "beta",
        "ba_",
        "alpha",
        "provided",
        "by_",
        "beta",
        "occur",
        "ba_",
        "alpha",
        "bx_",
        "beta",
        "bound",
        "ba_",
        "alpha",
        "\u03b2contraction",
        "replace",
        "wellformed",
        "part",
        "lambda",
        "bx_",
        "alpha",
        "bb_",
        "beta",
        "ba_",
        "alpha",
        "wff",
        "textsf",
        "sub",
        "ba_",
        "alpha",
        "bx_",
        "alpha",
        "bb_",
        "beta",
        "provided",
        "bound",
        "variable",
        "bb_",
        "beta",
        "distinct",
        "bx_",
        "alpha",
        "free",
        "variable",
        "ba_",
        "alpha",
        "\u03b2expansion",
        "infer",
        "bc",
        "bd",
        "bd",
        "inferred",
        "bc",
        "single",
        "application",
        "\u03b2contraction",
        "substitution",
        "bf_",
        "alpha",
        "bx_",
        "alpha",
        "infer",
        "bf_",
        "alpha",
        "ba_",
        "alpha",
        "provided",
        "bx_",
        "alpha",
        "free",
        "variable",
        "bf_",
        "alpha",
        "modus",
        "ponens",
        "ba_",
        "supset",
        "bb_",
        "ba_",
        "infer",
        "bb_",
        "generalization",
        "bf_",
        "alpha",
        "bx_",
        "alpha",
        "infer",
        "pi_",
        "alpha",
        "bf_",
        "alpha",
        "provided",
        "bx_",
        "alpha",
        "free",
        "variable",
        "bf_",
        "alpha",
        "elementary",
        "type",
        "theory",
        "start",
        "listing",
        "axiom",
        "shall",
        "call",
        "elementary",
        "type",
        "theory",
        "begin",
        "align",
        "p_",
        "lor",
        "p_",
        "supset",
        "p_",
        "tag",
        "p_",
        "supset",
        "p_",
        "lor",
        "q_",
        "tag",
        "p_",
        "lor",
        "q_",
        "supset",
        "q_",
        "lor",
        "p_",
        "tag",
        "p_",
        "supset",
        "q_",
        "supset",
        "r_",
        "lor",
        "p_",
        "supset",
        "r_",
        "lor",
        "q_",
        "tag",
        "pi_",
        "alpha",
        "f_",
        "alpha",
        "supset",
        "f_",
        "alpha",
        "x_",
        "alpha",
        "tag",
        "alpha",
        "forall",
        "x_",
        "alpha",
        "p_",
        "lor",
        "f_",
        "alpha",
        "x_",
        "alpha",
        "supset",
        "left",
        "p_",
        "lor",
        "pi_",
        "alpha",
        "f_",
        "alpha",
        "right",
        "tag",
        "alpha",
        "end",
        "align",
        "theorem",
        "elementary",
        "type",
        "theory",
        "theorem",
        "derived",
        "using",
        "rule",
        "inference",
        "axiom",
        "alpha",
        "type",
        "symbol",
        "alpha",
        "shall",
        "sometimes",
        "refer",
        "elementary",
        "type",
        "theory",
        "ct",
        "embodies",
        "logic",
        "propositional",
        "connective",
        "quantifier",
        "\u03bbconversion",
        "context",
        "type",
        "theory",
        "illustrate",
        "rule",
        "axiom",
        "introduced",
        "give",
        "short",
        "trivial",
        "proof",
        "ct",
        "following",
        "wff",
        "proof",
        "indicate",
        "inferred",
        "proof",
        "actually",
        "quite",
        "inefficient",
        "since",
        "line",
        "used",
        "later",
        "line",
        "derived",
        "directly",
        "line",
        "without",
        "using",
        "line",
        "additional",
        "proof",
        "line",
        "inserted",
        "illustrate",
        "relevant",
        "aspect",
        "sake",
        "readability",
        "many",
        "bracket",
        "deleted",
        "formula",
        "proof",
        "diligent",
        "reader",
        "able",
        "restore",
        "begin",
        "alignat",
        "forall",
        "x_",
        "imath",
        "left",
        "p_",
        "lor",
        "f_",
        "imath",
        "x_",
        "imath",
        "right",
        "supsetleft",
        "p_",
        "lor",
        "pi_",
        "imath",
        "f_",
        "imath",
        "right",
        "text",
        "axiom",
        "imath",
        "tag",
        "bigg",
        "lambda",
        "f_",
        "imath",
        "bigg",
        "forall",
        "x_",
        "imath",
        "p_",
        "lor",
        "f_",
        "imath",
        "x_",
        "imath",
        "supset",
        "bigg",
        "p_",
        "lor",
        "pi_",
        "imath",
        "f_",
        "imath",
        "bigg",
        "bigg",
        "bigg",
        "f_",
        "imath",
        "text",
        "\u03b2expansion",
        "tag",
        "pi_",
        "imath",
        "bigg",
        "lambda",
        "f_",
        "imath",
        "bigg",
        "forall",
        "x_",
        "imath",
        "p_",
        "lor",
        "f_",
        "imath",
        "x_",
        "imath",
        "supset",
        "bigg",
        "p_",
        "lor",
        "pi_",
        "imath",
        "f_",
        "imath",
        "bigg",
        "bigg",
        "bigg",
        "text",
        "generalization",
        "tag",
        "bigg",
        "lambda",
        "f_",
        "imath",
        "bigg",
        "forall",
        "x_",
        "imath",
        "p_",
        "lor",
        "f_",
        "imath",
        "x_",
        "imath",
        "supset",
        "bigg",
        "p_",
        "lor",
        "pi_",
        "imath",
        "f_",
        "imath",
        "bigg",
        "bigg",
        "bigg",
        "lambda",
        "x_",
        "imath",
        "r_",
        "imath",
        "x_",
        "imath",
        "text",
        "substitution",
        "tag",
        "forall",
        "x_",
        "imath",
        "p_",
        "lor",
        "lambda",
        "x_",
        "imath",
        "r_",
        "imath",
        "x_",
        "imath",
        "x_",
        "imath",
        "supset",
        "left",
        "p_",
        "lor",
        "pi_",
        "imath",
        "left",
        "lambda",
        "x_",
        "imath",
        "r_",
        "imath",
        "x_",
        "imath",
        "right",
        "right",
        "text",
        "\u03b2contraction",
        "tag",
        "forall",
        "x_",
        "imath",
        "p_",
        "lor",
        "lambda",
        "y_",
        "imath",
        "r_",
        "imath",
        "y_",
        "imath",
        "x_",
        "imath",
        "supset",
        "left",
        "p_",
        "lor",
        "pi_",
        "imath",
        "left",
        "lambda",
        "x_",
        "imath",
        "r_",
        "imath",
        "x_",
        "imath",
        "right",
        "right",
        "text",
        "\u03b1conversion",
        "tag",
        "forall",
        "x_",
        "imath",
        "left",
        "p_",
        "lor",
        "r_",
        "imath",
        "x_",
        "imath",
        "right",
        "supset",
        "left",
        "p_",
        "lor",
        "pi_",
        "imath",
        "left",
        "lambda",
        "x_",
        "imath",
        "r_",
        "imath",
        "x_",
        "imath",
        "right",
        "right",
        "text",
        "\u03b2contraction",
        "tag",
        "end",
        "alignat",
        "note",
        "written",
        "forall",
        "f_",
        "imath",
        "forall",
        "x_",
        "imath",
        "p_",
        "lor",
        "f_",
        "imath",
        "x_",
        "imath",
        "supset",
        "p_",
        "lor",
        "forall",
        "x_",
        "imath",
        "f_",
        "imath",
        "x_",
        "imath",
        "tag",
        "written",
        "forall",
        "x_",
        "imath",
        "p_",
        "lor",
        "r_",
        "imath",
        "x_",
        "imath",
        "supset",
        "p_",
        "lor",
        "forall",
        "x_",
        "imath",
        "r_",
        "imath",
        "x_",
        "imath",
        "tag",
        "thus",
        "derived",
        "well",
        "known",
        "law",
        "quantification",
        "theory",
        "illustrate",
        "one",
        "possible",
        "interpretation",
        "wff",
        "closely",
        "related",
        "axiom",
        "considering",
        "situation",
        "rancher",
        "put",
        "horse",
        "corral",
        "leaf",
        "night",
        "later",
        "remember",
        "whether",
        "closed",
        "gate",
        "corral",
        "reflecting",
        "situation",
        "come",
        "conclusion",
        "expressed",
        "take",
        "horse",
        "element",
        "type",
        "imath",
        "interpret",
        "p_",
        "mean",
        "gate",
        "closed",
        "interpret",
        "r_",
        "imath",
        "r_",
        "imath",
        "x_",
        "imath",
        "asserts",
        "x_",
        "imath",
        "left",
        "corral",
        "interpretation",
        "say",
        "true",
        "every",
        "horse",
        "gate",
        "closed",
        "horse",
        "left",
        "corral",
        "gate",
        "closed",
        "every",
        "horse",
        "left",
        "corral",
        "axiom",
        "listed",
        "add",
        "axiom",
        "obtain",
        "church",
        "type",
        "theory",
        "axiom",
        "extensionality",
        "axiom",
        "boolean",
        "functional",
        "extensionality",
        "following",
        "begin",
        "align",
        "x_",
        "equiv",
        "y_",
        "supset",
        "x_",
        "y_",
        "tag",
        "forall",
        "x_",
        "beta",
        "f_",
        "alpha",
        "beta",
        "x_",
        "beta",
        "g_",
        "alpha",
        "beta",
        "x_",
        "beta",
        "supset",
        "f_",
        "alpha",
        "beta",
        "g_",
        "alpha",
        "beta",
        "tag",
        "alpha",
        "beta",
        "end",
        "align",
        "church",
        "include",
        "axiom",
        "list",
        "axiom",
        "church",
        "mentioned",
        "possibility",
        "including",
        "henkin",
        "include",
        "henkin",
        "description",
        "expression",
        "exists_bx_",
        "alpha",
        "ba_",
        "stand",
        "lambda",
        "p_",
        "alpha",
        "exists",
        "y_",
        "alpha",
        "p_",
        "alpha",
        "y_",
        "alpha",
        "land",
        "forall",
        "z_",
        "alpha",
        "p_",
        "alpha",
        "z_",
        "alpha",
        "supset",
        "z_",
        "alpha",
        "y_",
        "alpha",
        "lambda",
        "bx_",
        "alpha",
        "ba_",
        "example",
        "exists_",
        "x_",
        "alpha",
        "p_",
        "alpha",
        "x_",
        "alpha",
        "stand",
        "lambda",
        "p_",
        "alpha",
        "exists",
        "y_",
        "alpha",
        "p_",
        "alpha",
        "y_",
        "alpha",
        "land",
        "forall",
        "z_",
        "alpha",
        "p_",
        "alpha",
        "z_",
        "alpha",
        "supset",
        "z_",
        "alpha",
        "y_",
        "alpha",
        "lambda",
        "x_",
        "alpha",
        "p_",
        "alpha",
        "x_",
        "alpha",
        "\u03bbconversion",
        "equivalent",
        "exists",
        "y_",
        "alpha",
        "lambda",
        "x_",
        "alpha",
        "p_",
        "alpha",
        "x_",
        "alpha",
        "y_",
        "alpha",
        "land",
        "forall",
        "z_",
        "alpha",
        "lambda",
        "x_",
        "alpha",
        "p_",
        "alpha",
        "x_",
        "alpha",
        "z_",
        "alpha",
        "supset",
        "z_",
        "alpha",
        "y_",
        "alpha",
        "reduces",
        "\u03bbconversion",
        "exists",
        "y_",
        "alpha",
        "p_",
        "alpha",
        "y_",
        "alpha",
        "land",
        "forall",
        "z_",
        "alpha",
        "p_",
        "alpha",
        "z_",
        "alpha",
        "supset",
        "z_",
        "alpha",
        "y_",
        "alpha",
        "asserts",
        "unique",
        "element",
        "property",
        "p_",
        "alpha",
        "example",
        "see",
        "general",
        "exists_bx_",
        "alpha",
        "ba_",
        "express",
        "assertion",
        "unique",
        "bx_",
        "alpha",
        "ba_",
        "unique",
        "element",
        "bx_",
        "alpha",
        "convenient",
        "notation",
        "atoibx_",
        "alpha",
        "ba_",
        "represent",
        "expression",
        "bx_",
        "alpha",
        "ba_",
        "russell",
        "showed",
        "whitehead",
        "russell",
        "b",
        "provide",
        "contextual",
        "definition",
        "notation",
        "formulation",
        "type",
        "theory",
        "church",
        "type",
        "theory",
        "atoibx_",
        "alpha",
        "ba_",
        "defined",
        "iota_",
        "alpha",
        "alpha",
        "lambda",
        "bx_",
        "alpha",
        "ba_",
        "thus",
        "atoi",
        "behaves",
        "like",
        "variablebinding",
        "operator",
        "defined",
        "term",
        "\u03bb",
        "aid",
        "constant",
        "iota_",
        "alpha",
        "alpha",
        "thus",
        "\u03bb",
        "still",
        "variablebinding",
        "operator",
        "needed",
        "since",
        "ba_",
        "describes",
        "bx_",
        "alpha",
        "iota_",
        "alpha",
        "alpha",
        "called",
        "description",
        "operator",
        "associated",
        "notation",
        "following",
        "axiom",
        "description",
        "exists_",
        "x_",
        "alpha",
        "p_",
        "alpha",
        "x_",
        "alpha",
        "supset",
        "p_",
        "alpha",
        "iota_",
        "alpha",
        "alpha",
        "p_",
        "alpha",
        "tag",
        "alpha",
        "say",
        "set",
        "p_",
        "alpha",
        "unique",
        "member",
        "iota_",
        "alpha",
        "alpha",
        "p_",
        "alpha",
        "p_",
        "alpha",
        "therefore",
        "unique",
        "member",
        "thus",
        "axiom",
        "asserts",
        "iota_",
        "alpha",
        "alpha",
        "map",
        "oneelement",
        "set",
        "unique",
        "member",
        "certain",
        "hypothesis",
        "one",
        "prove",
        "exists_bx_",
        "alpha",
        "ba_",
        "using",
        "axiom",
        "alpha",
        "one",
        "derive",
        "lambda",
        "bx_",
        "alpha",
        "ba_",
        "iota_",
        "alpha",
        "alpha",
        "lambda",
        "bx_",
        "alpha",
        "ba_",
        "also",
        "written",
        "lambda",
        "bx_",
        "alpha",
        "ba_",
        "atoibx_",
        "alpha",
        "ba_",
        "illustrate",
        "usefulness",
        "description",
        "operator",
        "small",
        "example",
        "suppose",
        "formalized",
        "theory",
        "real",
        "number",
        "theory",
        "constant",
        "_",
        "varrho",
        "times_",
        "varrho",
        "varrho",
        "varrho",
        "represent",
        "number",
        "multiplication",
        "function",
        "respectively",
        "varrho",
        "type",
        "real",
        "number",
        "represent",
        "multiplicative",
        "inverse",
        "function",
        "define",
        "wff",
        "textrm",
        "inv",
        "_",
        "varrho",
        "varrho",
        "lambda",
        "z_",
        "varrho",
        "atoi",
        "x_",
        "varrho",
        "times_",
        "varrho",
        "varrho",
        "varrho",
        "z_",
        "varrho",
        "x_",
        "varrho",
        "_",
        "varrho",
        "course",
        "traditional",
        "mathematical",
        "notation",
        "would",
        "write",
        "type",
        "symbol",
        "would",
        "write",
        "times_",
        "varrho",
        "varrho",
        "varrho",
        "z_",
        "varrho",
        "x_",
        "varrho",
        "z",
        "times",
        "x",
        "write",
        "textrm",
        "inv",
        "_",
        "varrho",
        "varrho",
        "z",
        "z",
        "thus",
        "z",
        "defined",
        "x",
        "z",
        "times",
        "x",
        "z",
        "provably",
        "able",
        "prove",
        "exists_",
        "x_",
        "varrho",
        "times_",
        "varrho",
        "varrho",
        "varrho",
        "textrm",
        "z",
        "x",
        "_",
        "varrho",
        "_",
        "varrho",
        "z",
        "times",
        "z",
        "establish",
        "z",
        "nothing",
        "significant",
        "z",
        "provable",
        "axiom",
        "choice",
        "axiom",
        "choice",
        "expressed",
        "follows",
        "church",
        "type",
        "theory",
        "exists",
        "x_",
        "alpha",
        "p_",
        "alpha",
        "x_",
        "alpha",
        "supset",
        "p_",
        "alpha",
        "iota_",
        "alpha",
        "alpha",
        "p_",
        "alpha",
        "tag",
        "alpha",
        "alpha",
        "say",
        "choice",
        "function",
        "iota_",
        "alpha",
        "alpha",
        "chooses",
        "every",
        "nonempty",
        "set",
        "p_",
        "alpha",
        "element",
        "designated",
        "iota_",
        "alpha",
        "alpha",
        "p_",
        "alpha",
        "set",
        "form",
        "axiom",
        "choice",
        "included",
        "list",
        "axiom",
        "iota_",
        "alpha",
        "alpha",
        "called",
        "selection",
        "operator",
        "instead",
        "description",
        "operator",
        "atoibx_",
        "alpha",
        "ba_",
        "mean",
        "bx_",
        "alpha",
        "ba_",
        "element",
        "bx_",
        "alpha",
        "selection",
        "operator",
        "meaning",
        "hilbert",
        "epsilon",
        "operator",
        "hilbert",
        "however",
        "provide",
        "one",
        "operator",
        "type",
        "\u03b1",
        "natural",
        "call",
        "atoi",
        "definite",
        "description",
        "operator",
        "context",
        "atoibx_",
        "alpha",
        "ba_",
        "mean",
        "bx_",
        "alpha",
        "ba_",
        "call",
        "indefinite",
        "description",
        "operator",
        "context",
        "atoibx_",
        "alpha",
        "ba_",
        "mean",
        "bx_",
        "alpha",
        "ba_",
        "clearly",
        "axiom",
        "choice",
        "implies",
        "axiom",
        "description",
        "sometimes",
        "formulation",
        "type",
        "theory",
        "used",
        "include",
        "axiom",
        "description",
        "axiom",
        "choice",
        "another",
        "formulation",
        "axiom",
        "choice",
        "simply",
        "asserts",
        "existence",
        "choice",
        "function",
        "without",
        "explicitly",
        "naming",
        "exists",
        "j_",
        "alpha",
        "alpha",
        "forall",
        "p_",
        "alpha",
        "exists",
        "x_",
        "alpha",
        "p_",
        "alpha",
        "x_",
        "alpha",
        "supset",
        "p_",
        "alpha",
        "j_",
        "alpha",
        "alpha",
        "p_",
        "alpha",
        "tag",
        "text",
        "ac",
        "alpha",
        "normally",
        "one",
        "assumes",
        "axiom",
        "choice",
        "type",
        "theory",
        "one",
        "assumes",
        "axiom",
        "schema",
        "asserts",
        "ac",
        "alpha",
        "type",
        "symbol",
        "\u03b1",
        "similar",
        "remark",
        "applies",
        "axiom",
        "extensionality",
        "description",
        "however",
        "modern",
        "proof",
        "system",
        "church",
        "type",
        "theory",
        "eg",
        "based",
        "resolution",
        "fact",
        "avoid",
        "addition",
        "axiom",
        "schema",
        "reason",
        "explained",
        "section",
        "work",
        "constrained",
        "goaldirected",
        "proof",
        "rule",
        "instead",
        "proceeding",
        "need",
        "introduce",
        "terminology",
        "cq_",
        "alternative",
        "formulation",
        "church",
        "type",
        "theory",
        "described",
        "section",
        "equivalent",
        "system",
        "described",
        "using",
        "axiom",
        "type",
        "symbol",
        "propositional",
        "symbol",
        "occur",
        "parenthesis",
        "yasuhara",
        "defined",
        "relation",
        "ge",
        "type",
        "reflexive",
        "transitive",
        "closure",
        "minimal",
        "relation",
        "alpha",
        "beta",
        "ge",
        "alpha",
        "alpha",
        "beta",
        "ge",
        "beta",
        "established",
        "alpha",
        "ge",
        "beta",
        "cq_",
        "vdash",
        "ac",
        "alpha",
        "supset",
        "ac",
        "beta",
        "given",
        "set",
        "type",
        "none",
        "propositional",
        "model",
        "cq_",
        "ac",
        "alpha",
        "fails",
        "alpha",
        "ge",
        "beta",
        "\u03b2",
        "s",
        "existence",
        "choice",
        "function",
        "higher",
        "type",
        "thus",
        "entail",
        "existence",
        "choice",
        "function",
        "lower",
        "type",
        "opposite",
        "generally",
        "case",
        "though",
        "b\u00fcchi",
        "shown",
        "schema",
        "expressing",
        "axiom",
        "choice",
        "zorn",
        "lemma",
        "derived",
        "relationship",
        "particular",
        "type",
        "involved",
        "complex",
        "axiom",
        "infinity",
        "one",
        "define",
        "natural",
        "number",
        "therefore",
        "basic",
        "mathematical",
        "structure",
        "real",
        "complex",
        "number",
        "type",
        "theory",
        "prove",
        "required",
        "property",
        "peano",
        "postulate",
        "one",
        "need",
        "axiom",
        "infinity",
        "many",
        "viable",
        "possibility",
        "axiom",
        "discussed",
        "church",
        "section",
        "church",
        "section",
        "andrew",
        "formulation",
        "based",
        "equality",
        "section",
        "nsim_",
        "lor_",
        "pi_",
        "alpha",
        "taken",
        "primitive",
        "constant",
        "wffs",
        "sfq_",
        "alpha",
        "alpha",
        "denote",
        "equality",
        "relation",
        "type",
        "\u03b1",
        "defined",
        "term",
        "present",
        "alternative",
        "formulation",
        "cq_",
        "church",
        "type",
        "theory",
        "primitive",
        "constant",
        "sfq_",
        "alpha",
        "alpha",
        "denoting",
        "equality",
        "nsim_",
        "lor_",
        "pi_",
        "alpha",
        "defined",
        "term",
        "sfq_",
        "alpha",
        "alpha",
        "tarski",
        "noted",
        "context",
        "higherorder",
        "logic",
        "one",
        "define",
        "propositional",
        "connective",
        "term",
        "logical",
        "equivalence",
        "quantifier",
        "quine",
        "showed",
        "quantifier",
        "connective",
        "defined",
        "term",
        "equality",
        "abstraction",
        "operator",
        "\u03bb",
        "context",
        "church",
        "type",
        "theory",
        "henkin",
        "rediscovered",
        "definition",
        "developed",
        "formulation",
        "church",
        "type",
        "theory",
        "based",
        "equality",
        "restricted",
        "attention",
        "propositional",
        "type",
        "andrew",
        "simplified",
        "axiom",
        "system",
        "cq_",
        "based",
        "idea",
        "shown",
        "equivalent",
        "formulation",
        "church",
        "type",
        "theory",
        "using",
        "axiom",
        "preceding",
        "section",
        "section",
        "thus",
        "provides",
        "alternative",
        "material",
        "preceding",
        "section",
        "detail",
        "cq_",
        "found",
        "andrew",
        "definition",
        "type",
        "symbol",
        "improper",
        "symbol",
        "variable",
        "cq_",
        "defined",
        "section",
        "logical",
        "constant",
        "cq_",
        "sfq_",
        "alpha",
        "alpha",
        "iota_",
        "imath",
        "imath",
        "type",
        "symbol",
        "\u03b1",
        "wffs",
        "cq_",
        "defined",
        "section",
        "abbreviation",
        "ba_",
        "alpha",
        "bb_",
        "alpha",
        "stand",
        "sfq_",
        "alpha",
        "alpha",
        "ba_",
        "alpha",
        "bb_",
        "alpha",
        "ba_",
        "equiv",
        "bb_",
        "stand",
        "sfq_",
        "a",
        "_",
        "b",
        "_",
        "t_",
        "stand",
        "sfq_",
        "sfq_",
        "f_",
        "stand",
        "lambda",
        "x_",
        "t_",
        "lambda",
        "x_",
        "x_",
        "pi_",
        "alpha",
        "stand",
        "sfq_",
        "alpha",
        "alpha",
        "lambda",
        "x_",
        "alpha",
        "t_",
        "forall",
        "bx_",
        "alpha",
        "ba",
        "stand",
        "pi_",
        "alpha",
        "lambda",
        "bx_",
        "alpha",
        "ba",
        "land_",
        "stand",
        "lambda",
        "x_",
        "lambda",
        "y_",
        "lambda",
        "g_",
        "g_",
        "t_",
        "t_",
        "lambda",
        "g_",
        "g_",
        "x_",
        "y_",
        "ba_",
        "land",
        "bb_",
        "stand",
        "land_",
        "ba_",
        "bb_",
        "nsim_",
        "stand",
        "sfq_",
        "f_",
        "t_",
        "denotes",
        "truth",
        "meaning",
        "pi_",
        "alpha",
        "discussed",
        "section",
        "see",
        "definition",
        "pi_",
        "alpha",
        "appropriate",
        "note",
        "lambda",
        "x_",
        "alpha",
        "t",
        "denotes",
        "set",
        "element",
        "type",
        "\u03b1",
        "pi_",
        "alpha",
        "s_",
        "alpha",
        "stand",
        "sfq_",
        "alpha",
        "alpha",
        "lambda",
        "x_",
        "alpha",
        "s_",
        "alpha",
        "respectively",
        "lambda",
        "x_",
        "alpha",
        "s_",
        "alpha",
        "therefore",
        "pi_",
        "alpha",
        "s_",
        "alpha",
        "asserts",
        "s_",
        "alpha",
        "set",
        "element",
        "type",
        "\u03b1",
        "s_",
        "alpha",
        "contains",
        "element",
        "type",
        "\u03b1",
        "seen",
        "f_",
        "also",
        "written",
        "forall",
        "x_",
        "x_",
        "asserts",
        "everything",
        "true",
        "false",
        "f_",
        "denotes",
        "falsehood",
        "expression",
        "lambda",
        "g_",
        "g_",
        "x_",
        "y_",
        "used",
        "represent",
        "ordered",
        "pair",
        "langle",
        "x_",
        "y_",
        "rangle",
        "conjunction",
        "x_",
        "land",
        "y_",
        "true",
        "iff",
        "x_",
        "y_",
        "true",
        "ie",
        "iff",
        "langle",
        "t_",
        "t_",
        "rangle",
        "langle",
        "x_",
        "y_",
        "rangle",
        "hence",
        "x_",
        "land",
        "y_",
        "expressed",
        "formula",
        "lambda",
        "g_",
        "g_",
        "t_",
        "t_",
        "lambda",
        "g_",
        "g_",
        "x_",
        "y_",
        "propositional",
        "connective",
        "existential",
        "quantifier",
        "easily",
        "defined",
        "using",
        "iota_",
        "imath",
        "imath",
        "one",
        "define",
        "description",
        "operator",
        "iota_",
        "alpha",
        "alpha",
        "type",
        "\u03b1",
        "axiom",
        "rule",
        "inference",
        "cq_",
        "single",
        "rule",
        "inference",
        "rule",
        "r",
        "bc",
        "ba_",
        "alpha",
        "bb_",
        "alpha",
        "infer",
        "result",
        "replacing",
        "one",
        "occurrence",
        "ba_",
        "alpha",
        "bc",
        "occurrence",
        "bb_",
        "alpha",
        "provided",
        "occurrence",
        "ba_",
        "alpha",
        "bc",
        "occurrence",
        "variable",
        "immediately",
        "preceded",
        "\u03bb",
        "axiom",
        "cq_",
        "following",
        "begin",
        "align",
        "g_",
        "t_",
        "land",
        "g_",
        "f_",
        "forall",
        "x_",
        "g_",
        "x_",
        "tag",
        "x_",
        "alpha",
        "y_",
        "alpha",
        "supset",
        "h_",
        "alpha",
        "x_",
        "alpha",
        "h_",
        "alpha",
        "y_",
        "alpha",
        "tag",
        "alpha",
        "f_",
        "alpha",
        "beta",
        "g_",
        "alpha",
        "beta",
        "forall",
        "x_",
        "beta",
        "f_",
        "alpha",
        "beta",
        "x_",
        "beta",
        "g_",
        "alpha",
        "beta",
        "x_",
        "beta",
        "tag",
        "alpha",
        "beta",
        "lambda",
        "bx_",
        "alpha",
        "bb_",
        "beta",
        "ba_",
        "alpha",
        "textsf",
        "subfree",
        "ba_",
        "alpha",
        "bx_",
        "alpha",
        "bb_",
        "beta",
        "tag",
        "quad",
        "text",
        "provided",
        "ba_",
        "alpha",
        "text",
        "free",
        "bx",
        "text",
        "bb_",
        "beta",
        "iota_",
        "imath",
        "imath",
        "sfq_",
        "imathimath",
        "y_",
        "imath",
        "y_",
        "imath",
        "tag",
        "end",
        "align",
        "semantics",
        "natural",
        "compare",
        "semantics",
        "type",
        "theory",
        "semantics",
        "firstorder",
        "logic",
        "theorem",
        "precisely",
        "wffs",
        "valid",
        "interpretation",
        "intuitive",
        "point",
        "view",
        "natural",
        "interpretation",
        "type",
        "theory",
        "standard",
        "model",
        "defined",
        "however",
        "consequence",
        "g\u00f6del",
        "incompleteness",
        "theorem",
        "g\u00f6del",
        "axiom",
        "suffice",
        "derive",
        "wffs",
        "valid",
        "standard",
        "model",
        "consistent",
        "recursively",
        "axiomatized",
        "extension",
        "axiom",
        "suffices",
        "purpose",
        "nevertheless",
        "experience",
        "show",
        "axiom",
        "sufficient",
        "purpose",
        "leon",
        "henkin",
        "considered",
        "problem",
        "clarifying",
        "sense",
        "complete",
        "definition",
        "theorem",
        "constitute",
        "henkin",
        "solution",
        "problem",
        "often",
        "referred",
        "general",
        "semantics",
        "henkin",
        "semantics",
        "frame",
        "collection",
        "cd_",
        "alpha",
        "_",
        "alpha",
        "nonempty",
        "domain",
        "set",
        "cd_",
        "alpha",
        "one",
        "type",
        "symbol",
        "\u03b1",
        "cd_",
        "sft",
        "sff",
        "sft",
        "represents",
        "truth",
        "sff",
        "represents",
        "falsehood",
        "cd_",
        "alpha",
        "beta",
        "collection",
        "function",
        "mapping",
        "cd_",
        "beta",
        "cd_",
        "alpha",
        "member",
        "cd_",
        "imath",
        "called",
        "individual",
        "interpretation",
        "langle",
        "cd_",
        "alpha",
        "_",
        "alpha",
        "frirangle",
        "consists",
        "frame",
        "function",
        "fri",
        "map",
        "constant",
        "c",
        "type",
        "\u03b1",
        "appropriate",
        "element",
        "cd_",
        "alpha",
        "called",
        "denotation",
        "c",
        "logical",
        "constant",
        "given",
        "standard",
        "denotation",
        "assignment",
        "value",
        "frame",
        "cd_",
        "alpha",
        "_",
        "alpha",
        "variable",
        "function",
        "phi",
        "phi",
        "bx_",
        "alpha",
        "in",
        "cd_",
        "alpha",
        "variable",
        "bx_",
        "alpha",
        "notation",
        "assignment",
        "phi",
        "ax",
        "map",
        "variable",
        "x",
        "value",
        "identical",
        "phi",
        "variable",
        "symbol",
        "different",
        "x",
        "interpretation",
        "cm",
        "langle",
        "cd_",
        "alpha",
        "_",
        "alpha",
        "frirangle",
        "general",
        "model",
        "aka",
        "henkin",
        "model",
        "iff",
        "binary",
        "function",
        "cv",
        "cv_",
        "phi",
        "ba_",
        "alpha",
        "in",
        "cd_",
        "alpha",
        "assignment",
        "phi",
        "wff",
        "ba_",
        "alpha",
        "following",
        "condition",
        "satisfied",
        "assignment",
        "wffs",
        "cv_",
        "phi",
        "bx_",
        "alpha",
        "phi",
        "bx_",
        "alpha",
        "variable",
        "bx_",
        "alpha",
        "cv_",
        "phi",
        "a_",
        "alpha",
        "fri",
        "a_",
        "alpha",
        "a_",
        "alpha",
        "primitive",
        "constant",
        "cv_",
        "phi",
        "ba_",
        "alpha",
        "beta",
        "bb_",
        "beta",
        "cv_",
        "phi",
        "ba_",
        "alpha",
        "beta",
        "cv_",
        "phi",
        "bb_",
        "beta",
        "value",
        "function",
        "cv_",
        "phi",
        "ba_",
        "alpha",
        "beta",
        "argument",
        "cv_",
        "phi",
        "bb_",
        "beta",
        "cv_",
        "phi",
        "lambda",
        "bx_",
        "alpha",
        "bb_",
        "beta",
        "function",
        "cd_",
        "alpha",
        "cd_",
        "beta",
        "whose",
        "value",
        "argument",
        "z",
        "in",
        "cd_",
        "alpha",
        "cv_",
        "psi",
        "bb_",
        "beta",
        "psi",
        "assignment",
        "psi",
        "bx_",
        "alpha",
        "z",
        "psi",
        "by_",
        "beta",
        "phi",
        "by_",
        "beta",
        "by_",
        "beta",
        "ne",
        "bx_",
        "alpha",
        "interpretation",
        "cm",
        "general",
        "model",
        "function",
        "cv",
        "uniquely",
        "determined",
        "cv_",
        "phi",
        "ba_",
        "alpha",
        "called",
        "value",
        "ba_",
        "alpha",
        "cm",
        "respect",
        "phi",
        "one",
        "easily",
        "show",
        "following",
        "statement",
        "hold",
        "general",
        "model",
        "cm",
        "assignment",
        "phi",
        "wffs",
        "ba",
        "bb",
        "cv_",
        "phi",
        "t_",
        "sft",
        "cv_",
        "phi",
        "f_",
        "sff",
        "cv_",
        "phi",
        "nsim_",
        "ba_",
        "sft",
        "iff",
        "cv_",
        "phi",
        "ba_",
        "sff",
        "cv_",
        "phi",
        "ba_",
        "lor",
        "bb_",
        "sft",
        "iff",
        "cv_",
        "phi",
        "ba_",
        "sft",
        "cv_",
        "phi",
        "bb_",
        "sft",
        "cv_",
        "phi",
        "ba_",
        "land",
        "bb_",
        "sft",
        "iff",
        "cv_",
        "phi",
        "ba_",
        "sft",
        "cv_",
        "phi",
        "bb_",
        "sft",
        "cv_",
        "phi",
        "ba_",
        "supset",
        "bb_",
        "sft",
        "iff",
        "cv_",
        "phi",
        "ba_",
        "sff",
        "cv_",
        "phi",
        "bb_",
        "sft",
        "cv_",
        "phi",
        "ba_",
        "equiv",
        "bb_",
        "sft",
        "iff",
        "cv_",
        "phi",
        "ba_",
        "cv_",
        "phi",
        "bb_",
        "cv_",
        "phi",
        "forall",
        "bx_",
        "alpha",
        "ba",
        "sft",
        "iff",
        "cv_",
        "phi",
        "ax",
        "ba",
        "sft",
        "in",
        "cd_",
        "alpha",
        "cv_",
        "phi",
        "exists",
        "bx_",
        "alpha",
        "ba",
        "sft",
        "iff",
        "exists",
        "in",
        "cd_",
        "alpha",
        "cv_",
        "phi",
        "ax",
        "ba",
        "sft",
        "semantics",
        "general",
        "model",
        "thus",
        "expected",
        "however",
        "subtlety",
        "note",
        "regarding",
        "following",
        "condition",
        "arbitrary",
        "type",
        "\u03b1",
        "equality",
        "cv_",
        "phi",
        "ba_",
        "alpha",
        "bb_",
        "alpha",
        "sft",
        "iff",
        "cv_",
        "phi",
        "ba_",
        "alpha",
        "cv_",
        "phi",
        "bb_",
        "alpha",
        "definition",
        "section",
        "employed",
        "equality",
        "defined",
        "term",
        "leibniz",
        "principle",
        "statement",
        "implied",
        "type",
        "\u03b1",
        "hold",
        "additionally",
        "require",
        "domain",
        "cd_",
        "alpha",
        "contain",
        "unit",
        "set",
        "object",
        "type",
        "\u03b1",
        "alternatively",
        "domain",
        "cd_",
        "alphaalpha",
        "contain",
        "respective",
        "identity",
        "relation",
        "object",
        "type",
        "\u03b1",
        "entail",
        "former",
        "need",
        "additional",
        "requirement",
        "included",
        "original",
        "work",
        "henkin",
        "demonstrated",
        "andrew",
        "a",
        "instead",
        "alternative",
        "definition",
        "section",
        "employed",
        "requirement",
        "obviously",
        "met",
        "due",
        "presence",
        "logical",
        "constant",
        "sfq_",
        "alpha",
        "alpha",
        "signature",
        "definition",
        "denote",
        "respective",
        "identity",
        "relation",
        "object",
        "type",
        "\u03b1",
        "therefore",
        "trivially",
        "ensure",
        "existence",
        "general",
        "model",
        "cm",
        "therefore",
        "natural",
        "option",
        "always",
        "assume",
        "primitive",
        "equality",
        "constant",
        "type",
        "\u03b1",
        "concrete",
        "choice",
        "base",
        "system",
        "church",
        "type",
        "theory",
        "realized",
        "andrew",
        "system",
        "cq_",
        "interpretation",
        "langle",
        "cd_",
        "alpha",
        "_",
        "alpha",
        "frirangle",
        "standard",
        "model",
        "iff",
        "\u03b1",
        "beta",
        "cd_",
        "alpha",
        "beta",
        "set",
        "function",
        "cd_",
        "beta",
        "cd_",
        "alpha",
        "clearly",
        "standard",
        "model",
        "general",
        "model",
        "say",
        "wff",
        "ba",
        "valid",
        "model",
        "cm",
        "iff",
        "cv_",
        "phi",
        "ba",
        "sft",
        "every",
        "assignment",
        "phi",
        "cm",
        "model",
        "set",
        "ch",
        "wffs",
        "model",
        "wff",
        "ch",
        "valid",
        "wff",
        "ba",
        "valid",
        "general",
        "standard",
        "sense",
        "iff",
        "ba",
        "valid",
        "every",
        "general",
        "standard",
        "model",
        "clearly",
        "wff",
        "valid",
        "general",
        "sense",
        "valid",
        "standard",
        "sense",
        "converse",
        "statement",
        "false",
        "completeness",
        "soundness",
        "theorem",
        "henkin",
        "wff",
        "theorem",
        "valid",
        "general",
        "sense",
        "frame",
        "belong",
        "interpretation",
        "interpretation",
        "general",
        "model",
        "order",
        "general",
        "model",
        "interpretation",
        "must",
        "frame",
        "satisfying",
        "certain",
        "closure",
        "condition",
        "discussed",
        "andrew",
        "b",
        "basically",
        "general",
        "model",
        "every",
        "wff",
        "must",
        "value",
        "respect",
        "assignment",
        "model",
        "said",
        "finite",
        "iff",
        "domain",
        "individual",
        "finite",
        "every",
        "finite",
        "model",
        "cq_",
        "standard",
        "andrew",
        "theorem",
        "every",
        "set",
        "sentence",
        "cq_",
        "infinite",
        "model",
        "also",
        "nonstandard",
        "model",
        "andrews",
        "theorem",
        "understanding",
        "distinction",
        "standard",
        "nonstandard",
        "model",
        "clarify",
        "many",
        "phenomenon",
        "example",
        "shown",
        "model",
        "cm",
        "langle",
        "cd_",
        "alpha",
        "_",
        "alpha",
        "frirangle",
        "cd_",
        "imath",
        "infinite",
        "domain",
        "cd_",
        "alpha",
        "countable",
        "thus",
        "cd_",
        "imath",
        "cd_",
        "imath",
        "countably",
        "infinite",
        "must",
        "bijection",
        "h",
        "however",
        "cantor",
        "theorem",
        "provable",
        "type",
        "theory",
        "therefore",
        "valid",
        "model",
        "say",
        "cd_",
        "imath",
        "subset",
        "member",
        "seemingly",
        "paradoxical",
        "situation",
        "called",
        "skolem",
        "paradox",
        "resolved",
        "looking",
        "carefully",
        "cantor",
        "theorem",
        "ie",
        "nsim",
        "exists",
        "g_",
        "imathimath",
        "forall",
        "f_",
        "imath",
        "exists",
        "j_",
        "imath",
        "g_",
        "imathimath",
        "j_",
        "imath",
        "f_",
        "imath",
        "considering",
        "mean",
        "model",
        "theorem",
        "say",
        "function",
        "g",
        "in",
        "cd_",
        "imathimath",
        "cd_",
        "imath",
        "cd_",
        "imath",
        "every",
        "set",
        "f_",
        "imath",
        "in",
        "cd_",
        "imath",
        "range",
        "usual",
        "interpretation",
        "statement",
        "cd_",
        "imath",
        "bigger",
        "cardinality",
        "cd_",
        "imath",
        "however",
        "actually",
        "mean",
        "model",
        "h",
        "cd_",
        "imathimath",
        "course",
        "cm",
        "must",
        "nonstandard",
        "axiom",
        "choice",
        "presumably",
        "true",
        "standard",
        "model",
        "nonstandard",
        "model",
        "cq_",
        "ac",
        "imath",
        "false",
        "andrew",
        "b",
        "thus",
        "ac",
        "imath",
        "provable",
        "cq_",
        "thus",
        "far",
        "investigation",
        "model",
        "theory",
        "church",
        "type",
        "theory",
        "far",
        "le",
        "extensive",
        "firstorder",
        "logic",
        "nevertheless",
        "work",
        "method",
        "constructing",
        "nonstandard",
        "model",
        "type",
        "theory",
        "model",
        "various",
        "form",
        "extensionality",
        "fail",
        "model",
        "theory",
        "arbitrary",
        "possibly",
        "incomplete",
        "set",
        "logical",
        "constant",
        "developing",
        "general",
        "method",
        "establishing",
        "completeness",
        "various",
        "system",
        "axiom",
        "respect",
        "various",
        "class",
        "model",
        "relevant",
        "paper",
        "include",
        "andrew",
        "a",
        "b",
        "henkin",
        "related",
        "work",
        "found",
        "benzm\u00fcller",
        "et",
        "al",
        "brown",
        "muskens",
        "metatheory",
        "lambdaconversion",
        "first",
        "three",
        "rule",
        "inference",
        "section",
        "called",
        "rule",
        "\u03bbconversion",
        "bd",
        "be",
        "wffs",
        "write",
        "bd",
        "conv",
        "be",
        "indicate",
        "bd",
        "converted",
        "be",
        "application",
        "rule",
        "equivalence",
        "relation",
        "wffs",
        "wff",
        "bd",
        "\u03b2normal",
        "form",
        "iff",
        "wellformed",
        "part",
        "form",
        "lambda",
        "bx_",
        "alpha",
        "bb_",
        "beta",
        "ba_",
        "alpha",
        "every",
        "wff",
        "convertible",
        "one",
        "\u03b2normal",
        "form",
        "indeed",
        "every",
        "sequence",
        "contraction",
        "application",
        "rule",
        "combined",
        "necessary",
        "alphabetic",
        "change",
        "bound",
        "variable",
        "wff",
        "finite",
        "obviously",
        "sequence",
        "extended",
        "terminates",
        "wff",
        "\u03b2normal",
        "form",
        "called",
        "strong",
        "normalization",
        "theorem",
        "churchrosser",
        "theorem",
        "wff",
        "\u03b2normal",
        "form",
        "unique",
        "modulo",
        "alphabetic",
        "change",
        "bound",
        "variable",
        "wff",
        "ba",
        "denote",
        "downarrow",
        "ba",
        "first",
        "wff",
        "enumeration",
        "\u03b2normal",
        "form",
        "ba",
        "conv",
        "downarrow",
        "ba",
        "bd",
        "conv",
        "be",
        "downarrow",
        "bd",
        "downarrow",
        "be",
        "using",
        "axiom",
        "extensionality",
        "one",
        "obtain",
        "following",
        "derived",
        "rule",
        "inference",
        "eta",
        "contraction",
        "replace",
        "wellformed",
        "part",
        "lambda",
        "by_",
        "beta",
        "bb_",
        "alpha",
        "beta",
        "by_",
        "beta",
        "wff",
        "bb_",
        "alpha",
        "beta",
        "provided",
        "by_",
        "beta",
        "occur",
        "free",
        "bb_",
        "alpha",
        "beta",
        "rule",
        "inverse",
        "called",
        "eta",
        "expansion",
        "sometimes",
        "used",
        "additional",
        "rule",
        "\u03bbconversion",
        "see",
        "church",
        "stenlund",
        "barendregt",
        "barendregt",
        "et",
        "al",
        "information",
        "\u03bbconversion",
        "worth",
        "mentioning",
        "\u03bbabstraction",
        "replaces",
        "need",
        "comprehension",
        "axiom",
        "church",
        "type",
        "theory",
        "higherorder",
        "unification",
        "challenge",
        "higherorder",
        "unification",
        "outlined",
        "briefly",
        "detail",
        "topic",
        "given",
        "dowek",
        "utilization",
        "higherorder",
        "theorem",
        "provers",
        "also",
        "discussed",
        "benzm\u00fcller",
        "miller",
        "definition",
        "higherorder",
        "unifier",
        "pair",
        "langle",
        "ba",
        "bbrangle",
        "wffs",
        "substitution",
        "theta",
        "free",
        "occurrence",
        "variable",
        "theta",
        "ba",
        "theta",
        "bb",
        "\u03b2normal",
        "form",
        "higherorder",
        "unifier",
        "set",
        "pair",
        "wffs",
        "unifier",
        "pair",
        "set",
        "higherorder",
        "unification",
        "differs",
        "firstorder",
        "unification",
        "baader",
        "snyder",
        "number",
        "important",
        "respect",
        "particular",
        "even",
        "unifier",
        "pair",
        "wffs",
        "exists",
        "may",
        "general",
        "unifier",
        "gould",
        "higherorder",
        "unification",
        "undecidable",
        "huet",
        "b",
        "even",
        "secondorder",
        "case",
        "goldfarb",
        "however",
        "algorithm",
        "devised",
        "huet",
        "jensen",
        "pietrzykowski",
        "called",
        "preunification",
        "find",
        "unifier",
        "set",
        "pair",
        "wffs",
        "one",
        "exists",
        "preunifiers",
        "computed",
        "huet",
        "procedure",
        "substitution",
        "reduce",
        "original",
        "unification",
        "problem",
        "one",
        "involving",
        "called",
        "flexflex",
        "unification",
        "pair",
        "flexflex",
        "pair",
        "variable",
        "head",
        "symbol",
        "term",
        "unified",
        "known",
        "always",
        "solution",
        "concrete",
        "computation",
        "solution",
        "thus",
        "postponed",
        "omitted",
        "preunification",
        "utilized",
        "resolution",
        "based",
        "theorem",
        "provers",
        "mentioned",
        "section",
        "pattern",
        "unification",
        "refers",
        "small",
        "subset",
        "unification",
        "problem",
        "first",
        "studied",
        "miller",
        "whose",
        "identification",
        "important",
        "construction",
        "practical",
        "system",
        "pattern",
        "unification",
        "problem",
        "every",
        "occurrence",
        "existentially",
        "quantified",
        "variable",
        "applied",
        "list",
        "argument",
        "distinct",
        "variable",
        "bound",
        "either",
        "\u03bbbinder",
        "universal",
        "quantifier",
        "scope",
        "existential",
        "quantifier",
        "thus",
        "existentially",
        "quantified",
        "variable",
        "applied",
        "general",
        "term",
        "restricted",
        "set",
        "bound",
        "variable",
        "pattern",
        "unification",
        "like",
        "firstorder",
        "unification",
        "decidable",
        "general",
        "unifiers",
        "exist",
        "solvable",
        "problem",
        "pattern",
        "unification",
        "preferably",
        "employed",
        "applicable",
        "stateoftheart",
        "theorem",
        "provers",
        "church",
        "type",
        "theory",
        "unifying",
        "principle",
        "unifying",
        "principle",
        "introduced",
        "smullyan",
        "see",
        "also",
        "smullyan",
        "tool",
        "deriving",
        "number",
        "basic",
        "metatheorems",
        "firstorder",
        "logic",
        "uniform",
        "way",
        "principle",
        "extended",
        "elementary",
        "type",
        "theory",
        "andrew",
        "extensional",
        "type",
        "theory",
        "henkin",
        "general",
        "semantics",
        "without",
        "description",
        "choice",
        "benzm\u00fcller",
        "brown",
        "kohlhase",
        "outline",
        "extension",
        "detail",
        "elementary",
        "type",
        "theory",
        "unifying",
        "principle",
        "extended",
        "elementary",
        "type",
        "theory",
        "system",
        "ct",
        "section",
        "andrew",
        "applying",
        "idea",
        "takahashi",
        "unifying",
        "principle",
        "ct",
        "used",
        "establish",
        "cutelimination",
        "ct",
        "andrew",
        "completeness",
        "proof",
        "various",
        "system",
        "type",
        "theory",
        "huet",
        "a",
        "kohlhase",
        "miller",
        "first",
        "give",
        "definition",
        "state",
        "principle",
        "definition",
        "property",
        "gamma",
        "finite",
        "set",
        "wffs",
        "_",
        "abstract",
        "consistency",
        "property",
        "iff",
        "finite",
        "set",
        "cs",
        "wffs",
        "_",
        "following",
        "property",
        "hold",
        "wffs",
        "b",
        "gamma",
        "cs",
        "atom",
        "ba",
        "ba",
        "in",
        "cs",
        "nsim",
        "ba",
        "in",
        "cs",
        "gamma",
        "cs",
        "cup",
        "ba",
        "gamma",
        "cs",
        "cup",
        "downarrow",
        "ba",
        "gamma",
        "cs",
        "cup",
        "nsim",
        "nsim",
        "ba",
        "gamma",
        "cs",
        "cup",
        "ba",
        "gamma",
        "cs",
        "cup",
        "ba",
        "lor",
        "bb",
        "gamma",
        "cs",
        "cup",
        "ba",
        "gamma",
        "cs",
        "cup",
        "bb",
        "gamma",
        "cs",
        "cup",
        "nsim",
        "ba",
        "lor",
        "bb",
        "gamma",
        "cs",
        "cup",
        "nsim",
        "ba",
        "nsim",
        "bb",
        "gamma",
        "cs",
        "cup",
        "pi_",
        "alpha",
        "ba_",
        "alpha",
        "gamma",
        "cs",
        "cup",
        "pi_",
        "alpha",
        "ba_",
        "alpha",
        "ba_",
        "alpha",
        "bb_",
        "alpha",
        "wff",
        "bb_",
        "alpha",
        "gamma",
        "cs",
        "cup",
        "nsim",
        "pi_",
        "alpha",
        "ba_",
        "alpha",
        "gamma",
        "cs",
        "cup",
        "nsim",
        "ba_",
        "alpha",
        "bc_",
        "alpha",
        "variable",
        "parameter",
        "bc_",
        "alpha",
        "occur",
        "free",
        "ba_",
        "alpha",
        "wff",
        "cs",
        "note",
        "consistency",
        "abstract",
        "consistency",
        "property",
        "unifying",
        "principle",
        "ct",
        "gamma",
        "abstract",
        "consistency",
        "property",
        "gamma",
        "cs",
        "cs",
        "consistent",
        "ct",
        "typical",
        "application",
        "unifying",
        "principle",
        "suppose",
        "procedure",
        "cm",
        "used",
        "refute",
        "set",
        "sentence",
        "wish",
        "show",
        "complete",
        "ct",
        "set",
        "sentence",
        "let",
        "gamma",
        "cs",
        "mean",
        "cs",
        "refutable",
        "cm",
        "show",
        "gamma",
        "abstract",
        "consistency",
        "property",
        "suppose",
        "ba",
        "theorem",
        "ct",
        "nsim",
        "ba",
        "inconsistent",
        "ct",
        "unifying",
        "principle",
        "gamma",
        "nsim",
        "ba",
        "nsim",
        "ba",
        "refutable",
        "cm",
        "extensional",
        "type",
        "theory",
        "extension",
        "unifying",
        "principle",
        "towards",
        "church",
        "type",
        "theory",
        "general",
        "semantics",
        "studied",
        "since",
        "mid",
        "ninety",
        "primary",
        "motivation",
        "support",
        "refutational",
        "completeness",
        "investigation",
        "proof",
        "calculus",
        "underlying",
        "emerging",
        "higherorder",
        "automated",
        "theorem",
        "provers",
        "see",
        "section",
        "initial",
        "interest",
        "fragment",
        "church",
        "type",
        "theory",
        "called",
        "extensional",
        "type",
        "theory",
        "includes",
        "extensionality",
        "axiom",
        "excludes",
        "iota_",
        "alpha",
        "alpha",
        "axiom",
        "description",
        "choice",
        "largely",
        "neglected",
        "automated",
        "theorem",
        "provers",
        "time",
        "analogous",
        "distinction",
        "made",
        "extensional",
        "type",
        "theory",
        "defined",
        "equality",
        "section",
        "equality",
        "defined",
        "via",
        "leibniz",
        "principle",
        "extensional",
        "type",
        "theory",
        "primitive",
        "equality",
        "eg",
        "system",
        "cq_",
        "section",
        "alternatively",
        "system",
        "based",
        "logical",
        "constant",
        "nsim_",
        "lor_",
        "pi_",
        "alpha",
        "section",
        "additional",
        "primitive",
        "logical",
        "constant",
        "_",
        "alphaalpha",
        "added",
        "first",
        "attempt",
        "towards",
        "unifying",
        "principle",
        "extensional",
        "type",
        "theory",
        "primitive",
        "equality",
        "presented",
        "kohlhase",
        "condition",
        "given",
        "still",
        "incomplete",
        "subsequently",
        "modified",
        "complemented",
        "follows",
        "obtain",
        "unifying",
        "principle",
        "extensional",
        "type",
        "theory",
        "defined",
        "equality",
        "benzm\u00fcller",
        "kohlhase",
        "added",
        "following",
        "condition",
        "boolean",
        "extensionality",
        "functional",
        "extensionality",
        "saturation",
        "condition",
        "ct",
        "presentation",
        "adapted",
        "technical",
        "reason",
        "also",
        "employ",
        "slightly",
        "stronger",
        "variant",
        "condition",
        "based",
        "\u03b2conversion",
        "rather",
        "\u03b2normalization",
        "gamma",
        "cs",
        "cup",
        "ba_",
        "bb_",
        "gamma",
        "cs",
        "cup",
        "ba_",
        "bb_",
        "gamma",
        "cs",
        "cup",
        "nsim",
        "ba_",
        "nsim",
        "bb_",
        "gamma",
        "cs",
        "cup",
        "ba_",
        "alphabeta",
        "bb_",
        "alphabeta",
        "gamma",
        "cs",
        "cup",
        "ba_",
        "alphabeta",
        "bc_beta",
        "bb_",
        "alphabeta",
        "bc_beta",
        "parameter",
        "bc_",
        "beta",
        "occur",
        "free",
        "cs",
        "gamma",
        "cs",
        "cup",
        "ba_",
        "gamma",
        "cs",
        "cup",
        "nsim",
        "ba_",
        "saturation",
        "condition",
        "required",
        "properly",
        "establish",
        "principle",
        "however",
        "since",
        "condition",
        "related",
        "proof",
        "theoretic",
        "notion",
        "cutelimination",
        "limit",
        "utility",
        "principle",
        "completeness",
        "proof",
        "machineoriented",
        "calculus",
        "principle",
        "nevertheless",
        "used",
        "benzm\u00fcller",
        "kohlhase",
        "a",
        "benzm\u00fcller",
        "a",
        "b",
        "obtain",
        "completeness",
        "proof",
        "system",
        "extensional",
        "higherorder",
        "resolution",
        "principle",
        "also",
        "applied",
        "kohlhase",
        "study",
        "completeness",
        "related",
        "extensional",
        "higherorder",
        "tableau",
        "calculus",
        "extensionality",
        "rule",
        "leibniz",
        "equality",
        "adapted",
        "benzm\u00fcller",
        "kohlhase",
        "a",
        "respectively",
        "benzm\u00fcller",
        "different",
        "option",
        "achieving",
        "unifying",
        "principle",
        "extensional",
        "type",
        "theory",
        "primitive",
        "equality",
        "presented",
        "benzm\u00fcller",
        "a",
        "work",
        "primitive",
        "logical",
        "constant",
        "_",
        "alphaalpha",
        "used",
        "addition",
        "nsim_",
        "lor_",
        "pi_",
        "alpha",
        "redundant",
        "choice",
        "logical",
        "constant",
        "rare",
        "higherorder",
        "theorem",
        "provers",
        "one",
        "option",
        "introduce",
        "reflexivity",
        "substitutivity",
        "condition",
        "alternative",
        "combine",
        "reflexivity",
        "condition",
        "condition",
        "connecting",
        "primitive",
        "defined",
        "equality",
        "substitutivity",
        "condition",
        "follows",
        "note",
        "introducing",
        "defined",
        "notion",
        "equality",
        "based",
        "leibniz",
        "principle",
        "course",
        "still",
        "possible",
        "context",
        "defined",
        "equality",
        "denoted",
        "remainder",
        "section",
        "doteq",
        "properly",
        "distinguish",
        "primitive",
        "equality",
        "gamma",
        "cs",
        "cup",
        "nsim",
        "ba_",
        "alpha",
        "ba_",
        "alpha",
        "gamma",
        "cs",
        "cup",
        "ba_",
        "alpha",
        "ba_",
        "alpha",
        "gamma",
        "cs",
        "cup",
        "ba_",
        "alpha",
        "doteq",
        "ba_",
        "alpha",
        "gamma",
        "cs",
        "cup",
        "ba_",
        "gamma",
        "cs",
        "cup",
        "nsim",
        "ba_",
        "saturation",
        "condition",
        "still",
        "added",
        "independent",
        "option",
        "considered",
        "principle",
        "applied",
        "benzm\u00fcller",
        "a",
        "b",
        "prove",
        "completeness",
        "extensional",
        "higherorder",
        "rueresolution",
        "calculus",
        "underlying",
        "higherorder",
        "automated",
        "theorem",
        "prover",
        "leo",
        "successor",
        "leoii",
        "benzm\u00fcller",
        "et",
        "al",
        "principle",
        "presented",
        "general",
        "way",
        "allows",
        "various",
        "possibility",
        "concerning",
        "treatment",
        "extensionality",
        "equality",
        "range",
        "elementary",
        "type",
        "theory",
        "extensional",
        "type",
        "theory",
        "principle",
        "applied",
        "obtain",
        "completeness",
        "proof",
        "associated",
        "range",
        "natural",
        "deduction",
        "calculus",
        "saturation",
        "condition",
        "still",
        "used",
        "work",
        "based",
        "insight",
        "brown",
        "thesis",
        "solution",
        "replacing",
        "undesirable",
        "saturation",
        "condition",
        "two",
        "weaker",
        "condition",
        "presented",
        "benzm\u00fcller",
        "brown",
        "kohlhase",
        "work",
        "also",
        "study",
        "relation",
        "saturation",
        "cutelimination",
        "two",
        "weaker",
        "condition",
        "termed",
        "mating",
        "decomposition",
        "easier",
        "demonstrate",
        "saturation",
        "completeness",
        "proof",
        "machineoriented",
        "calculus",
        "omitting",
        "type",
        "information",
        "second",
        "one",
        "abusing",
        "notation",
        "gamma",
        "cs",
        "cup",
        "nsim",
        "ba_",
        "bb_",
        "atom",
        "ba_",
        "bb_",
        "gamma",
        "cs",
        "cup",
        "nsim",
        "ba_",
        "doteq",
        "bb_",
        "gamma",
        "cs",
        "cup",
        "nsim",
        "h",
        "overline",
        "ban_",
        "alphan",
        "doteq",
        "h",
        "overline",
        "bbn_",
        "alphan",
        "head",
        "symbol",
        "h_",
        "betaoverline",
        "alphan",
        "parameter",
        "i",
        "leq",
        "leq",
        "n",
        "gamma",
        "cs",
        "cup",
        "nsim",
        "bai_",
        "alphai",
        "doteq",
        "bbi_",
        "alphai",
        "modified",
        "principle",
        "applied",
        "benzm\u00fcller",
        "et",
        "al",
        "show",
        "completeness",
        "sequent",
        "calculus",
        "extensional",
        "type",
        "theory",
        "defined",
        "equality",
        "extended",
        "unifying",
        "principle",
        "extensional",
        "type",
        "theory",
        "primitive",
        "equality",
        "presented",
        "used",
        "backes",
        "brown",
        "prove",
        "completeness",
        "tableau",
        "calculus",
        "type",
        "theory",
        "incorporates",
        "axiom",
        "choice",
        "closely",
        "related",
        "simplified",
        "principle",
        "also",
        "presented",
        "studied",
        "steen",
        "applied",
        "showing",
        "completeness",
        "paramodulation",
        "calculus",
        "steen",
        "underlying",
        "theorem",
        "prover",
        "leoiii",
        "steen",
        "benzm\u00fcller",
        "cutelimination",
        "cutsimulation",
        "cutelimination",
        "proof",
        "see",
        "also",
        "sep",
        "entry",
        "proof",
        "theory",
        "church",
        "type",
        "theory",
        "often",
        "closely",
        "related",
        "proof",
        "takahashi",
        "prawitz",
        "mint",
        "formulation",
        "type",
        "theory",
        "may",
        "found",
        "andrew",
        "dowek",
        "werner",
        "brown",
        "benzm\u00fcller",
        "et",
        "al",
        "shown",
        "certain",
        "wffs",
        "_",
        "axiom",
        "extensionality",
        "description",
        "choice",
        "see",
        "section",
        "induction",
        "used",
        "justify",
        "cut",
        "cutfree",
        "sequent",
        "calculus",
        "elementary",
        "type",
        "theory",
        "moreover",
        "notion",
        "cutsimulation",
        "cutstrong",
        "axiom",
        "introduced",
        "work",
        "need",
        "omitting",
        "defined",
        "equality",
        "eliminating",
        "cutstrong",
        "axiom",
        "extensionality",
        "description",
        "choice",
        "induction",
        "machineoriented",
        "calculus",
        "eg",
        "replacing",
        "constrained",
        "goaldirected",
        "rule",
        "order",
        "reduce",
        "cutsimulation",
        "effect",
        "discussed",
        "major",
        "challenge",
        "higherorder",
        "automated",
        "theorem",
        "proving",
        "word",
        "including",
        "cutstrong",
        "axiom",
        "machineoriented",
        "proof",
        "calculus",
        "church",
        "type",
        "theory",
        "essentially",
        "bad",
        "including",
        "cut",
        "rule",
        "since",
        "cut",
        "rule",
        "mimicked",
        "expansion",
        "proof",
        "expansion",
        "proof",
        "generalization",
        "notion",
        "herbrand",
        "expansion",
        "theorem",
        "firstorder",
        "logic",
        "provides",
        "elegant",
        "concise",
        "nonredundant",
        "representation",
        "relationship",
        "theorem",
        "tautology",
        "obtained",
        "appropriate",
        "instantiation",
        "quantifier",
        "underlies",
        "various",
        "proof",
        "theorem",
        "miller",
        "proved",
        "wff",
        "ba",
        "theorem",
        "elementary",
        "type",
        "theory",
        "ba",
        "expansion",
        "proof",
        "brown",
        "concept",
        "generalized",
        "extensional",
        "expansion",
        "proof",
        "obtain",
        "analogous",
        "theorem",
        "involving",
        "type",
        "theory",
        "extensionality",
        "decision",
        "problem",
        "since",
        "type",
        "theory",
        "includes",
        "firstorder",
        "logic",
        "surprise",
        "system",
        "type",
        "theory",
        "undecidable",
        "however",
        "one",
        "may",
        "look",
        "solvable",
        "special",
        "case",
        "decision",
        "problem",
        "example",
        "system",
        "cq_",
        "obtained",
        "adding",
        "cq_",
        "additional",
        "axiom",
        "forall",
        "x_",
        "imath",
        "forall",
        "y_",
        "imath",
        "x_",
        "imath",
        "y_",
        "imath",
        "decidable",
        "although",
        "system",
        "ct",
        "elementary",
        "type",
        "theory",
        "analogous",
        "firstorder",
        "logic",
        "certain",
        "respect",
        "considerably",
        "complex",
        "language",
        "special",
        "case",
        "decision",
        "problem",
        "provability",
        "ct",
        "seem",
        "rather",
        "intractable",
        "part",
        "information",
        "special",
        "case",
        "decision",
        "problem",
        "may",
        "found",
        "andrew",
        "summarize",
        "wff",
        "form",
        "exists",
        "bx",
        "ldots",
        "exists",
        "bxn",
        "babb",
        "theorem",
        "ct",
        "iff",
        "substitution",
        "theta",
        "theta",
        "ba",
        "conv",
        "theta",
        "bb",
        "particular",
        "vdash",
        "babb",
        "iff",
        "ba",
        "conv",
        "bb",
        "solves",
        "decision",
        "problem",
        "wffs",
        "form",
        "babb",
        "naturally",
        "circumstance",
        "trivial",
        "equality",
        "formula",
        "provable",
        "ct",
        "change",
        "drastically",
        "axiom",
        "extensionality",
        "added",
        "ct",
        "vdash",
        "exists",
        "bx_",
        "beta",
        "babb",
        "iff",
        "wff",
        "be_",
        "beta",
        "vdash",
        "lambda",
        "bx_",
        "beta",
        "babb",
        "be_",
        "beta",
        "decision",
        "problem",
        "class",
        "wffs",
        "form",
        "exists",
        "bx_",
        "beta",
        "babb",
        "unsolvable",
        "wff",
        "form",
        "forall",
        "bx",
        "ldots",
        "forall",
        "bxnbc",
        "bc",
        "quantifierfree",
        "provable",
        "ct",
        "iff",
        "downarrow",
        "bc",
        "tautologous",
        "hand",
        "decision",
        "problem",
        "wffs",
        "form",
        "exists",
        "bzbc",
        "bc",
        "quantifierfree",
        "unsolvable",
        "contrast",
        "corresponding",
        "decision",
        "problem",
        "firstorder",
        "logic",
        "function",
        "symbol",
        "known",
        "solvable",
        "maslov",
        "since",
        "irrelevant",
        "vacuous",
        "quantifier",
        "always",
        "introduced",
        "show",
        "solvable",
        "class",
        "wffs",
        "ct",
        "prenex",
        "normal",
        "form",
        "defined",
        "solely",
        "structure",
        "prefix",
        "existential",
        "quantifier",
        "occur",
        "automation",
        "machineoriented",
        "proof",
        "calculus",
        "development",
        "respectively",
        "improvement",
        "machineoriented",
        "proof",
        "calculus",
        "church",
        "type",
        "theory",
        "still",
        "challenge",
        "research",
        "topic",
        "compared",
        "eg",
        "theoretical",
        "practical",
        "maturity",
        "achieved",
        "firstorder",
        "automated",
        "theorem",
        "proving",
        "area",
        "still",
        "infancy",
        "obviously",
        "challenge",
        "also",
        "much",
        "bigger",
        "firstorder",
        "logic",
        "practically",
        "way",
        "expressive",
        "nature",
        "termlanguage",
        "church",
        "type",
        "theory",
        "cause",
        "larger",
        "bushier",
        "difficult",
        "traverse",
        "proof",
        "search",
        "space",
        "firstorder",
        "logic",
        "moreover",
        "remember",
        "unification",
        "constitutes",
        "important",
        "control",
        "filter",
        "mechanism",
        "firstorder",
        "theorem",
        "proving",
        "undecidable",
        "general",
        "type",
        "theory",
        "see",
        "section",
        "positive",
        "side",
        "however",
        "chance",
        "find",
        "significantly",
        "shorter",
        "proof",
        "firstorder",
        "logic",
        "well",
        "illustrated",
        "small",
        "concrete",
        "example",
        "boolos",
        "clearly",
        "much",
        "progress",
        "needed",
        "leverage",
        "practical",
        "relevance",
        "existing",
        "calculus",
        "church",
        "type",
        "theory",
        "implementation",
        "see",
        "section",
        "challenge",
        "include",
        "appropriate",
        "handling",
        "impredicative",
        "nature",
        "church",
        "type",
        "theory",
        "form",
        "blind",
        "guessing",
        "generally",
        "avoided",
        "complete",
        "proof",
        "procedure",
        "must",
        "intelligently",
        "guided",
        "eliminationreduction",
        "cutsimulation",
        "effect",
        "see",
        "section",
        "caused",
        "defined",
        "equality",
        "cutstrong",
        "axiom",
        "eg",
        "extensionality",
        "description",
        "choice",
        "induction",
        "search",
        "space",
        "general",
        "undecidability",
        "unification",
        "rendering",
        "rather",
        "problematic",
        "filter",
        "mechanism",
        "controlling",
        "proof",
        "search",
        "invention",
        "suitable",
        "heuristic",
        "traversing",
        "search",
        "space",
        "provision",
        "suitable",
        "termorderings",
        "effective",
        "exploitation",
        "term",
        "rewriting",
        "procedure",
        "development",
        "efficient",
        "data",
        "structure",
        "combination",
        "strong",
        "technical",
        "support",
        "essential",
        "operation",
        "\u03bbconversion",
        "substitution",
        "rewriting",
        "planned",
        "future",
        "edition",
        "article",
        "elaborate",
        "machineoriented",
        "proof",
        "calculus",
        "church",
        "type",
        "theory",
        "time",
        "however",
        "provide",
        "selection",
        "historical",
        "recent",
        "reference",
        "interested",
        "reader",
        "see",
        "also",
        "section",
        "sequent",
        "calculus",
        "sch\u00fctte",
        "takahashi",
        "takeuti",
        "mint",
        "brown",
        "benzm\u00fcller",
        "et",
        "al",
        "mating",
        "method",
        "andrew",
        "bibel",
        "bishop",
        "resolution",
        "calculus",
        "andrew",
        "huet",
        "a",
        "jensen",
        "pietrzykowski",
        "benzm\u00fcller",
        "a",
        "benzm\u00fcller",
        "kohlhase",
        "a",
        "tableau",
        "method",
        "kohlhase",
        "brown",
        "smolka",
        "backes",
        "brown",
        "paramodulation",
        "calculus",
        "benzm\u00fcller",
        "a",
        "b",
        "steen",
        "early",
        "proof",
        "assistant",
        "early",
        "computer",
        "system",
        "proving",
        "theorem",
        "church",
        "type",
        "theory",
        "extension",
        "include",
        "hol",
        "gordon",
        "gordon",
        "melham",
        "tps",
        "andrew",
        "et",
        "al",
        "andrew",
        "brown",
        "isabelle",
        "paulson",
        "pvs",
        "owre",
        "et",
        "al",
        "shankar",
        "imp",
        "farmer",
        "et",
        "al",
        "hol",
        "light",
        "harrison",
        "omega",
        "siekmann",
        "et",
        "al",
        "\u03bbclam",
        "richardson",
        "et",
        "al",
        "see",
        "internet",
        "reference",
        "section",
        "link",
        "info",
        "provers",
        "mentioned",
        "later",
        "majority",
        "system",
        "focused",
        "least",
        "initially",
        "interactive",
        "proof",
        "provided",
        "rather",
        "limited",
        "support",
        "additional",
        "proof",
        "automation",
        "full",
        "proof",
        "automation",
        "pioneered",
        "particular",
        "tps",
        "project",
        "progress",
        "made",
        "ninety",
        "project",
        "started",
        "similar",
        "activity",
        "respectively",
        "enforced",
        "however",
        "resource",
        "investment",
        "achievement",
        "lacking",
        "much",
        "behind",
        "seen",
        "firstorder",
        "theorem",
        "proving",
        "significant",
        "progress",
        "fostered",
        "later",
        "particular",
        "development",
        "commonly",
        "supported",
        "syntax",
        "church",
        "type",
        "theory",
        "called",
        "tptp",
        "thf",
        "sutcliffe",
        "benzm\u00fcller",
        "inclusion",
        "onwards",
        "tptp",
        "thf",
        "division",
        "yearly",
        "casc",
        "competition",
        "kind",
        "world",
        "championship",
        "automated",
        "theorem",
        "proving",
        "see",
        "sutcliffe",
        "detail",
        "automated",
        "theorem",
        "provers",
        "selection",
        "theorem",
        "provers",
        "church",
        "type",
        "theory",
        "presented",
        "focus",
        "system",
        "successfully",
        "participated",
        "tptp",
        "thf",
        "casc",
        "competition",
        "past",
        "latest",
        "edition",
        "mentioned",
        "system",
        "accessed",
        "online",
        "via",
        "systemontptp",
        "infrastructure",
        "sutcliffe",
        "nearly",
        "mentioned",
        "system",
        "produce",
        "verifiable",
        "proof",
        "certificate",
        "tptp",
        "tstp",
        "syntax",
        "detail",
        "automation",
        "church",
        "type",
        "theory",
        "given",
        "benzm\u00fcller",
        "miller",
        "tps",
        "prover",
        "andrew",
        "et",
        "al",
        "andrew",
        "brown",
        "used",
        "prove",
        "theorem",
        "elementary",
        "type",
        "theory",
        "extensional",
        "type",
        "theory",
        "automatically",
        "interactively",
        "semiautomatically",
        "searching",
        "proof",
        "automatically",
        "tps",
        "first",
        "search",
        "expansion",
        "proof",
        "miller",
        "extensional",
        "expansion",
        "proof",
        "brown",
        "theorem",
        "part",
        "process",
        "involves",
        "searching",
        "acceptable",
        "mating",
        "andrew",
        "bishop",
        "behavior",
        "tps",
        "controlled",
        "set",
        "flag",
        "also",
        "called",
        "mode",
        "simple",
        "scheduling",
        "mechanism",
        "employed",
        "latest",
        "version",
        "tps",
        "sequentially",
        "run",
        "fifty",
        "mode",
        "limited",
        "amount",
        "time",
        "tps",
        "winner",
        "first",
        "thf",
        "casc",
        "competition",
        "leoii",
        "prover",
        "benzm\u00fcller",
        "et",
        "al",
        "successor",
        "leo",
        "benzm\u00fcller",
        "kohlhase",
        "b",
        "hardwired",
        "omega",
        "proof",
        "assistant",
        "leo",
        "stand",
        "logical",
        "engine",
        "omega",
        "provers",
        "based",
        "rueresolution",
        "calculus",
        "developed",
        "benzm\u00fcller",
        "a",
        "b",
        "leo",
        "first",
        "prover",
        "implement",
        "calculus",
        "rule",
        "extensionality",
        "avoid",
        "cutsimulation",
        "effect",
        "leoii",
        "inherits",
        "adapts",
        "provides",
        "additional",
        "calculus",
        "rule",
        "description",
        "choice",
        "prover",
        "internally",
        "collaborates",
        "firstorder",
        "provers",
        "preferably",
        "e",
        "sat",
        "solver",
        "pioneered",
        "cooperative",
        "higherorderfirstorder",
        "proof",
        "automation",
        "since",
        "prover",
        "often",
        "weak",
        "find",
        "refutation",
        "among",
        "steadily",
        "growing",
        "set",
        "clause",
        "clause",
        "leoii",
        "search",
        "space",
        "attain",
        "special",
        "status",
        "firstorder",
        "clause",
        "modulo",
        "application",
        "appropriate",
        "transformation",
        "function",
        "therefore",
        "leoii",
        "progressively",
        "launch",
        "time",
        "limited",
        "call",
        "clause",
        "firstorder",
        "theorem",
        "prover",
        "firstorder",
        "prover",
        "report",
        "refutation",
        "leoii",
        "also",
        "terminates",
        "part",
        "idea",
        "already",
        "implemented",
        "predecessor",
        "leo",
        "communication",
        "leoii",
        "cooperating",
        "firstorder",
        "theorem",
        "provers",
        "us",
        "tptp",
        "language",
        "standard",
        "leoii",
        "winner",
        "second",
        "thf",
        "casc",
        "competition",
        "satallax",
        "prover",
        "brown",
        "based",
        "complete",
        "ground",
        "tableau",
        "calculus",
        "church",
        "type",
        "theory",
        "choice",
        "backes",
        "brown",
        "initial",
        "tableau",
        "branch",
        "formed",
        "assumption",
        "conjecture",
        "negation",
        "conclusion",
        "point",
        "satallax",
        "try",
        "determine",
        "unsatisfiability",
        "satisfiability",
        "branch",
        "satallax",
        "progressively",
        "generates",
        "higherorder",
        "formula",
        "corresponding",
        "propositional",
        "clause",
        "satallax",
        "us",
        "sat",
        "solver",
        "minisat",
        "engine",
        "test",
        "current",
        "set",
        "propositional",
        "clause",
        "unsatisfiability",
        "clause",
        "unsatisfiable",
        "original",
        "branch",
        "unsatisfiable",
        "satallax",
        "provides",
        "calculus",
        "rule",
        "extensionality",
        "description",
        "choice",
        "quantifier",
        "function",
        "type",
        "generation",
        "higherorder",
        "formula",
        "corresponding",
        "clause",
        "may",
        "terminate",
        "case",
        "minisat",
        "report",
        "final",
        "set",
        "clause",
        "satisfiable",
        "original",
        "set",
        "higherorder",
        "formula",
        "satisfiable",
        "standard",
        "model",
        "type",
        "interpreted",
        "finite",
        "set",
        "satallax",
        "winner",
        "thf",
        "casc",
        "competition",
        "since",
        "isabellehol",
        "system",
        "nipkow",
        "wenzel",
        "paulson",
        "originally",
        "designed",
        "interactive",
        "prover",
        "however",
        "order",
        "ease",
        "user",
        "interaction",
        "several",
        "automatic",
        "proof",
        "tactic",
        "added",
        "year",
        "appropriately",
        "scheduling",
        "subset",
        "proof",
        "tactic",
        "quite",
        "powerful",
        "isabellehol",
        "since",
        "turned",
        "also",
        "automatic",
        "theorem",
        "prover",
        "tptp",
        "thf",
        "tptp",
        "syntax",
        "format",
        "run",
        "command",
        "shell",
        "like",
        "provers",
        "powerful",
        "proof",
        "tactic",
        "scheduled",
        "isabellehol",
        "include",
        "sledgehammer",
        "tool",
        "blanchette",
        "et",
        "al",
        "invokes",
        "sequence",
        "external",
        "firstorder",
        "higherorder",
        "theorem",
        "provers",
        "model",
        "finder",
        "nitpick",
        "blanchette",
        "nipkow",
        "equational",
        "reasoner",
        "simp",
        "untyped",
        "tableau",
        "prover",
        "blast",
        "simplifier",
        "classical",
        "reasoner",
        "auto",
        "force",
        "fast",
        "bestfirst",
        "search",
        "procedure",
        "best",
        "contrast",
        "automated",
        "theorem",
        "provers",
        "mentioned",
        "tptp",
        "incarnation",
        "isabellehol",
        "yet",
        "output",
        "proof",
        "certificate",
        "isabellehol",
        "winner",
        "thf",
        "casc",
        "competition",
        "agsyhol",
        "prover",
        "based",
        "generic",
        "lazy",
        "narrowing",
        "proof",
        "search",
        "algorithm",
        "backtracking",
        "employed",
        "comparably",
        "small",
        "search",
        "state",
        "maintained",
        "prover",
        "output",
        "proof",
        "term",
        "sequent",
        "style",
        "verified",
        "agda",
        "system",
        "coqatp",
        "implement",
        "noninductive",
        "part",
        "calculus",
        "construction",
        "bertot",
        "cast\u00e9ran",
        "system",
        "output",
        "proof",
        "term",
        "accepted",
        "proof",
        "addition",
        "definition",
        "coq",
        "proof",
        "assistant",
        "prover",
        "employ",
        "axiom",
        "functional",
        "extensionality",
        "choice",
        "excluded",
        "middle",
        "boolean",
        "extensionality",
        "supported",
        "addition",
        "axiom",
        "small",
        "library",
        "basic",
        "lemma",
        "employed",
        "leoiii",
        "prover",
        "implement",
        "paramodulation",
        "calculus",
        "church",
        "type",
        "theory",
        "steen",
        "system",
        "descendant",
        "leo",
        "leoii",
        "provides",
        "calculus",
        "rule",
        "extensionality",
        "description",
        "choice",
        "system",
        "put",
        "emphasis",
        "implementation",
        "efficient",
        "set",
        "underlying",
        "data",
        "structure",
        "simplification",
        "routine",
        "heuristic",
        "rewriting",
        "tradition",
        "predecessor",
        "leoiii",
        "cooperates",
        "firstorder",
        "reasoning",
        "tool",
        "using",
        "translation",
        "manysorted",
        "firstorder",
        "logic",
        "prover",
        "accepts",
        "every",
        "common",
        "tptp",
        "syntax",
        "dialect",
        "thus",
        "widely",
        "applicable",
        "recently",
        "prover",
        "also",
        "extended",
        "natively",
        "support",
        "almost",
        "every",
        "normal",
        "higherorder",
        "modal",
        "logic",
        "zipperposition",
        "bentkamp",
        "et",
        "al",
        "new",
        "inspiring",
        "higherorder",
        "theorem",
        "prover",
        "current",
        "state",
        "development",
        "still",
        "working",
        "comparably",
        "weak",
        "fragment",
        "church",
        "type",
        "theory",
        "called",
        "lambdafree",
        "higherorder",
        "logic",
        "comprehensionfree",
        "higherorder",
        "logic",
        "nevertheless",
        "supporting",
        "\u03bbnotation",
        "system",
        "based",
        "superposition",
        "calculus",
        "developed",
        "bottom",
        "progressively",
        "extended",
        "towards",
        "stronger",
        "fragment",
        "church",
        "type",
        "theory",
        "support",
        "relevant",
        "extension",
        "datatypes",
        "recursive",
        "function",
        "arithmetic",
        "various",
        "called",
        "proof",
        "hammer",
        "spirit",
        "isabelle",
        "sledgehammer",
        "tool",
        "recently",
        "developed",
        "integrated",
        "modern",
        "proof",
        "assistant",
        "prominent",
        "example",
        "include",
        "hol",
        "hammer",
        "kaliszyk",
        "urban",
        "hol",
        "light",
        "similar",
        "hammer",
        "czaika",
        "kaliszyk",
        "proof",
        "assistant",
        "coq",
        "counter",
        "model",
        "finding",
        "support",
        "finding",
        "finite",
        "model",
        "countermodels",
        "formula",
        "church",
        "type",
        "theory",
        "implemented",
        "already",
        "tableaubased",
        "prover",
        "hot",
        "konrad",
        "restricted",
        "counter",
        "model",
        "finding",
        "capability",
        "also",
        "implemented",
        "provers",
        "satallax",
        "leoii",
        "leoiii",
        "advanced",
        "finite",
        "model",
        "finding",
        "support",
        "currently",
        "realized",
        "system",
        "nitpick",
        "nunchaku",
        "refute",
        "tool",
        "integrated",
        "isabelle",
        "proof",
        "assistant",
        "nitpick",
        "also",
        "available",
        "standalone",
        "tool",
        "accepts",
        "tptp",
        "thf",
        "syntax",
        "system",
        "particularly",
        "valuable",
        "exposing",
        "error",
        "misconception",
        "problem",
        "encoding",
        "revealing",
        "bug",
        "thf",
        "theorem",
        "provers",
        "application",
        "semantics",
        "natural",
        "language",
        "church",
        "type",
        "theory",
        "play",
        "important",
        "role",
        "study",
        "formal",
        "semantics",
        "natural",
        "language",
        "pioneering",
        "work",
        "done",
        "richard",
        "montague",
        "see",
        "paper",
        "english",
        "formal",
        "language",
        "universal",
        "grammar",
        "proper",
        "treatment",
        "quantification",
        "ordinary",
        "english",
        "reprinted",
        "montague",
        "crucial",
        "component",
        "montague",
        "analysis",
        "natural",
        "language",
        "definition",
        "tensed",
        "intensional",
        "logic",
        "montague",
        "enhancement",
        "church",
        "type",
        "theory",
        "montague",
        "grammar",
        "huge",
        "impact",
        "since",
        "developed",
        "many",
        "direction",
        "least",
        "typelogicalcategorical",
        "grammar",
        "related",
        "work",
        "intensional",
        "higherorder",
        "modal",
        "logic",
        "presented",
        "gallin",
        "muskens",
        "mathematics",
        "computer",
        "science",
        "proof",
        "assistant",
        "based",
        "church",
        "type",
        "theory",
        "including",
        "isabellehol",
        "hol",
        "light",
        "hol",
        "pvs",
        "successfully",
        "utilized",
        "broad",
        "range",
        "application",
        "computer",
        "science",
        "mathematics",
        "application",
        "computer",
        "science",
        "include",
        "verification",
        "hardware",
        "software",
        "security",
        "protocol",
        "prominent",
        "example",
        "lverified",
        "project",
        "isabellehol",
        "used",
        "formally",
        "prove",
        "sel",
        "operating",
        "system",
        "kernel",
        "implement",
        "abstract",
        "mathematical",
        "model",
        "specifying",
        "kernel",
        "supposed",
        "klein",
        "et",
        "al",
        "mathematics",
        "proof",
        "assistant",
        "applied",
        "development",
        "library",
        "mathematical",
        "theory",
        "verification",
        "challenge",
        "theorem",
        "early",
        "example",
        "mathematical",
        "library",
        "developed",
        "since",
        "eighty",
        "tps",
        "project",
        "exemplary",
        "list",
        "theorem",
        "proved",
        "automatically",
        "tps",
        "given",
        "andrew",
        "et",
        "al",
        "prominent",
        "recent",
        "example",
        "hale",
        "flyspeck",
        "hol",
        "light",
        "employed",
        "develop",
        "formal",
        "proof",
        "kepler",
        "conjecture",
        "hale",
        "et",
        "al",
        "example",
        "strongly",
        "exploit",
        "automation",
        "support",
        "isabellehol",
        "sledgehammer",
        "nitpick",
        "presented",
        "benzm\u00fcller",
        "scott",
        "forthcoming",
        "work",
        "different",
        "axiom",
        "system",
        "category",
        "theory",
        "explored",
        "compared",
        "solid",
        "overview",
        "past",
        "ongoing",
        "formalization",
        "project",
        "obtained",
        "consulting",
        "respective",
        "source",
        "isabelle",
        "archive",
        "formal",
        "proof",
        "journal",
        "formalized",
        "reasoning",
        "thf",
        "entry",
        "sutcliffe",
        "tptp",
        "problem",
        "library",
        "improving",
        "proof",
        "automation",
        "within",
        "proof",
        "assistantsbased",
        "proof",
        "hammering",
        "tool",
        "form",
        "prover",
        "integrationis",
        "relevant",
        "minimizing",
        "interaction",
        "effort",
        "future",
        "application",
        "computational",
        "metaphysics",
        "artificial",
        "intelligence",
        "church",
        "type",
        "theory",
        "classical",
        "logic",
        "topical",
        "application",
        "philosophy",
        "artificial",
        "intelligence",
        "often",
        "require",
        "expressive",
        "nonclassical",
        "logic",
        "order",
        "support",
        "application",
        "reasoning",
        "tool",
        "church",
        "type",
        "theory",
        "shallow",
        "semantical",
        "embedding",
        "technique",
        "see",
        "also",
        "section",
        "developed",
        "generalizes",
        "extends",
        "idea",
        "underlying",
        "well",
        "known",
        "standard",
        "translation",
        "modal",
        "logic",
        "firstorder",
        "logic",
        "technique",
        "applied",
        "assessment",
        "modern",
        "variant",
        "ontological",
        "argument",
        "range",
        "higherorder",
        "theorem",
        "provers",
        "including",
        "leoii",
        "satallax",
        "nitpick",
        "isabellehol",
        "course",
        "experiment",
        "leoii",
        "detected",
        "inconsistency",
        "premise",
        "g\u00f6del",
        "argument",
        "provers",
        "succeeded",
        "automatically",
        "proving",
        "scott",
        "emendation",
        "confirm",
        "consistency",
        "emended",
        "premise",
        "detail",
        "work",
        "presented",
        "related",
        "sep",
        "entry",
        "automated",
        "reasoning",
        "see",
        "section",
        "logic",
        "philosophy",
        "semantical",
        "embedding",
        "approach",
        "adapted",
        "extended",
        "range",
        "nonclassical",
        "logic",
        "related",
        "application",
        "philosophy",
        "includes",
        "encoding",
        "formal",
        "assessment",
        "ambitious",
        "ethical",
        "metaphysical",
        "theory",
        "artificial",
        "intelligence",
        "includes",
        "mechanization",
        "deontic",
        "logic",
        "normative",
        "reasoning",
        "well",
        "automatic",
        "proof",
        "muddy",
        "child",
        "puzzle",
        "see",
        "appendix",
        "b",
        "dynamic",
        "epistemic",
        "logic",
        "famous",
        "puzzle",
        "epistemic",
        "reasoning",
        "respectively",
        "dynamic",
        "epistemic",
        "reasoning"
    ]
}