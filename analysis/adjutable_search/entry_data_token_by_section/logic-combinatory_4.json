{
    "main_text": "Nonclassical logics and typed CL || Simple types\n3.1 Simple types\n\nCombinatory terms are thought of as functions, and functions are thought to\nhave a domain (a set of possible inputs) and a codomain (a set\nof possible outputs). For example, if a unary function is considered as a set\nof ordered pairs, then the domain and codomain are given by the first and\nsecond projections, respectively. If partial and non-onto functions are\npermitted, then supersets of the sets resulting from the first and\nsecond projections can also be domains and codomains. \n Category theory,\nwhere functions are components of categories (without a set theoretic\nreduction assumed), retains the notions of a domain and a codomain; moreover,\nevery function has a unique domain and codomain.\n\nFunctions that have the same domain and codomain may be quite different,\nhowever, by abstraction, they are of the same sort or type. As a simple\nillustration, let \\(f_1\\) and \\(f_2\\) be two functions defined as \\(f_1=\n\\lambda x.\\,8\\cdot x\\) and \\(f_2=\\lambda x.\\,x/3\\). If \\(x\\) is a variable \nranging over reals, then \\(f_1\\) and \\(f_2\\) have the same domain and codomain\n(i.e., they have the same type \\(\\mathbb{R}\\rightarrow\\mathbb{R}\\)), although\n\\(f_1\\ne f_2\\), because \\(f_1(x)\\ne f_2(x)\\) whenever \\(x\\ne0\\). The usual\nnotation to indicate that a function \\(f\\) has \\(A\\) as its domain and \\(B\\)\nas its codomain is \\(f\\colon A\\rightarrow B\\). It is a happy coincidence that\nnowadays \u2018\\(\\rightarrow\\)\u2019 is often used in logics as a symbol for\nentailment or (nonclassical) implication.\n\nGiven a set of basic types (that we denote by \\(P\\)), types are defined\nas follows.\n\nIf \\(p\\in P\\) then \\(p\\) is a type;\nif \\(A,B\\) are types then \\((A\\rightarrow B)\\) is a type.\n\n\nTo distinguish these types from other types\u2014some of which are introduced\nin the next section\u2014they are called simple types.\n\nThe connection between combinators and types may be explained on the example\nof the identity combinator. Compound combinatory terms are formed by the\napplication operation. Premises of modus ponens can be joined by fusion\n(denoted by \\(\\circ\\)), which is like the application operation in the\nstrongest relevance logic \\(B\\). \\(\\textsf{I}x \\triangleright x\\) and so if\n\\(x\\)'s type is \\(A\\), then \\(\\textsf{I}x\\)'s type should imply \\(A\\). \nFurthermore, \\(\\textsf{I}x\\)'s type should be of the form \\(X\\circ A\\), for\nsome type \\(X\\); then \\(\\textsf{I}\\) can be of type \\(A\\rightarrow A\\). In\nthe example, we fixed \\(x\\)'s type, however, \\(\\textsf{I}\\) can be applied to\nany term, hence, it is more accurate to say that \\(A\\rightarrow A\\) is the\ntype schema of \\(\\textsf{I}\\), or that \\(\\textsf{I}\\)'s type can be any\nformula of the form of self-implication.\n\nThe type-assignment system TA\\(_\\textrm{CL}\\) is formally defined as the\nfollowing deduction system. (When implicational formulas are considered as\ntypes, the usual convention is to omit parentheses by association to the\nright.) \n\n\\[\n\\Delta\\vdash\\textsf{S}\\colon(A\\rightarrow B\\rightarrow C)\\rightarrow (A\\rightarrow B)\\rightarrow A\\rightarrow C\n\\]\n\n\\[\n\\Delta\\vdash\\textsf{K}\\colon A \\rightarrow B\\rightarrow A\n\\]\n\n\\[\n\\frac{\\Delta\\vdash M\\colon A\\rightarrow B \\quad\\Theta\\vdash N\\colon A}\n     {\\Delta,\\Theta\\vdash MN\\colon B}\n\\]\n\n\nExpressions of the form \\(M\\colon A\\) above are called type\nassignments. A characteristic feature of type-assignment systems is that\nif \\(M\\colon A\\) is provable then \\(A\\) is considered to be one of the types\nthat can be assigned to \\(M\\). However, a provable assignment does not\npreclude other types from becoming associated to the same term \\(M\\), that is\na type assignment does not fix the type of a term rigidly. \\(\\Delta\\) and\n\\(\\Theta\\) on the left-hand side of \\(\\vdash\\)  are sets of type assignments\nto variables, and they are assumed to be consistent\u2014meaning that no\nvariable may be assigned two or more types.\n\nType assignment systems are often called Curry-style typing systems. \nAnother way to type terms is by fixing a type for each term, in which case\neach term has exactly one type. Such calculi are called Church-style typing\nsystems. Then, for example, the identity combinator \\(\\textsf{I}\\) of type\n\n\\[\n(A\\rightarrow A\\rightarrow A)\\rightarrow A\\rightarrow A\\rightarrow A\n\\]\n\n is not the same as the identity combinator \\(\\textsf{I}\\) of type\n\n\\[\n((B \\rightarrow B)\\rightarrow B)\\rightarrow(B\\rightarrow B)\\rightarrow B.\n\\]\n\n The two styles of typing have quite a lot in\ncommon, but there are certain differences between them. In particular,\nno self-application is typable in a Church-style typing system,\nwhereas some of those terms can be assigned a type in a Curry-style\ntyping system. Curry-style typing systems proved very useful in\nestablishing various properties of CL and \\(\\lambda\\)-calculi. The\nChurch-style typing, on the other hand, emulates more closely the\ntyping in certain functional programming languages (without\nobjects).\n\nThere is no one-one correspondence between types and combinators in either\nstyle of typing: not all combinators can be assigned a type, and some\nimplicational formulas cannot be assigned to any combinatory term. A\ncombinator that can be assigned a type is said to be typable, and a\ntype that can be assigned to a combinator is said to be inhabited. For\ninstance, \\(\\textsf{M}\\) has no (simple) type, because an implicational\nformula is never identical to its own antecedent. On the other hand, Peirce\u2019s\nlaw, \\(((A\\rightarrow B)\\rightarrow A) \\rightarrow A\\) is not the type of any\ncombinator in the type assignment system TA\\(_\\textrm{CL}\\).  Despite (or,\nindeed, due to) the discrepancy between implicational formulas and combinatory\nterms, classes of implicational formulas that can be assigned to certain sets\nof combinatory terms coincide with sets of theorems of some important\nlogics.\n\nTheorem. \\(A\\rightarrow B\\) is a theorem of the intuitionistic\nimplicational logic, denoted by \\(IPC_\\rightarrow\\) or\n\\(J_\\rightarrow\\), iff for some \\(M\\), \\(M\\colon A\\rightarrow B\\) is a\nprovable type assignment in TA\\(_\\textrm{CL}\\), where the term \\(M\\)\nis built from \\(\\textsf{S}\\) and \\(\\textsf{K}\\), that is, \\(M\\) is a\ncombinator over the base \\(\\{\\textsf{S},\\textsf{K}\\}\\).\n\n\nA combinator that inhabits an implicational theorem encodes a proof of\nthat theorem in the deduction system TA\\(_\\textrm{CL}\\). There is an algorithm\nto recover the formulas that constitute a proof of the type of the combinator,\nmoreover, the algorithm produces a proof that is minimal and well-structured. \nThe correspondence between implicational theorems of intuitionistic logic (and\ntheir proofs) and typable closed \\(\\lambda\\)-terms (or combinators) is called\nthe Curry\u2013Howard isomorphism. The usual notion of a proof in a\nHilbert-style axiomatic system is quite lax, but it can be tidied up to obtain\nthe notion of traversing proofs. In a traversing proof there is a\none-one correspondence between subterms of a combinator and the formulas in\nthe traversing proof as well as between applications and detachments therein\n(cf. Bimb\u00f3 2007).\n\nThe above correspondence can be modified for other implicational logics and\ncombinatory bases. The next theorem lists correspondences that obtain between\nthe implicational fragments of the relevance logics \\(R\\) and \\(T\\) and\nsome combinatory bases that are of interest in themselves.\n\nTheorem. \\(A\\rightarrow B\\) is a theorem of \\(R_{\\rightarrow}\\)\n(or \\(T_{\\rightarrow}\\)) iff for some \\(M\\), \\(M\\colon A\\rightarrow B\\)\nis a provable type assignment where \\(M\\) is a combinator over \\(\\{\\textsf{B},\n\\textsf{I},\\textsf{W},\\textsf{C}\\}\\) (or over \\(\\{\\textsf{B},\\textsf{B}^\\prime,\n\\textsf{I},\\textsf{S},\\textsf{S}^\\prime\\}\\)).\n\n\nThe calculus \\(\\textrm{TA}_\\textrm{CL}\\) may be amended by adding\naxiom schemas for the combinators in the two bases. (The axiom schemas\nof the combinators that are not in these bases may be omitted from the\ncalculus or simply may be neglected in proofs.) The new axioms\nare as follows.\n\n\\[\\begin{align*}\n\\textsf{B} &\\colon\n  (A\\rightarrow B)\\rightarrow(C\\rightarrow A)\\rightarrow C\\rightarrow B \\\\\n\\textsf{B}^\\prime &\\colon\n  (A\\rightarrow B)\\rightarrow(B\\rightarrow C)\\rightarrow A\\rightarrow C \\\\\n\\textsf{C} &\\colon \n  (A\\rightarrow B\\rightarrow C)\\rightarrow B\\rightarrow A\\rightarrow C \\\\\n\\textsf{W} &\\colon\n  (A\\rightarrow A\\rightarrow B)\\rightarrow A\\rightarrow B \\\\\n\\textsf{S}^\\prime &\\colon \n  (A\\rightarrow B)\\rightarrow(A\\rightarrow B\\rightarrow C)\\rightarrow A\\rightarrow C \\\\\n\\textsf{I} &\\colon \n  A\\rightarrow A\n\\end{align*}\\]\n\n\nThe combinatory base \\(\\{\\textsf{B},\\textsf{C},\\textsf{W},\\textsf{I}\\}\\) is\nespecially interesting, because these combinators suffice for a definition of\na bracket abstraction that is equivalent to the \\(\\lambda\\)-abstraction of the\n\\(\\lambda\\textsf{I}\\)-calculus.  To put it differently, all functions that\ndepend on all of their arguments can be defined by this base. The other base\nallows the definition of functions that can be described by terms in the class\nof the so-called hereditary right maximal terms (cf. Bimb\u00f3\n2005). Informally, the idea behind these terms is that functions can be\nenumerated, and then their successive applications should form a sequence in\nwhich the indexes are \u201cglobally increasing.\u201d\n\nA type assignment has two parts: a term and a formula. The\nquestions whether some term can be assigned a type and whether some type can\nbe assigned to a term are the problems of typability and\nof inhabitation, respectively. Although these questions may be posed\nabout one and the same set of type assignments, the computational properties\nof these problems may differ widely.\n\nTheorem. It is decidable if a term \\(M\\) can be assigned a type, that\nis, if \\(M\\) is typable. \n\n\nThe theorem is stated in a rather general way without specifying exactly which\ncombinatory base or which modification of TA\\(_\\textrm{CL}\\) is assumed,\nbecause the theorem holds for any combinatory base. Indeed, there is an\nalgorithm that given a combinator decides if the combinator is typable, and\nfor a typable combinator produces a type too. Of course, in the\ncombinatorially complete base \\(\\{\\textsf{S},\\textsf{K}\\}\\) all the\ncombinators are expressible as terms consisting of these two combinators\nonly. However, this assumption is not needed for a solution of typability,\nthough it might provide an explanation for the existence of a general\nalgorithm.\n\nThe problem of inhabitation does not have a similar general solution,\nbecause the problem of the equality of combinatory terms is undecidable. Given\na set of axiom schemas that are types of combinators with detachment as the\nrule of inference, the problem of the decidability of a logic can be\nviewed as the problem of inhabitation. Indeed, if \\(A\\) is an implicational\nformula, then to decide whether \\(A\\) is a theorem amounts to determining if\nthere is a term (over the base that corresponds to the axiom schemas) that\ncan be assigned \\(A\\) as its type. (Of course, a more sophisticated algorithm\nmay actually produce such a term, in which case it is easy to verify the\ncorrectness of the claim by reconstructing the proof of the theorem.)\n\nTo see from where complications can emerge in the case of decidability, we\ncompare the rule of the formation of terms and the rule\nof detachment. Given a combinatory base and a denumerable set of\nvariables, it is decidable by inspection whether a term is or is\nnot in the set of the generated terms. That is, all the inputs of the rule\nare retained in the output as subterms of the resulting term. In contrast, an\napplication of detachment results in a formula that is a proper subformula of\nthe major premise (and in the exceptional case when the major premise is an\ninstance of self-identity it is identical to the minor premise). The lack of\nthe retention of all subformulas of premises through applications of modus\nponens is the culprit behind the difficulty of some of the decision problems\nof implicational logics. It is then somewhat unsurprising that for many\ndecidable logics there is a decision procedure utilizing sequent calculi in\nwhich the cut theorem and the subformula property hold. A solution to the\nproblem of inhabitation may run into difficulties similar to those that arise\nin decidability problems in general.\n\nFor example, the combinator \\(\\textsf{K}\\) can be assigned the following\ntype. \n\n\n\\[\np\\rightarrow(q\\rightarrow(q\\rightarrow q\\rightarrow q)\\rightarrow(q\n\\rightarrow q)\\rightarrow q\\rightarrow q)\\rightarrow p\n\\]\n\n\n\\(\\textsf{SKK}\\) can be assigned the type \\(p\\rightarrow p\\). There is a\nproof in TA\\(_\\textrm{CL}\\) ending in \\(\\textsf{SKK}\\colon p\\rightarrow p\\) \nthat does not contain the long formula above. However, there is a proof of\n\\(\\textsf{SKK}\\colon p\\rightarrow p\\) that contains the above formula the\nsecond antecedent of which is not a subformula of \\(p\\rightarrow p\\), indeed,\nthe sets of the subformulas of the two formulas are disjoint. (We picked two\ndifferent propositional variables, \\(p\\) and \\(q\\) to emphasize this point.)\nSome important cases of the problem of inhabitation, however, are\ndecidable.\n\nTheorem. It is decidable if a type has an inhabitant over the base\n\\(\\{\\textsf{S},\\textsf{K}\\}\\). \n\n\nThis theorem amounts to the typed version of the decidability of the\nimplicational fragment of \n intuitionistic logic\nthat is part of\n Gentzen\u2019s decidability result\n(dating from 1935).\n\nTheorem. It is decidable if a type has an inhabitant over the base \n\\(\\{\\textsf{I},\\textsf{C},\\textsf{B}^\\prime,\\textsf{W}\\}\\).\n\n\nThe theorem is the typed equivalent of the decidability of the implicational\nfragment of the logic of relevant implication. The decidability\nof \\(R_{\\rightarrow}\\) was proved by Saul A. Kripke in 1959 together\nwith the decidability of the closely related \\(E_{\\rightarrow}\\) (the\nimplicational fragment of the logic of entailment).\n\nTheorem. It is decidable if a type has an inhabitant over the base \n\\(\\{\\textsf{B},\\textsf{B}^\\prime,\\textsf{I},\\textsf{W}\\}\\).\n\n\nthe theorem is the typed version of the decidability of the\nimplicational fragment of the logic of ticket entailment\n\\(T_\\rightarrow\\), that was proved\u2014together with the\ndecidability of \\(R_\\rightarrow\\) (\\(R_\\rightarrow\\) with the truth\nconstant \\(t\\)) and \\(T_\\rightarrow^\\textbf{t}\\) (\\(T_\\rightarrow\\)\nwith the truth constant \\(t\\))\u2014in Bimb\u00f3 and Dunn\n(2012) and Bimb\u00f3 and Dunn (2013). An independent result\n(for \\(T_\\rightarrow\\) only) is in Padovani (2013), which\nextends Broda et al. (2004).\n\nThe decision procedures for \\(T_\\rightarrow^\\textbf{t}\\) and\n\\(R_\\rightarrow^\\textbf{t}\\) do not use \\(\\textrm{TA}_\\textrm{CL}\\) or\naxiomatic calculi, instead, they build upon consecution calculi\n(i.e., sequent calculi in which the structural connective is not\nassumed to be associative). The idea that there is an affinity between\nstructural rules and combinators goes back at least to Curry\n(1963). To tighten the connection, Dunn and Meyer (1997)\nintroduced structurally free logics in which introduction rules\nfor combinators replace structural rules\u2014hence the label for\nthese logics. Bimb\u00f3 and Dunn (2014) introduced a technique to\ngenerate a combinatory inhabitant for theorems of \\(T_\\rightarrow\\)\nfrom their standard proofs in the sequent calculus, which is used in\nthe decision procedure for \\(T_\\rightarrow^\\textbf{t}\\).  Sequent\ncalculi provide better control over proofs than natural deduction or\naxiomatic systems do. The combinatory extraction procedure of\nBimb\u00f3 and Dunn (2014) yields an effective link between\ncombinators and types grounded in sequent calculus proofs, which\nobviates the apparent advantage of \\(\\textrm{TA}_\\textrm{CL}\\) and\naxiomatic systems.\n\nThe rule of substitution is built-in into the formulation of\n\\(\\textrm{TA}_\\textrm{CL}\\) via the rule schema called detachment and the\naxiom schemas for the basic combinators. It is obvious that there are\nformulas of least complexity that are types of \\(\\textsf{S}\\) and\n\\(\\textsf{K}\\), such that all the other types of \\(\\textsf{S}\\) and\n\\(\\textsf{K}\\) are their substitution instances. A formula that has this\nproperty is called a principal type of a combinator. Obviously, a\ncombinator that has a principal type, has denumerably many principal types,\nwhich are all substitution instances of each other; hence, it is justified to\ntalk about the principal type schema of a combinator. The existence of\nprincipal types for complex combinators is not obvious, nevertheless,\nobtains.\n\nTheorem. If the term \\(M\\) is typable, then \\(M\\) has a principal type\nand a principal type schema. \n\n\nPrincipal types and principal type schemas may seem now to be\ninterchangeable everywhere. Thus we could take a slightly different\napproach and define \\(\\textrm{TA}_\\textrm{CL}\\) to include axioms and\nthe rule schema of detachment together with the rule of\nsubstitution. This version of \\(\\textrm{TA}_\\textrm{CL}\\) would\nassume the following form.\n\n\\[\n\\Delta\\vdash\\textsf{S}\\colon(p \\rightarrow q\\rightarrow s)\\rightarrow(p\\rightarrow q)\\rightarrow p\\rightarrow s\n\\]\n\n\\[\n\\Delta\\vdash\\textsf{K}\\colon q\\rightarrow s\\rightarrow q\n\\]\n\n\\[\n\\frac{\\Delta\\vdash M\\colon A\\rightarrow B\\qquad \\Theta\\vdash N\\colon A}\n     {\\Delta,\\Theta\\vdash MN\\colon B}\n\\]\n\n\\[\n\\frac{\\Delta\\vdash M\\colon A}\n     {\\Delta[P/B]\\vdash M\\colon A[P/B]}\n\\]\n\n\nwhere \\(P\\) ranges over propositional variables. (The substitution notation is\nextended\u2014in the obvious way\u2014to sets of type assignments.) Clearly,\nthe two deduction systems are equivalent.\n\nIf substitution were dropped altogether, then the applicability of detachment\nwould become extremely limited, for instance, \\(\\textsf{SK}\\) no longer would\nbe typable. A compromise between having substitution everywhere and having no\nsubstitution at all is to modify the detachment rule so that that includes as\nmuch substitution as necessary to ensure the applicability of the detachment\nrule. Such a rule (without combinatory terms or type assignments) was invented\nin the 1950s by Carew\u00a0A.\u00a0Meredith, and it is usually\ncalled condensed detachment. The key to the applicability of detachment\nis to find a common substitution instance of the minor premise and of the\nantecedent of the major premise. This step is called unification.  (A\nbit more formally, let \\(s(A)\\) denote the application of the substitution\n\\(s\\) to \\(A\\).  Then, the result of the condensed detachment of \\(A\\) from\n\\(B\\rightarrow C\\) is \\(s(C)\\), when there is an \\(s\\) such that \\(s(A)=\ns(B)\\), and for any \\(s_1\\) with this property, there is an \\(s_2\\) such that\n\\(s_1\\) is the composition of \\(s\\) and \\(s_2\\).)\n\nNotice that it is always possible to choose substitution instances of a pair\nof formulas so that the sets of their propositional variables are disjoint,\nbecause formulas are finite objects. The most general common instance\nof two formulas \\(A\\) and \\(B\\) (that do not share a propositional variable)\nis \\(C\\), where \\(C\\) is a substitution instance of both \\(A\\) and \\(B\\), and \npropositional variables are identified by the substitutions only if the\nidentification is necessary to obtain a formula that is a substitution\ninstance of both \\(A\\) and \\(B\\). The unification theorem (specialized\nto simple types) implies that if two formulas \\(A\\) and \\(B\\) have a common\ninstance then there is a formula \\(C\\) such that all the common instances of\n\\(A\\) and \\(B\\) are substitution instances of \\(C\\). Obviously, a pair of\nformulas either has no common instance at all, or it has \\(\\aleph_0\\) many\nmost general common instances.\n\nA famous example of a pair of formulas that have no common instance is\n\\(A\\rightarrow A\\) and \\(A\\rightarrow A\\rightarrow B\\). The instances \\(p\n\\rightarrow p\\) and \\(q\\rightarrow q\\rightarrow r\\) share no propositional\nvariables, however, neither \\(q\\rightarrow q\\) nor \\((q\\rightarrow r)\\rightarrow\nq\\rightarrow r\\) matches the shape of the second formula. To put the problem\ndifferently, \\(q\\) and \\(q\\rightarrow r\\) would have to be unified, but they\ncannot be unified no matter what formula is substituted for \\(q\\). An\nimmediate consequence of this is that \\(\\textsf{WI}\\) is not typable.\n\nOn the other hand,\n\n\\[\n(r\\rightarrow r)\\rightarrow r\\rightarrow r\n\\]\n\n and \n\\[\n((s\\rightarrow s)\\rightarrow s\\rightarrow s)\\rightarrow (s \\rightarrow\ns)\\rightarrow s\\rightarrow s\n\\]\n\n are substitution instances of \\(p\\rightarrow\np\\) and of \\(q\\rightarrow q\\). Furthermore, all simple types are substitution\ninstances of a propositional variable, hence \\(\\textsf{II}\\) can be assigned\nboth the type \\(r\\rightarrow r\\) and the type (\\(s\\rightarrow s)\\rightarrow\ns\\rightarrow s\\)\u2014and, of course, the latter happens to be an instance of \nthe former because \\(A\\rightarrow A\\) is the principal type schema of\n\\(\\textsf{II}\\). If we apply condensed detachment to \\(p\\rightarrow p\\) and\n\\(q\\rightarrow q\\), then we get \\(q\\rightarrow q\\) (via the substitutions\n\\([p/q\\rightarrow q]\\) and \\([q/q])\\), and so condensed detachment yields the\nprincipal type of \\(\\textsf{II}\\). Incidentally, \\(\\textsf{II}\\) and \n\\(\\textsf{I}\\) provide an excellent example to illustrate that distinct\nterms may have the same principal type schema.\n\nCondensed detachment has been used extensively to refine\naxiomatizations of various implicational logics, especially, in search\nfor shorter and fewer axioms. Some logics may be formulated using\naxioms (rather than axiom schemas) together with the rule of condensed\ndetachment\u2014without loss of theorems. All the logics that we\nmentioned so far (\\(J_{\\rightarrow}\\), \\(R_{\\rightarrow}\\),\n\\(T_{\\rightarrow}\\) and \\(E_{\\rightarrow}\\)) are\n\\(\\mathbf{D}\\)-complete, that is, they all may be axiomatized\nby axioms and the rule of condensed detachment. That is, the\nimplicational fragments of classical and intuitionistic logics, and\nthe implicational fragments of the relevance logics \\(R\\), \\(E\\)\nand \\(T\\) are all \\(\\mathbf{D}\\)-complete.  (See Bimb\u00f3 (2007) for\nsome further technical details.)\n\nSimply typed systems have been extended in various directions. Logics often\ncontain connectives beyond implication. It is a natural modification of a type\nassignment system to expand the set of types via including further type\nconstructors. Conjunction and fusion are the easiest to explain or\nmotivate as type constructors, however, disjunction and backward implication\nhave been introduced into types too. Types are useful, because they allow us\nto get a grip on classes of terms from the point of view of their behavior\nwith respect to reduction.\n\nTait\u2019s theorem. If a combinatory term \\(M\\) is typable (with simple\ntypes) then \\(M\\) strongly normalizes, that is, all reduction sequences of\n\\(M\\) are finite (i.e., terminate). \n\n\nThe converse of this claim is, obviously, not true. For example,\n\\(\\textsf{WI}\\) strongly normalizes but untypable, because the antecedent of\ncontraction cannot be unified with any instance of self-implication. The aim\nto extend the set of typable terms led to the introduction of \\(\\land\\) into\ntypes.\n",
    "section_title": "3.1 Simple types",
    "entry_title": "Combinatory Logic",
    "hierarchy_title": "Combinatory Logic || Nonclassical logics and typed CL || Simple types",
    "tokenized_text": [
        "nonclassical",
        "logic",
        "typed",
        "cl",
        "simple",
        "type",
        "simple",
        "type",
        "combinatory",
        "term",
        "thought",
        "function",
        "function",
        "thought",
        "domain",
        "set",
        "possible",
        "input",
        "codomain",
        "set",
        "possible",
        "output",
        "example",
        "unary",
        "function",
        "considered",
        "set",
        "ordered",
        "pair",
        "domain",
        "codomain",
        "given",
        "first",
        "second",
        "projection",
        "respectively",
        "partial",
        "nononto",
        "function",
        "permitted",
        "supersets",
        "set",
        "resulting",
        "first",
        "second",
        "projection",
        "also",
        "domain",
        "codomains",
        "category",
        "theory",
        "function",
        "component",
        "category",
        "without",
        "set",
        "theoretic",
        "reduction",
        "assumed",
        "retains",
        "notion",
        "domain",
        "codomain",
        "moreover",
        "every",
        "function",
        "unique",
        "domain",
        "codomain",
        "function",
        "domain",
        "codomain",
        "may",
        "quite",
        "different",
        "however",
        "abstraction",
        "sort",
        "type",
        "simple",
        "illustration",
        "let",
        "f_",
        "f_",
        "two",
        "function",
        "defined",
        "f_",
        "lambda",
        "xcdot",
        "x",
        "f_lambda",
        "x",
        "x",
        "x",
        "variable",
        "ranging",
        "real",
        "f_",
        "f_",
        "domain",
        "codomain",
        "ie",
        "type",
        "mathbb",
        "r",
        "rightarrowmathbb",
        "r",
        "although",
        "f_ne",
        "f_",
        "f_",
        "x",
        "ne",
        "f_",
        "x",
        "whenever",
        "xne",
        "usual",
        "notation",
        "indicate",
        "function",
        "f",
        "a",
        "domain",
        "b",
        "codomain",
        "fcolon",
        "arightarrow",
        "b",
        "happy",
        "coincidence",
        "nowadays",
        "rightarrow",
        "often",
        "used",
        "logic",
        "symbol",
        "entailment",
        "nonclassical",
        "implication",
        "given",
        "set",
        "basic",
        "type",
        "denote",
        "p",
        "type",
        "defined",
        "follows",
        "pin",
        "p",
        "p",
        "type",
        "b",
        "type",
        "arightarrow",
        "b",
        "type",
        "distinguish",
        "type",
        "typessome",
        "introduced",
        "next",
        "sectionthey",
        "called",
        "simple",
        "type",
        "connection",
        "combinators",
        "type",
        "may",
        "explained",
        "example",
        "identity",
        "combinator",
        "compound",
        "combinatory",
        "term",
        "formed",
        "application",
        "operation",
        "premise",
        "modus",
        "ponens",
        "joined",
        "fusion",
        "denoted",
        "circ",
        "like",
        "application",
        "operation",
        "strongest",
        "relevance",
        "logic",
        "b",
        "textsf",
        "x",
        "triangleright",
        "x",
        "x",
        "s",
        "type",
        "a",
        "textsf",
        "x",
        "s",
        "type",
        "imply",
        "a",
        "furthermore",
        "textsf",
        "x",
        "s",
        "type",
        "form",
        "xcirc",
        "a",
        "type",
        "x",
        "textsf",
        "type",
        "arightarrow",
        "a",
        "example",
        "fixed",
        "x",
        "s",
        "type",
        "however",
        "textsf",
        "applied",
        "term",
        "hence",
        "accurate",
        "say",
        "arightarrow",
        "a",
        "type",
        "schema",
        "textsf",
        "textsf",
        "s",
        "type",
        "formula",
        "form",
        "selfimplication",
        "typeassignment",
        "system",
        "ta",
        "_textrm",
        "cl",
        "formally",
        "defined",
        "following",
        "deduction",
        "system",
        "implicational",
        "formula",
        "considered",
        "type",
        "usual",
        "convention",
        "omit",
        "parenthesis",
        "association",
        "right",
        "deltavdashtextsf",
        "colon",
        "arightarrow",
        "brightarrow",
        "c",
        "rightarrow",
        "arightarrow",
        "b",
        "rightarrow",
        "arightarrow",
        "c",
        "deltavdashtextsf",
        "k",
        "colon",
        "rightarrow",
        "brightarrow",
        "frac",
        "deltavdash",
        "mcolon",
        "arightarrow",
        "b",
        "quadthetavdash",
        "ncolon",
        "delta",
        "thetavdash",
        "mncolon",
        "b",
        "expression",
        "form",
        "mcolon",
        "a",
        "called",
        "type",
        "assignment",
        "characteristic",
        "feature",
        "typeassignment",
        "system",
        "mcolon",
        "a",
        "provable",
        "a",
        "considered",
        "one",
        "type",
        "assigned",
        "m",
        "however",
        "provable",
        "assignment",
        "preclude",
        "type",
        "becoming",
        "associated",
        "term",
        "m",
        "type",
        "assignment",
        "fix",
        "type",
        "term",
        "rigidly",
        "delta",
        "theta",
        "lefthand",
        "side",
        "vdash",
        "set",
        "type",
        "assignment",
        "variable",
        "assumed",
        "consistentmeaning",
        "variable",
        "may",
        "assigned",
        "two",
        "type",
        "type",
        "assignment",
        "system",
        "often",
        "called",
        "currystyle",
        "typing",
        "system",
        "another",
        "way",
        "type",
        "term",
        "fixing",
        "type",
        "term",
        "case",
        "term",
        "exactly",
        "one",
        "type",
        "calculus",
        "called",
        "churchstyle",
        "typing",
        "system",
        "example",
        "identity",
        "combinator",
        "textsf",
        "type",
        "arightarrow",
        "arightarrow",
        "rightarrow",
        "arightarrow",
        "arightarrow",
        "identity",
        "combinator",
        "textsf",
        "type",
        "b",
        "rightarrow",
        "b",
        "rightarrow",
        "b",
        "rightarrow",
        "brightarrow",
        "b",
        "rightarrow",
        "b",
        "two",
        "style",
        "typing",
        "quite",
        "lot",
        "common",
        "certain",
        "difference",
        "particular",
        "selfapplication",
        "typable",
        "churchstyle",
        "typing",
        "system",
        "whereas",
        "term",
        "assigned",
        "type",
        "currystyle",
        "typing",
        "system",
        "currystyle",
        "typing",
        "system",
        "proved",
        "useful",
        "establishing",
        "various",
        "property",
        "cl",
        "lambda",
        "calculi",
        "churchstyle",
        "typing",
        "hand",
        "emulates",
        "closely",
        "typing",
        "certain",
        "functional",
        "programming",
        "language",
        "without",
        "object",
        "oneone",
        "correspondence",
        "type",
        "combinators",
        "either",
        "style",
        "typing",
        "combinators",
        "assigned",
        "type",
        "implicational",
        "formula",
        "assigned",
        "combinatory",
        "term",
        "combinator",
        "assigned",
        "type",
        "said",
        "typable",
        "type",
        "assigned",
        "combinator",
        "said",
        "inhabited",
        "instance",
        "textsf",
        "simple",
        "type",
        "implicational",
        "formula",
        "never",
        "identical",
        "antecedent",
        "hand",
        "peirce",
        "law",
        "arightarrow",
        "b",
        "rightarrow",
        "rightarrow",
        "a",
        "type",
        "combinator",
        "type",
        "assignment",
        "system",
        "ta",
        "_textrm",
        "cl",
        "despite",
        "indeed",
        "due",
        "discrepancy",
        "implicational",
        "formula",
        "combinatory",
        "term",
        "class",
        "implicational",
        "formula",
        "assigned",
        "certain",
        "set",
        "combinatory",
        "term",
        "coincide",
        "set",
        "theorem",
        "important",
        "logic",
        "theorem",
        "arightarrow",
        "b",
        "theorem",
        "intuitionistic",
        "implicational",
        "logic",
        "denoted",
        "ipc_rightarrow",
        "j_rightarrow",
        "iff",
        "m",
        "mcolon",
        "arightarrow",
        "b",
        "provable",
        "type",
        "assignment",
        "ta",
        "_textrm",
        "cl",
        "term",
        "m",
        "built",
        "textsf",
        "textsf",
        "k",
        "m",
        "combinator",
        "base",
        "textsf",
        "textsf",
        "k",
        "combinator",
        "inhabits",
        "implicational",
        "theorem",
        "encodes",
        "proof",
        "theorem",
        "deduction",
        "system",
        "ta",
        "_textrm",
        "cl",
        "algorithm",
        "recover",
        "formula",
        "constitute",
        "proof",
        "type",
        "combinator",
        "moreover",
        "algorithm",
        "produce",
        "proof",
        "minimal",
        "wellstructured",
        "correspondence",
        "implicational",
        "theorem",
        "intuitionistic",
        "logic",
        "proof",
        "typable",
        "closed",
        "lambda",
        "terms",
        "combinators",
        "called",
        "curryhoward",
        "isomorphism",
        "usual",
        "notion",
        "proof",
        "hilbertstyle",
        "axiomatic",
        "system",
        "quite",
        "lax",
        "tidied",
        "obtain",
        "notion",
        "traversing",
        "proof",
        "traversing",
        "proof",
        "oneone",
        "correspondence",
        "subterms",
        "combinator",
        "formula",
        "traversing",
        "proof",
        "well",
        "application",
        "detachment",
        "therein",
        "cf",
        "bimb\u00f3",
        "correspondence",
        "modified",
        "implicational",
        "logic",
        "combinatory",
        "base",
        "next",
        "theorem",
        "list",
        "correspondence",
        "obtain",
        "implicational",
        "fragment",
        "relevance",
        "logic",
        "r",
        "t",
        "combinatory",
        "base",
        "interest",
        "theorem",
        "arightarrow",
        "b",
        "theorem",
        "r_",
        "rightarrow",
        "t_",
        "rightarrow",
        "iff",
        "m",
        "mcolon",
        "arightarrow",
        "b",
        "provable",
        "type",
        "assignment",
        "m",
        "combinator",
        "textsf",
        "b",
        "textsf",
        "textsf",
        "w",
        "textsf",
        "c",
        "textsf",
        "b",
        "textsf",
        "b",
        "prime",
        "textsf",
        "textsf",
        "textsf",
        "prime",
        "calculus",
        "textrm",
        "ta",
        "_textrm",
        "cl",
        "may",
        "amended",
        "adding",
        "axiom",
        "schema",
        "combinators",
        "two",
        "base",
        "axiom",
        "schema",
        "combinators",
        "base",
        "may",
        "omitted",
        "calculus",
        "simply",
        "may",
        "neglected",
        "proof",
        "new",
        "axiom",
        "follows",
        "begin",
        "align",
        "textsf",
        "b",
        "colon",
        "arightarrow",
        "b",
        "rightarrow",
        "crightarrow",
        "rightarrow",
        "crightarrow",
        "b",
        "textsf",
        "b",
        "prime",
        "colon",
        "arightarrow",
        "b",
        "rightarrow",
        "brightarrow",
        "c",
        "rightarrow",
        "arightarrow",
        "c",
        "textsf",
        "c",
        "colon",
        "arightarrow",
        "brightarrow",
        "c",
        "rightarrow",
        "brightarrow",
        "arightarrow",
        "c",
        "textsf",
        "w",
        "colon",
        "arightarrow",
        "arightarrow",
        "b",
        "rightarrow",
        "arightarrow",
        "b",
        "textsf",
        "prime",
        "colon",
        "arightarrow",
        "b",
        "rightarrow",
        "arightarrow",
        "brightarrow",
        "c",
        "rightarrow",
        "arightarrow",
        "c",
        "textsf",
        "colon",
        "arightarrow",
        "end",
        "align",
        "combinatory",
        "base",
        "textsf",
        "b",
        "textsf",
        "c",
        "textsf",
        "w",
        "textsf",
        "especially",
        "interesting",
        "combinators",
        "suffice",
        "definition",
        "bracket",
        "abstraction",
        "equivalent",
        "lambda",
        "abstraction",
        "lambdatextsf",
        "calculus",
        "put",
        "differently",
        "function",
        "depend",
        "argument",
        "defined",
        "base",
        "base",
        "allows",
        "definition",
        "function",
        "described",
        "term",
        "class",
        "socalled",
        "hereditary",
        "right",
        "maximal",
        "term",
        "cf",
        "bimb\u00f3",
        "informally",
        "idea",
        "behind",
        "term",
        "function",
        "enumerated",
        "successive",
        "application",
        "form",
        "sequence",
        "index",
        "globally",
        "increasing",
        "type",
        "assignment",
        "two",
        "part",
        "term",
        "formula",
        "question",
        "whether",
        "term",
        "assigned",
        "type",
        "whether",
        "type",
        "assigned",
        "term",
        "problem",
        "typability",
        "inhabitation",
        "respectively",
        "although",
        "question",
        "may",
        "posed",
        "one",
        "set",
        "type",
        "assignment",
        "computational",
        "property",
        "problem",
        "may",
        "differ",
        "widely",
        "theorem",
        "decidable",
        "term",
        "m",
        "assigned",
        "type",
        "m",
        "typable",
        "theorem",
        "stated",
        "rather",
        "general",
        "way",
        "without",
        "specifying",
        "exactly",
        "combinatory",
        "base",
        "modification",
        "ta",
        "_textrm",
        "cl",
        "assumed",
        "theorem",
        "hold",
        "combinatory",
        "base",
        "indeed",
        "algorithm",
        "given",
        "combinator",
        "decides",
        "combinator",
        "typable",
        "typable",
        "combinator",
        "produce",
        "type",
        "course",
        "combinatorially",
        "complete",
        "base",
        "textsf",
        "textsf",
        "k",
        "combinators",
        "expressible",
        "term",
        "consisting",
        "two",
        "combinators",
        "however",
        "assumption",
        "needed",
        "solution",
        "typability",
        "though",
        "might",
        "provide",
        "explanation",
        "existence",
        "general",
        "algorithm",
        "problem",
        "inhabitation",
        "similar",
        "general",
        "solution",
        "problem",
        "equality",
        "combinatory",
        "term",
        "undecidable",
        "given",
        "set",
        "axiom",
        "schema",
        "type",
        "combinators",
        "detachment",
        "rule",
        "inference",
        "problem",
        "decidability",
        "logic",
        "viewed",
        "problem",
        "inhabitation",
        "indeed",
        "a",
        "implicational",
        "formula",
        "decide",
        "whether",
        "a",
        "theorem",
        "amount",
        "determining",
        "term",
        "base",
        "corresponds",
        "axiom",
        "schema",
        "assigned",
        "a",
        "type",
        "course",
        "sophisticated",
        "algorithm",
        "may",
        "actually",
        "produce",
        "term",
        "case",
        "easy",
        "verify",
        "correctness",
        "claim",
        "reconstructing",
        "proof",
        "theorem",
        "see",
        "complication",
        "emerge",
        "case",
        "decidability",
        "compare",
        "rule",
        "formation",
        "term",
        "rule",
        "detachment",
        "given",
        "combinatory",
        "base",
        "denumerable",
        "set",
        "variable",
        "decidable",
        "inspection",
        "whether",
        "term",
        "set",
        "generated",
        "term",
        "input",
        "rule",
        "retained",
        "output",
        "subterms",
        "resulting",
        "term",
        "contrast",
        "application",
        "detachment",
        "result",
        "formula",
        "proper",
        "subformula",
        "major",
        "premise",
        "exceptional",
        "case",
        "major",
        "premise",
        "instance",
        "selfidentity",
        "identical",
        "minor",
        "premise",
        "lack",
        "retention",
        "subformulas",
        "premise",
        "application",
        "modus",
        "ponens",
        "culprit",
        "behind",
        "difficulty",
        "decision",
        "problem",
        "implicational",
        "logic",
        "somewhat",
        "unsurprising",
        "many",
        "decidable",
        "logic",
        "decision",
        "procedure",
        "utilizing",
        "sequent",
        "calculus",
        "cut",
        "theorem",
        "subformula",
        "property",
        "hold",
        "solution",
        "problem",
        "inhabitation",
        "may",
        "run",
        "difficulty",
        "similar",
        "arise",
        "decidability",
        "problem",
        "general",
        "example",
        "combinator",
        "textsf",
        "k",
        "assigned",
        "following",
        "type",
        "prightarrow",
        "qrightarrow",
        "qrightarrow",
        "qrightarrow",
        "q",
        "rightarrow",
        "q",
        "rightarrow",
        "q",
        "rightarrow",
        "qrightarrow",
        "q",
        "rightarrow",
        "p",
        "textsf",
        "skk",
        "assigned",
        "type",
        "prightarrow",
        "p",
        "proof",
        "ta",
        "_textrm",
        "cl",
        "ending",
        "textsf",
        "skk",
        "colon",
        "prightarrow",
        "p",
        "contain",
        "long",
        "formula",
        "however",
        "proof",
        "textsf",
        "skk",
        "colon",
        "prightarrow",
        "p",
        "contains",
        "formula",
        "second",
        "antecedent",
        "subformula",
        "prightarrow",
        "p",
        "indeed",
        "set",
        "subformulas",
        "two",
        "formula",
        "disjoint",
        "picked",
        "two",
        "different",
        "propositional",
        "variable",
        "p",
        "q",
        "emphasize",
        "point",
        "important",
        "case",
        "problem",
        "inhabitation",
        "however",
        "decidable",
        "theorem",
        "decidable",
        "type",
        "inhabitant",
        "base",
        "textsf",
        "textsf",
        "k",
        "theorem",
        "amount",
        "typed",
        "version",
        "decidability",
        "implicational",
        "fragment",
        "intuitionistic",
        "logic",
        "part",
        "gentzen",
        "decidability",
        "result",
        "dating",
        "theorem",
        "decidable",
        "type",
        "inhabitant",
        "base",
        "textsf",
        "textsf",
        "c",
        "textsf",
        "b",
        "prime",
        "textsf",
        "w",
        "theorem",
        "typed",
        "equivalent",
        "decidability",
        "implicational",
        "fragment",
        "logic",
        "relevant",
        "implication",
        "decidability",
        "r_",
        "rightarrow",
        "proved",
        "saul",
        "a",
        "kripke",
        "together",
        "decidability",
        "closely",
        "related",
        "e_",
        "rightarrow",
        "implicational",
        "fragment",
        "logic",
        "entailment",
        "theorem",
        "decidable",
        "type",
        "inhabitant",
        "base",
        "textsf",
        "b",
        "textsf",
        "b",
        "prime",
        "textsf",
        "textsf",
        "w",
        "theorem",
        "typed",
        "version",
        "decidability",
        "implicational",
        "fragment",
        "logic",
        "ticket",
        "entailment",
        "t_rightarrow",
        "provedtogether",
        "decidability",
        "r_rightarrow",
        "r_rightarrow",
        "truth",
        "constant",
        "t",
        "t_rightarrowtextbf",
        "t_rightarrow",
        "truth",
        "constant",
        "t",
        "in",
        "bimb\u00f3",
        "dunn",
        "bimb\u00f3",
        "dunn",
        "independent",
        "result",
        "t_rightarrow",
        "padovani",
        "extends",
        "broda",
        "et",
        "al",
        "decision",
        "procedure",
        "t_rightarrowtextbf",
        "r_rightarrowtextbf",
        "use",
        "textrm",
        "ta",
        "_textrm",
        "cl",
        "axiomatic",
        "calculus",
        "instead",
        "build",
        "upon",
        "consecution",
        "calculus",
        "ie",
        "sequent",
        "calculus",
        "structural",
        "connective",
        "assumed",
        "associative",
        "idea",
        "affinity",
        "structural",
        "rule",
        "combinators",
        "go",
        "back",
        "least",
        "curry",
        "tighten",
        "connection",
        "dunn",
        "meyer",
        "introduced",
        "structurally",
        "free",
        "logic",
        "introduction",
        "rule",
        "combinators",
        "replace",
        "structural",
        "ruleshence",
        "label",
        "logic",
        "bimb\u00f3",
        "dunn",
        "introduced",
        "technique",
        "generate",
        "combinatory",
        "inhabitant",
        "theorem",
        "t_rightarrow",
        "standard",
        "proof",
        "sequent",
        "calculus",
        "used",
        "decision",
        "procedure",
        "t_rightarrowtextbf",
        "sequent",
        "calculus",
        "provide",
        "better",
        "control",
        "proof",
        "natural",
        "deduction",
        "axiomatic",
        "system",
        "combinatory",
        "extraction",
        "procedure",
        "bimb\u00f3",
        "dunn",
        "yield",
        "effective",
        "link",
        "combinators",
        "type",
        "grounded",
        "sequent",
        "calculus",
        "proof",
        "obviates",
        "apparent",
        "advantage",
        "textrm",
        "ta",
        "_textrm",
        "cl",
        "axiomatic",
        "system",
        "rule",
        "substitution",
        "builtin",
        "formulation",
        "textrm",
        "ta",
        "_textrm",
        "cl",
        "via",
        "rule",
        "schema",
        "called",
        "detachment",
        "axiom",
        "schema",
        "basic",
        "combinators",
        "obvious",
        "formula",
        "least",
        "complexity",
        "type",
        "textsf",
        "textsf",
        "k",
        "type",
        "textsf",
        "textsf",
        "k",
        "substitution",
        "instance",
        "formula",
        "property",
        "called",
        "principal",
        "type",
        "combinator",
        "obviously",
        "combinator",
        "principal",
        "type",
        "denumerably",
        "many",
        "principal",
        "type",
        "substitution",
        "instance",
        "hence",
        "justified",
        "talk",
        "principal",
        "type",
        "schema",
        "combinator",
        "existence",
        "principal",
        "type",
        "complex",
        "combinators",
        "obvious",
        "nevertheless",
        "obtains",
        "theorem",
        "term",
        "m",
        "typable",
        "m",
        "principal",
        "type",
        "principal",
        "type",
        "schema",
        "principal",
        "type",
        "principal",
        "type",
        "schema",
        "may",
        "seem",
        "interchangeable",
        "everywhere",
        "thus",
        "could",
        "take",
        "slightly",
        "different",
        "approach",
        "define",
        "textrm",
        "ta",
        "_textrm",
        "cl",
        "include",
        "axiom",
        "rule",
        "schema",
        "detachment",
        "together",
        "rule",
        "substitution",
        "version",
        "textrm",
        "ta",
        "_textrm",
        "cl",
        "would",
        "assume",
        "following",
        "form",
        "deltavdashtextsf",
        "colon",
        "p",
        "rightarrow",
        "qrightarrow",
        "rightarrow",
        "prightarrow",
        "q",
        "rightarrow",
        "prightarrow",
        "deltavdashtextsf",
        "k",
        "colon",
        "qrightarrow",
        "srightarrow",
        "q",
        "frac",
        "deltavdash",
        "mcolon",
        "arightarrow",
        "bqquad",
        "thetavdash",
        "ncolon",
        "delta",
        "thetavdash",
        "mncolon",
        "b",
        "frac",
        "deltavdash",
        "mcolon",
        "delta",
        "pb",
        "vdash",
        "mcolon",
        "pb",
        "p",
        "range",
        "propositional",
        "variable",
        "substitution",
        "notation",
        "extendedin",
        "obvious",
        "wayto",
        "set",
        "type",
        "assignment",
        "clearly",
        "two",
        "deduction",
        "system",
        "equivalent",
        "substitution",
        "dropped",
        "altogether",
        "applicability",
        "detachment",
        "would",
        "become",
        "extremely",
        "limited",
        "instance",
        "textsf",
        "sk",
        "longer",
        "would",
        "typable",
        "compromise",
        "substitution",
        "everywhere",
        "substitution",
        "modify",
        "detachment",
        "rule",
        "includes",
        "much",
        "substitution",
        "necessary",
        "ensure",
        "applicability",
        "detachment",
        "rule",
        "rule",
        "without",
        "combinatory",
        "term",
        "type",
        "assignment",
        "invented",
        "s",
        "carew",
        "a",
        "meredith",
        "usually",
        "called",
        "condensed",
        "detachment",
        "key",
        "applicability",
        "detachment",
        "find",
        "common",
        "substitution",
        "instance",
        "minor",
        "premise",
        "antecedent",
        "major",
        "premise",
        "step",
        "called",
        "unification",
        "bit",
        "formally",
        "let",
        "denote",
        "application",
        "substitution",
        "s",
        "a",
        "result",
        "condensed",
        "detachment",
        "a",
        "brightarrow",
        "c",
        "c",
        "s",
        "b",
        "s_",
        "property",
        "s_",
        "s_",
        "composition",
        "s",
        "s_",
        "notice",
        "always",
        "possible",
        "choose",
        "substitution",
        "instance",
        "pair",
        "formula",
        "set",
        "propositional",
        "variable",
        "disjoint",
        "formula",
        "finite",
        "object",
        "general",
        "common",
        "instance",
        "two",
        "formula",
        "a",
        "b",
        "share",
        "propositional",
        "variable",
        "c",
        "c",
        "substitution",
        "instance",
        "a",
        "b",
        "propositional",
        "variable",
        "identified",
        "substitution",
        "identification",
        "necessary",
        "obtain",
        "formula",
        "substitution",
        "instance",
        "a",
        "b",
        "unification",
        "theorem",
        "specialized",
        "simple",
        "type",
        "implies",
        "two",
        "formula",
        "a",
        "b",
        "common",
        "instance",
        "formula",
        "c",
        "common",
        "instance",
        "a",
        "b",
        "substitution",
        "instance",
        "c",
        "obviously",
        "pair",
        "formula",
        "either",
        "common",
        "instance",
        "aleph_",
        "many",
        "general",
        "common",
        "instance",
        "famous",
        "example",
        "pair",
        "formula",
        "common",
        "instance",
        "arightarrow",
        "a",
        "arightarrow",
        "arightarrow",
        "b",
        "instance",
        "p",
        "rightarrow",
        "p",
        "qrightarrow",
        "qrightarrow",
        "r",
        "share",
        "propositional",
        "variable",
        "however",
        "neither",
        "qrightarrow",
        "q",
        "qrightarrow",
        "r",
        "rightarrow",
        "qrightarrow",
        "r",
        "match",
        "shape",
        "second",
        "formula",
        "put",
        "problem",
        "differently",
        "q",
        "qrightarrow",
        "r",
        "would",
        "unified",
        "unified",
        "matter",
        "formula",
        "substituted",
        "q",
        "immediate",
        "consequence",
        "textsf",
        "wi",
        "typable",
        "hand",
        "rrightarrow",
        "r",
        "rightarrow",
        "rrightarrow",
        "r",
        "srightarrow",
        "rightarrow",
        "srightarrow",
        "rightarrow",
        "rightarrow",
        "rightarrow",
        "srightarrow",
        "substitution",
        "instance",
        "prightarrow",
        "p",
        "qrightarrow",
        "q",
        "furthermore",
        "simple",
        "type",
        "substitution",
        "instance",
        "propositional",
        "variable",
        "hence",
        "textsf",
        "ii",
        "assigned",
        "type",
        "rrightarrow",
        "r",
        "type",
        "srightarrow",
        "rightarrow",
        "srightarrow",
        "s",
        "and",
        "course",
        "latter",
        "happens",
        "instance",
        "former",
        "arightarrow",
        "a",
        "principal",
        "type",
        "schema",
        "textsf",
        "ii",
        "apply",
        "condensed",
        "detachment",
        "prightarrow",
        "p",
        "qrightarrow",
        "q",
        "get",
        "qrightarrow",
        "q",
        "via",
        "substitution",
        "pqrightarrow",
        "q",
        "qq",
        "condensed",
        "detachment",
        "yield",
        "principal",
        "type",
        "textsf",
        "ii",
        "incidentally",
        "textsf",
        "ii",
        "textsf",
        "provide",
        "excellent",
        "example",
        "illustrate",
        "distinct",
        "term",
        "may",
        "principal",
        "type",
        "schema",
        "condensed",
        "detachment",
        "used",
        "extensively",
        "refine",
        "axiomatizations",
        "various",
        "implicational",
        "logic",
        "especially",
        "search",
        "shorter",
        "fewer",
        "axiom",
        "logic",
        "may",
        "formulated",
        "using",
        "axiom",
        "rather",
        "axiom",
        "schema",
        "together",
        "rule",
        "condensed",
        "detachmentwithout",
        "loss",
        "theorem",
        "logic",
        "mentioned",
        "far",
        "j_",
        "rightarrow",
        "r_",
        "rightarrow",
        "t_",
        "rightarrow",
        "e_",
        "rightarrow",
        "mathbf",
        "complete",
        "may",
        "axiomatized",
        "axiom",
        "rule",
        "condensed",
        "detachment",
        "implicational",
        "fragment",
        "classical",
        "intuitionistic",
        "logic",
        "implicational",
        "fragment",
        "relevance",
        "logic",
        "r",
        "e",
        "t",
        "mathbf",
        "complete",
        "see",
        "bimb\u00f3",
        "technical",
        "detail",
        "simply",
        "typed",
        "system",
        "extended",
        "various",
        "direction",
        "logic",
        "often",
        "contain",
        "connective",
        "beyond",
        "implication",
        "natural",
        "modification",
        "type",
        "assignment",
        "system",
        "expand",
        "set",
        "type",
        "via",
        "including",
        "type",
        "constructor",
        "conjunction",
        "fusion",
        "easiest",
        "explain",
        "motivate",
        "type",
        "constructor",
        "however",
        "disjunction",
        "backward",
        "implication",
        "introduced",
        "type",
        "type",
        "useful",
        "allow",
        "u",
        "get",
        "grip",
        "class",
        "term",
        "point",
        "view",
        "behavior",
        "respect",
        "reduction",
        "tait",
        "theorem",
        "combinatory",
        "term",
        "m",
        "typable",
        "simple",
        "type",
        "m",
        "strongly",
        "normalizes",
        "reduction",
        "sequence",
        "m",
        "finite",
        "ie",
        "terminate",
        "converse",
        "claim",
        "obviously",
        "true",
        "example",
        "textsf",
        "wi",
        "strongly",
        "normalizes",
        "untypable",
        "antecedent",
        "contraction",
        "unified",
        "instance",
        "selfimplication",
        "aim",
        "extend",
        "set",
        "typable",
        "term",
        "led",
        "introduction",
        "land",
        "type"
    ]
}