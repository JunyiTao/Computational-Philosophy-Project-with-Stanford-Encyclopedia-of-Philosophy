{
    "url": "turing-machine",
    "title": "Turing Machines",
    "authorship": {
        "year": "Copyright \u00a9 2018",
        "author_text": "Liesbeth De Mol\n<liesbeth.demol@univ-lille3.fr>",
        "author_links": [
            {
                "https://pro.univ-lille.fr/liesbeth-de-mol/": "Liesbeth De Mol"
            },
            {
                "mailto:liesbeth%2edemol%40univ-lille3%2efr": "liesbeth.demol@univ-lille3.fr"
            }
        ],
        "raw_html": "<div id=\"article-copyright\">\n<p>\n<a href=\"../../info.html#c\">Copyright \u00a9 2018</a> by\n\n<br/>\n<a href=\"https://pro.univ-lille.fr/liesbeth-de-mol/\" target=\"other\">Liesbeth De Mol</a>\n&lt;<a href=\"mailto:liesbeth%2edemol%40univ-lille3%2efr\"><em>liesbeth<abbr title=\" dot \">.</abbr>demol<abbr title=\" at \">@</abbr>univ-lille3<abbr title=\" dot \">.</abbr>fr</em></a>&gt;\n    </p>\n</div>"
    },
    "pubinfo": [
        "First published Mon Sep 24, 2018"
    ],
    "preamble": "\n\nTuring machines, first described by Alan Turing\nin Turing 1936\u20137, are simple abstract computational devices\nintended to help investigate the extent and limitations of what can be\ncomputed. Turing\u2019s \u2018automatic machines\u2019, as he\ntermed them in 1936, were specifically devised for the computing of\nreal numbers. They were first named \u2018Turing machines\u2019 by\nAlonzo Church in a review of Turing\u2019s paper (Church 1937).\nToday, they are considered to be one of the foundational models of\ncomputability and (theoretical) computer \nscience.[1]\n",
    "toc": [
        {
            "#DefiTuriMach": "1. Definitions of the Turing Machine"
        },
        {
            "#TuriDefi": "1.1 Turing\u2019s Definition"
        },
        {
            "#PostDefi": "1.2 Post\u2019s Definition"
        },
        {
            "#DefiForm": "1.3 The Definition Formalized"
        },
        {
            "#DescBehaTuriMach": "1.4 Describing the Behavior of a Turing Machine"
        },
        {
            "#CompTuriMach": "2. Computing with Turing Machines"
        },
        {
            "#SomeSimpExam": "2.1 Some (Simple) Examples"
        },
        {
            "#CompNumbProb": "2.2 Computable Numbers and Problems"
        },
        {
            "#TuriUnivMach": "2.3 Turing\u2019s Universal Machine"
        },
        {
            "#InteProgBehaNota": "2.3.1 Interchangeability of program and behavior: a notation"
        },
        {
            "#InteProgBehaBasiSetFunc": "2.3.2 Interchangeability of program and behavior: a basic set of functions"
        },
        {
            "#HaltProbEnts": "2.4 The Halting Problem and the Entscheidungsproblem"
        },
        {
            "#DireIndiProoUncoDeciProb": "2.4.1 Direct and indirect proofs of uncomputable decision problems"
        },
        {
            "#TuriBasiProbCIRCPRINEnts": "2.4.2 Turing\u2019s basic problem CIRC?, PRINT? and the Entscheidungsproblem"
        },
        {
            "#HaltProb": "2.4.3 The halting problem"
        },
        {
            "#VariTuriMach": "2.5 Variations on the Turing machine"
        },
        {
            "#PhilIssuRelaTuriMach": "3. Philosophical Issues Related to Turing Machines"
        },
        {
            "#HumaMachComp": "3.1 Human and Machine Computations"
        },
        {
            "#ThesDefiAxioTheo": "3.2 Thesis, Definition, Axioms or Theorem"
        },
        {
            "#AlteHistModeComp": "4. Alternative Historical Models of Computability"
        },
        {
            "#GeneRecuFunc": "4.1 General Recursive Functions"
        },
        {
            "#LDefi": "4.2 \u03bb-Definability"
        },
        {
            "#PostProdSyst": "4.3 Post Production Systems"
        },
        {
            "#Form1": "4.4 Formulation 1"
        },
        {
            "#ImpaTuriMachCompScie": "5. Impact of Turing Machines on Computer Science"
        },
        {
            "#ImpaTheoCompScie": "5.1 Impact on Theoretical Computer Science"
        },
        {
            "#TuriMachModeComp": "5.2 Turing Machines and the Modern Computer"
        },
        {
            "#TheoProg": "5.3 Theories of Programming"
        },
        {
            "#Bib": "Bibliography"
        },
        {
            "#Aca": "Academic Tools"
        },
        {
            "#Oth": "Other Internet Resources"
        },
        {
            "#BusyBeav": "Busy Beaver"
        },
        {
            "#HaltProb_1": "The Halting Problem"
        },
        {
            "#OnliTuriMachSimu": "Online Turing Machine Simulators"
        },
        {
            "#SoftSimu": "Software simulators"
        },
        {
            "#HardSimu": "Hardware simulators"
        },
        {
            "#Rel": "Related Entries"
        }
    ],
    "main_text": "\n1. Definitions of the Turing Machine\n1.1 Turing\u2019s Definition\n\nTuring introduced Turing machines in the context of research into the\nfoundations of mathematics. More particularly, he used these abstract\ndevices to prove that there is no effective general method or\nprocedure to solve, calculate or compute every instance of the\nfollowing problem:\n\n\nEntscheidungsproblem The problem to decide\nfor every statement in first-order logic (the so-called restricted\nfunctional calculus, see the entry on\n classical logic\n for an introduction) whether or not it is derivable in that\nlogic.\n\n\nNote that in its original form (Hilbert & Ackermann 1928), the\nproblem was stated in terms of validity rather than derivability.\nGiven G\u00f6del\u2019s completeness theorem (G\u00f6del 1929)\nproving that there is an effective procedure (or not) for derivability\nis also a solution to the problem in its validity form. In order to\ntackle this problem, one needs a formalized notion of \u201ceffective\nprocedure\u201d and Turing\u2019s machines were intended to do\nexactly that.\n\nA Turing machine then, or a computing machine as Turing\ncalled it, in Turing\u2019s original definition is a machine capable\nof a finite set of configurations \\(q_{1},\\ldots,q_{n}\\) (the\nstates of the machine, called m-configurations by Turing). It\nis supplied with a one-way infinite and one-dimensional tape divided\ninto squares each capable of carrying exactly one symbol. At any\nmoment, the machine is scanning the content of one square\nr which is either blank (symbolized by \\(S_0\\)) or contains a\nsymbol \\(S_{1},\\ldots ,S_{m}\\) with \\(S_1 = 0\\) and \\(S_2 =\n1\\).\n\nThe machine is an automatic machine (a-machine) which means\nthat at any given moment, the behavior of the machine is completely\ndetermined by the current state and symbol (called the\nconfiguration) being scanned. This is the so-called\ndeterminacy condition\n (Section 3).\n These a-machines are contrasted with the so-called choice\nmachines for which the next state depends on the decision of an\nexternal device or operator (Turing 1936\u20137: 232). A Turing\nmachine is capable of three types of action:\n\nPrint \\(S_i\\), move one square to the left (L) and go to\nstate \\(q_{j}\\)\nPrint \\(S_i\\), move one square to the right (R) and go to\nstate \\(q_{j}\\)\nPrint \\(S_i\\), do not move (N) and go to state\n\\(q_{j}\\)\n\n\nThe \u2018program\u2019 of a Turing machine can then be written as a\nfinite set of quintuples of the form:  \n\n\\[q_{i}S_{j}S_{i,j}M_{i,j}q_{i,j}\\]\n\n\nWhere \\(q_i\\) is the current state, \\(S_j\\) the content of the square\nbeing scanned, \\(S_{i,j}\\) the new content of the square; \\(M_{i,j}\\)\nspecifies whether the machine is to move one square to the left, to\nthe right or to remain at the same square, and \\(q_{i,j}\\) is the next\nstate of the machine. These quintuples are also called the transition\nrules of a given machine. The Turing machine \\(T_{\\textrm{Simple}}\\)\nwhich, when started from a blank tape, computes the sequence\n\\(S_0S_1S_0S_1\\ldots\\) is then given by\n Table 1.\n\n\nTable 1: Quintuple representation of\n\\(T_{\\textrm{Simple}}\\) \n\n\\[\n\\begin{align}\\hline\n;q_{1}S_{0}S_{0}Rq_{2}\\\\\n;q_{1}S_{1}S_{0}Rq_{2}\\\\\n;q_{2}S_{0}S_{1}Rq_{1}\\\\\n;q_{2}S_{1}S_{1}Rq_{1}\\\\\\hline\n\\end{align}\n\\]\n\n\n\nNote that \\(T_{\\textrm{Simple}}\\) will never enter a configuration\nwhere it is scanning \\(S_1\\) so that two of the four quintuples are\nredundant. Another typical format to represent Turing machines and\nwhich was also used by Turing is the transition table.\n Table 2\n gives the transition table of \\(T_{\\textrm{Simple}}\\).\n\n\nTable 2: Transition table for\n\\(T_{\\textrm{Simple}}\\)\n\n\n\n\n\\(S_0\\)\n\\(S_1\\) \n\n\\(q_1\\)\n\\(S_{0}\\opR q_{2}\\)\n\\(S_{0}\\opR q_{2}\\) \n\n\\(q_2\\)\n\\(S_{1}\\opR q_{1}\\)\n\\(S_{1}\\opR q_{1}\\)  \n\n\n\nWhere current definitions of Turing machines usually have only one\ntype of symbols (usually just 0 and 1; it was proven by Shannon that\nany Turing machine can be reduced to a binary Turing machine (Shannon\n1956)) Turing, in his original definition of so-called computing\nmachines, used two kinds of symbols: the figures which\nconsist entirely of 0s and 1s and the so-called symbols of the\nsecond kind. These are differentiated on the Turing machine tape\nby using a system of alternating squares of figures and symbols of the\nsecond kind. One sequence of alternating squares contains the figures\nand is called the sequence of F-squares. It contains the\nsequence computed by the machine; the other is called the\nsequence of E-squares. The latter are used to mark\nF-squares and are there to \u201cassist the memory\u201d\n(Turing 1936\u20137: 232). The content of the E-squares is\nliable to change. F-squares however cannot be changed which\nmeans that one cannot implement algorithms whereby earlier computed\ndigits need to be changed. Moreover, the machine will never print a\nsymbol on an F-square if the F-square preceding it has\nnot been computed yet. This usage of F and E-squares can\nbe quite useful (see\n Sec. 2.3)\n but, as was shown by Emil L. Post, it results in a number of\ncomplications (see\n Sec. 1.2).\n\nThere are two important things to notice about the Turing machine\nsetup. The first concerns the definition of the machine itself, namely\nthat the machine\u2019s tape is potentially infinite. This\ncorresponds to an assumption that the memory of the machine is\n(potentially) infinite. The second concerns the definition of Turing\ncomputable, namely that a function will be Turing computable if there\nexists a set of instructions that will result in a Turing machine\ncomputing the function regardless of the amount of time it takes. One\ncan think of this as assuming the availability of potentially infinite\ntime to complete the computation.\n\nThese two assumptions are intended to ensure that the definition of\ncomputation that results is not too narrow. This is, it ensures that\nno computable function will fail to be Turing-computable solely\nbecause there is insufficient time or memory to complete the\ncomputation. It follows that there may be some Turing computable\nfunctions which may not be carried out by any existing computer,\nperhaps because no existing machine has sufficient memory to carry out\nthe task. Some Turing computable functions may not ever be computable\nin practice, since they may require more memory than can be built\nusing all of the (finite number of) atoms in the universe. If we\nmoreover assume that a physical computer is a finite realization of\nthe Turing machine, and so that the Turing machine functions as a good\nformal model for the computer, a result which shows that a function is\nnot Turing computable is very strong, since it implies that no\ncomputer that we could ever build could carry out the computation. In\nSection 2.4, it is shown that there are functions which are not\nTuring-computable.\n1.2 Post\u2019s Definition\n\nTuring\u2019s definition was standardized through (some of)\nPost\u2019s modifications of it in Post 1947. In that paper Post\nproves that a certain problem from mathematics known as Thue\u2019s\nproblem or the word problem for semi-groups is not Turing computable\n(or, in Post\u2019s words, recursively unsolvable). Post\u2019s main\nstrategy was to show that if it were decidable then the following\ndecision problem from Turing 1936\u20137 would also be decidable:\n\n\nPRINT? The problem to decide for every Turing machine\nM whether or not it will ever print some symbol (for instance,\n0).\n\n\nIt was however proven by Turing that PRINT? is not\nTuring computable and so the same is true of Thue\u2019s problem.\n\nWhile the uncomputability of PRINT? plays a central\nrole in Post\u2019s proof, Post believed that Turing\u2019s proof of\nthat was affected by the \u201cspurious Turing convention\u201d\n(Post 1947: 9), viz. the system of F and E-squares.\nThus, Post introduced a modified version of the Turing machine. The\nmost important differences between Post\u2019s and Turing\u2019s\ndefinition are:\n\n\n\nPost\u2019s Turing machine, when in a given state, either prints or\nmoves and so its transition rules are more \u2018atomic\u2019 (it\ndoes not have the composite operation of moving and printing). This\nresults in the quadruple notation of Turing machines, where each\nquadruple is in one of the three forms of\n Table 3:\n\n\nTable 3: Post\u2019s Quadruple\nnotation \n\n\\[\n\\begin{aligned}\\hline\n& q_iS_jS_{i,j}q_{i,j}\\\\\n& q_iS_jLq_{i,j}\\\\\n& q_iS_jRq_{i,j}\\\\\\hline\n\\end{aligned}\n\\]\n\n \nPost\u2019s Turing machine has only one kind of symbol and so\ndoes not rely on the Turing system of F and\nE-squares.\nPost\u2019s Turing machine has a two-way infinite tape.\nPost\u2019s Turing machine halts when it reaches a state for\nwhich no actions are defined.\n\n\nNote that Post\u2019s reformulation of the Turing machine is very\nmuch rooted in his Post 1936. (Some of) Post\u2019s modifications of Turing\u2019s\ndefinition became part of the definition of the Turing machine in\nstandard works such as Kleene 1952 and Davis 1958. Since that time,\nseveral (logically equivalent) definitions have been introduced.\nToday, standard definitions of Turing machines are, in some respects,\ncloser to Post\u2019s Turing machines than to Turing\u2019s\nmachines. In what follows we will use a variant on the standard\ndefinition from Minsky 1967 which uses the quintuple notation but has no E and\nF-squares and includes a special halting state H. It\nalso has only two move operations, viz., L and R and so\nthe action whereby the machine merely prints is not used. When the\nmachine is started, the tape is blank except for some finite portion\nof the tape. Note that the blank square can also be represented as a\nsquare containing the symbol \\(S_0\\) or simply 0. The finite content\nof the tape will also be called the dataword on the tape.\n1.3 The Definition Formalized\n\nTalk of \u201ctape\u201d and a \u201cread-write head\u201d is\nintended to aid the intuition (and reveals something of the time in\nwhich Turing was writing) but plays no important role in the\ndefinition of Turing machines. In situations where a formal analysis\nof Turing machines is required, it is appropriate to spell out the\ndefinition of the machinery and program in more mathematical terms.\nPurely formally a Turing machine can be specified as a quadruple \\(T =\n(Q,\\Sigma, s, \\delta)\\) where:\n\nQ is a finite set of states q\n\\(\\Sigma\\) is a finite set of symbols\ns is the initial state \\(s \\in Q\\)\n\n\n\\(\\delta\\) is a transition function determining the next move: \n\n\\[\\delta :  (Q \\times \\Sigma) \\rightarrow (\\Sigma \\times \\{L,R\\} \\times Q)\\]\n\n \n\n\nThe transition function for the machine T is a function from\ncomputation states to computation states. If \\(\\delta(q_i,S_j) =\n(S_{i,j},D,q_{i,j})\\), then when the machine\u2019s state is \\(q_j\\),\nreading the symbol \\(S_j\\), \\(T\\) replaces \\(S_j\\) by \\(S_{i,j}\\),\nmoves in direction \\(D \\in \\{L,R\\}\\) and goes to state\n\\(q_{i,j}\\).\n1.4 Describing the Behavior of a Turing Machine\n\nWe introduce a representation which allows us to describe the behavior\nor dynamics of a Turing machine \\(T_n\\), relying on the notation of\nthe complete configuration (Turing 1936\u20137: 232) also\nknown today as instantaneous description (ID) (Davis 1982:\n6). At any\nstage of the computation of \\(T_{i}\\) its ID is given by:\n\n(1)the content of the\ntape, that is, its data word\n(2)the location of the\nreading head\n(3)the machine\u2019s\ninternal state\n\n\nSo, given some Turing machine T which is in state \\(q_{i}\\)\nscanning the symbol \\(S_{j}\\), its ID is given by \\(Pq_{i}S_{j}Q\\)\nwhere P and Q are the finite words to the left and right\nhand side of the square containing the symbol \\(S_{j}\\).\n Figure 1\n gives a visual representation of an ID of some Turing machine\nT in state \\(q_i\\) scanning the tape.\n\n\n\nFigure 1: A complete configuration of\nsome Turing machine T\n\n\nThe notation thus allows us to capture the developing behavior of the\nmachine and its tape through its consecutive IDs.\n Figure 2\n gives the first few consecutive IDs of \\(T_{\\textrm{Simple}}\\) using\na graphical representation.\n\n\n\nFigure 2: The dynamics of\n\\(T_{\\textrm{Simple}}\\) graphical representation\n\n\nThe animation can be started by clicking on the picture. One can also\nexplicitly print the consecutive IDs, using their symbolic\nrepresentations. This results in a state-space diagram of the behavior\nof a Turing machine. So, for \\(T_{\\textrm{Simple}}\\) we get (Note that\n\\(\\overline{0}\\) means the infinite repetition of 0s): \n\n\\[\\begin{matrix}\n\\overline{0}q_1{\\bf 0}\\overline{0}\\\\\n\\overline{0}{\\color{blue} 0}q_2{\\bf 0}\\overline{0}\\\\\n\\overline{0}{\\color{blue}01}q_1{\\bf 0}\\overline{0}\\\\\n\\overline{0}{\\color{blue}010}q_2{\\bf 0}\\overline{0}\\\\\n\\overline{0}{\\color{blue}0101}q_1{\\bf 0}\\overline{0}\\\\\n\\overline{0}{\\color{blue}01010}q_2{\\bf 0}\\overline{0}\\\\\n\\vdots\n\\end{matrix}\\]\n\n2. Computing with Turing Machines\n\nAs explained in\n Sec. 1.1,\n Turing machines were originally intended to formalize the notion of\ncomputability in order to tackle a fundamental problem of mathematics.\nIndependently of Turing, Alonzo Church gave a different but logically\nequivalent formulation (see\n Sec. 4).\n Today, most computer scientists agree that Turing\u2019s, or any\nother logically equivalent, formal notion captures all\ncomputable problems, viz. for any computable problem, there is a\nTuring machine which computes it. This is known as the\nChurch-Turing thesis, Turing\u2019s thesis (when\nthe reference is only to Turing\u2019s work) or Church\u2019s\nthesis (when the reference is only to Church\u2019s work).\n\nIt implies that, if accepted, any problem not computable by a Turing\nmachine is not computable by any finite means whatsoever. Indeed,\nsince it was Turing\u2019s ambition to capture \u201c[all] the\npossible processes which can be carried out in computing a\nnumber\u201d (Turing 1936\u20137: 249), it follows that, if we\naccept Turing\u2019s analysis:\n\nAny problem not computable by a Turing machine is not\n\u201ccomputable\u201d in the absolute sense (at least, absolute\nrelative to humans, see\n Section 3).\nFor any problem that we believe is computable, we should be able\nto construct a Turing machine which computes it. To put it in\nTuring\u2019s wording:\n\n\nIt is my contention that [the] operations [of a computing machine]\ninclude all those which are used in the computation of a number.\n(Turing 1936\u20137: 231)\n \n\n\nIn this section, examples will be given which illustrate the\ncomputational power and boundaries of the Turing machine\nmodel. Section 3 then discusses some philosophical issues related to\nTuring\u2019s thesis.\n2.1 Some (Simple) Examples\n\nIn order to speak about a Turing machine that does something useful\nfrom the human perspective, we will have to provide an interpretation\nof the symbols recorded on the tape. For example, if we want to design\na machine which will compute some mathematical function, addition say,\nthen we will need to describe how to interpret the ones and zeros\nappearing on the tape as numbers.\n\nIn the examples that follow we will represent the number n as\na block of \\(n+1\\) copies of the symbol \u20181\u2019 on the tape.\nThus we will represent the number 0 as a single \u20181\u2019 and\nthe number 3 as a block of four \u20181\u2019s. This is called\nunary notation.\n\nWe will also have to make some assumptions about the configuration of\nthe tape when the machine is started, and when it finishes, in order\nto interpret the computation. We will assume that if the function to\nbe computed requires n arguments, then the Turing machine\nwill start with its head scanning the leftmost \u20181\u2019 of a\nsequence of n blocks of \u20181\u2019s. The blocks of\n\u20181\u2019s representing the arguments must be separated by a\nsingle occurrence of the symbol \u20180\u2019. For example, to\ncompute the sum \\(3+4\\), a Turing machine will start in the\nconfiguration shown in\n Figure 3.\n\n\n\nFigure 3: Initial configuration for a\ncomputation over two numbers n and m\n\n\nHere the supposed addition machine takes two arguments representing\nthe numbers to be added, starting at the leftmost 1 of the first\nargument. The arguments are separated by a single 0 as required, and\nthe first block contains four \u20181\u2019s, representing the\nnumber 3, and the second contains five \u20181\u2019s, representing\nthe number 4.\n\nA machine must finish in standard configuration too. There must be a\nsingle block of symbols (a sequence of 1s representing some number or\na symbol representing another kind of output) and the machine must be\nscanning the leftmost symbol of that sequence. If the machine\ncorrectly computes the function then this block must represent the\ncorrect answer.\n\nAdopting this convention for the terminating configuration of a Turing\nmachine means that we can compose machines by identifying the final\nstate of one machine with the initial state of the next.\nAddition of two numbers n and m\n\nTable 4\n gives the transition table of a Turing machine \\(T_{\\textrm{Add}_2}\\)\nwhich adds two natural numbers n and m. We assume the\nmachine starts in state \\(q_1\\) scanning the leftmost 1 of\n\\(n+1\\).\n\n\nTable 4: Transition table for\n\\(T_{\\textrm{Add}_2}\\)\n\n\n\n\n0\n1 \n\n\\(q_1\\)\n/\n\\(0\\opR q_2\\) \n\n\\(q_2\\)\n\\(1\\opL q_3\\)\n\\(1\\opR q_2\\) \n\n\\(q_3\\)\n\\(0\\opR q_{4}\\)\n\\(1\\opL q_3\\) \n\n\\(q_4\\)\n\\(/\\)\n\\(0\\opR q_{\\textrm{halt}}\\)  \n\n\n\nThe idea of doing an addition with Turing machines when using unary\nrepresentation is to shift the leftmost number n one square to\nthe right. This is achieved by erasing the leftmost 1 of \\(n +1\\)\n(this is done in state \\(q_1\\)) and then setting the 0 between \\(n+1\\)\nand \\(m+1\\) to 1 (state \\(q_2\\)). We then have \\(n + m + 2\\) and so we\nstill need to erase one additional 1. This is done by erasing the\nleftmost 1 (states \\(q_3\\) and \\(q_4\\)).\n Figure 4\n shows this computation for \\(3 + 4\\).\n\n\n\nFigure 4: The computation of \\(3+4\\) by\n\\(T_{\\textrm{Add}_2}\\)\n\nAddition of n numbers\n\nWe can generalize \\(T_{\\textrm{Add}_2}\\) to a Turing machine\n\\(T_{\\textrm{Add}_i}\\) for the addition of an arbitrary number\ni of integers \\(n_1, n_2,\\ldots, n_j\\). We assume\nagain that the machine starts in state \\(q_1\\) scanning the leftmost 1\nof \\(n_1+1\\). The transition table for such a machine\n\\(T_{\\textrm{Add}_i}\\) is given in\n Table 5.\n\n\nTable 5: Transition table for\n\\(T_{\\textrm{Add}_i}\\)\n\n\n\n\n0\n1 \n\n\\(q_1\\)\n/\n\\(0\\opR q_2\\) \n\n\\(q_2\\)\n\\(1\\opR q_3\\)\n\\(1\\opR q_2\\) \n\n\\(q_3\\)\n\\(0\\opL q_{6}\\)\n\\(1\\opL q_4\\) \n\n\\(q_4\\)\n\\(0\\opR q_5\\)\n\\(1\\opL q_4\\) \n\n\\(q_5\\)\n/\n\\(0\\opR q_1\\) \n\n\\(q_6\\)\n\\(0\\opR q_{\\textrm{halt}}\\)\n\\(1\\opL q_6\\) \n\n\n\n\nThe machine \\(T_{\\textrm{Add}_i}\\) uses the principle of shifting the\naddends to the right which was also used for \\(T_{\\textrm{Add}_2}\\).\nMore particularly, \\(T_{add_i}\\) computes the sum of \\(n_1 + 1\\),\n\\(n_2 + 1\\),\u2026 \\(n_i+1\\) from left to right, viz. it computes\nthis sum as follows:  \n\n\\[\\begin{align}\nN_1 & = n_1 + n_2 + 1\\\\\nN_2  & = N_1 + n_3 \\\\\nN_3  &= N_2 + n_4\\\\\n &\\vdots\\\\\nN_i  &= N_{i-1} + n_i + 1\n\\end{align}\n\\]\n\n\nThe most important difference between \\(T_{\\textrm{Add}_2}\\) and\n\\(T_{\\textrm{Add}_i}\\) is that \\(T_{\\textrm{Add}_i}\\) needs to verify\nif the leftmost addend \\(N_j, 1 < j \\leq i\\) is equal to\n\\(N_i\\). This is achieved by checking whether the first 0 to the right\nof \\(N_j\\) is followed by another 0 or not (states \\(q_2\\) and\n\\(q_3\\)). If it is not the case, then there is at least one more\naddend \\(n_{j+1}\\) to be added. Note that, as was the case for \\(T_{\\textrm{Add}_2}\\), the machine needs to erase an additional one from the addend \\(n_{j+1}\\) which is done via state \\(q_5\\). It then moves back to state \\(q_1\\). \nIf, on the other hand, \\(N_j = N_i\\), the machine moves to the leftmost 1 of \\(N_i = n_1 + n_2 + \\ldots + n_i + 1 \\) and halts.\n2.2 Computable Numbers and Problems\n\nTuring\u2019s original paper is concerned with computable (real)\nnumbers. A (real) number is Turing computable if there exists a\nTuring machine which computes an arbitrarily precise approximation to\nthat number. All of the algebraic numbers (roots of polynomials with\nalgebraic coefficients) and many transcendental mathematical\nconstants, such as e and \\(\\pi\\) are Turing-computable.\nTuring gave several examples of classes of numbers computable by\nTuring machines (see section 10 Examples of large classes of\nnumbers which are computable of Turing 1936\u20137) as a\nheuristic argument showing that a wide diversity of classes of numbers\ncan be computed by Turing machines.\n\nOne might wonder however in what sense computation with numbers, viz.\ncalculation, captures non-numerical but computable problems\nand so how Turing machines capture all general and effective\nprocedures which determine whether something is the case or not.\nExamples of such problems are:\n\n\u201cdecide for any given x whether or not x\ndenotes a prime\u201d\n\u201cdecide for any given x whether or not x is\nthe description of a Turing machine\u201d.\n\n\nIn general, these problems are of the form:\n\n\u201cdecide for any given x whether or not x has\nproperty X\u201d\n\n\nAn important challenge of both theoretical and concrete advances in\ncomputing (often at the interface with other disciplines) has become\nthe problem of providing an interpretation of X such that it\ncan be tackled computationally. To give just one concrete example, in\ndaily computational practices it might be important to have a method\nto decide for any digital \u201csource\u201d whether or not it can\nbe trusted and so one needs a computational interpretation of\ntrust.\n\nThe characteristic function of a predicate is a function\nwhich has the value TRUE or FALSE when given appropriate arguments. In\norder for such functions to be computable, Turing relied on\nG\u00f6del\u2019s insight that these kind of problems can be encoded\nas a problem about numbers (See\n G\u00f6del\u2019s incompleteness theorem\n and the next\n Sec. 2.3)\n In Turing\u2019s wording:\n\n\nThe expression \u201cthere is a general process for determining\n\u2026\u201d has been used [here] [\u2026] as equivalent to\n\u201cthere is a machine which will determine \u2026\u201d. This\nusage can be justified if and only if we can justify our definition of\n\u201ccomputable\u201d. For each of these \u201cgeneral\nprocess\u201d problems can be expressed as a problem concerning a\ngeneral process for determining whether a given integer n has a\nproperty \\(G(n)\\) [e.g. \\(G(n)\\) might mean \u201cn is\nsatisfactory\u201d or \u201cn is the G\u00f6del\nrepresentation of a provable formula\u201d], and this is equivalent\nto computing a number whose n-th figure is 1 if \\(G(n)\\) is\ntrue and 0 if it is false. (1936\u20137: 248)\n\n\nIt is the possibility of coding the \u201cgeneral process\u201d\nproblems as numerical problems that is essential to Turing\u2019s\nconstruction of the universal Turing machine and its use within a\nproof that shows there are problems that cannot be computed by a\nTuring machine.\n2.3 Turing\u2019s Universal Machine\n\nThe universal Turing machine which was constructed to prove the\nuncomputability of certain problems, is, roughly speaking, a Turing\nmachine that is able to compute what any other Turing machine\ncomputes. Assuming that the Turing machine notion fully captures\ncomputability (and so that Turing\u2019s thesis is valid), it is\nimplied that anything which can be \u201ccomputed\u201d, can also be\ncomputed by that one universal machine. Conversely, any problem that\nis not computable by the universal machine is considered to be\nuncomputable.\n\nThis is the rhetorical and theoretical power of the universal machine\nconcept, viz. that one relatively simple formal device captures all\n\u201cthe possible processes which can be carried out in\ncomputing a number\u201d (Turing 1936\u20137). It is also one\nof the main reasons why Turing has been retrospectively\nidentified as one of the founding fathers of computer science (see\n Section 5).\n\nSo how to construct a universal machine U out of the set of\nbasic operations we have at our disposal? Turing\u2019s approach is\nthe construction of a machine U which is able to (1)\n\u2018understand\u2019 the program of any other machine\n\\(T_{n}\\) and, based on that \u201cunderstanding\u201d, (2)\n\u2018mimic\u2019 the behavior of \\(T_{n}\\). To this end, a method\nis needed which allows to treat the program and the behavior of\n\\(T_n\\) interchangeably since both aspects are manipulated on the same\ntape and by the same machine. This is achieved by Turing in two basic\nsteps: the development of (1) a notational method (2) a set of\nelementary functions which treats that notation\u2014independent of\nwhether it is formalizing the program or the behavior of\n\\(T_n\\)\u2014as text to be compared, copied down, erased, etc. In\nother words, Turing develops a technique that allows to treat program\nand behavior on the same level.\n2.3.1 Interchangeability of program and behavior: a notation\n\nGiven some machine \\(T_n\\), Turing\u2019s basic idea is to construct\na machine \\(T_n'\\) which, rather than directly printing the output\nof \\(T_n\\), prints out the successive complete configurations or\ninstantaneous descriptions of \\(T_n\\). In order to achieve this,\n\\(T_n'\\):\n\n\n[\u2026] could be made to depend on having the rules of operation\n[\u2026] of [\\(T_n\\)] written somewhere within itself [\u2026]\neach step could be carried out by referring to these rules. (Turing\n1936\u20137: 242)\n\n\nIn other words, \\(T_n'\\) prints out the successive complete\nconfigurations of \\(T_n\\) by having the program of \\(T_n\\) written on\nits tape. Thus, Turing needs a notational method which makes it\npossible to \u2018capture\u2019 two different aspects of a Turing\nmachine on one and the same tape in such a way they can be treated\nby the same machine, viz.:\n\n(1) its description in\nterms of what it should do\u2014the quintuple\nnotation\n(2) its description in\nterms of what it is doing\u2014the complete configuration\nnotation\n\n\nThus, a first and perhaps most essential step, in the construction of\nU are the quintuple and complete configuration notation and\nthe idea of putting them on the same tape. More particularly, the tape\nis divided into two regions which we will call the A and\nB region here. The A region contains a notation of the\n\u2018program\u2019 of \\(T_n\\) and the B region a notation\nfor the successive complete configurations of \\(T_n\\). In\nTuring\u2019s paper they are separated by an additional symbol\n\u201c::\u201d.\n\nTo simplify the construction of U and in order to encode any\nTuring machine as a unique number, Turing develops a third notation\nwhich permits to express the quintuples and complete configurations\nwith letters only. This is determined by [Note that we use\nTuring\u2019s original encoding. Of course, there is a broad variety\nof possible encodings, including binary encodings]:\n\nReplacing each state \\(q_i\\) in a quintuple of \\(T_n\\) by \\[D\\underbrace{A\\ldots A}_i,\\] so, for instance \\(q_3\\) becomes \\(DAAA\\).\nReplacing each symbol \\(S_{j}\\) in a quintuple of \\(T_n\\) by \\[D\\underbrace{C\\ldots C}_j,\\] so, for instance, \\(S_1\\) becomes \\(DC\\).\n\n\nUsing this method, each quintuple of some Turing machine \\(T_n\\) can\nbe expressed in terms of a sequence of capital letters and so the\n\u2018program\u2019 of any machine \\(T_{n}\\) can be expressed by the\nset of symbols A, C, D, R, L, N and ;. This is the so-called\nStandard Description (S.D.) of a Turing machine. Thus, for\ninstance, the S.D. of \\(T_{\\textrm{Simple}}\\) is:  \n\n;DADDRDAA;DADCDRDAA;DAADDCRDA;DAADCDCRDA\n\n\nThis is, essentially, Turing\u2019s version of\n G\u00f6del numbering.\n Indeed, as Turing shows, one can easily get a numerical description\nrepresentation or Description Number (D.N.) of a Turing\nmachine \\(T_{n}\\) by replacing:\n\n\u201cA\u201d by \u201c1\u201d\n\u201cC\u201d by \u201c2\u201d\n\u201cD\u201d by \u201c3\u201d\n\u201cL\u201d by \u201c4\u201d\n\u201cR\u201d by \u201c5\u201d\n\u201cN\u201d by \u201c6\u201d\n\u201c;\u201d by \u201c7\u201d\n\n\nThus, the D.N. of \\(T_{\\textrm{Simple}}\\) is: \n\n7313353117313135311731133153173113131531\n\n\nNote that every machine \\(T_n\\) has a unique D.N.; a D.N. represents\none and one machine only.\n\nClearly, the method used to determine the \\(S.D.\\) of some machine\n\\(T_n\\) can also be used to write out the successive complete\nconfigurations of \\(T_n\\). Using \u201c:\u201d as a separator\nbetween successive complete configurations, the first few complete\nconfigurations of \\(T_{\\textrm{Simple}}\\) are:  \n\n:DAD:DDAAD:DDCDAD:DDCDDAAD:DDCDDCDAD\n\n2.3.2 Interchangeability of program and behavior: a basic set of functions\n\nHaving a notational method to write the program and successive\ncomplete configurations of some machine \\(T_n\\) on one and the same\ntape of some other machine \\(T_n'\\) is the first step in\nTuring\u2019s construction of U. However, U should also\nbe able to \u201cemulate\u201d the program of \\(T_n\\) as written in\nregion A so that it can actually write out its successive\ncomplete configurations in region B. Moreover it should be\npossible to \u201ctake out and exchange[\u2026] [the rules of operations of some Turing machine] for\nothers\u201d (Turing 1936\u20137: 242). Viz.,\nit should be able not just to calculate but also to compute, an issue\nthat was also dealt with by others such as Church, G\u00f6del and Post\nusing their own formal devices. It should, for instance, be able to\n\u201crecognize\u201d whether it is in region A or B\nand it should be able to determine whether or not a certain sequence\nof symbols is the next state \\(q_i\\) which needs to be executed.\n\nThis is achieved by Turing through the construction of a sequence of\nTuring computable problems such as:\n\nFinding the leftmost or rightmost occurrence of a sequence of\nsymbols\nMarking a sequence of symbols by some symbol a (remember\nthat Turing uses two kinds of alternating squares)\nComparing two symbol sequences\nCopying a symbol sequence\n\n\nTuring develops a notational technique, called skeleton\ntables, for these functions which serves as a kind of shorthand\nnotation for a complete Turing machine table but can be easily used to\nconstruct more complicated machines from previous ones. The technique\nis quite reminiscent of the recursive technique of composition (see:\n recursive functions).\n\nTo illustrate how such functions are Turing computable, we discuss one\nsuch function in more detail, viz. the compare function. It is\nconstructed on the basis of a number of other Turing computable\nfunctions which are built on top of each other. In order to understand\nhow these functions work, remember that Turing used a system of\nalternating F and E-squares where the F-squares\ncontain the actual quintuples and complete configurations and the\nE-squares are used as a way to mark off certain parts of the\nmachine tape. For the comparing of two sequences \\(S_1\\) and \\(S_2\\),\neach symbol of \\(S_1\\) will be marked by some symbol a and each\nsymbol of \\(S_2\\) will be marked by some symbol b.\n\nTuring defined nine different functions to show how the compare\nfunction can be computed with Turing machines:\n\nFIND\\((q_{i}, q_{j},a)\\): this machine function searches for the\nleftmost occurrence of a. If a is found, the machine\nmoves to state \\(q_{i}\\) else it moves to state \\(q_{j}\\). This is\nachieved by having the machine first move to the beginning of the tape\n(indicated by a special mark) and then to have it move right until it\nfinds a or reaches the rightmost symbol on the tape.\nFINDL\\((q_{i}, q_{j},a)\\): the same as FIND but after a has\nbeen found, the machine moves one square to the left. This is used in\nfunctions which need to compute on the symbols in F-squares\nwhich are marked by symbols a in the E-squares.\nERASE\\((q_{i},q_{j},a)\\): the machine computes FIND. If a is\nfound, it erases a and goes to state \\(q_{i}\\) else it goes to\nstate \\(q_{j}\\)\nERASE_ALL\\((q_j,a) = \\textrm{ERASE}(\\textrm{ERASE}\\_\\textrm{ALL},\nq_j,a)\\): the machines computes ERASE on a repeatedly until all\na\u2019s have been erased. Then it moves to \\(q_{j}\\).\nEQUAL\\((q_i,q_j,a)\\): the machine checks whether or not the\ncurrent symbol is a. If yes, it moves to state \\(q_i\\) else it\nmoves to state \\(q_j\\)\nCMP_XY\\((q_i,q_j,b) = \\textrm{FINDL(EQUAL}(q_i,q_j,x), q_j, b)\\):\nwhatever the current symbol x, the machine computes FINDL on\nb (and so looks for the symbol marked by b). If there is\na symbol y marked with b, the machine computes\n\\(\\textrm{EQUAL}\\) on x and y, else, the machine goes to\nstate \\(q_j\\). In other words, CMP_XY\\((q_i,q_j,b)\\) compares whether\nthe current symbol is the same as the leftmost symbol marked\nb.\nCOMPARE_MARKED\\((q_i,q_j,q_n,a,b)\\): the machine checks whether\nthe leftmost symbols marked a and b respectively are the\nsame. If there is no symbol marked a nor b, the machine\ngoes to state \\(q_{n}\\); if there is a symbol marked a and one\nmarked b and they are the same, the machine goes to state\n\\(q_i\\), else the machine goes to state \\(q_j\\). The function is\ncomputed as \\(\\textrm{FINDL(CMP}\\_XY(q_i,q_j,b),\n\\textrm{FIND}(q_j,q_n,b),a)\\)\n\\(\\textrm{COMPARE}\\_\\textrm{ERASE}(q_iq_j,q_n,a,b)\\): the same as\nCOMPARE_MARKED but when the symbols marked a and b are the same,\nthe marks a and b are erased. This is achieved by\ncomputing \\(\\textrm{ERASE}\\) first on a and then on\nb.\n\n\n\\(\\textrm{COMPARE}\\_\\textrm{ALL}(q_j,q_n,a,b)\\) The machine compares\nthe sequences A and B marked with a and b\nrespectively. This is done by repeatedly computing COMPARE_ERASE on a and\nb. If A and B are equal, all a\u2019s and\nb\u2019s will have been erased and the machine moves to state\n\\(q_j\\), else, it will move to state \\(q_n\\). It is computed by\n\n\\[\\textrm{COMPARE}\\_\\textrm{ERASE}(\\textrm{COMPARE}\\_\\textrm{ALL}(q_j,q_n,a,b),q_j,q_n,a,b)\\]\n\n and so by recursively calling\n\\(\\textrm{COMPARE}\\_\\textrm{ALL}\\).\n\n\nIn a similar manner, Turing defines the following functions:\n\n\\(\\textrm{COPY}(q_i,a)\\): copy the sequence of symbols marked with\na\u2019s to the right of the last complete configuration and\nerase the marks.\n\\(\\textrm{COPY}_{n}(q_i, a_1,a_2,\\ldots ,a_n)\\): copy down the\nsequences marked \\(a_1\\) to \\(a_n\\) to the right of the last complete\nconfiguration and erase all marks \\(a_i\\).\n\\(\\textrm{REPLACE}(q_i, a,b)\\): replace all letters a by\nb\n\\(\\textrm{MARK_NEXT_CONFIG}(q_i,a)\\): mark the first configuration\n\\(q_iS_j\\) to the right of the machine\u2019s head with the letter\na.\n\\(\\textrm{FIND}\\_\\textrm{RIGHT}(q_i,a)\\): find the rightmost\nsymbol a.\n\n\nUsing the basic functions COPY, REPLACE and COMPARE, Turing constructs\na universal Turing machine.\n\nBelow is an outline of the universal Turing machine indicating how\nthese basic functions indeed make possible universal computation. It\nis assumed that upon initialization, U has on its tape the S.D.\nof some Turing machine \\(T_n\\). Remember that Turing uses the system\nof alternating F and E-squares and so, for instance, the\nS.D. of \\(T_{\\textrm{Simple}}\\) will be written on the tape of\nU as: \n\n;_D_A_D_D_R_D_A_A_;_D_A_D_C_D_R_D_A_A_;_D_A_A_D_D_C_R_D_A_;_D_A_A_D_C_D_C_R_D_A_\n\n\nwhere \u201c_\u201d indicates an unmarked E-square.\n\nINIT: To the right of the rightmost quintuple of\nT_n, U prints ::_:_D_A_, where _\nindicates an unmarked E-square.\n\n\nFIND_NEXT_STATE: The machine first marks (1) with y the\nconfiguration \\(q_{CC,i}S_{CC,j}\\) of the rightmost (and so last)\ncomplete configuration computed by U in the B part of\nthe tape and (2) with x the configuration \\(q_{q,m}S_{q,n}\\) of\nthe leftmost quintuple which is not preceded by a marked (with the\nletter z) semicolon in the A part of the tape. The two\nconfigurations are compared. If they are identical, the machine moves\nto MARK_OPERATIONS, if not, it marks the semicolon preceding\n\\(q_{q,m}S_{q,n}\\) with z and goes to FIND_NEXT_STATE. This is\neasily achieved using the function COMPARE_ALL which means that,\nwhatever the outcome of the comparison, the marks x and\ny will be erased. For instance, suppose that \\(T_n =\nT_{\\textrm{Simple}}\\) and that the last complete configuration of\n\\(T_{\\textrm{Simple}}\\) as computed by U is:  \n\n\\[\\tag{1}\n\\label{CC_univ}\n:\\_\\underbrace{D\\_}_{S_0}\\underbrace{D\\_C\\_}_{S_1}\\underbrace{D\\_}_{S_0}\\textcolor{orange}{\\underbrace{D\\_A\\_A\\_}_{q_{2}}\\underbrace{D\\_}_{S_0}}\n\\]\n\n\nThen U will move to region A and determine that the\ncorresponding quintuple is:  \n\n\\[\\tag{2}\\label{quint_univ}\n\\textcolor{orange}{\\underbrace{D\\_A\\_A\\_}_{q_{2}}\\underbrace{D\\_}_{S_{0}}}\\underbrace{D\\_C\\_}_{S_1}\\underbrace{R\\_}\\underbrace{D\\_A\\_}_{q_1}\\]\n\n \n\n\nMARK_OPERATIONS: The machine U marks the operations that it\nneeds to execute in order to compute the next complete configuration\nof \\(T_n\\). The printing and move (L,R, N) operations are marked with\nu and the next state with y. All marks z are\nerased. Continuing with our example, U will mark\n\\(\\eqref{quint_univ}\\) as follows:  \n\n\\[D\\_A\\_A\\_D\\_\\textcolor{magenta}{DuCuRu}\\textcolor{green}{DyAy}\\]\n\n \n\n\nMARK_COMPCONFIG: The last complete configuration of \\(T_n\\) as\ncomputed by U is marked into four regions: the configuration\n\\(q_{CC,i}S_{CC,j}\\) itself is left unmarked; the symbol just\npreceding it is marked with an x and the remaining symbols to\nthe left or marked with v. Finally, all symbols to the right,\nif any, are marked with w and a \u201c:\u201d is printed to\nthe right of the rightmost symbol in order to indicate the beginning\nof the next complete configuration of \\(T_n\\) to be computed by\nU. Continuing with our example, \\(\\eqref{CC_univ}\\) will be\nmarked as follows by U:  \n\n\\[\\textcolor{red}{\\underbrace{Dv}_{S_0}\\underbrace{DvCv}_{S_1}}\\textcolor{blue}{\\underbrace{Dx}_{S_0}}\\underbrace{D\\_A\\_A\\_}_{q_2}\\underbrace{D\\_}_{S_0}:\\_\\]\n\n\nU then goes to PRINT\nPRINT. It is determined if, in the instructions that have been\nmarked in MARK_OPERATIONS, there is an operation Print 0 or Print 1.\nIf that is the case, \\(0:\\) respectively \\(1:\\) is printed to the\nright of the last complete configuration. This is not a necessary\nfunction but Turing insisted on having U print out not just the\n(coded) complete configurations computed by \\(T_n\\) but also the\nactual (binary) real number computed by \\(T_n\\).\n\n\nPRINT_COMPLETE_CONFIGURATION. U prints the next complete\nconfiguration and erases all marks u, v, w, x, y. It then\nreturns to FIND_NEXT_STATE. U first searches for the rightmost\nletter u, to check which move is needed (R, L, N) and\nerases the mark u for R, L, N. Depending on the value\nL, R or N will then write down the next complete\nconfiguration by applying COPY\\(_5\\) to u, v, w, x, y. The move\noperation (L, R, N) is accounted for by the particular\ncombination of u, v, w, x, y:  \n\n\\[\\begin{array}{ll}\n\\textrm{When ~} L: &\n\\textrm{COPY}_5(\\textrm{FIND}\\_\\textrm{NEXT}\\_\\textrm{STATE},\n\\textcolor{red}{v},\\textcolor{green}{y},\\textcolor{blue}{x},\\textcolor{magenta}{u},\\textcolor{RawSienna}{w})\\\\\n\\textrm{When ~} R: &\n\\textrm{COPY}_5(\\textrm{FIND}\\_\\textrm{NEXT}\\_\\textrm{STATE},\n\\textcolor{red}{v},\\textcolor{blue}{x},\\textcolor{magenta}{u},\\textcolor{green}{y},\\textcolor{RawSienna}{w})\\\\\n\\textrm{When ~} N: &\n\\textrm{COPY}_5(\\textrm{FIND}\\_\\textrm{NEXT}\\_\\textrm{STATE},\n\\textcolor{red}{v},\\textcolor{blue}{x},\\textcolor{green}{y},\\textcolor{magenta}{u},\\textcolor{RawSienna}{w})\n\\end{array}\\] \n\nFollowing our example, since \\(T_{\\textrm{Simple}}\\)\nneeds to move right, the new rightmost complete configursiation of\n\\(T_{\\textrm{Simple}}\\) written on the tape of U is: \n\n\\[\\textcolor{red}{\\underbrace{D\\_}_{S_0}\\underbrace{D\\_C\\_}_{S_1}}\\textcolor{blue}{\\underbrace{D\\_}_{S_0}}\\textcolor{magenta}{\\underbrace{D\\_C\\_}_{S_1}}\\textcolor{green}{\\underbrace{D\\_A\\_}_{q_1}}\n\\]\n\n\nSince we have that for this complete configuration the square being\nscanned by \\(T_{\\textrm{Simple}}\\) is one that was not included in the\nprevious complete configuration (viz. \\(T_{\\textrm{Simple}}\\) has\nreached beyond the rightmost previous point) the complete\nconfiguration as written out by U is in fact incomplete. This\nsmall defect was corrected by Post (Post 1947) by including an additional instruction in the function\nused to mark the complete configuration in the next round.\n\n\nAs is clear, Turing\u2019s universal machine indeed requires that\nprogram and \u2018data\u2019 produced by that program are\nmanipulated interchangeably, viz. the program and its productions are\nput next to each other and treated in the same manner, as sequences of\nletters to be copied, marked, erased and compared.\n\nTuring\u2019s particular construction is quite intricate with its\nreliance on the F and E-squares, the use of a rather\nlarge set of symbols and a rather arcane notation used to describe the\ndifferent functions discussed above. Since 1936 several modifications\nand simplifications have been implemented. The removal of the\ndifference between F and E-squares was already discussed\nin\n Section 1.2\n and it was proven by Shannon that any Turing machine, including the\nuniversal machine, can be reduced to a binary Turing machine (Shannon\n1956). Since the 1950s, there has been quite some research on what\ncould be the smallest possible universal devices (with respect to the\nnumber of states and symbols) and quite some \u201csmall\u201d\nuniversal Turing machines have been found. These results are usually\nachieved by relying on other equivalent models of computability such\nas, for instance, tag systems. For a survey on research into small\nuniversal devices (see Margenstern 2000; Woods & Neary 2009).\n2.4 The Halting Problem and the Entscheidungsproblem\n\nAs explained, the purpose of Turing\u2019s paper was to show that the\nEntscheidungsproblem for first-order logic is not computable. The same\nresult was achieved independently by Church (1936a, 1936b) using a different kind of formal device which is logically\nequivalent to a Turing machine (see\n Sec. 4).\n The result went very much against what Hilbert had hoped to achieve\nwith his finitary and formalist program. Indeed, next to\nG\u00f6del\u2019s incompleteness results, they broke much of\nHilbert\u2019s dream of making mathematics void of\nIgnorabimus and which was explicitly expressed in the\nfollowing words of Hilbert:\n\n\nThe true reason why Comte could not find an unsolvable problem, lies\nin my opinion in the assertion that there exists no unsolvable\nproblem. Instead of the stupid Ignorabimus, our solution should be: We\nmust know. We shall know. (1930: 963) [translation by the author] \n\n\nNote that the solvability Hilbert is referring to here concerns\nsolvability of mathematical problems in general and not just\nmechanically solvable. It is shown however in Mancosu et al. 2009 (p.\n94), that this general aim of solving every mathematical problem,\nunderpins two particular convictions of Hilbert namely that (1) the\naxioms of number theory are complete and (2) that there are no\nundecidable problems in mathematics.\n2.4.1 Direct and indirect proofs of uncomputable decision problems\n\nSo, how can one show, for a particular decision problem\n\\(\\textrm{D}_i\\), that it is not computable? There are two main\nmethods:\n\nIndirect proof: take some problem\n\\(\\textrm{D}_{\\textrm{uncomp}}\\) which is already known to be\nuncomputable and show that the problem \u201creduces\u201d to\n\\(\\textrm{D}_{i}\\).\nDirect proof: prove the uncomputability of\n\\(\\textrm{D}_{i}\\) directly by assuming some version of the\nChurch-Turing thesis.\n\n\nToday, one usually relies on the first method while it is evident that\nin the absence of a problem \\(\\textrm{D}_{\\textrm{uncomp}}\\), Turing\nbut also Church and Post (see\n Sec. 4)\n had to rely on the direct approach.\n\nThe notion of reducibility has its origins in the work of Turing and\nPost who considered several variants of computability (Post 1947;\nTuring 1939). The concept was later appropriated in the context of\ncomputational complexity theory and is today one of the basic concepts\nof both computability and computational complexity theory (Odifreddi\n1989; Sipser 1996). Roughly speaking, a reduction of a problem \\(D_i\\)\nto a problem \\(D_j\\) comes down to providing an effective procedure\nfor translating every instance \\(d_{i,m}\\) of the problem \\(D_i\\) to\nan instance \\(d_{j,n}\\) of \\(D_j\\) in such a way that an effective\nprocedure for solving \\(d_{j,n}\\) also yields an effective procedure\nfor solving \\(d_{i,m}\\). In other words, if \\(D_i\\) reduces to \\(D_j\\)\nthen, if \\(D_i\\) is uncomputable so is \\(D_j\\). Note that the\nreduction of one problem to another can also be used in decidability\nproofs: if \\(D_i\\) reduces to \\(D_j\\) and \\(D_j\\) is known to be\ncomputable then so is \\(D_i\\).\n\nIn the absence of D\\(_{\\textrm{uncomp}}\\) a very\ndifferent approach was required and Church, Post and Turing each used\nmore or less the same approach to this end (Gandy 1988). First of all,\none needs a formalism which captures the notion of computability.\nTuring proposed the Turing machine formalism to this end. A second\nstep is to show that there are problems that are not computable within\nthe formalism. To achieve this, a uniform process U\nneeds to be set-up relative to the formalism which is able to compute\nevery computable number. One can then use (some form of)\ndiagonalization in combination with U to derive a\ncontradiction. Diagonalization was introduced by Cantor to show that\nthe set of real numbers is \u201cuncountable\u201d or not\ndenumerable. A variant of the method was used also by G\u00f6del in\nthe proof of his\n first incompleteness theorem.\n2.4.2 Turing\u2019s basic problem CIRC?, PRINT? and the Entscheidungsproblem\n\nRecall that in Turing\u2019s original version of the Turing machine,\nthe machines are computing real numbers. This implied that a\n\u201cwell-behaving\u201d Turing machine should in fact never halt\nand print out an infinite sequence of figures. Such machines were\nidentified by Turing as circle-free. All other machines are\ncalled circular machines. A number n which is the D.N.\nof a circle-free machine is called satisfactory.\n\nThis basic difference is used in Turing\u2019s proof of the\nuncomputability of:\n\n\nCIRC? The problem to decide for every number n\nwhether or not it is satisfactory\n\n\nThe proof of the uncomputability of CIRC? uses the\nconstruction of a hypothetical and circle-free machine \\(T_{decide}\\)\nwhich computes the diagonal sequence of the set of all computable\nnumbers computed by the circle-free machines. Hence, it relies for its\nconstruction on the universal Turing machine and a hypothetical\nmachine that is able to decide CIRC? for each number\nn given to it. It is shown that the machine \\(T_{decide}\\)\nbecomes a circular machine when it is provided with its own\ndescription number, hence the assumption of a machine which is capable\nof solving CIRC? must be false.\n\nBased on the uncomputability of CIRC?, Turing then\nshows that also PRINT? is not computable. More\nparticularly he shows that if PRINT? were to be\ncomputable, also CIRC? would be decidable, viz. he\nrephrases PRINT? in such a way that it becomes the\nproblem to decide for any machine whether or not it will print an\ninfinity of symbols which would amount to deciding\nCIRC?.\n\nFinally, based on the uncomputability of PRINT?\nTuring shows that the Entscheidungsproblem is not decidable. This is\nachieved by showing:\n\nhow for each Turing machine T, it is possible to construct\na corresponding formula T in first-order logic\nand\nif there is a general method for determining whether\nT is provable, then there is a general method for\nproving that T will ever print 0. This is the problem\nPRINT? and so cannot be decidable (provided we accept\nTuring\u2019s thesis).\n\n\nIt thus follows from the uncomputability of PRINT?,\nthat the Entscheidungsproblem is not computable.\n2.4.3 The halting problem\n\nGiven Turing\u2019s focus on computable real numbers, his base\ndecision problem is about determining whether or not some Turing\nmachine will not halt and so is not quite the same as the\nmore well-known halting problem:\n\n\nHALT? The problem to decide for every Turing\nmachine T whether or not T will halt.\n\n\n\nTuring\u2019s problem PRINT? is in fact very close\nto HALT? (see Davis 1958: Chapter 5, Theorem\n2.3).\n\nA popular proof of HALT? goes as follows. Assume that\nHALT? is computable. Then it should be possible to\nconstruct a Turing machine which decides, for each machine \\(T_i\\) and\nsome input w for \\(T_i\\) whether or not \\(T_i\\) will halt on\nw. Let us call this machine \\(T_{H}\\). More particularly, we\nhave: \n\n\\[\nT_H(T_i,w) = \\left\\{ \n \\begin{array}{ll} \n \\textrm{HALT} & \\textrm{if \\(T_i\\) halts on } w\\\\\n \\textrm{LOOP} & \\textrm{if \\(T_i\\) loops on } w\n \\end{array} \\right.\n\\]\n\n\nWe now define a second machine \\(T_D\\) which relies on the assumption\nthat the machine \\(T_H\\) can be constructed. More particularly, we\nhave:  \n\n\\[\nT_D(T_i,D.N.~of~ T_i) = \\left\\{ \n\\begin{array}{ll} \n \\textrm{HALT} & \\textrm{if \\(T_i\\) does not halt on its own} \\\\\n               & \\qquad \\textrm{description number}\\\\ \n\\textrm{LOOP} & \\textrm{if \\(T_i\\) halts on its own} \\\\\n               & \\qquad \\textrm{description number}\\\\ \n \\end{array} \n\\right.\n\\]\n\n\nIf we now set \\(T_i\\) to \\(T_D\\) we end up with a contradiction: if\n\\(T_D\\) halts it means that \\(T_D\\) does not halt and vice versa. A\npopular but quite informal variant of this proof was given by\nChristopher Strachey in the context of programming (Strachey\n1965).\n2.5 Variations on the Turing machine\n\nAs is clear from\n Sections 1.1\n and\n 1.2,\n there is a variety of definitions of the Turing machine. One can use\na quintuple or quadruple notation; one can have different types of\nsymbols or just one; one can have a two-way infinite or a one-way\ninfinite tape; etc. Several other less obvious modifications have been\nconsidered and used in the past. These modifications can be of two\nkinds: generalizations or restrictions. These do not result in\n\u201cstronger\u201d or \u201cweaker\u201d models. Viz. these\nmodified machines compute no more and no less than the Turing\ncomputable functions. This adds to the robustness of the Turing\nmachine definition.\nBinary machines\n\nIn his short 1936 note Post considers machines that either mark or unmark a square which\nmeans we have only two symbols \\(S_0\\) and \\(S_1\\) but he did not\nprove that this formulation captures exactly the Turing computable\nfunctions. It was Shannon who proved that for any Turing machine\nT with n symbols there is a Turing machine with two\nsymbols that simulates T (Shannon 1956). He also showed that\nfor any Turing machine with m states, there is a Turing machine\nwith only two states that simulates it.\nNon-erasing machines\n\nNon-erasing machines are machines that can only overprint \\(S_0\\). In\nMoore 1952, it was mentioned that Shannon proved that non-erasing\nmachines can compute what any Turing machine computes. This result was\ngiven in a context of actual digital computers of the 50s which relied\non punched tape (and so, for which, one cannot erase). Shannon\u2019s\nresult however remained unpublished. It was Wang who published the\nresult (Wang 1957).\nNon-writing machines\n\nIt was shown by Minsky that for every Turing machine there is a\nnon-writing Turing machine with two tapes that simulates it.\nMultiple tapes\n\nInstead of one tape one can consider a Turing machine with multiple\ntapes. This turned out the be very useful in several different\ncontexts. For instance, Minsky, used two-tape non-writing Turing machines to prove that a certain decision problem defined by Post (the decision problem for tag systems) is\nnon-Turing computable (Minsky 1961). Hartmanis and Stearns then,\nin their founding paper for computational complexity theory, proved\nthat any n-tape Turing machine reduces to a single tape Turing\nmachine and so anything that can be computed by an n-tape or\nmultitape Turing machine can also be computed by a single tape Turing\nmachine, and conversely (Hartmanis & Stearns 1965). They used\nmultitape machines because they were considered to be closer to actual\ndigital computers.\nn-dimensional Turing machines\n\nAnother variant is to consider Turing machines where the tape is not\none-dimensional but n-dimensional. This variant too reduces to\nthe one-dimensional variant.\nNon-deterministic machines\n\nAn apparently more radical reformulation of the notion of Turing\nmachine is that of non-deterministic Turing machines. As explained in\n 1.1,\n one fundamental condition of Turing\u2019s machines is the so-called\ndeterminacy condition, viz. the idea that at any given moment, the\nmachine\u2019s behavior is completely determined by the configuration\nor state it is in and the symbol it is scanning. Next to these, Turing\nalso mentions the idea of choice machines for which the next state is\nnot completely determined by the state and symbol pair. Instead, some\nexternal device makes a random choice of what to do next.\nNon-deterministic Turing machines are a kind of choice machines: for\neach state and symbol pair, the non-deterministic machine makes an\narbitrary choice between a finite (possibly zero) number of states.\nThus, unlike the computation of a deterministic Turing machine, the\ncomputation of a non-deterministic machine is a tree of possible\nconfiguration paths. One way to visualize the computation of a\nnon-deterministic Turing machine is that the machine spawns an exact\ncopy of itself and the tape for each alternative available transition,\nand each machine continues the computation. If any of the machines\nterminates successfully, then the entire computation terminates and\ninherits that machine\u2019s resulting tape. Notice the word\nsuccessfully in the preceding sentence. In this formulation, some\nstates are designated as accepting states and when the\nmachine terminates in one of these states, then the computation is\nsuccessful, otherwise the computation is unsuccessful and any other\nmachines continue in their search for a successful outcome. The\naddition of non-determinism to Turing machines does not alter the\nextent of Turing-computability. Non-determinism was introduced for\nfinite automata in the paper, Rabin & Scott 1959, where it is also\nshown that adding non-determinism does not result in more powerful\nautomata. Non-deterministic Turing machines are an important model in\nthe context of\n computational complexity theory.\nWeak and semi-weak machines\n\nWeak Turing machines are machines where some word over the alphabet is\nrepeated infinitely often to the left and right of the input.\nSemi-weak machines are machines where some word is repeated infinitely\noften either to the left or right of the input. These machines are\ngeneralizations of the standard model in which the initial tape\ncontains some finite word (possibly nil). They were introduced to\ndetermine smaller universal machines. Watanabe was the first to define\na universal semi-weak machine with six states and five symbols\n(Watanabe 1961). Recently, a number of researchers have determined\nseveral small weak and semi-weak universal Turing machines (e.g.,\nWoods & Neary 2007; Cook 2004)\n\nBesides these variants on the Turing machine model, there are also\nvariants that result in models which capture, in some well-defined\nsense, more than the (Turing)-computable functions. Examples of such\nmodels are oracle machines (Turing 1939), infinite-time Turing\nmachines (Hamkins & Lewis 2008) and accelerating Turing machines\n(Copeland 2002). There are various reasons for introducing such\nstronger models. Some are well-known models of computability or\nrecursion theory and are used in the theory of higher-order recursion\nand relative computability (oracle machines); others, like the\naccelerating machines, were introduced in the context of\n supertasks\n and the idea of providing physical models that \u201ccompute\u201d\nfunctions which are not Turing-computable.\n3. Philosophical Issues Related to Turing Machines\n3.1 Human and Machine Computations\n\nIn its original context, Turing\u2019s identification between the\ncomputable numbers and Turing machines was aimed at proving that the\nEntscheidungsproblem is not a computable problem and so not a\nso-called \u201cgeneral process\u201d problem (Turing 1936\u20137:\n248). The basic assumption to be made for this result is that our\n\u201cintuitive\u201d notion of computability can be formally\ndefined as Turing computability and so that there are no\n\u201ccomputable\u201d problems that are not Turing computable. But\nwhat was Turing\u2019s \u201cintuitive\u201d notion of\ncomputability and how can we be sure that it really covers all\ncomputable problems, and, more generally, all kinds of computations?\nThis is a very basic question in the\n philosophy of computer science.\n\nAt the time Turing was writing his paper, the modern computer was not\ndeveloped yet and so rephrasings of Turing\u2019s thesis which\nidentify Turing computability with computability by a modern computer\nare interpretations rather than historically correct statements of\nTuring\u2019s thesis. The existing computing machines at the time\nTuring wrote his paper, such as the differential analyzer or desk\ncalculators, were quite restricted in what they could compute and were\nused in a context of human computational practices (Grier 2007). It is\nthus not surprising that Turing did not attempt to formalize machine\ncomputation but rather human computation and so computable problems in\nTuring\u2019s paper become computable by human means. This is very\nexplicit in Section 9 of Turing 1936\u20137 where he shows that\nTuring machines are a \u2018natural\u2019 model of (human)\ncomputation by analyzing the process of human computation. The\nanalysis results in a kind of abstract human \u2018computor\u2019\nwho fulfills a set of different conditions that are rooted in\nTuring\u2019s recognition of a set of human limitations which\nrestrict what we can compute (of our sensory apparatus but also of our\nmental apparatus). This \u2018computor\u2019 computes (real) numbers\non an infinite one-dimensional tape divided into squares [Note: Turing\nassumed that the reduction of the 2-dimensional character of the paper\na human mathematician usually works on \u201cis not essential of\ncomputation\u201d (Turing 1936\u20137: 249)]. It has the following\nrestrictions (Gandy 1988; Sieg 1994):\n\nDeterminacy condition D \u201cThe behaviour of\nthe computer at any moment is determined by the symbols which he is\nobserving and his \u2018state of mind\u2019 at that moment.\u201d\n(Turing 1936\u20137: 250)\nBoundedness condition B1 \u201cthere is a bound\nB to the number of symbols or squares which the computer can observe\nat one moment. If he wishes to observe more, he must use successive\nobservations.\u201d (Turing 1936\u20137: 250)\nBoundedness condition B2 \u201cthe number of\nstates of mind which need be taken into account is finite\u201d\n(Turing 1936\u20137: 250)\nLocality condition L1 \u201cWe may [\u2026]\nassume that the squares whose symbols are changed are always\n\u2018observed\u2019 squares.\u201d (Turing 1936\u20137: 250)\nLocality condition L2 \u201ceach of the new\nobserved squares is within L squares of an immediately\npreviously observed square.\u201d (Turing 1936\u20137: 250)\n\n\nIt is this so-called \u201cdirect appeal to intuition\u201d\n(1936\u20137: 249) of Turing\u2019s analysis and resulting model\nthat explain why the Turing machine is today considered by many as the\nbest standard model of computability (for a strong statement of this\npoint of view, see Soare 1996). Indeed, from the above set of\nconditions one can quite easily derive Turing\u2019s machines. This\nis achieved basically by analyzing the restrictive conditions into\n\u201c\u2018simple operations\u2019 which are so elementary that it\nis not easy to imagine them further divided\u201d (Turing\n1936\u20137: 250).\n\nNote that while Turing\u2019s analysis focuses on human computation,\nthe application of his identification between (human) computation and\nTuring machine computation to the Entscheidungsproblem suggests that\nhe did not consider the possibility of a model of computation\nthat somehow goes \u201cbeyond\u201d human computation and is\ncapable of providing an effective and general procedure which solves\nthe Entscheidungsproblem. If that would have been the case, he would\nnot have considered the Entscheidungsproblem to be uncomputable.\n\nThe focus on human computation in Turing\u2019s analysis of\ncomputation, has led researchers to extend Turing\u2019s analysis to\ncomputation by physical devices. This results in (versions of) the\nphysical Church-Turing thesis. Robin Gandy focused on extending\nTuring\u2019s analysis to discrete mechanical devices (note that he\ndid not consider analog machines). More particularly, like Turing,\nGandy starts from a basic set of restrictions of computation by\ndiscrete mechanical devices and, on that basis, develops a new model\nwhich he proved to be reducible to the Turing machine model. This work\nis continued by Wilfried Sieg who proposed the framework of Computable\nDynamical Systems (Sieg 2008). Others have considered the possibility\nof \u201creasonable\u201d models from physics which\n\u201ccompute\u201d something that is not Turing computable. See for\ninstance Aaronson, Bavarian, & Gueltrini 2016 (Other Internet\nResources) in which it is shown that if closed timelike curves\nwould exist, the halting problem would become solvable with finite\nresources. Others have proposed alternative models for computation\nwhich are inspired by the Turing machine model but capture specific\naspects of current computing practices for which the Turing machine\nmodel is considered less suited. One example here are the persistent\nTuring machines intended to capture interactive processes. Note\nhowever that these results do not show that there are\n\u201ccomputable\u201d problems that are not Turing\ncomputable. These and other related proposals have been considered by\nsome authors as reasonable models of computation that somehow compute\nmore than Turing machines. It is the latter kind of statements that\nbecame affiliated with research on so-called hypercomputation\nresulting in the early 2000s in a rather fierce debate in the computer\nscience community, see, e.g., Teuscher 2004 for various positions.\n3.2 Thesis, Definition, Axioms or Theorem\n\nAs is clear, strictly speaking, Turing\u2019s thesis is not provable,\nsince, in its original form, it is a claim about the relationship\nbetween a formal and a vague or intuitive concept. By consequence,\nmany consider it as a thesis or a definition. The thesis would be\nrefuted if one would be able to provide an intuitively acceptable\neffective procedure for a task that is not Turing-computable. This\nfar, no such counterexample has been found. Other independently\ndefined notions of computability based on alternative foundations,\nsuch as\n recursive functions\n and abacus machines have also been shown to be equivalent to Turing\ncomputability. These equivalences between quite different formulations\nindicate that there is a natural and robust notion of computability\nunderlying our understanding. Given this apparent robustness of our\nnotion of computability, some have proposed to avoid the notion of a\nthesis altogether and instead propose a set of axioms used to sharpen\nthe informal notion. There are several approaches, most notably, an\napproach of structural axiomatization where computability itself is\naxiomatized (Sieg 2008) and one whereby an axiomatization is given\nfrom which the Church-Turing thesis can be derived (Dershowitz &\nGurevich 2008).\n4. Alternative Historical Models of Computability\n\nBesides the Turing machine, several other models were introduced\nindependently of Turing in the context of research into the foundation\nof mathematics which resulted in theses that are logically equivalent\nto Turing\u2019s thesis. For each of these models it was proven that\nthey capture the Turing computable functions. Note that the\ndevelopment of the modern computer stimulated the development of other\nmodels such as register machines or Markov algorithms. More recently,\ncomputational approaches in disciplines such as biology or physics,\nresulted in bio-inspired and physics-inspired models such as Petri\nnets or quantum Turing machines. A discussion of such models, however,\nlies beyond the scope of this entry.\n4.1 General Recursive Functions\n\nThe original formulation of general\n recursive functions can be\n found in G\u00f6del 1934, which built on a suggestion by Herbrand. In\n Kleene 1936 a simpler definition was given and in Kleene 1943 the\n standard form which uses the so-called minimization or\n \\(\\mu\\)-operator was introduced. For more information, see the entry\n on\n recursive functions.\n\nChurch used the definition of general recursive functions to state his\nthesis:\n\n\nChurch\u2019s thesis Every effectively calculable\nfunction is general recursive\n\n\nIn the context of recursive function one uses the notion of recursive\nsolvability and unsolvability rather than Turing computability and\nuncomputability. This terminology is due to Post (1944).\n4.2 \u03bb-Definability\n\nChurch\u2019s \u03bb-calculus has its origin in the papers (Church\n1932, 1933) and which were intended as a logical foundation for\nmathematics. It was Church\u2019s conviction at that time that this\ndifferent formal approach might avoid G\u00f6del incompleteness (Sieg\n1997: 177). However, the logical system proposed by Church was proven\ninconsistent by his two PhD students Stephen C. Kleene and Barkley\nRosser and so they started to focus on a subpart of that logic which\nwas basically the \u03bb-calculus. Church, Kleene and Rosser started\nto \u03bb-define any calculable function they could think of and\nquite soon Church proposed to define effective calculability in terms\nof \u03bb-definability. However, it was only after Church, Kleene\nand Rosser had established that general recursiveness and\n\u03bb-definability are equivalent that Church announced his thesis\npublicly and in terms of general recursive functions rather than\n\u03bb-definability (Davis 1982; Sieg 1997).\n\nIn \u03bb-calculus there are only two types of symbols. The three\nprimitive symbols \u03bb, (, ) also called the improper symbols, and\nan infinite list of variables. There are three rules to define the\nwell-formed formulas of \u03bb-calculus, called\n\u03bb-formulas.\n\nThe \u03bb-formulas are first of all the variables\nthemselves.\nIf P is a \u03bb-formula containing x as\na free variable then \\(\\lambda x[\\textbf{P}]\\) is also a\n\u03bb-formula. The \u03bb-operator is used to bind variables and\nit thus converts an expression containing free variables into one that\ndenotes a function\nIf M and N are \u03bb-formulas\nthen so is {M}(N), where\n{M}(N) is to be understood as the\napplication of the function M to\nN.\n\n\nThe \u03bb-formulas, or well-formed formulas of \u03bb-calculus\nare all and only those formulas that result from (repeated)\napplication of these three rules.\n\nThere are three operations or rules of conversion. Let us define\n\\(\\textrm{S}_{\\mathbf{N}}^{x}\\mathbf{M}|\\) as standing for the formula\nthat results by substitution of N for x in\nM.\n\nReduction. To replace any part \\(\\{\\lambda x\n\\mathbf{[M]}\\} (\\mathbf{N})\\) of a formula by\n\\(\\textrm{S}_{\\mathbf{N}}^{x}\\mathbf{M}|\\) provided that the bound\nvariables of M are distinct both from x and\nfrom the free variables of N. For example \\(\\{\\lambda\nx [x^{2}]\\}(2)\\) reduces to \\(2^{2}\\)\nExpansion To replace any part\n\\(\\textrm{S}_{\\mathbf{N}}^{x}\\mathbf{M}|\\) of a formula by \\(\\{\\lambda\nx \\mathbf{[M]}\\} (\\mathbf{N})\\) provided that \\(((\\lambda x\n\\mathbf{M}) \\mathbf{N})\\) is well-formed and the bound variables of\nM are distinct both from x and from the free\nvariables in N. For example, \\(2^{2}\\) can be\nexpanded to \\(\\{\\lambda x [x^{2}]\\}(2)\\)\nChange of bound variable To replace any part\nM of a formula by\n\\(\\textrm{S}_{\\textrm{y}}^{x}\\mathbf{M}|\\) provided that x is\nnot a free variable of M and y does not occur\nin M. For example changing \\(\\{\\lambda x [x^{2}]\\}\\)\nto \\(\\{\\lambda y [y^{2}]\\}\\)\n\n\nChurch introduces the following abbreviations to define the natural\nnumbers in \u03bb-calculus:  \n\n\\[\\begin{array}{l}\n1 \\rightarrow \\lambda yx.yx,\\\\\n2 \\rightarrow \\lambda yx.y(yx),\\\\\n3 \\rightarrow \\lambda yx.y(y(yx)),\\\\\n\\ldots \n\\end{array}\\]\n\n\nUsing this definition, it is possible to \u03bb-define\nfunctions over the positive integers. A function F of one\npositive integer is \u03bb-definable if we can find a\n\u03bb-formula F, such that if \\(F(m) = n\\) and\nm and n are \u03bb-formulas\nstanding for the integers m and n, then the\n\u03bb-formula \\(\\{\\mathbf{F}\\} (\\mathbf{m})\\) can be\nconverted to n by applying the conversion\nrules of \u03bb-calculus. Thus, for example, the successor function\nS, first introduced by Church, can be \u03bb-defined as\nfollows:  \n\n\\[S \\rightarrow \\lambda abc. b(abc)\\]\n\n\nTo give an example, applying S to the \u03bb-formula standing\nfor 2, we get:  \n\n\\[\\begin{align}\n\\big(\\lambda abc. b(abc)\\big ) \\big(\\lambda yx. y(yx)\\big) \\\\ \n\\rightarrow \\lambda bc. b\\big( \\big(\\lambda yx. y(yx)\\big) bc\\big)\\\\ \n\\rightarrow \\lambda bc. b\\big( \\big(\\lambda x. b(bx)\\big) c\\big)\\\\ \n\\rightarrow \\lambda bc. b (b(bc))\n\\end{align}\\]\n\n\nToday, \u03bb-calculus is considered to be a basic model in the\ntheory of programming.\n4.3 Post Production Systems\n\nAround 1920\u201321 Emil Post developed different but related types\nof production systems in order to develop a syntactical form which\nwould allow him to tackle the decision problem for first-order logic.\nOne of these forms are Post canonical systems C which became\nlater known as Post production systems.\n\nA canonical system consists of a finite alphabet \\(\\Sigma\\), a finite\nset of initial words \\(W_{0,0}\\), \\(W_{0,1}\\),\u2026, \\(W_{0,n}\\)\nand a finite set of production rules of the following form:\n\n\\[\n\\begin{array}{c}\ng_{11}P_{i_{1}^{1}}g_{12}P_{i_{2}^{1}} \\ldots g_{1m_{1}}P_{i^{1}_{m_{1}}}g_{1 {(m_{1} + 1)}}\\\\\ng_{21}P_{i_{1}^{2}}g_{22}P_{i_{2}^{2}} \\ldots g_{2m_{2}}P_{i^{2}_{m_{2}}}g_{2 {(m_{2} + 1)}}\\\\\n\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\\\\\ng_{k1}P_{i_{1}^{k}}g_{k2}P_{i_{2}^{k}} \\ldots g_{km_{k}}P_{i^{k}_{m_{k}}}g_{k {(m_{k} + 1)}}\\\\\n\\textit{produce}\\\\\ng_{1}P_{i_{1}}g_{2}P_{i_{2}} \\ldots g_{m}P_{i_{m}}g_{(m + 1)}\\\\\n\\end{array}\n\\]\n\n\nThe symbols g are a kind of metasymbols: they correspond to\nactual sequences of letters in actual productions. The symbols\nP are the operational variables and so can represent any\nsequence of letters in a production. So, for instance, consider a\nproduction system over the alphabet \\(\\Sigma = \\{a,b\\}\\) with initial\nword:  \n\n\\[W_0 =  ababaaabbaabbaabbaba\\]\n\n\nand the following production rule: \n\n\\[\n\\begin{array}{c}\nP_{1,1}bbP_{1,2}\\\\\n\\textit{produces}\\\\\nP_{1,3}aaP_{1,4}\\\\\n\\end{array}\n\\]\n\n\nThen, starting with \\(W_0\\), there are three possible ways to apply\nthe production rule and in each application the variables \\(P_{1,i}\\)\nwill have different values but the values of the g\u2019s are fixed.\nAny set of finite sequences of words that can be produced by a\ncanonical system is called a canonical set.\n\nA special class of canonical forms defined by Post are normal systems.\nA normal system N consists of a finite alphabet \\(\\Sigma\\), one\ninitial word \\(W_0 \\in \\Sigma^{\\ast}\\) and a finite set of production\nrules, each of the following form: \n\n\\[\n\\begin{array}{c}\ng_iP\\\\\n\\textit{produces}\\\\\nPg_i'\\\\\n\\end{array}\n\\]\n\n\nAny set of finite sequences of words that can be produced by a normal\nsystem is called a normal set. Post was able to show that for\nany canonical set C over some alphabet \\(\\Sigma\\) there is a\nnormal set N over an alphabet \\(\\Delta\\) with \\(\\Sigma\n\\subseteq \\Delta\\) such that \\(C = N \\cap \\Sigma^{\\ast}\\). It was his\nconviction that (1) any set of finite sequences that can be generated\nby finite means can be generated by canonical systems and (2) the\nproof that for every canonical set there is a normal set which\ncontains it, which resulted in Post\u2019s thesis I:\n\n\nPost\u2019s thesis I (Davis 1982) Every set of\nfinite sequences of letters that can be generated by finite processes\ncan also be generated by normal systems. More particularly, any set of\nwords on an alphabet \\(\\Sigma\\) which can be generated by a finite\nprocess is of the form \\(N \\cap \\Sigma^{\\ast}\\), with N a\nnormal set.\n\n\nPost realized that \u201c[for the thesis to obtain its full\ngenerality] a complete analysis would have to be made of all the\npossible ways in which the human mind could set up finite processes\nfor generating sequences\u201d (Post 1965: 408) and it is quite\nprobable that the formulation 1 given in Post 1936 and which is almost\nidentical to Turing\u2019s machines is the result of such an\nanalysis.\n\nPost production systems became important formal devices in computer\nscience and, more particularly, formal language theory (Davis 1989;\nPullum 2011).\n4.4 Formulation 1\n\nIn 1936 Post published a short note from which one can derive\nPost\u2019s second thesis (De Mol 2013):\n\n\nPost\u2019s thesis II Solvability of a\nproblem in the intuitive sense coincides with solvability by\nformulation 1\n\n\nFormulation 1 is very similar to Turing machines but the\n\u2018program\u2019 is given as a list of directions which a human\nworker needs to follow. Instead of a one-way infinite tape,\nPost\u2019s \u2018machine\u2019 consists of a two-way infinite\nsymbol space divided into boxes. The idea is that a worker is working\nin this symbol space, being capable of a set of five primitive acts\n(\\(O_{1}\\) mark a box, \\(O_{2}\\) unmark a box, \\(O_{3}\\) move one box\nto the left, \\(O_{4}\\) move one box to the right, \\(O_{5}\\)\ndetermining whether the box he is in is marked or unmarked), following\na finite set of directions \\(d_{1}\\),\u2026, \\(d_{n}\\) where each\ndirection \\(d_{i}\\) always has one of the following forms:\n\nPerform one of the operations (\\(O_{1}\\)\u2013\\(O_4\\)) and go to\ninstruction \\(d_{j}\\)\nPerform operation \\(O_{5}\\) and according as the box the worker is\nin is marked or unmarked follow direction \\(d_{j'}\\) or\n\\(d_{j''}\\).\nStop.\n\n\nPost also defined a specific terminology for his formulation 1 in\norder to define the solvability of a problem in terms of formulation\n1. These notions are applicability, finite-1-process, 1-solution and\n1-given. Roughly speaking these notions assure that a decision problem\nis solvable with formulation 1 on the condition that the solution\ngiven in the formalism always terminates with a correct solution.\n5. Impact of Turing Machines on Computer Science\n\nTuring is today one of the most celebrated figures of computer\nscience. Many consider him as the father of computer science and the\nfact that the main award in the computer science community is called\nthe Turing award is a clear indication of that (Daylight 2015). This\nwas strengthened by the Turing centenary celebrations from 2012, which\nwere largely coordinated by S. Barry Cooper. This resulted not only in\nan enormous number of scientific events around Turing but also a\nnumber of initiatives that brought the idea of Turing as the father of\ncomputer science also to the broader public (Bullynck, Daylight, &\nDe Mol 2015). Amongst Turing\u2019s contributions which are today\nconsidered as pioneering, the 1936 paper on Turing machines stands out\nas the one which has the largest impact on computer science. However,\nrecent historical research shows also that one should treat the impact\nof Turing machines with great care and that one should be careful in\nretrofitting the past into the present.\n5.1 Impact on Theoretical Computer Science\n\nToday, the Turing machine and its theory are part of the theoretical\nfoundations of computer science. It is a standard reference in\nresearch on foundational questions such as:\n\nWhat is an algorithm?\nWhat is a computation?\nWhat is a physical computation?\nWhat is an efficient computation?\netc.\n\n\nIt is also one of the main models for research into a broad range of\nsubdisciplines in theoretical computer science such as: variant and\nminimal models of computability, higher-order computability,\n computational complexity theory,\n algorithmic information theory, etc. This significance of the Turing\nmachine model for theoretical computer science has at least two\nhistorical roots.\n\nFirst of all, there is the continuation of the work in mathematical\nlogic from the 1920s and 1930s by people like Martin Davis\u2014who\nis a student of Post and Church\u2014and Kleene. Within that\ntradition, Turing\u2019s work was of course well-known and the Turing\nmachine was considered as the best model of computability given. Both\nDavis and Kleene published a book in the 1950s on these topics (Kleene\n1952; Davis 1958) which soon became standard references not just for\nearly computability theory but also for more theoretical reflections\nin the late 1950s and 1960s on computing.\n\nSecondly, one sees that in the 1950s there is a need for theoretical\nmodels to reflect on the new computing machines, their abilities and\nlimitations and this in a more systematic manner. It is in that\ncontext that the theoretical work already done was picked up. One\nimportant development is automata theory in which one can situate,\namongst others, the development of other machine models like the\nregister machine model or the Wang B machine model which are,\nultimately, rooted in Turing\u2019s and Post\u2019s machines; there\nare the minimal machine designs discussed in\n Section 5.2;\n and there is the use of Turing machines in the context of what would\nbecome the origins of formal language theory, viz the study of\ndifferent classes of machines with respect to the different\n\u201clanguages\u201d they can recognize and so also their\nlimitations and strengths. It are these more theoretical developments\nthat contributed to the establishment of\n computational complexity theory\n in the 1960s. Of course, besides Turing machines, other models also\nplayed and play an important role in these developments. Still, within\ntheoretical computer science it is mostly the Turing machine which\nremains the model, even today. Indeed, when in 1965 one of the\nfounding papers of computational complexity theory (Hartmanis &\nStearns 1965) is published, it is the multitape Turing machine which\nis introduced as the standard model for the computer.\n5.2 Turing Machines and the Modern Computer\n\nIn several accounts, Turing has been identified not just as the father\nof computer science but as the father of the modern computer. The\nclassical story for this more or less goes as follows: the blueprint\nof the modern computer can be found in von Neumann\u2019s EDVAC\ndesign and today classical computers are usually described as having a\nso-called von Neumann architecture. One fundamental idea of the EDVAC\ndesign is the so-called stored-program idea. Roughly speaking this\nmeans the storage of instructions and data in the same memory allowing\nthe manipulation of programs as data. There are good reasons for\nassuming that von Neumann knew the main results of Turing\u2019s\npaper (Davis 1988). Thus, one could argue that the stored-program\nconcept originates in Turing\u2019s notion of the universal Turing\nmachine and, singling this out as the defining feature of the modern\ncomputer, some might claim that Turing is the father of the modern\ncomputer. Another related argument is that Turing was the first who\n\u201ccaptured\u201d the idea of a general-purpose machine through\nhis notion of the universal machine and that in this sense he also\n\u201cinvented\u201d the modern computer (Copeland & Proudfoot\n2011). This argument is then strengthened by the fact that Turing was\nalso involved with the construction of an important class of computing\ndevices (the Bombe) used for decrypting the German Enigma code and\nlater proposed the design of the ACE (Automatic Computing Engine)\nwhich was explicitly identified as a kind of physical realization of\nthe universal machine by Turing himself:\n\n\nSome years ago I was researching on what might now be described as an\ninvestigation of the theoretical possibilities and limitations of\ndigital computing machines. [\u2026] Machines such as the ACE may be\nregarded as practical versions of this same type of machine. (Turing\n1947)\n\n\nNote however that Turing already knew the ENIAC and EDVAC designs and\nproposed the ACE as a kind of improvement on that design (amongst\nothers, it had a simpler hardware architecture).\n\nThese claims about Turing as the inventor and/or father of the\ncomputer have been scrutinized by some historians of computing\n(Daylight 2014; Haigh 2013; Haigh 2014; Mounier-Kuhn 2012), mostly in the wake of the Turing centenary and\nthis from several perspectives. Based on that research it is clear\nthat claims about Turing being the inventor of the modern computer\ngive a distorted and biased picture of the development of the modern\ncomputer. At best, he is one of the many who made a contribution to\none of the several historical developments (scientific, political,\ntechnological, social and industrial) which resulted, ultimately, in\n(our concept of) the modern computer. Indeed, the \u201cfirst\u201d\ncomputers are the result of a wide number of innovations and so are\nrooted in the work of not just one but several people with diverse\nbackgrounds and viewpoints.\n\nIn the 1950s then the (universal) Turing machine starts to become an\naccepted model in relation to actual computers and is used as a tool\nto reflect on the limits and potentials of general-purpose computers\nby both engineers, mathematicians and logicians. More particularly,\nwith respect to machine designs, it was the insight that only a few\nnumber of operations were required to built a general-purpose machine\nwhich inspired in the 1950s reflections on minimal machine\narchitectures. Frankel, who (partially) constructed the MINAC stated\nthis as follows:\n\n\nOne remarkable result of Turing\u2019s investigation is that he was\nable to describe a single computer which is able to compute\nany computable number. He called this machine a universal\ncomputer. It is thus the \u201cbest possible\u201d computer\nmentioned.\n\n[\u2026] This surprising result shows that in examining the question\nof what problems are, in principle, solvable by computing machines, we\ndo not need to consider an infinite series of computers of greater and\ngreater complexity but may think only of a single machine. \n\nEven more surprising than the theoretical possibility of such a\n\u201cbest possible\u201d computer is the fact that it need not be\nvery complex. The description given by Turing of a universal computer\nis not unique. Many computers, some of quite modest complexity,\nsatisfy the requirements for a universal computer. (Frankel 1956:\n635)\n\n\nThe result was a series of experimental machines such as the MINAC,\nTX-0 (Lincoln Lab) or the ZERO machine (van der Poel) which in their\nturn became predecessors of a number of commercial machines. It is\nworth pointing out that also Turing\u2019s ACE machine design fits\ninto this philosophy. It was also commercialized as the BENDIX G15\nmachine (De Mol, Bullynck, & Daylight 2018).\n\nOf course, by minimizing the machine instructions, coding or\nprogramming became a much more complicated task. To put it in\nTuring\u2019s words who clearly realized this trade-off between code\nand (hard-wired) instructions when designing the ACE: \u201c[W]e have\noften simplified the circuit at the expense of the code\u201d (Turing\n1947).\nAnd indeed, one sees that with these early minimal designs, much\neffort goes into developing more efficient coding strategies. It is\nhere that one can also situate one historical root of making the\nconnection between the universal Turing machine and the important\nprinciple of the interchangeability between hardware and programs.\n\nToday, the universal Turing machine is by many still considered as the\nmain theoretical model of the modern computer especially in relation\nto the so-called von Neumann architecture. Of course, other models\nhave been introduced for other architectures such as the Bulk\nsynchronous parallel model for parallel machines or the persistent\nTuring machine for modeling interactive problems.\n5.3 Theories of Programming\n\nThe idea that any general-purpose machine can, in principle, be\nmodeled as a universal Turing machine also became an important\nprinciple in the context of automatic programming in the 1950s\n(Daylight 2015). In the machine design context it was the minimizing\nof the machine instructions that was the most important consequence of\nthat viewpoint. In the programming context then it was about the idea\nthat one can built a machine that is able to\n\u2018mimic\u2019\u2019 the behavior of any other machine and so,\nultimately, the interchangeability between machine hardware and\nlanguage implementations. This is introduced in several forms in the\n1950s by people like John W. Carr III and Saul Gorn\u2014who were\nalso actively involved in the shaping of the Association for\nComputing Machinery (ACM)\u2014as the unifying theoretical idea\nfor automatic programming which indeed is about the (automatic)\n\u201ctranslation\u201d of higher-order to lower-level, and,\nultimately, machine code. Thus, also in the context of programming,\nthe universal Turing machine starts to take on its foundational role\nin the 1950s (Daylight 2015).\n\nWhereas the Turing machine is and was a fundamental theoretical model\ndelimiting what is possible and not on the general level, it did not\nhave a real impact on the syntax and semantics of programming\nlanguages. In that context it were rather \u03bb-calculus and Post\nproduction systems that had an effect (though also here one should be\ncareful in overstating the influence of a formal model on a\nprogramming practice). In fact, Turing machines were often regarded as\nmachine models rather than as a model for programming:\n\n\nTuring machines are not conceptually different from the automatic\ncomputers in general use, but they are very poor in their control\nstructure. [\u2026] Of course, most of the theory of computability\ndeals with questions which are not concerned with the particular ways\ncomputations are represented. It is sufficient that computable\nfunctions be represented somehow by symbolic expressions, e.g.,\nnumbers, and that functions computable in terms of given functions be\nsomehow represented by expressions computable in terms of the\nexpressions representing the original functions. However, a practical\ntheory of computation must be applicable to particular algorithms.\n(McCarthy 1963: 37)\n\n\nThus one sees that the role of the Turing machine for computer science\nshould be situated rather on the theoretical level: the universal\nmachine is today by many still considered as the model for the modern\ncomputer while its ability to mimic machines through its manipulation\nof programs-as-data is one of the basic principles of modern\ncomputing. Moreover, its robustness and naturalness as a model of\ncomputability have made it the main model to challenge if one is\nattacking versions of the so-called (physical) Church-Turing\nthesis.\n",
    "bibliography": {
        "categories": [],
        "cat_ref_text": {
            "ref_list": [
                "Barwise, Jon and John Etchemendy, 1993, <em>Turing\u2019s\nWorld</em>, Stanford, CA: CSLI Publications.",
                "Boolos, George S. and Richard C. Jeffrey, 1974, <em>Computability\nand Logic</em>, Cambridge: Cambridge University Press; fifth edition\n2007. doi:10.1017/CBO9780511804076 (fifth edition)",
                "Bromley, Allan G., 1985, \u201cStored Program Concept. The Origin\nof the Stored Program Concept\u201d, Technical Report 274, Basser\nDepartment of Computer Science, November 1985.\n [<a href=\"https://web.archive.org/web/20171002030127/http://sydney.edu.au/engineering/it/research/tr/tr274.pdf\" target=\"other\">Bromley 1985 available online</a>]",
                "Bullynck, Maarten, Edgar G. Daylight, and Liesbeth De Mol, 2015,\n\u201cWhy Did Computer Science Make a Hero Out of Turing?\u201d,\n<em>Communications of the ACM</em>, 58(3):\n37\u201339.doi:10.1145/2658985",
                "Church, Alonzo, 1932, \u201cA Set of Postulates for the\nFoundation of Logic\u201d, <em>Annals of Mathematics</em>, 33(2):\n346\u2013366. doi:10.2307/1968337",
                "\u2013\u2013\u2013, 1933, \u201cA Set of Postulates for the\nFoundation of Logic (Second Paper)\u201d, <em>Annals of\nMathematics</em>, 34(4): 839\u2013864. doi:10.2307/1968702",
                "\u2013\u2013\u2013, 1936a, \u201cAn Unsolvable Problem of\nElementary Number Theory\u201d, <em>American Journal of\nMathematics</em>, 58(2): 345\u2013363.",
                "\u2013\u2013\u2013, 1936b, \u201cA Note on the\nEntscheidungsproblem\u201d, <em>Journal of Symbolic Logic</em>, 1(1):\n40\u201341. doi:10.2307/2269326",
                "\u2013\u2013\u2013, 1937, \u201cReview of: On Computable\nNumbers with An Application to the Entscheidungsproblem by A.M.\nTuring\u201d, <em>Journal of Symbolic Logic</em>, 2(1): 42\u201343.\ndoi:10.1017/S002248120003958X",
                "Cook, Matthew, 2004, \u201cUniversality in Elementary Cellular\nAutomata\u201d, <em>Complex Systems</em>, 15(1): 1\u201340.",
                "Cooper, S. Barry and Jan Van Leeuwen, 2013, <em>Alan Turing: His\nWork and Impact</em>, Amsterdam: Elsevier.\ndoi:10.1016/C2010-0-66380-2",
                "Copeland, B. Jack, 2002, \u201cAccelerating Turing\nMachines\u201d, <em>Minds and Machines</em>, 12(2): 281\u2013301.\ndoi:10.1023/A:1015607401307",
                "Copeland, B. Jack and Diane Proudfoot, 2011, \u201cAlan Turing:\nFather of the Modern Computer\u201d, <em>The Rutherford Journal</em>,\n4: 1.\n [<a href=\"http://www.rutherfordjournal.org/article040101.html\" target=\"other\">Copeland &amp; Proudfoot 2011 available online</a>]",
                "Davis, Martin, 1958 [1982], <em>Computability and\nUnsolvability</em>, New York: McGraw-Hill. Reprinted Dover, 1982.",
                "\u2013\u2013\u2013, 1965, <em>The Undecidable. Basic papers on\nundecidable propositions, unsolvable problems and computable\nfunctions</em>, New York: Raven Press.",
                "\u2013\u2013\u2013, 1978, \u201cWhat is a Computation?\u201d,\nLynn Arthur Steen (ed.), <em>Mathematics Today: Twelve Informal\nEssays</em>, New York: Springer, pp. 241\u2013267.\ndoi:10.1007/978-1-4613-9435-8_10",
                "\u2013\u2013\u2013, 1982, \u201cWhy G\u00f6del Didn\u2019t\nHave Church\u2019s Thesis\u201d, <em>Information and Control</em>,\n54:(1\u20132): 3\u201324. doi:10.1016/S0019-9958(82)91226-8",
                "\u2013\u2013\u2013, 1988, \u201cMathematical Logic and the\nOrigin of the Modern Computer\u201d, in Herken 1988:\n149\u2013174.",
                "\u2013\u2013\u2013, 1989, \u201cEmil Post\u2019s Contribution\nto Computer Science\u201d, <em>Proceedings of the Fourth Annual\nSymposium on Logic in Computer Science</em>, IEEE Computer Society\nPress, pp. 134\u2013137. doi:10.1109/LICS.1989.39167",
                "Davis, Martin and Wilfried Sieg, 2015, \u201cConceptual\nConfluence in 1936: Post and Turing\u201d, in Giovanni Sommaruga and\nThomas Strahm (eds.), <em>Turing\u2019s Revolution: The Impact of His\nIdeas about Computability</em>, Cham: Springer.\ndoi:10.1007/978-3-319-22156-4_1",
                "Daylight, Edgar G., 2014, \u201cA Turing Tale\u201d,\n<em>Communications of the ACM</em>, 57(10): 36\u201338.\ndoi:10.1145/2629499",
                "\u2013\u2013\u2013, 2015, \u201cTowards a Historical Notion of\n\u2018Turing\u2014The Father of Computer Science\u2019\u201d,\n<em>History and Philosophy of Logic</em>, . 36(3): 205\u2013228.\ndoi:10.1080/01445340.2015.1082050",
                "De Mol, Liesbeth, 2013, \u201cGenerating, Solving and the\nMathematics of Homo Sapiens. Emil Post\u2019s Views On\ncomputation\u201d, Hector Zenil (ed.), <em>A Computable Universe.\nUnderstanding Computation &amp; Exploring Nature As Computation</em>,\nHackensack, NJ: World Scientific, pp. 45\u201362.\ndoi:10.1142/9789814374309_0003\n [<a href=\"https://hal.univ-lille3.fr/hal-01396500/document\" target=\"other\">De Mol 2013 available online</a>]\n ",
                "De Mol, Liesbeth, Maarten Bullynck, and Edgar G. Daylight, 2018,\n\u201cLess is More in the Fifties: Encounters between Logical\nMinimalism and Computer Design during the 1950s\u201d, <em>IEEE\nAnnals of the History of Computing</em>, 40(1): 19\u201345.\ndoi:10.1109/MAHC.2018.012171265\n [<a href=\"https://hal.univ-lille3.fr/hal-01345592\" target=\"other\">De Mol et al. 2018 available online</a>]",
                "Deutsch, D., 1985, \u201cQuantum Theory, the Church-Turing\nPrinciple and the Universal Quantum Computer\u201d, <em>Proceedings\nof the Royal Society A</em>, 400(1818): 97\u2013117.\ndoi:10.1098/rspa.1985.0070",
                "Dershowitz, Nachum and Yuri Gurevich, 2008, \u201c A Natural\nAxiomatization of Computability and Proof of Church\u2019s\nThesis\u201d, <em>Bulletin of Symbolic Logic</em>, 14(3):\n299\u2013350.",
                "Frankel, Stanley, 1956, \u201cUseful Applications of a\nMagnetic-Drum Computer\u201d, <em>Electrical Engineering</em>, 75(7):\n634\u201339, doi:10.1109/EE.1956.6442018",
                "Gandy, Robin, 1980, \u201cChurch\u2019s Thesis and Principles\nfor Mechanism\u201d, in Jon Barwise, H. Jerome Keisler, and Kenneth\nKunen (eds.), <em>The Kleene Symposium: Proceedings of the Symposium\nHeld June 18\u201324, 1978 at Madison, Wisconsin, U.S.A.</em>,\n(Studies in Logic and the Foundations of Mathematics, 101), Amsterdam:\nNorth-Holland, pp. 123\u2013148.\ndoi:10.1016/S0049-237X(08)71257-6",
                "\u2013\u2013\u2013, 1988, \u201cThe Confluence of Ideas in\n1936\u201d, in Herken 1988: 55\u2013111.",
                "G\u00f6del, Kurt, 1929, \u201cDie Vollst\u00e4ndigkeit der Axiome\ndes logischen Funktionenkalk\u00fcl\u201d, <em>Monatshefte f\u00fcr\nMathematik und Physik</em>, 37: 349\u2013360.\ndoi:10.1007/BF01696781",
                "\u2013\u2013\u2013, 1934, \u201cOn Undecidable Propositions of\nFormal Mathematical Systems\u201d, mimeographed lecture notes by\nS. C.  Kleene and J. B. Rosser, Institute for Advanced Study,\nPrinceton, NJ; corrected and amplified in Davis 1965:\n41\u201374.",
                "Grier, David Alan, 2007, <em>When Computers Were Human</em>,\nPrinceton, NJ: Princeton University Press.",
                "Haigh, Thomas, 2013, \u201c\u2018Stored Program\nConcept\u2019 Considered Harmful: History and Historiography\u201d,\nin Paola Bonizzoni, Vasco Brattka, and Benedikt L\u00f6we, <em>The\nNature of Computation. Logic, Algorithms, Applications: 9th Conference\non Computability in Europe, CiE 2013, Milan, Italy, July 1\u20135,\n2013 Proceedings</em>, (Lecture Notes in Computer Science, 7921),\nBerlin: Springer, pp. 241\u2013251.\ndoi:10.1007/978-3-642-39053-1_28",
                "\u2013\u2013\u2013, 2014, \u201cActually, Turing Did Not Invent the\nComputer\u201d, <em>Communications of the ACM</em>, 57(1):\n36\u201341. doi:10.1145/2542504",
                "Hamkins, Joel David and Andy Lewis, 2000, \u201cInfinite Time\nTuring Machines\u201d, <em>Journal of Symbolic Logic</em>, 65(2):\n567\u2013604. doi:10.2307/2586556",
                "Hartmanis, J. and R.E. Stearns, 1965, \u201cOn the Computational\nComplexity of Algorithms\u201d <em>Transactions of the American\nMathematical Society</em>, 117: 285\u2013306.\ndoi:10.1090/S0002-9947-1965-0170805-7",
                "Herken, Rolf, (ed.), 1988, <em>The Universal Turing Machine: A\nHalf-Century Survey</em>, New York: Oxford University Press.",
                "Hilbert, David, 1930, \u201cNaturerkennen und Logik\u201d,\n<em>Naturwissenschaften</em>, 18(47\u201349): 959\u2013963.\ndoi:10.1007/BF01492194",
                "Hilbert, David and Wilhelm Ackermann, 1928, <em>Grundz\u00fcge der\nTheoretischen Logik</em>, Berlin: Springer.\ndoi:10.1007/978-3-642-65400-8",
                "Hodges, Andrew, 1983, <em>Alan Turing: The Enigma</em>, New York:\nSimon and Schuster.",
                "Kleene, Stephen Cole, 1936, \u201cGeneral Recursive Functions of\nNatural Numbers\u201d, <em>Mathematische Annalen</em>, 112:\n727\u2013742. doi:10.1007/BF01565439",
                "\u2013\u2013\u2013, 1943, \u201cRecursive predicates and\nquantifiers\u201d, <em>Transactions of the American Mathematical\nSociety</em>, 53(1): 41\u201373. doi:10.2307/2267986",
                "\u2013\u2013\u2013, 1952, <em>Introduction to\nMetamathematics</em>, Amsterdam: North Holland.",
                "Lambek, Joachim, 1961, \u201cHow to Program an Infinite\nAbacus\u201d, <em>Canadian Mathematical Bulletin</em>, 4:\n295\u2013302. doi:10.4153/CMB-1961-032-6",
                "Lewis, Henry R. and Christos H. Papadimitriou, 1981, <em>Elements\nof the Theory of Computation</em>, Englewood Cliffs, NJ:\nPrentice-Hall.",
                "Lin, Shen and Tibor Rad\u00f3, 1965, \u201cComputer Studies of\nTuring Machine Problems\u201d, <em>Journal of the Association for\nComputing Machinery</em>, 12(2): 196\u2013212.\ndoi:10.1145/321264.321270",
                "Mancosu, Paolo, Richard Zach, and Calixto Badesa, 2009, \u201cThe\nDevelopment of Mathematical Logic from Russell to Tarski,\n1900\u20131935\u201d, in Leila Haaparanta (ed.), <em>The Development\nof Modern Logic</em>, New York: Oxford University Press, pp.\n318\u2013470. doi:10.1093/acprof:oso/9780195137316.003.0029\n [<a href=\"https://ucalgary.ca/rzach/papers/history.html\" target=\"other\">Mancosu et al. 2009 available online</a>]",
                "Margenstern, Maurice, 2000, \u201cFrontier Between Decidability\nand Undecidability: A Survey\u201d, <em>Theoretical Computer\nScience</em>, 231(2): 217\u2013251.\ndoi:10.1016/S0304-3975(99)00102-4",
                "McCarthy, John, 1963, \u201cA Basis for a Mathematical Theory of\nComputation\u201d, in: P. Braffort and D. Hirschberg, <em>Computer\nProgramming and Formal Systems</em>, Amsterdam: North-Holland, pp.\n33\u201370.\n [<a href=\"http://www-formal.stanford.edu/jmc/basis1/basis1.html\" target=\"other\">McCarthy 1963 available online</a>]",
                "Minsky, Marvin, 1961, \u201cRecursive Unsolvability of Post's\nProblem of \u2018Tag\u2019 and other Topics in Theory of Turing\nMachines\u201d, <em>Annals of Mathematics</em>, 74(3): 437\u2013455.\ndoi:10.2307/2269716",
                "\u2013\u2013\u2013, 1967, <em>Computation: Finite and Infinite\nMachines</em>, Englewood Cliffs, NJ: Prentice Hall.",
                "Moore, E.F., 1952, \u201cA simplified universal Turing\nmachine\u201d, <em>Proceedings of the Association of Computing\nMachinery</em> (meetings at Toronto, Ontario), Washington, DC:\nSauls Lithograph,  50\u201355. doi:10.1145/800259.808993",
                "Mounier-Kuhn, Pierre, 2012, \u201cLogic and Computing in France:\nA Late Convergence\u201d, in <em>AISB/IACAP World Congress 2012:\nHistory and Philosophy of Programming</em>, University of Birmingham,\n2-6 July 2012.\n [<a href=\"https://www.academia.edu/5252629/Logic_and_Computing_in_France_A_Late_Convergence\" target=\"other\">Mounier-Kuhn 2012 available online</a>]",
                "Odifreddi, P., 1989, <em>Classical Recursion Theory</em>,\nAmsterdam: Elsevier.",
                "Petzold, Charles, 2008, <em>The Annotated Turing: A Guided Tour\nThrough Alan Turing\u2019s Historic Paper on Computability and Turing\nMachines</em>, Indianapolis, IN: Wiley.",
                "Post, Emil L., 1936, \u201cFinite Combinatory\nProcesses-Formulation 1\u201d, <em>Journal of Symbolic Logic</em>,\n1(3): 103\u2013105. doi:10.2307/2269031",
                "\u2013\u2013\u2013, 1944, \u201cRecursively Enumerable Sets of\nPositive Integers and Their Decision Problems\u201d, <em>Bulletin of\nthe American Mathematical Society</em>, 50(5): 284\u2013316.\n [<a href=\"https://projecteuclid.org/euclid.bams/1183505800\" target=\"other\">Post 1944 available online</a>]",
                "\u2013\u2013\u2013, 1947, \u201cRecursive Unsolvability of a\nProblem of Thue\u201d, <em>Journal of Symbolic Logic</em>, 12(1):\n1\u201311. doi:10.2307/2267170",
                "\u2013\u2013\u2013, 1965, \u201cAbsolutely Unsolvable Problems\nand Relatively Undecidable Propositions\u2014Account of an\nAnticipation\u201d, in Martin Davis (ed.), <em>The Undecidable: Basic\nPapers on Undecidable Propositions, Unsolvable Problems and Computable\nFunctions</em>, New York: Raven Press. Corrected republication 2004,\nDover publications, New York, pp. 340\u2013433.",
                "Pullum, Geoffrey K., 2011, \u201cOn the Mathematical Foundations\nof <em>Syntactic Structures</em>\u201d, <em>Journal of Logic,\nLanguage and Information</em>, 20(3): 277\u2013296.\ndoi:10.1007/s10849-011-9139-8",
                "Rabin, M.O. and D. Scott, 1959, \u201cFinite Automata and their\nDecision Problems\u201d, <em>IBM Journal of Research and\nDevelopment</em>, 3(2): 114\u2013125. doi:10.1147/rd.32.0114",
                "Rad\u00f3, Tibor, 1962, \u201cOn Non-Computable\nFunctions\u201d, <em>Bell System Technical Journal</em>, 41(3/May):\n877\u2013884. doi:10.1002/j.1538-7305.1962.tb00480.x",
                "Shannon, Claude E., 1956, \u201cA Universal Turing Machine with\nTwo Internal States\u201d, in Shannon &amp; McCarthy 1956:\n157\u2013165. doi:10.1515/9781400882618-007",
                "Shannon, Claude E. and John McCarthy (eds), 1956, <em>Automata\nStudies</em>, (Annals of Mathematics Studies, 34), Princeton:\nPrinceton University Press.",
                "Shapiro, Stewart, 2007, \u201cComputability, Proof, and\nOpen-Texture\u201d, in Adam Olszewski, Jan Wolenski, and Robert\nJanusz (eds.), <em>Church\u2019s Thesis After 70 years</em>, Berlin:\nOntos Verlag, pp. 420\u2013455. doi:10.1515/9783110325461.420",
                "Sieg, Wilfried, 1994, \u201cMechanical Procedures and\nMathematical Experience\u201d, in Alexander George (ed.),\n<em>Mathematics and Mind</em>, Oxford: Oxford University Press, pp.\n71\u2013117.",
                "\u2013\u2013\u2013, 1997, \u201cStep by Recursive Step:\nChurch\u2019s Analysis of Effective Calculability\u201d, <em>The\nBulletin of Symbolic Logic</em>, 3(2): 154\u2013180.\ndoi:10.2307/421012",
                "\u2013\u2013\u2013, 2008, \u201cChurch without Dogma: Axioms\nfor Computability\u201d, in S. Barry Cooper, Benedikt L\u00f6we, and\nAndrea Sorbi (eds.), <em>New Computational Paradigms: Changing\nConceptions of What is Computable</em>, New York: Springer Verlag, pp.\n139\u2013152. doi:10.1007/978-0-387-68546-5_7",
                "Sipser, Michael, 1996, <em>Introduction to the Theory of\nComputation</em>, Boston: PWS Publishing.",
                "Soare, Robert I., 1996, \u201cComputability and Recursion\u201d,\n<em>Bulletin for Symbolic Logic</em>, 2(3): 284\u2013321.\ndoi:10.2307/420992",
                "Strachey, Christopher, 1965, \u201cAn Impossible Program (letter\nto the editor )\u201d, <em>The Computer Journal</em>, 7(4): 313.\ndoi:10.1093/comjnl/7.4.313",
                "Teuscher, Christof (ed.), 2004, <em>Alan Turing: Life and Legacy\nof a Great Thinker</em>, Berlin: Springer.\ndoi:10.1007/978-3-662-05642-4",
                "Turing, A.M., 1936\u20137, \u201cOn Computable Numbers, With an\nApplication to the Entscheidungsproblem\u201d, <em>Proceedings of the\nLondon Mathematical Society</em>, s2-42: 230\u2013265; correction\n<em>ibid</em>., s2-43: 544\u2013546 (1937).\ndoi:10.1112/plms/s2-42.1.230 and doi:10.1112/plms/s2-43.6.544 ",
                "\u2013\u2013\u2013, 1937, \u201cComputability and\n\u03bb-Definability\u201d, <em>Journal of Symbolic Logic</em>,\n2(4): 153\u2013163. doi:10.2307/2268280",
                "\u2013\u2013\u2013, 1939, \u201cSystems of Logic Based on\nOrdinals\u201d, <em>Proceedings of the London Mathematical\nSociety</em>, s2-45: 161\u2013228. doi:10.1112/plms/s2-45.1.161",
                "\u2013\u2013\u2013, 1947 [1986], \u201cLecture to the London\nMathematical Society on 20 February 1947\u201d, reprinted in <em>A M.\nTuring's ACE Report of 1946 and Other Papers: Papers by Alan Turing\nand Michael Woodger</em>, (Charles Babbage Institute Reprint, 10),\nB.E. Carpenter and R.W. Doran (eds.), Cambridge, MA: MIT Press,\n1986.",
                "\u2013\u2013\u2013, 1954, \u201cSolvable and Unsolvable\nProblems\u201d, <em>Science News</em>, (February, Penguin), 31:\n7\u201323.",
                "Wang, Hao, 1957, \u201cA Variant to Turing\u2019s Theory of\nComputing Machines\u201d, <em>Journal of the ACM</em>, 4(1):\n63\u201392. doi:10.1145/320856.320867",
                "Watanabe, Shigeru, 1961, \u201c5-Symbol 8-State and 5-Symbol\n6-State Universal Turing Machines\u201d, <em>Journal of the ACM</em>,\n8(4): 476\u2013483. doi:10.1145/321088.321090",
                "Woods, Damien and Turlough Neary, 2007, \u201cSmall Semi-Weakly\nUniversal Turing Machines\u201d, in J\u00e9r\u00f4me Durand-Lose\nand Maurice Margenstern (eds.), <em>Machines, Computations, and\nUniversality: 5th International Conference, MCU 2007 Orl\u00e9ans,\nFrance, September 10\u201313, 2007</em>, (Lecture Notes in Computer\nScience, 4664), Berlin: Springer, pp. 303\u2013315.\ndoi:10.1007/978-3-540-74593-8_26",
                "\u2013\u2013\u2013, 2009, \u201cThe Complexity of Small\nUniversal Turing Machines: A Survey\u201d, <em>Theoretical Computer\nScience</em>, 410(4\u20135): 443\u2013450.\ndoi:10.1016/j.tcs.2008.09.051"
            ]
        },
        "raw_text": "<div id=\"bibliography\">\n<h2 id=\"Bib\">Bibliography</h2>\n<ul class=\"hanging\">\n<li>Barwise, Jon and John Etchemendy, 1993, <em>Turing\u2019s\nWorld</em>, Stanford, CA: CSLI Publications.</li>\n<li>Boolos, George S. and Richard C. Jeffrey, 1974, <em>Computability\nand Logic</em>, Cambridge: Cambridge University Press; fifth edition\n2007. doi:10.1017/CBO9780511804076 (fifth edition)</li>\n<li>Bromley, Allan G., 1985, \u201cStored Program Concept. The Origin\nof the Stored Program Concept\u201d, Technical Report 274, Basser\nDepartment of Computer Science, November 1985.\n [<a href=\"https://web.archive.org/web/20171002030127/http://sydney.edu.au/engineering/it/research/tr/tr274.pdf\" target=\"other\">Bromley 1985 available online</a>]</li>\n<li>Bullynck, Maarten, Edgar G. Daylight, and Liesbeth De Mol, 2015,\n\u201cWhy Did Computer Science Make a Hero Out of Turing?\u201d,\n<em>Communications of the ACM</em>, 58(3):\n37\u201339.doi:10.1145/2658985</li>\n<li>Church, Alonzo, 1932, \u201cA Set of Postulates for the\nFoundation of Logic\u201d, <em>Annals of Mathematics</em>, 33(2):\n346\u2013366. doi:10.2307/1968337</li>\n<li>\u2013\u2013\u2013, 1933, \u201cA Set of Postulates for the\nFoundation of Logic (Second Paper)\u201d, <em>Annals of\nMathematics</em>, 34(4): 839\u2013864. doi:10.2307/1968702</li>\n<li>\u2013\u2013\u2013, 1936a, \u201cAn Unsolvable Problem of\nElementary Number Theory\u201d, <em>American Journal of\nMathematics</em>, 58(2): 345\u2013363.</li>\n<li>\u2013\u2013\u2013, 1936b, \u201cA Note on the\nEntscheidungsproblem\u201d, <em>Journal of Symbolic Logic</em>, 1(1):\n40\u201341. doi:10.2307/2269326</li>\n<li>\u2013\u2013\u2013, 1937, \u201cReview of: On Computable\nNumbers with An Application to the Entscheidungsproblem by A.M.\nTuring\u201d, <em>Journal of Symbolic Logic</em>, 2(1): 42\u201343.\ndoi:10.1017/S002248120003958X</li>\n<li>Cook, Matthew, 2004, \u201cUniversality in Elementary Cellular\nAutomata\u201d, <em>Complex Systems</em>, 15(1): 1\u201340.</li>\n<li>Cooper, S. Barry and Jan Van Leeuwen, 2013, <em>Alan Turing: His\nWork and Impact</em>, Amsterdam: Elsevier.\ndoi:10.1016/C2010-0-66380-2</li>\n<li>Copeland, B. Jack, 2002, \u201cAccelerating Turing\nMachines\u201d, <em>Minds and Machines</em>, 12(2): 281\u2013301.\ndoi:10.1023/A:1015607401307</li>\n<li>Copeland, B. Jack and Diane Proudfoot, 2011, \u201cAlan Turing:\nFather of the Modern Computer\u201d, <em>The Rutherford Journal</em>,\n4: 1.\n [<a href=\"http://www.rutherfordjournal.org/article040101.html\" target=\"other\">Copeland &amp; Proudfoot 2011 available online</a>]</li>\n<li>Davis, Martin, 1958 [1982], <em>Computability and\nUnsolvability</em>, New York: McGraw-Hill. Reprinted Dover, 1982.</li>\n<li>\u2013\u2013\u2013, 1965, <em>The Undecidable. Basic papers on\nundecidable propositions, unsolvable problems and computable\nfunctions</em>, New York: Raven Press.</li>\n<li>\u2013\u2013\u2013, 1978, \u201cWhat is a Computation?\u201d,\nLynn Arthur Steen (ed.), <em>Mathematics Today: Twelve Informal\nEssays</em>, New York: Springer, pp. 241\u2013267.\ndoi:10.1007/978-1-4613-9435-8_10</li>\n<li>\u2013\u2013\u2013, 1982, \u201cWhy G\u00f6del Didn\u2019t\nHave Church\u2019s Thesis\u201d, <em>Information and Control</em>,\n54:(1\u20132): 3\u201324. doi:10.1016/S0019-9958(82)91226-8</li>\n<li>\u2013\u2013\u2013, 1988, \u201cMathematical Logic and the\nOrigin of the Modern Computer\u201d, in Herken 1988:\n149\u2013174.</li>\n<li>\u2013\u2013\u2013, 1989, \u201cEmil Post\u2019s Contribution\nto Computer Science\u201d, <em>Proceedings of the Fourth Annual\nSymposium on Logic in Computer Science</em>, IEEE Computer Society\nPress, pp. 134\u2013137. doi:10.1109/LICS.1989.39167</li>\n<li>Davis, Martin and Wilfried Sieg, 2015, \u201cConceptual\nConfluence in 1936: Post and Turing\u201d, in Giovanni Sommaruga and\nThomas Strahm (eds.), <em>Turing\u2019s Revolution: The Impact of His\nIdeas about Computability</em>, Cham: Springer.\ndoi:10.1007/978-3-319-22156-4_1</li>\n<li>Daylight, Edgar G., 2014, \u201cA Turing Tale\u201d,\n<em>Communications of the ACM</em>, 57(10): 36\u201338.\ndoi:10.1145/2629499</li>\n<li>\u2013\u2013\u2013, 2015, \u201cTowards a Historical Notion of\n\u2018Turing\u2014The Father of Computer Science\u2019\u201d,\n<em>History and Philosophy of Logic</em>, . 36(3): 205\u2013228.\ndoi:10.1080/01445340.2015.1082050</li>\n<li>De Mol, Liesbeth, 2013, \u201cGenerating, Solving and the\nMathematics of Homo Sapiens. Emil Post\u2019s Views On\ncomputation\u201d, Hector Zenil (ed.), <em>A Computable Universe.\nUnderstanding Computation &amp; Exploring Nature As Computation</em>,\nHackensack, NJ: World Scientific, pp. 45\u201362.\ndoi:10.1142/9789814374309_0003\n [<a href=\"https://hal.univ-lille3.fr/hal-01396500/document\" target=\"other\">De Mol 2013 available online</a>]\n </li>\n<li>De Mol, Liesbeth, Maarten Bullynck, and Edgar G. Daylight, 2018,\n\u201cLess is More in the Fifties: Encounters between Logical\nMinimalism and Computer Design during the 1950s\u201d, <em>IEEE\nAnnals of the History of Computing</em>, 40(1): 19\u201345.\ndoi:10.1109/MAHC.2018.012171265\n [<a href=\"https://hal.univ-lille3.fr/hal-01345592\" target=\"other\">De Mol et al. 2018 available online</a>]</li>\n<li>Deutsch, D., 1985, \u201cQuantum Theory, the Church-Turing\nPrinciple and the Universal Quantum Computer\u201d, <em>Proceedings\nof the Royal Society A</em>, 400(1818): 97\u2013117.\ndoi:10.1098/rspa.1985.0070</li>\n<li>Dershowitz, Nachum and Yuri Gurevich, 2008, \u201c A Natural\nAxiomatization of Computability and Proof of Church\u2019s\nThesis\u201d, <em>Bulletin of Symbolic Logic</em>, 14(3):\n299\u2013350.</li>\n<li>Frankel, Stanley, 1956, \u201cUseful Applications of a\nMagnetic-Drum Computer\u201d, <em>Electrical Engineering</em>, 75(7):\n634\u201339, doi:10.1109/EE.1956.6442018</li>\n<li>Gandy, Robin, 1980, \u201cChurch\u2019s Thesis and Principles\nfor Mechanism\u201d, in Jon Barwise, H. Jerome Keisler, and Kenneth\nKunen (eds.), <em>The Kleene Symposium: Proceedings of the Symposium\nHeld June 18\u201324, 1978 at Madison, Wisconsin, U.S.A.</em>,\n(Studies in Logic and the Foundations of Mathematics, 101), Amsterdam:\nNorth-Holland, pp. 123\u2013148.\ndoi:10.1016/S0049-237X(08)71257-6</li>\n<li>\u2013\u2013\u2013, 1988, \u201cThe Confluence of Ideas in\n1936\u201d, in Herken 1988: 55\u2013111.</li>\n<li>G\u00f6del, Kurt, 1929, \u201cDie Vollst\u00e4ndigkeit der Axiome\ndes logischen Funktionenkalk\u00fcl\u201d, <em>Monatshefte f\u00fcr\nMathematik und Physik</em>, 37: 349\u2013360.\ndoi:10.1007/BF01696781</li>\n<li>\u2013\u2013\u2013, 1934, \u201cOn Undecidable Propositions of\nFormal Mathematical Systems\u201d, mimeographed lecture notes by\nS. C.  Kleene and J. B. Rosser, Institute for Advanced Study,\nPrinceton, NJ; corrected and amplified in Davis 1965:\n41\u201374.</li>\n<li>Grier, David Alan, 2007, <em>When Computers Were Human</em>,\nPrinceton, NJ: Princeton University Press.</li>\n<li>Haigh, Thomas, 2013, \u201c\u2018Stored Program\nConcept\u2019 Considered Harmful: History and Historiography\u201d,\nin Paola Bonizzoni, Vasco Brattka, and Benedikt L\u00f6we, <em>The\nNature of Computation. Logic, Algorithms, Applications: 9th Conference\non Computability in Europe, CiE 2013, Milan, Italy, July 1\u20135,\n2013 Proceedings</em>, (Lecture Notes in Computer Science, 7921),\nBerlin: Springer, pp. 241\u2013251.\ndoi:10.1007/978-3-642-39053-1_28</li>\n<li>\u2013\u2013\u2013, 2014, \u201cActually, Turing Did Not Invent the\nComputer\u201d, <em>Communications of the ACM</em>, 57(1):\n36\u201341. doi:10.1145/2542504</li>\n<li>Hamkins, Joel David and Andy Lewis, 2000, \u201cInfinite Time\nTuring Machines\u201d, <em>Journal of Symbolic Logic</em>, 65(2):\n567\u2013604. doi:10.2307/2586556</li>\n<li>Hartmanis, J. and R.E. Stearns, 1965, \u201cOn the Computational\nComplexity of Algorithms\u201d <em>Transactions of the American\nMathematical Society</em>, 117: 285\u2013306.\ndoi:10.1090/S0002-9947-1965-0170805-7</li>\n<li>Herken, Rolf, (ed.), 1988, <em>The Universal Turing Machine: A\nHalf-Century Survey</em>, New York: Oxford University Press.</li>\n<li>Hilbert, David, 1930, \u201cNaturerkennen und Logik\u201d,\n<em>Naturwissenschaften</em>, 18(47\u201349): 959\u2013963.\ndoi:10.1007/BF01492194</li>\n<li>Hilbert, David and Wilhelm Ackermann, 1928, <em>Grundz\u00fcge der\nTheoretischen Logik</em>, Berlin: Springer.\ndoi:10.1007/978-3-642-65400-8</li>\n<li>Hodges, Andrew, 1983, <em>Alan Turing: The Enigma</em>, New York:\nSimon and Schuster.</li>\n<li>Kleene, Stephen Cole, 1936, \u201cGeneral Recursive Functions of\nNatural Numbers\u201d, <em>Mathematische Annalen</em>, 112:\n727\u2013742. doi:10.1007/BF01565439</li>\n<li>\u2013\u2013\u2013, 1943, \u201cRecursive predicates and\nquantifiers\u201d, <em>Transactions of the American Mathematical\nSociety</em>, 53(1): 41\u201373. doi:10.2307/2267986</li>\n<li>\u2013\u2013\u2013, 1952, <em>Introduction to\nMetamathematics</em>, Amsterdam: North Holland.</li>\n<li>Lambek, Joachim, 1961, \u201cHow to Program an Infinite\nAbacus\u201d, <em>Canadian Mathematical Bulletin</em>, 4:\n295\u2013302. doi:10.4153/CMB-1961-032-6</li>\n<li>Lewis, Henry R. and Christos H. Papadimitriou, 1981, <em>Elements\nof the Theory of Computation</em>, Englewood Cliffs, NJ:\nPrentice-Hall.</li>\n<li>Lin, Shen and Tibor Rad\u00f3, 1965, \u201cComputer Studies of\nTuring Machine Problems\u201d, <em>Journal of the Association for\nComputing Machinery</em>, 12(2): 196\u2013212.\ndoi:10.1145/321264.321270</li>\n<li>Mancosu, Paolo, Richard Zach, and Calixto Badesa, 2009, \u201cThe\nDevelopment of Mathematical Logic from Russell to Tarski,\n1900\u20131935\u201d, in Leila Haaparanta (ed.), <em>The Development\nof Modern Logic</em>, New York: Oxford University Press, pp.\n318\u2013470. doi:10.1093/acprof:oso/9780195137316.003.0029\n [<a href=\"https://ucalgary.ca/rzach/papers/history.html\" target=\"other\">Mancosu et al. 2009 available online</a>]</li>\n<li>Margenstern, Maurice, 2000, \u201cFrontier Between Decidability\nand Undecidability: A Survey\u201d, <em>Theoretical Computer\nScience</em>, 231(2): 217\u2013251.\ndoi:10.1016/S0304-3975(99)00102-4</li>\n<li>McCarthy, John, 1963, \u201cA Basis for a Mathematical Theory of\nComputation\u201d, in: P. Braffort and D. Hirschberg, <em>Computer\nProgramming and Formal Systems</em>, Amsterdam: North-Holland, pp.\n33\u201370.\n [<a href=\"http://www-formal.stanford.edu/jmc/basis1/basis1.html\" target=\"other\">McCarthy 1963 available online</a>]</li>\n<li>Minsky, Marvin, 1961, \u201cRecursive Unsolvability of Post's\nProblem of \u2018Tag\u2019 and other Topics in Theory of Turing\nMachines\u201d, <em>Annals of Mathematics</em>, 74(3): 437\u2013455.\ndoi:10.2307/2269716</li>\n<li>\u2013\u2013\u2013, 1967, <em>Computation: Finite and Infinite\nMachines</em>, Englewood Cliffs, NJ: Prentice Hall.</li>\n<li>Moore, E.F., 1952, \u201cA simplified universal Turing\nmachine\u201d, <em>Proceedings of the Association of Computing\nMachinery</em> (meetings at Toronto, Ontario), Washington, DC:\nSauls Lithograph,  50\u201355. doi:10.1145/800259.808993</li>\n<li>Mounier-Kuhn, Pierre, 2012, \u201cLogic and Computing in France:\nA Late Convergence\u201d, in <em>AISB/IACAP World Congress 2012:\nHistory and Philosophy of Programming</em>, University of Birmingham,\n2-6 July 2012.\n [<a href=\"https://www.academia.edu/5252629/Logic_and_Computing_in_France_A_Late_Convergence\" target=\"other\">Mounier-Kuhn 2012 available online</a>]</li>\n<li>Odifreddi, P., 1989, <em>Classical Recursion Theory</em>,\nAmsterdam: Elsevier.</li>\n<li>Petzold, Charles, 2008, <em>The Annotated Turing: A Guided Tour\nThrough Alan Turing\u2019s Historic Paper on Computability and Turing\nMachines</em>, Indianapolis, IN: Wiley.</li>\n<li>Post, Emil L., 1936, \u201cFinite Combinatory\nProcesses-Formulation 1\u201d, <em>Journal of Symbolic Logic</em>,\n1(3): 103\u2013105. doi:10.2307/2269031</li>\n<li>\u2013\u2013\u2013, 1944, \u201cRecursively Enumerable Sets of\nPositive Integers and Their Decision Problems\u201d, <em>Bulletin of\nthe American Mathematical Society</em>, 50(5): 284\u2013316.\n [<a href=\"https://projecteuclid.org/euclid.bams/1183505800\" target=\"other\">Post 1944 available online</a>]</li>\n<li>\u2013\u2013\u2013, 1947, \u201cRecursive Unsolvability of a\nProblem of Thue\u201d, <em>Journal of Symbolic Logic</em>, 12(1):\n1\u201311. doi:10.2307/2267170</li>\n<li>\u2013\u2013\u2013, 1965, \u201cAbsolutely Unsolvable Problems\nand Relatively Undecidable Propositions\u2014Account of an\nAnticipation\u201d, in Martin Davis (ed.), <em>The Undecidable: Basic\nPapers on Undecidable Propositions, Unsolvable Problems and Computable\nFunctions</em>, New York: Raven Press. Corrected republication 2004,\nDover publications, New York, pp. 340\u2013433.</li>\n<li>Pullum, Geoffrey K., 2011, \u201cOn the Mathematical Foundations\nof <em>Syntactic Structures</em>\u201d, <em>Journal of Logic,\nLanguage and Information</em>, 20(3): 277\u2013296.\ndoi:10.1007/s10849-011-9139-8</li>\n<li>Rabin, M.O. and D. Scott, 1959, \u201cFinite Automata and their\nDecision Problems\u201d, <em>IBM Journal of Research and\nDevelopment</em>, 3(2): 114\u2013125. doi:10.1147/rd.32.0114</li>\n<li>Rad\u00f3, Tibor, 1962, \u201cOn Non-Computable\nFunctions\u201d, <em>Bell System Technical Journal</em>, 41(3/May):\n877\u2013884. doi:10.1002/j.1538-7305.1962.tb00480.x</li>\n<li>Shannon, Claude E., 1956, \u201cA Universal Turing Machine with\nTwo Internal States\u201d, in Shannon &amp; McCarthy 1956:\n157\u2013165. doi:10.1515/9781400882618-007</li>\n<li>Shannon, Claude E. and John McCarthy (eds), 1956, <em>Automata\nStudies</em>, (Annals of Mathematics Studies, 34), Princeton:\nPrinceton University Press.</li>\n<li>Shapiro, Stewart, 2007, \u201cComputability, Proof, and\nOpen-Texture\u201d, in Adam Olszewski, Jan Wolenski, and Robert\nJanusz (eds.), <em>Church\u2019s Thesis After 70 years</em>, Berlin:\nOntos Verlag, pp. 420\u2013455. doi:10.1515/9783110325461.420</li>\n<li>Sieg, Wilfried, 1994, \u201cMechanical Procedures and\nMathematical Experience\u201d, in Alexander George (ed.),\n<em>Mathematics and Mind</em>, Oxford: Oxford University Press, pp.\n71\u2013117.</li>\n<li>\u2013\u2013\u2013, 1997, \u201cStep by Recursive Step:\nChurch\u2019s Analysis of Effective Calculability\u201d, <em>The\nBulletin of Symbolic Logic</em>, 3(2): 154\u2013180.\ndoi:10.2307/421012</li>\n<li>\u2013\u2013\u2013, 2008, \u201cChurch without Dogma: Axioms\nfor Computability\u201d, in S. Barry Cooper, Benedikt L\u00f6we, and\nAndrea Sorbi (eds.), <em>New Computational Paradigms: Changing\nConceptions of What is Computable</em>, New York: Springer Verlag, pp.\n139\u2013152. doi:10.1007/978-0-387-68546-5_7</li>\n<li>Sipser, Michael, 1996, <em>Introduction to the Theory of\nComputation</em>, Boston: PWS Publishing.</li>\n<li>Soare, Robert I., 1996, \u201cComputability and Recursion\u201d,\n<em>Bulletin for Symbolic Logic</em>, 2(3): 284\u2013321.\ndoi:10.2307/420992</li>\n<li>Strachey, Christopher, 1965, \u201cAn Impossible Program (letter\nto the editor )\u201d, <em>The Computer Journal</em>, 7(4): 313.\ndoi:10.1093/comjnl/7.4.313</li>\n<li>Teuscher, Christof (ed.), 2004, <em>Alan Turing: Life and Legacy\nof a Great Thinker</em>, Berlin: Springer.\ndoi:10.1007/978-3-662-05642-4</li>\n<li>Turing, A.M., 1936\u20137, \u201cOn Computable Numbers, With an\nApplication to the Entscheidungsproblem\u201d, <em>Proceedings of the\nLondon Mathematical Society</em>, s2-42: 230\u2013265; correction\n<em>ibid</em>., s2-43: 544\u2013546 (1937).\ndoi:10.1112/plms/s2-42.1.230 and doi:10.1112/plms/s2-43.6.544 </li>\n<li>\u2013\u2013\u2013, 1937, \u201cComputability and\n\u03bb-Definability\u201d, <em>Journal of Symbolic Logic</em>,\n2(4): 153\u2013163. doi:10.2307/2268280</li>\n<li>\u2013\u2013\u2013, 1939, \u201cSystems of Logic Based on\nOrdinals\u201d, <em>Proceedings of the London Mathematical\nSociety</em>, s2-45: 161\u2013228. doi:10.1112/plms/s2-45.1.161</li>\n<li>\u2013\u2013\u2013, 1947 [1986], \u201cLecture to the London\nMathematical Society on 20 February 1947\u201d, reprinted in <em>A M.\nTuring's ACE Report of 1946 and Other Papers: Papers by Alan Turing\nand Michael Woodger</em>, (Charles Babbage Institute Reprint, 10),\nB.E. Carpenter and R.W. Doran (eds.), Cambridge, MA: MIT Press,\n1986.</li>\n<li>\u2013\u2013\u2013, 1954, \u201cSolvable and Unsolvable\nProblems\u201d, <em>Science News</em>, (February, Penguin), 31:\n7\u201323.</li>\n<li>Wang, Hao, 1957, \u201cA Variant to Turing\u2019s Theory of\nComputing Machines\u201d, <em>Journal of the ACM</em>, 4(1):\n63\u201392. doi:10.1145/320856.320867</li>\n<li>Watanabe, Shigeru, 1961, \u201c5-Symbol 8-State and 5-Symbol\n6-State Universal Turing Machines\u201d, <em>Journal of the ACM</em>,\n8(4): 476\u2013483. doi:10.1145/321088.321090</li>\n<li>Woods, Damien and Turlough Neary, 2007, \u201cSmall Semi-Weakly\nUniversal Turing Machines\u201d, in J\u00e9r\u00f4me Durand-Lose\nand Maurice Margenstern (eds.), <em>Machines, Computations, and\nUniversality: 5th International Conference, MCU 2007 Orl\u00e9ans,\nFrance, September 10\u201313, 2007</em>, (Lecture Notes in Computer\nScience, 4664), Berlin: Springer, pp. 303\u2013315.\ndoi:10.1007/978-3-540-74593-8_26</li>\n<li>\u2013\u2013\u2013, 2009, \u201cThe Complexity of Small\nUniversal Turing Machines: A Survey\u201d, <em>Theoretical Computer\nScience</em>, 410(4\u20135): 443\u2013450.\ndoi:10.1016/j.tcs.2008.09.051</li>\n</ul>\n</div>"
    },
    "related_entries": {
        "entry_list": [
            "Church-Turing Thesis",
            "computability and complexity",
            "computational complexity theory",
            "recursive functions",
            "Turing, Alan"
        ],
        "entry_link": [
            {
                "../church-turing/": "Church-Turing Thesis"
            },
            {
                "../computability/": "computability and complexity"
            },
            {
                "../computational-complexity/": "computational complexity theory"
            },
            {
                "../recursive-functions/": "recursive functions"
            },
            {
                "../turing/": "Turing, Alan"
            }
        ]
    },
    "academic_tools": {
        "listed_text": [
            "<img alt=\"sep man icon\" src=\"../../symbols/sepman-icon.jpg\"/>",
            "<a href=\"https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=turing-machine\" target=\"other\">How to cite this entry</a>.",
            "<img alt=\"sep man icon\" src=\"../../symbols/sepman-icon.jpg\"/>",
            "<a href=\"https://leibniz.stanford.edu/friends/preview/turing-machine/\" target=\"other\">Preview the PDF version of this entry</a> at the\n <a href=\"https://leibniz.stanford.edu/friends/\" target=\"other\">Friends of the SEP Society</a>.",
            "<img alt=\"inpho icon\" src=\"../../symbols/inpho.png\"/>",
            "<a href=\"https://www.inphoproject.org/entity?sep=turing-machine&amp;redirect=True\" target=\"other\">Look up topics and thinkers related to this entry</a>\n at the Internet Philosophy Ontology Project (InPhO).",
            "<img alt=\"phil papers icon\" src=\"../../symbols/pp.gif\"/>",
            "<a href=\"http://philpapers.org/sep/turing-machine/\" target=\"other\">Enhanced bibliography for this entry</a>\nat <a href=\"http://philpapers.org/\" target=\"other\">PhilPapers</a>, with links to its database."
        ],
        "listed_links": [
            {
                "https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=turing-machine": "How to cite this entry"
            },
            {
                "https://leibniz.stanford.edu/friends/preview/turing-machine/": "Preview the PDF version of this entry"
            },
            {
                "https://leibniz.stanford.edu/friends/": "Friends of the SEP Society"
            },
            {
                "https://www.inphoproject.org/entity?sep=turing-machine&redirect=True": "Look up topics and thinkers related to this entry"
            },
            {
                "http://philpapers.org/sep/turing-machine/": "Enhanced bibliography for this entry"
            },
            {
                "http://philpapers.org/": "PhilPapers"
            }
        ]
    },
    "other_internet_resources": {
        "listed_text": [
            "\u201cTuring Machines\u201d, <em>Stanford Encyclopedia of\nPhilosophy</em> (Fall 2018 Edition), Edward N. Zalta (ed.), URL =\n &lt;<a href=\"http://plato.stanford.edu/archives/fall2018/entries/turing-machine/\" target=\"other\">http://plato.stanford.edu/archives/fall2018/entries/turing-machine/</a>&gt;.\n <span>[</span>This was the previous entry on Turing Machines in the SEP,\nwritten by David Barker-Plummer.<span>]</span>.",
            "Aaronson, Scott, Mohammad Bavarian, and Giulio Gueltrini, 2016,\n \u201c<a href=\"https://arxiv.org/abs/1609.05507\" target=\"other\">Computability Theory of Closed Timelike Curves</a>\u201d, manuscript available at arXiv.org.",
            "<a href=\"https://www.turing.org.uk/turing/\" target=\"other\">The Alan Turing Home Page</a>,\n maintained by Andrew Hodges",
            "<a href=\"https://www.bletchleypark.org.uk/\" target=\"other\">Bletchley Park</a>,\n in the U.K., where, during the Second World War, Alan Turing was\ninvolved in code breaking activities at Station X.",
            "<a href=\"https://web.archive.org/web/20161105013714/http://somos.crg4.com:80/bb.html\" target=\"other\">Michael Somos\u2019 page of Busy Beaver references.</a>",
            "<a href=\"https://www.netfunny.com/rhf/jokes/89q4/halting.760.html\" target=\"other\">Halting problem is solvable (funny)</a>",
            "<a href=\"https://www.turing.org.uk/book/update/tmjavar.html\" target=\"other\">Andrew Hodges\u2019 Turing Machine Simulator</a>\n (for limited number of machines)",
            "<a href=\"http://ironphoenix.org/tril/tm/\" target=\"other\">Suzanne Britton\u2019s Turing Machine Simulator</a>\n (A Java Applet)",
            "<a href=\"http://www.softlookup.com/download.asp?id=2147\" target=\"other\">Visual Turing</a>:\n freeware simulator for Windows 95/98/NT/2000",
            "<a href=\"http://aturingmachine.com/\" target=\"other\">Turing Machine in the Classic Style</a>,\n Mike Davey\u2019s physical Turing machine simulator.",
            "<a href=\"http://legoofdoom.blogspot.com/\" target=\"other\">Lego of Doom</a>,\n Turing machine simulator using Lego\u2122."
        ],
        "listed_links": [
            {
                "http://plato.stanford.edu/archives/fall2018/entries/turing-machine/": "http://plato.stanford.edu/archives/fall2018/entries/turing-machine/"
            },
            {
                "https://arxiv.org/abs/1609.05507": "Computability Theory of Closed Timelike Curves"
            },
            {
                "https://www.turing.org.uk/turing/": "The Alan Turing Home Page"
            },
            {
                "https://www.bletchleypark.org.uk/": "Bletchley Park"
            },
            {
                "https://web.archive.org/web/20161105013714/http://somos.crg4.com:80/bb.html": "Michael Somos\u2019 page of Busy Beaver references."
            },
            {
                "https://www.netfunny.com/rhf/jokes/89q4/halting.760.html": "Halting problem is solvable (funny)"
            },
            {
                "https://www.turing.org.uk/book/update/tmjavar.html": "Andrew Hodges\u2019 Turing Machine Simulator"
            },
            {
                "http://ironphoenix.org/tril/tm/": "Suzanne Britton\u2019s Turing Machine Simulator"
            },
            {
                "http://www.softlookup.com/download.asp?id=2147": "Visual Turing"
            },
            {
                "http://aturingmachine.com/": "Turing Machine in the Classic Style"
            },
            {
                "http://legoofdoom.blogspot.com/": "Lego of Doom"
            }
        ]
    }
}