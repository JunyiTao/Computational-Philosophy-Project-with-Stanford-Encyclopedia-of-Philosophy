{"url": "computer-science", "title": "The Philosophy of Computer Science", "authorship": {"year": "Copyright \u00a9 2021", "author_text": "Nicola Angius\n<nangius@uniss.it>\nGiuseppe Primiero\n<giuseppe.primiero@unimi.it>\nRaymond Turner\n<turnr@essex.ac.uk>", "author_links": [{"https://uniss.academia.edu/NicolaAngius": "Nicola Angius"}, {"mailto:nangius%40uniss%2eit": "nangius@uniss.it"}, {"mailto:giuseppe%2eprimiero%40unimi%2eit": "giuseppe.primiero@unimi.it"}, {"http://cswww.essex.ac.uk/staff/turnr/": "Raymond Turner"}, {"mailto:turnr%40essex%2eac%2euk": "turnr@essex.ac.uk"}], "raw_html": "<div id=\"article-copyright\">\n<p>\n<a href=\"../../info.html#c\">Copyright \u00a9 2021</a> by\n\n<br/>\n<a href=\"https://uniss.academia.edu/NicolaAngius\" target=\"other\">Nicola Angius</a>\n&lt;<a href=\"mailto:nangius%40uniss%2eit\"><em>nangius<abbr title=\" at \">@</abbr>uniss<abbr title=\" dot \">.</abbr>it</em></a>&gt;<br/>\nGiuseppe Primiero\n&lt;<a href=\"mailto:giuseppe%2eprimiero%40unimi%2eit\"><em>giuseppe<abbr title=\" dot \">.</abbr>primiero<abbr title=\" at \">@</abbr>unimi<abbr title=\" dot \">.</abbr>it</em></a>&gt;<br/>\n<a href=\"http://cswww.essex.ac.uk/staff/turnr/\" target=\"other\">Raymond Turner</a>\n&lt;<a href=\"mailto:turnr%40essex%2eac%2euk\"><em>turnr<abbr title=\" at \">@</abbr>essex<abbr title=\" dot \">.</abbr>ac<abbr title=\" dot \">.</abbr>uk</em></a>&gt;\n    </p>\n</div>"}, "pubinfo": ["First published Tue Aug 20, 2013", "substantive revision Tue Jan 19, 2021"], "preamble": "\n\nThe philosophy of computer science is concerned with the ontological\nand methodological issues arising from within the academic discipline\nof computer science, and from the practice of software development and\nits commercial and industrial deployment. More specifically, the\nphilosophy of computer science considers the ontology and epistemology\nof computational systems, focusing on problems associated with their\nspecification, programming, implementation, verification and testing.\nThe complex nature of computer programs\u00a0ensures that many of the\nconceptual questions raised by the philosophy of computer science have\nrelated ones in the\n philosophy of mathematics,\n the philosophy of empirical sciences, and the\n philosophy of technology.\n We shall provide an analysis of such topics that reflects the layered\nnature of the ontology of computational systems in Sections 1\u20135;\nwe then discuss topics involved in their methodology in Sections\n6\u20138.\n", "toc": [{"#CompSyst": "1. Computational Systems"}, {"#SoftHard": "1.1 Software and Hardware"}, {"#MethLeveAbst": "1.2 The Method of Levels of Abstractions"}, {"#InteSpec": "2. Intention and Specification"}, {"#Inte": "2.1 Intentions"}, {"#DefiSpec": "2.2 Definitions and Specifications"}, {"#SpecFunc": "2.3 Specifications and Functions"}, {"#Algo": "3. Algorithms"}, {"#ClasAppr": "3.1 Classical Approaches"}, {"#FormAppr": "3.2 Formal Approaches"}, {"#InfoAppr": "3.3 Informal Approaches"}, {"#Prog": "4. Programs"}, {"#ProgTheo": "4.1 Programs as Theories"}, {"#ProgTechArti": "4.2 Programs as Technical Artifacts"}, {"#ProgTheiRelaWorl": "4.3 Programs and their Relation to the World"}, {"#Impl": "5. Implementation"}, {"#ImplSemaInte": "5.1 Implementation as Semantic Interpretation"}, {"#ImplRelaSpecArti": "5.2 Implementation as the Relation Specification-Artifact"}, {"#ImplForLoAs": "5.3 Implementation for LoAs"}, {"#PhysComp": "5.4 Physical Computation"}, {"#Veri": "6. Verification"}, {"#ModeTheo": "6.1 Models and Theories"}, {"#TestExpe": "6.2 Testing and Experiments"}, {"#Expl": "6.3 Explanation"}, {"#Corr": "7. Correctness"}, {"#MathCorr": "7.1 Mathematical Correctness"}, {"#PhysCorr": "7.2 Physical Correctness"}, {"#Misc": "7.3 Miscomputations"}, {"#EpisStatCompScie": "8. The Epistemological Status of Computer Science\u00a0"}, {"#CompScieMathDisc": "8.1 Computer Science as a Mathematical Discipline"}, {"#CompScieEngiDisc": "8.2 Computer Science as an Engineering Discipline"}, {"#NComScieScieDisc": "8.3\u00a0Computer Science as a Scientific Discipline"}, {"#Bib": "Bibliography"}, {"#Aca": "Academic Tools"}, {"#Oth": "Other Internet Resources"}, {"#Rel": "Related Entries"}], "main_text": "\n1. Computational Systems\n\nComputational systems are widespread in everyday life. Their design,\ndevelopment and analysis are the proper object of study of the\ndiscipline of computer science. The philosophy of computer science\ntreats them instead as objects of theoretical analysis. Its first aim\nis to define such systems, i.e., to develop an ontology of\ncomputational systems. The literature offers two main approaches on\nthe topic. A first one understands computational systems as defined by\ndistinct ontologies for software and hardware, usually taken to be\ntheir elementary components. A different approach sees computational\nsystems as comprising several other elements around the\nsoftware-hardware dichotomy: under this second view, computational\nsystems are defined on the basis of a hierarchy of levels of\nabstraction, arranging hardware levels at the bottom of such a\nhierarchy and extending upwards to elements of the design and\ndownwards to include the user. In the following we present these two\napproaches.\n1.1 Software and Hardware\n\nUsually, computational systems are seen as composed of two\nontologically distinct entities: software and hardware. Algorithms,\nsource codes, and programs fall in the first category of abstract\nentities; microprocessors, hard drives, and computing machines are\nconcrete, physical entities.\n\nMoore (1978) argues that such a duality is one of the three myths of\ncomputer science, in that the dichotomy software/hardware has a\npragmatic, but not an ontological, significance. Computer programs, as\nthe set of instructions a computer may execute, can be examined both\nat the symbolic level, as encoded instructions, and at the physical\nlevel, as the set of instructions stored in a physical medium. Moore\nstresses that no program exists as a pure abstract entity, that is,\nwithout a physical realization (a flash drive, a hard disk on a\nserver, or even a piece of paper). Early programs were even hardwired\ndirectly and, at the beginning of the computer era, programs consisted\nonly in patterns of physical levers. By the software/hardware\nopposition, one usually identifies software with the symbolic level of\nprograms, and hardware with the corresponding physical level. The\ndistinction, however, can be only pragmatically justified in that it\ndelimits the different tasks of developers. For them, software may be\ngiven by algorithms and the source code implementing them, while\nhardware is given by machine code and the microprocessors able to\nexecute it. By contrast, engineers realizing circuits implementing\nhardwired programs may be inclined to call software many physical\nparts of a computing machine. In other words, what counts as software\nfor one professional may count as hardware for another one.\n\nSuber (1988) goes even further, maintaining that hardware is a kind of\nsoftware. Software is defined as any pattern that is amenable to being\nread and executed: once one realizes that all physical objects display\npatterns, one is forced to accept the conclusion that hardware, as a\nphysical object, is also software. Suber defines a pattern as\n\u201cany definite structure, not in the narrow sense that requires\nsome recurrence, regularity, or symmetry\u201d (1988, 90) and argues\nthat any such structure can indeed be read and executed: for any\ndefinite pattern to which no meaning is associated, it is always\npossible to conceive a syntax and a semantics giving a meaning,\nthereby making the pattern an executable program.\n\nColburn (1999, 2000), while keeping software and hardware apart,\nstresses that the former has a dual nature, it is a \u201cconcrete\nabstraction\u201d as being both abstract and concrete. To define\nsoftware, one needs to make reference to both a \u201cmedium of\ndescription\u201d, i.e., the language used to express an algorithm,\nand a \u201cmedium of execution\u201d, namely the circuits composing\nthe hardware. While software is always concrete in that there is no\nsoftware without a concretization in some physical medium, it is\nnonetheless abstract, because programmers do not consider the\nimplementing machines in their activities: they would rather develop a\nprogram executable by any machine. This aspect is called by Colburn\n(1999) \u201cenlargement of content\u201d and it defines abstraction\nin computer science as an \u201cabstraction of content\u201d:\ncontent is enlarged rather than deleted, as it happens with\nmathematical abstraction.\n\nIrmak (2012) criticizes the dual nature of software proposed by\nColburn (1999, 2000). He understands an abstract entity as one lacking\nspatio-temporal properties, while being concrete means having those\nproperties. Defining software as a concrete abstraction would\ntherefore imply for software to have contradictory properties.\nSoftware does have temporal properties: as an object of human\ncreation, it starts to exist at some time once conceived and\nimplemented; and it can cease to exist at a certain subsequent time.\nSoftware ceases to exist when all copies are destroyed, their authors\ndie and nobody else remembers the respective algorithms. As an object\nof human creation, software is an artifact. However, software lacks\nspatial properties in that it cannot be identified with any concrete\nrealization of it. Destroying all the physical copies of a given\nsoftware would not imply that a particular software ceases to exist,\nas stated above, nor, for the very same reason, would deleting all\ntexts implementing the software algorithms in some high-level\nlanguage. Software is thus an abstract entity endowed with temporal\nproperties. For these reasons, Irmak (2010) definies software as an\nabstract artifact.\n\nDuncan (2011) points out that distinguishing software from hardware\nrequires a finer ontology than the one involving the simple\nabstract/concrete dichotomy. Duncan (2017) aims at providing such an\nontology by focusing on Turner\u2019s (2011) notion of specification\nas an expression that gives correctness conditions for a program (see\n \u00a72).\n Duncan (2017) stresses that a program acts also as a specification\nfor the implementing machine, meaning that a program specifies all\ncorrect behaviors that the machine is required to perform. If the\nmachine does not act consistently with the program, the machine is\nsaid to malfunction, in the same way a program which is not correct\nwith respect to its specification is said to be flawed or containing a\nbug. Another ontological category necessary to define the distinction\nsoftware/hardware is that of artifact, which Duncan (2017) defines as\na physical, spatio-temporal entity, which has been constructed so as\nto fulfill some functions and such that there is a community\nrecognizing the artifact as serving that purpose. That said, software\nis defined as a set of instructions encoded in some programming\nlanguage which act as specifications for an artifact able to read\nthose instructions; hardware is defined as an artifact whose function\nis to carry out the specified computation.\n1.2 The Method of Levels of Abstractions\n\nAs shown above, the distinction between software and hardware is not a\nsharp one. A different ontological approach to computational systems\nrelies on the role of abstraction. Abstraction is a crucial element in\ncomputer science, and it takes many different forms. Goguen &\nBurstall (1985) describe some of this variety, of which the following\nexamples are instances. Code can be repeated during programming, by\nnaming text and a parameter, a practice known as procedural\nabstraction. This operation has its formal basis in the abstraction\noperation of the lambda calculus (see the entry on the\n lambda calculus)\n and it allows a formal mechanism known as polymorphism (Hankin 2004).\nAnother example is typing, typical of functional programming, which\nprovides an expressive system of representation for the syntactic\nconstructors of the language. Or else, in object-oriented design,\npatterns (Gamma et al. 1994) are abstracted from the common structures\nthat are found in software systems and used as interfaces between the\nimplementation of an object and its specification.\n\nAll these examples share an underlying methodology in the Levels of\nAbstraction (henceforth LoA), used also in mathematics (Mitchelmore\nand White 2004) and philosophy (Floridi 2008). Abstractions in\nmathematics are piled upon each other in a never-ending search for\nmore and more abstract concepts. On this account, abstraction is\nself-contained: an abstract mathematical object takes its meaning only\nfrom the system within which it is defined and the only constraint is\nthat new objects be related to each other in a consistent system that\ncan be operated on without reference to previous or external meanings.\nSome argue that, in this respect at least, abstraction in computer\nscience is fundamentally different from abstraction in mathematics:\ncomputational abstraction must leave behind an implementation trace\nand this means that information is hidden but not destroyed (Colburn\n& Shute 2007). Any details that are ignored at one LoA must not be\nignored by one of the lower LoAs: for example, programmers need not\nworry about the precise location in memory associated with a\nparticular variable, but the virtual machine is required to handle all\nmemory allocations. This reliance of abstraction on different levels\nis reflected in the property of computational systems to depend upon\nthe existence of an implementation: for example, even though classes\nhide details of their methods, they must have implementations. Hence,\ncomputational abstractions preserve both an abstract guise and an\nimplementation.\n\nA full formulation of LoAs for the ontology of digital computational\nsystems has been devised in Primiero (2016), including:\n\nIntention\nSpecification\nAlgorithm\nHigh-level programming language instructions\nAssembly/machine code operations\nExecution\n\n\nIntention is the cognitive act that defines a computational\nproblem to be solved: it formulates the request to create a\ncomputational process to perform a certain task. Requests of this sort\nare usually provided by customers, users, and other stakeholders\ninvolved in a given software development project.\nSpecification is the formulation of the set of requirements\nnecessary for solving the computational problem at hand: it concerns\nthe possibly formal determination of the operations the software must\nperform, through the process known as requirements elicitation.\nAlgorithm expresses the procedure providing a solution to the\nproposed computational problem, one which must meet the requirements\nof the specification. High-level programming language (such\nas C, Java, or Python) instructions constitute the linguistic\nimplementation of the proposed algorithm, often called the source\ncode, and they can be understood by trained programmers but cannot be\ndirectly executed by a machine. The instructions coded in high-level\nlanguage are compiled, i.e., translated, by a compiler into\nassembly code and then assembled in machine code\noperations, executable by a processor. Finally, the\nexecution LoA is the physical level of the running software,\ni.e., of the computer architecture executing the instructions.\n\nAccording to this view, no LoA taken in isolation is able to define\nwhat a computational system is, nor to determine how to distinguish\nsoftware from hardware. Computational systems are rather defined by\nthe whole abstraction hierarchy; each LoA in itself expresses a\nsemantic level associated with a realization, either linguistic or\nphysical.\n2. Intention and Specification\n\nIntention refers to a cognitive state outside the computational system\nwhich expresses the formulation of a computational problem to be\nsolved.\u00a0Specifications describe the functions that the\ncomputational system to be developed must fulfil. Whereas\nintentions,\u00a0per se, do not pose\u00a0specific\nphilosophical controversies inside\u00a0the philosophy of computer\nscience, issues arise in connection with the definition of what a\nspecification is and its relation with intentions.\n2.1 Intentions\n\nIntentions articulate\u00a0the criteria to determine whether a\ncomputational\u00a0system is appropriate (i.e., correct, see\n \u00a77),\n and therefore it is considered as the first LoA of the computational\nsystem appropriate to that problem. For instance, customers and users\nmay require a smartphone app able to filter out annoying calls from\ncall centers; such request constitutes the intention LoA in the\ndevelopment of a computational system able to perform such a task. In\nthe software development process of non-naive systems, intentions are\nusually gathered by such techniques as brainstorming, surveys,\nprototyping, and even focus groups (Clarke and Moreira 1999), aimed at\ndefining a structured set of the various stakeholders\u2019\nintentions. At this LoA, no reference is made to how to solve\nthe computational problem, but only the description of the problem\nthat must be solved is provided.\n\nIn contemporary literature, intentions have been the object of\nphilosophical inquiry at least since Anscombe (1963). Philosophers\nhave investigated \u201cintentions with which\u201d an action is\nperformed (Davidson 1963), intentions of doing something in the future\n(Davidson 1978), and intentional actions (Anscombe 1963, Baier 1970,\nFerrero 2017). Issues arise concerning which of the three kinds of\nintention is primary, how they are connected, the relation between\nintentions and belief, whether intentions are or presuppose specific\nmental states, and whether intentions act as causes of actions (see\nthe entry on\n intention).\n More formal problems concern the opportunity for an agent of having\ninconsistent intentions and yet being considered rational (Bratman\n1987, Duijf et al. 2019).\n\nIn their role as the first LoA in the ontology of computational\nsystems, intentions can certainly be acknowledged as intentions for\nthe future, in that they express the objective of constructing systems\nable to perform some desired computational tasks. Since intentions, as\nstated above, confine themselves to the definition of the\ncomputational problem to be solved, without specifying its\ncomputational solution, their ontological and epistemological analysis\ndoes not differ from those referred to in the philosophical\nliterature. In other words, there is nothing specifically\ncomputational in the intentions defining computational systems which\ndeserves a separate treatment in the philosophy of computer science.\nWhat matters here is the relation between intention and specification,\nin that intentions provide correctness criteria for specifications;\nspecifications are asked to express how the computational problem put\nforward by intentions is to be solved.\n2.2 Definitions and Specifications\n\nConsider the\u00a0example of the call filtering app again;\u00a0a\nspecification may require to create a black-list of phone numbers\nassociated with call centers; to update the list every n\ndays; to check, upon an incoming call, whether the number is on the\nblack-list; to communicate\u00a0to the call management system not to\nallow the incoming call in case of an affirmative answer, and to allow\nthe call in case of negative answer.\n\nThe latter is a full-fledged specification, though expressed in a\nnatural language. Specifications are often advanced in a natural\nlanguage to be closer to the stakeaholder\u2019s intentions and only\nsubsequently they are\u00a0formalized in a proper formal language.\nSpecifications may be expressed by means of graphical languages such\nas UML (Fowler 2003), or more formal languages such as TPL (Turner\n2009a) and VDM (Jones 1990), using predicate logic, or Z (Woodcock and\nDavies 1996), focusing on set theory. For instance, Type Predicate\nLogic (TPL) expresses the requirements of computational systems using\npredicate logic formulas, wherein the type of the quantified variables\nis specified. The choice of the variable types allows one to define\nspecifications at the more appropriate abstraction level. Whether\nspecifications are expressed in an informal or formal guise often\ndepends on the development method followed, with formal specifications\nusually preferred in the context of formal development methods.\nMoreover, formal specifications facilitate verification of correctness\nfor computational systems (see\n \u00a76).\n\nTurner (2018) asks what difference is there between models and\nspecifications, both of which are extensively used in computer\nscience. The difference is located in what Turner (2011) calls the\nintentional stance: models describe an intended\nsystem to be developed and, in case of a mismatch between the two, the\nmodels are to be refined; specifications prescribe how the\nsystem is to be built so as to comply with the intended functions, and\nin case of mismatch it is the system that needs to be refined.\nMatching between model and system reflects a correspondence between\nintentions \u2014 describing what system is to be\nconstructed in terms of the computational problem the system must be\nable to solve \u2014 and specifications \u2014 determining\nhow the system is to be constructed, in terms of the set of\nrequirements necessary for solving the computational problem, as\nexemplified for the call filtering app. In Turner\u2019s (2011)\nwords, \u201csomething is a specification when it is given\ncorrectness jurisdiction over an artefact\u201d: specifications\nprovide correctness criteria for computational systems. Computational\nsystems are thus correct when they comply with their specifications,\nthat is, when they behave according to them. Conversely, they provide\ncriteria of malfunctioning\n (\u00a77.3):\n a computational system malfunctions when it does not behave\nconsistently with its specifications. Turner (2011) is careful to\nnotice that such a definition of specifications is an idealization:\nspecifications are themselves revised in some cases, such as when the\nspecified computational systems cannot be realized because of physical\nlaws constraints or cost limitations, or when it turns out that the\nadvanced specifications are not correct formalizations of the\nintentions of clients and users.\n\nMore generally, the correctness problem does not only deal with\nspecifications, but with any two LoAs defining computational systems,\nas the next subsection will examine.\n2.3 Specifications and Functions\n\nFully implemented and constructed computational systems are\ntechnical artifacts, i.e., human-made systems designed and\nimplemented with the explicit aim of fulfilling specific functions\n(Kroes 2012). Technical artifacts so defined include tables,\nscrewdrivers, cars, bridges, or televisions, and they are distinct\nboth from natural objects (e.g. rocks, cats, or dihydrogen monoxide\nmolecules), which are not human-made, and artworks, which do not\nfulfill functions. As such, the ontology of computational systems\nfalls under that of technical artifacts (Meijers 2000) characterized\nby a duality, as they are defined by both functional\nand structural properties (Kroes 2009, see also the entry on\n philosophy of technology).\n Functional properties specify the functions the artifact is required\nto perform; structural properties express the physical properties\nthrough which the artifact can perform them. Consider a screwdriver:\nfunctional properties may include the function of screwing and\nunscrewing; structural properties can refer to a piece of metal\ncapable of being inserted on the head of the screw and a plastic\nhandle that allows a clockwise and anticlockwise motion. Functions can\nbe realized in multiple ways by their structural counterparts. For\ninstance, the function for the screwdriver could well be realized by a\nfull metal screwdriver, or by an electric screwdriver defined by very\ndifferent structural properties.\n\nThe layered ontology of computational systems characterized by many\ndifferent LoAs seems to extend the dual ontology defining technical\nartifacts (Floridi et al. 2015). Turner (2018) argues that\ncomputational systems are still artifacts in the sense of (Kroes 2009,\n2012), as each LoA is a functional level for lower LoAs and a\nstructural level for upper LoAs:\n\nthe intention expresses the functions that the system must achieve\nand is implemented by the specification;\nthe specification plays a functional role, explaining in details\nthe concrete functions that the software must implement, and it is\nrealized by an algorithm, its structural level;\u00a0\nthe algorithm expresses the procedures that the high-level\nlanguage program, its structural level, must implement;\ninstructions in high level language define the functional\nproperties for the machine language code, which realizes them;\nmachine code, finally, expresses the functional properties\nimplemented by the execution level, which expresses physical\nstructural properties.\n\n\nIt follows, according to Turner (2018), that structural levels need\nnot be necessarily physical levels, and that the notion of abstract\nartifact holds in computer science. For this reason, Turner (2011)\ncomes to define high-level language programs themselves as technical\nartifacts, in that they constitute a structural level implementing\nspecifications as their functional level\n (see\u00a0\u00a74.2).\n\nA first consequence is that each LoA \u2013\u00a0expressing\nwhat function to accomplish \u2013\u00a0can be realized by a\nmultiplicity of potential structural levels expressing how\nthose functions are accomplished: an intended functionality can be\nrealized by a specification in multiple ways; a computational problem\nexpressed by a specification has solutions by a multiplicity of\ndifferent algorithms, which can differ for some important properties\nbut are all equally valid (see\n \u00a73);\n an algorithm may be implemented in different programs, each written\nin a different high-level programming language, all expressing the\nsame program if they implement the same algorithm (Angius and\nPrimiero 2019); source code can be compiled in a multiplicity of\nmachine languages, adopting different ISAs (Instruction Set\nArchitectures); executable code can be installed and run on a\nmultiplicity of machines (provided that these share the same ISA).\n\nA second consequence is that each LoA as a functional level provides\ncorrectness criteria for lower levels (Primiero 2020). Not just at the\nimplementation level, correctness is required at any LoA from\nspecification to execution, and the cause of malfunctions may be\nlocated at any LoA not correctly implementing its proper functional\nlevel (see\n \u00a77.3\u00a0and\n Fresco, Primiero (2013)). According to Turner (2018), the\nspecification level can be said to be correct or incorrect with\nrespect to intentions, despite the difficulty of verifying their\ncorrectness. Correctness of any non-physical layer can be verified\nmathematically through formal verification, and the execution physical\nlevel can be verified empirically, through testing\n (\u00a76).\n Verifying correctness of specifications with respect to\nclients\u2019 intentions would require instead having access to the\nmental states of the involved agents.\n\nThis latter problem relates to the more general one of establishing\nhow artifacts possess functions, and what it means that structural\nproperties are related to the intentions of agents. The problem is\nwell-known also in the philosophy of biology and the cognitive\nsciences, and two main theories have been put forward as solutions.\nAccording to the causal theory of function (Cummins 1975),\nfunctions are determined by the physical capacities of artifacts: for\nexample, the physical ability of the heart of contracting and\nexpanding determines its function of pumping blood in the circulatory\nsystem. However, this theory faces serious problems when applied to\ntechnical artifacts. First, it prevents defining correctness and\nmalfunctioning (Kroes 2010): suppose the call filtering app installed\non our smartphone starts banning calls from contacts in our mobile\nphonebook; according to the causal theory of function this would be a\nnew function of the app. Second, the theory does not distinguish\nintended functions from side effects (Turner 2011): in case of a\nlong-lasting call, our smartphone would certainly start heating;\nhowever, this is not a function intended by clients or developers.\nAccording to the intentional theory of function (McLaughlin\n2001, Searle 1995), the function fixed by the designer or the user is\nthe intended one of the artifact, and structural properties of\nartifacts are selected so as to be able to fulfill it. This theory is\nable to explain correctness and malfunction, as well as to distinguish\nside effects from intended functions. However, it does not say where\nthe function actually resides, whether in the artifact or in the mind\nof the agent. In the former case, one is back at the question of how\nartifacts possess functions. In the latter case, a further explanation\nis needed about how mental states are related to physical properties\nof artifacts (Kroes 2010). Turner (2018) holds that the intuitions\nbehind both the causal and the intentional theories of function are\nuseful to understand the relation between function and structure in\ncomputational systems, and suggests that the two theories be combined\ninto a single one. On the one hand, there is no function without\nimplementation; on the other hand, there is no intention without\nclients, developers, and users.\n3. Algorithms\n\nEven though known and widely used since antiquity, the problem of\ndefining what algorithms are is still open (Vardi 2012). The word\n\u201calgorithm\u201d originates from the name of the\nninth-century Persian mathematician Ab\u016b Ja\u02bffar\nMu\u1e25ammad ibn M\u016bs\u0101 al-Khw\u0101rizm\u012b, who\nprovided rules for arithmetic operations using Arabic numerals.\nIndeed, the rules one follows to compute basic arithmetic operations\nsuch as multiplication or division, are everyday examples of\nalgorithms. Other well-known examples include rules to bisect an angle\nusing compass and straightedge, or Euclid\u2019s algorithm for\ncalculating the greatest common divisor. Intuitively, an algorithm is\na set of instructions allowing the fulfillment of a given task.\nDespite this ancient tradition in mathematics, only modern logical and\nphilosophical reflection put forward the task of providing a\ndefinition of what an algorithm is, in connection with the\nfoundational crisis of mathematics of the early twentieth century (see\nthe entry on the\n philosophy of mathematics).\n The notion of effective calculability arose from logical\nresearch, providing some formal counterpart to the intuitive notion of\nalgorithm and giving birth to the theory of computation. Since then,\ndifferent definitions of algorithms have been proposed,\nranging\u00a0from formal to non-formal approaches, as sketched in the\nnext sections.\n3.1 Classical Approaches\n\nMarkov (1954) provides a first precise definition of algorithm as a\ncomputational process that is determined,\napplicable, and effective. A computational process\nis determined if the instructions involved are precise enough\nnot to allow for any \u201carbitrary choice\u201d in their\nexecution. The (human or artificial) computer must\u00a0never be\nunsure about what step to carry out next. Algorithms are\napplicable for Markov in that they hold for classes of inputs\n(natural numbers for basic arithmetic operations) rather than for\nsingle inputs (specific natural numbers). Markov (1954:1) defines\neffectiveness as \u201cthe tendency of the algorithm to\nobtain a certain result\u201d. In other words, an algorithm is\neffective in that it will eventually produce the answer to the\ncomputational problem.\n\nKleene (1967) specifies finiteness as a further important\nproperty: an algorithm is a procedure which can be described by means\nof a finite set of instructions and needs a finite number of steps to\nprovide an answer to the computational problem. As a counterexample,\nconsider a while loop defined by a finite number of steps,\nbut which runs forever since the condition in the loop is always\nsatisfied. Instructions should also be amenable to mechanical\nexecution, that is, no insight is required for the machine to follow\nthem. Following Markov\u2019s determinability and strengthening\neffectiveness, Kleene (1967) additionally specifies that instructions\nshould be able to recognize that the solution to the computational\nproblem has been achieved, and halt the computation.\n\nKnuth (1973) recalls and deepens the analyses of Markov (1954) and\nKleene (1967) by stating that:\n\n\nBesides merely being a finite set of rules that gives a sequence of\noperations for solving a specific type of problem, an algorithm has\nfive important features:\n\nFiniteness. An algorithm must always terminate after a\nfinite number of steps. [\u2026]\nDefiniteness. Each step of an algorithm must be precisely\ndefined; the actions to be carried out must be rigorously and\nunambiguously specified for each case. [\u2026]\nInput. An algorithm has zero or more inputs.\n[\u2026]\nOutput. An algorithm has zero or more outputs.\n[\u2026]\nEffectiveness. An algorithm is also generally expected to\nbe effective, in the sense that its operations must all be\nsufficiently basic that they can in principle be done exactly and in a\nfinite length of time by someone using pencil and paper. (Knuth 1973:\n4\u20136) [\u2026]\n\n\n\nAs in Kleene (1967), finiteness affects both the number of\ninstructions and the number of implemented computational steps. As in\nMarkov\u2019s determinacy, Knuth\u2019s definiteness principle\nrequires that each successive computational step be unambiguously\nspecified. Furthermore, Knuth (1973) more explicitly requires that\nalgorithms have (potentially empty sets of) inputs and outputs. By\nalgorithms with no inputs or outputs Knuth probably refers to\nalgorithms using internally stored data as inputs or algorithms not\nreturning data to an external user (Rapaport 2019, ch. 7, in Other\nInternet Resources). As for effectiveness, besides Markov\u2019s\ntendency \u201cto obtain a certain result\u201d, Knuth requires that\nthe result be obtained in a finite amount of time and that the\ninstructions be atomic, that is, simple enough to be understandable\nand executable by a human or artificial computer.\n3.2 Formal Approaches\n\nGurevich (2011) maintains, on the one hand, that it is not possible to\nprovide formal definitions of algorithms, as the notion continues to\nevolve\u00a0over time: consider how sequential algorithms, used in\nancient mathematics, are flanked by parallel, analog, or quantum\nalgorithms in current computer science practice, and how new kinds of\nalgorithms are likely to be envisioned in the near\u00a0future. On the\nother hand, a formal analysis can be advanced if concerned only with\nclassical sequential algorithms. In particular, Gurevich (2000)\nprovides an axiomatic definition for this class of algorithms.\n\nAny sequential algorithm can be simulated by a sequential abstract\nstate machine satisfying three axioms:\n\nThe sequential-time postulate associates to any algorithm\nA a set of states S(A), a set of initial states\nI(A) subset of S(A), and a map from S(A) to\nS(A) of one-step transformations of A. States are\nsnapshot descriptions of running algorithms. A run of A is a\n(potentially infinite) sequence of states, starting from some initial\nstate, such that there is a one-step transformation from one state to\nits successor in the sequence. Termination is not presupposed by\nGurevich\u2019s definition. One-step transformations need not be\natomic, but they may be composed of a bounded set of atomic\noperations.\nAccording to the abstract-state postulate, states in\nS(A) are first-order structures, as commonly defined\nin mathematical logic; in other words, states provide a semantics to\nfirst-order statements.\nFinally, the bounded-exploration postulate states that\ngiven two states X and Y of A there is\nalways a set T of terms such that, when X and\nY coincide over T, the set of updates of X\ncorresponds to the set of updates of Y. X and\nY coincide over T when, for every term t in\nT, the evaluation of t in X is the same as\nthe evaluation of t in Y. This allows algorithm\nA to explore only those parts of states which are relative to\nterms in T.\n\n\nMoschovakis (2001) objects that the intuitive notion of algorithm is\nnot captured in full by abstract machines. Given a general recursive\nfunction f: \u2115 \u2192 \u2115 defined on natural\nnumbers, there are usually many different algorithms computing it;\n\u201cessential, implementation-independent properties\u201d are not\ncaptured by abstract machines, but rather by a system of recursive\nequations. Consider the algorithm mergesort for sorting\nlists; there are many different abstract machines for\nmergesort, and the question arises which one is to be chosen\nas the mergesort algorithm. The mergesort algorithm\nis instead the system of recursive equations specifying the involved\nfunction, whereas abstract machines for the mergesort\nprocedure are different implementations of the same\nalgorithm. Two questions are put forward by Moschovakis\u2019\nformal analysis: different implementations of the same\nalgorithm should be equivalent implementations, and yet, an\nequivalence relation among algorithm implementations is to be formally\ndefined. Furthermore, it remains to be clarified what the intuitive\nnotion of algorithm formalized by systems of recursive equations\namounts to.\n\nPrimiero (2020) proposes a reading of the nature of algorithms at\nthree different levels of abstraction. At a very high LoA, algorithms\ncan be defined abstracting from the procedure they describe, allowing\nfor many different sets of states and transitions. At this LoA\nalgorithms can be understood as informal specifications, that\nis, as informal descriptions of a procedure P. At a lower\nLoA, algorithms specify the instructions needed to solve the given\ncomputational problem; in other words, they specify a procedure.\nAlgorithms can thus be defined as procedures, or descriptions\nin some given formal language L of how to execute a procedure\nP. Many important properties of algorithms, including those\nrelated to complexity classes and data structures, cannot be\ndetermined at the procedural LoA, and instead make reference to an\nabstract machine implementing the procedure is needed. At a bottom\nLoA, algorithms can be defined as implementable abstract\nmachines, viz. as the specification, in a formal language\nL, of the executions of a program P for a given\nabstract machine M. The threefold definition of algorithms\nallows Primiero (2020) to supply a formal definition of equivalence\nrelations for algorithms in terms of the algebraic notions of\nsimulation and bisimulation (Milner 1973, see also\nAngius and Primero 2018). A machine Mi executing a\nprogram Pi implements the same algorithm of a\nmachine Mj executing a program\nPj if and only if the abstract machines\ninterpreting Mi and Mj are in\na bisimulation relation.\n3.3 Informal Approaches\n\nVardi (2012) underlines how, despite the many formal and informal\ndefinitions available, there is no general consensus on what an\nalgorithm is. The approaches of Gurevich (2000) and Moschovakis\n(2001), which can even be proved to be logically equivalent, only\nprovide logical constructs for algorithms, leaving unanswered the main\nquestion. Hill (2013) suggests that an informal definition of\nalgorithms, taking into account the intuitive understanding one has\nabout algorithms, may be more useful, especially for the public\ndiscourse and the communication between practitioners and users.\n\nRapaport (2012, Appendix) provides an attempt to summarize the three\nclassical definitions of algorithm sketched above stating that:\n\nAn algorithm (for executor E to accomplish goal G) is:\n\n\na procedure, that is, a finite set (or sequence) of statements (or\nrules, or instructions), such that each statement is:\n\n\ncomposed of a finite number of symbols (or marks) from a finite\nalphabet\nand unambiguous for E\u2014that is,\n\n\nE knows how to do it\nE can do it\nit can be done in a finite amount of time\nand, after doing it, E knows what to do next\u2014\n \n \nwhich procedure takes a finite amount of time (that is, it\nhalts),\nand that ends with G accomplished.\n\n\n\nRapaport stresses that an algorithm is a procedure, i.e., a finite\nsequence of statements taking the form of rules or instructions.\nFiniteness is here expressed by requiring that instructions contain a\nfinite number of symbols from a finite alphabet.\n\nHill (2016) aims at providing an informal definition of algorithm,\nstarting from Rapaport\u2019s (2012):\n\nAn algorithm is a finite, abstract, effective, compound control\nstructure, imperatively given, accomplishing a given purpose, under\ngiven provisions.(Hill 2016: 48).\n\n\nFirst of all, algorithms are compound structures rather than\natomic objects, i.e., they are composed of smaller units, namely\ncomputational steps. These structures are finite and effective, as\nexplicitly mentioned by Markov, Kleene, and Knuth. While these authors\ndo not explicitly mention abstractness, Hill (2016) maintains it is\nimplicit in their analysis. Algorithms are abstract simply in\nthat they lack spatio-temporal properties and are independent from\ntheir instances. They provide control, that is,\n\u201ccontent that brings about some kind of change from one state to\nanother, expressed in values of variables and consequent\nactions\u201d (p. 45). Algorithms are imperatively given, as\nthey command state transitions to carry out specified operations.\nFinally, algorithms operate to achieve certain purposes under\nsome usually well-specified provisions, or preconditions.\nFrom this viewpoint, the author argues, algorithms are on a par with\nspecifications in their specifying a goal under certain resources.\nThis definition allows to distinguish algorithms from other compound\ncontrol structures. For instance, recipes are not algorithms because\nthey are not effective; nor are games, which are not imperatively\ngiven.\n4. Programs\n\nThe ontology of computer programs is strictly related to the subsumed\nnature of computational systems (see\n \u00a71).\n If computational systems are defined on the basis of the\nsoftware-hardware dichotomy, programs are abstract entities\ninterpreting the former and opposed to the concrete nature of\nhardware. Examples of such interpretations are provided in\n \u00a71.1\n and include the \u201cconcrete abstraction\u201d definition by\nColburn (2000), the \u201cabstract artifact\u201d characterization\nby Irmak (2012), and programs as specifications of machines proposed\nby Duncan (2011). By contrast, under the interpretation of\ncomputational systems by a hierarchy of LoAs, programs are\nimplementations of algorithms. We refer to\n \u00a75\n on implementation for an analysis of the ontology of programs in this\nsense. This section focuses on definitions of programs with a\nsignificant relevance in the literature, namely those views that\nconsider programs as theories or as artifacts, with a focus on the\nproblem of the relation between programs and the world.\n4.1 Programs as Theories\n\nThe view that programs are theories goes back to approaches in\ncognitive science. In the context of the so-called Information\nProcessing Psychology (IPP) for the simulative investigation on human\ncognitive processes, Newell and Simon (1972) advanced the thesis that\nsimulative programs are empirical theories of their simulated\nsystems. Newell and Simon assigned to a computer program the role of\ntheory of the simulated system as well as of the simulative system,\nnamely the machine running the program, to formulate predictions on\nthe simulated system. In particular, the execution traces of the\nsimulative program, given a specific problem to solve, are used to\npredict the mental operation strategies that will be performed by the\nhuman subject when asked to accomplish the same task. In case of a\nmismatch between execution traces and the verbal reports of the\noperation strategies of the human subject, the empirical theory\nprovided by the simulative program is revised. The predictive use of\nsuch a computer program is comparable, according to Newell and Simon,\nto the predictive use of the evolution laws of a system that are\nexpressed by differential or difference equations.\n\nNewell and Simon\u2019s idea that programs are theories has been\nshared by the cognitive scientists Pylyshyn (1984) and Johnson-Laird\n(1988). Both agree that programs, in contrast to typical theories, are\nbetter at\u00a0facing\u00a0the complexity of the simulative process to\nbe modelled, forcing one to fill-in all the details that are necessary\nfor the program to be executed. Whereas incomplete or incoherent\ntheories may be advanced at some stage of scientific inquiry, this is\nnot the case for programs.\n\nOn the other hand, Moore (1978) considers the programs-as-theories\nthesis another myth\u00a0of computer science.\u00a0As programs can\nonly simulate some set of empirical phenomena, at most they play the\nrole of computational models of those phenomena. Moore\nnotices that for programs to be acknowledged as models, semantic\nfunctions are nevertheless needed to interpret the empirical system\nbeing simulated. However, the view that programs are models should not\nbe mistaken for the definition of programs as theories: theories\nexplain and predict the empirical phenomena\nsimulated by models, while simulation by programs does not offer\nthat.\n\nAccording to computer scientist Paul Thagard (1984), understanding\nprograms as theories would require a syntactic or a\nsemantic view of theories (see the entry on\n the structure of scientific theories).\n But programs do not comply with either of the two views. According to\nthe syntactic view (Carnap 1966, Hempel 1970), theories are sets of\nsentences expressed in some defined language able to describe target\nempirical systems; some of those sentences define the axioms of the\ntheory, and some are law-like statements expressing regularities of\nthose systems. Programs are sets of instructions written in some\ndefined programming language which, however, do not describe any\nsystem, insofar as they are procedural linguistic entities and not\ndeclarative ones. To this, Rapaport (2020, see Other Internet\nResources) objects that procedural programming languages can often be\ntranslated into declarative languages and that there are languages,\nsuch as Prolog, that can be interpreted both procedurally and\ndeclaratively. According to the semantic view (Suppe 1989, Van\nFraassen 1980), theories are introduced by a collection of models,\ndefined as set-theoretic structures satisfying the theory\u2019s\nsentences. However, in contrast to Moore (1978), Thagard (1984) denies\nprograms the epistemological status of models: programs simulate\nphysical systems without satisfying theories\u2019 laws and axioms.\nRather, programs include, for simulation purposes, implementation\ndetails for the programming language used, but not of the target\nsystem being simulated.\n\nA yet different approach to the problem of whether programs are\ntheories comes from the computer scientist Peter Naur (1985).\nAccording to Naur, programming is a theory building process not in the\nsense that programs are theories, but because the successful\nprogram\u2019s development and life-cycle require that programmers\nand developers have theories of programs available. A theory is here\nunderstood, following Ryle (2009), as a corpus of knowledge shared by\na scientific community about some set of empirical phenomena, and not\nnecessarily expressed axiomatically or formally. Theories of\nprograms are necessary during the program life-cycle to be able to\nmanage requests of program modifications pursuant to observed\nmiscomputations or unsatisfactory solutions to the computational\nproblem the program was asked to solve. In particular, theories of\nprograms should allow developers to modify the program so that new\nsolutions to the problem at stake can be provided. For this reason,\nNaur (1985) deems such theories more fundamental, in software\ndevelopment, than documentations and specifications.\n\nFor Turner (2010, 2018 ch. 10), programming languages are mathematical\nobjects defined by a formal grammar and a formal semantics. In\nparticular, each syntactic construct, such as an assignment, a\nconditional or a while loop, is defined by a grammatical rule\ndetermining its syntax, and by a semantic rule associating a meaning\nto it. Depending on whether an operational or a denotational semantics\nis preferred, meaning is given in terms of respectively the operations\nof an abstract machine or of mathematical partial functions from set\nof states to set of states. For instance, the simple assignment\nstatement \\(x := E\\) is associated, under an operational semantics,\nwith the machine operation \\(update(s,x,v)\\) which assigns variable\n\\(v\\) interpreted as \\(E\\) to variable \\(x\\) in state \\(s\\). Both in\nthe case of an operational and of a denotational semantics, programs\ncan be understood as mathematical theories expressing the operations\nof an implementing machine. Consider operational semantics: a\nsyntactic rule of the form \\(\\langle P,s \\rangle \\Downarrow s'\\)\nstates semantically that program \\(P\\) executed in state \\(s\\) results\nin \\(s'.\\) According to Turner (2010, 2018), a programming language\nwith an operational semantics is akin to an axiomatic theory of\noperations in which rules provide axioms for the relation\n\\(\\Downarrow\\).\n4.2 Programs as Technical Artifacts\n\nPrograms can be understood as technical artifacts because programming\nlanguages are defined, as any other artifact, on the basis of both\nfunctional and structural properties (Turner 2014, 2018 ch. 5).\nFunctional properties of (high level) programming languages are\nprovided by the semantics associated with each syntactic construct of\nthe language. Turner (2014) points out that programming languages can\nindeed be understood as axiomatic theories only when their functional\nlevel is isolated. Structural properties, on the other hand, are\nspecified in terms of the implementation of the language, but not\nidentified with physical components of computing machines: given a\nsyntactic construct of the language with an associated functional\ndescription, its structural property is determined by the physical\noperations that a machine performs to implement an instruction for the\nconstruct at hand. For instance, the assignment construct \\(x := E\\)\nis to be linked to the physical computation of the value of expression\n\\(E\\) and to the placement of the value of \\(E\\) in the physical\nlocation \\(x\\).\n\nAnother requirement for a programming language to be considered a\ntechnical artifact is that it has to be endowed with a semantics\nproviding correctness criteria for the language implementation. The\nprogrammer attests to functional and structural properties of a\nprogram by taking the semantics to have correctness jurisdiction over\nthe program.\n4.3 Programs and their Relation to the World\n\nThe problem of whether computer programs are theories is tied with the\nrelation that programs entertain with the outside world. If programs\nwere theories, they would have to represent some empirical system, and\na semantic relation would be directly established between the program\nand the world. By contrast, some have argued that the relation between\nprograms and natural systems is mediated by models of the outside\nworld (Colburn et al. 1993, Smith 1985). In particular, Smith\n(1985) argues that models are abstract descriptions of empirical\nsystems, and computational systems operating in them have programs\nthat act as models of the models, i.e., they represent abstract models\nof reality. Such an account of the ontology of programs comes in handy\nwhen describing the correctness problem in computer science (see\n \u00a7 7):\n if specifications are considered as models requiring certain\nbehaviors from computational systems, programs can be seen as models\nsatisfying specifications.\n\nTwo views of programs can be given depending on whether one admits\ntheir relation with the world (Rapaport 2020, ch. 17, see Other\nInternet Resource). According to a first view, programs are\n\u201cwide\u201d, \u201cexternal\u201d and \u201csemantic\u201d:\nthey grant direct reference to objects of an empirical system and\noperations on those objects. According to a second view, programs are\n\u201cnarrow\u201d, \u201cinternal\u201d, and\n\u201csyntactic\u201d: they make only reference to the atomic\noperations of an implementing machine carrying out computations.\nRapaport (2020, see Other Internet Resources) argues that programs\nneed not be \u201cexternal\u201d and\n\u201csemantic\u201d. First, computation itself needs not to be\n\u201cexternal\u201d: a Turing machine executes the instructions\ncontained in its finite table by using data written on its tape and\nhalting after the data resulting from the computation have\u00a0been\nwritten on the tape. Data are\u00a0not, strictly speaking, in-put-from\nand out-put-to an external user. Furthemore, Knuth (1973) required\nalgorithms to have zero or more inputs and outputs (see\n \u00a7 3.1).\n A computer program requiring no inputs may be a program, say,\noutputting all prime numbers from 1; and a program with no outputs can\nbe a program that computes the value of some given variable x without\nreturning the value stored in x as output. Second, programs need not\nbe \u201cexternal\u201d, teleological, i.e., goal oriented. This\nview opposes other known positions in the literature. Suber (1988)\nargues that, without considering goals and purposes, it would not be\npossible to assess whether a computer program is correct, that is, if\nit behaves as intended. And as recalled in\n \u00a73.3.,\n Hill (2016) specifies in her informal definition that algorithms\naccomplish \u201ca given purpose, under given provisions.\u201d\n(Hill 2016: 48). To these views, Rapaport (2020, ch. 17, see Other\nInternet Resource) replies that whereas goals, purposes, and\nprogrammers\u2019 intentions may be very useful for a human computor\nto understand a program, they are not necessary for an artificial\ncomputer to carry out the computations instructed by the program code.\nIndeed, the principle of effectiveness that classical approaches\nrequire for algorithms (see\n \u00a73.1)\n demands, among other properties, that algorithms be executed without\nany recourse to intuition. In other words, a machine executing a\nprogram for adding natural numbers does not \u201cunderstand\u201d\nthat it is adding; at the same time, knowing that a given program\nperforms addition may help a human agent to understand the\nprogram\u2019s code.\n\nAccording to this view, computing involves just symbols, not meanings.\nTuring machines become symbols manipulators and not a single but\nmultiple meanings can be associated with its operations. How can then\none identify when two programs are the same program, if not\nby their meanings, that is, by considering what function they perform?\nOne answer comes from Piccini\u2019s analysis of computation and its\n\u201cinternal semantics\u201d (Piccini 2008, 2015 ch. 3):\ntwo programs can be identified as identical by analysing only their\nsyntax and the operations the programs carry out on their symbols. The\neffects of string manipulation operations can be considered an\ninternal semantics of a program. The latter can be easily determined\nby isolating subroutines or methods in the program\u2019s code and\ncan afterwards be used to identify a program or to establish whether\ntwo programs are the same, namely when they are defined by the same\nsubroutines.\n\nHowever, it has been argued that there are cases in which it is not\npossible to determine whether two programs are the same without making\nreference to an external semantics. Sprevak (2010) proposes to\nconsider two programs for addition which differ from the fact that one\noperates on Arabic, the other one on Roman numerals. The two programs\ncompute the same function, namely addition, but this cannot always be\nestablished by inspecting the code with its subroutines; it must be\ndetermined by assigning content to the input/output strings,\ninterpreting Arabic and Roman numerals as numbers. In that regard,\nAngius and Primiero (2018) underline how the problem of identity for\ncomputer programs does not differ from the problem of identity for\nnatural kinds (Lowe 1998) and technical artifacts (Carrara et al.\n2014). The problem can be tackled by fixing an identity criterion,\nnamely a formal relation, that any two programs should entertain in\norder to be defined as identical. Angius and Primiero (2018) show how\nto use the process algebra relation of bisimulation between the two\nautomata implemented by two programs under examination as such an\nidentity criterion. Bisimulation allows to establish matching\nstructural properties of programs implementing the same function, as\nwell as providing weaker criteria for copies in terms of simulation.\nThis brings the discussion back to the notion of programs as\nimplementations. We now turn to analyze this latter concept.\n5. Implementation\n\nThe word \u2018implementation\u2019 is often associated with a\nphysical realization of a computing system, i.e., to a machine\nexecuting a computer program. In particular, according to the dual\nontology of computing systems examined in\n \u00a71.1,\n implementation in this sense reduces to the structural hardware, as\nopposed to the functional software. By contrast, following the method\nof the levels of abstraction\n (\u00a7 1.2),\n implementation becomes a wider relation holding between any LoA\ndefining a computational system and the levels higher in the\nhierarchy. Accordingly, an algorithm is an implementation of a (set\nof) specification(s); a program expressed in a high level programming\nlanguage can be defined as an implementation of an algorithm (see\n \u00a74);\n assembly and machine code instructions can be seen as an\nimplementation of a set of high-level programming language\ninstructions with respect to a given ISA; finally, executions are\nphysical, observable, implementations of those machine code\ninstructions. By the same token, programs formulated in a high-level\nlanguage are also implementations of specifications, and, as similarly\nargued by the dual-ontology paradigm, executions are implementations\nof high-level programming language instructions. According to Turner\n(2018), even the specification can be understood as an implementation\nof what has been called intention.\n\nWhat remains to be examined here is the nature of the implementation\nrelation thus defined. Analyzing this relation is essential to define\nthe notion of correctness\n (\u00a77).\n Indeed, a correct program amounts to a correct implementation of an\nalgorithm; and a correct computing system is a correct implementation\nof a set of specifications. In other words, under this view, the\nnotion of correctness is paired with that of implementation for any\nLoA: any level can be said to be correct with respect to upper levels\nif and only if it is a correct implementation thereof.\n\nThe following three subsections examine three main definitions of the\nimplementation relation that have been advanced in the philosophy of\ncomputer science literature.\n5.1 Implementation as Semantic Interpretation\n\nA first philosophical analysis of the notion of implementation in\ncomputer science is advanced by Rapaport (1999, 2005). He defines an\nimplementation I as the semantic interpretation of a\nsyntactic or abstract domain A in a medium of implementation\nM. If implementation is understood as a relation holding\nbetween a given LoA and any upper level in the hierarchical ontology\nof a computational system, it follows that Rapaport\u2019s definition\nextends accordingly, so that any LoA provides a semantic\ninterpretation in a given medium of implementation for the upper\nlevels. Under this view, specifications provide semantic\ninterpretations of intentions expressed by stakeholders in the\nspecification (formal) language, and algorithms provide semantic\ninterpretations of specifications using one of the many languages\nalgorithms can be formulated in (natural languages, pseudo-code, logic\nlanguages, functional languages etc.). The medium of implementation\ncan be either abstract or concrete. A computer program is the\nimplementation of an algorithm in that the former provides a semantic\ninterpretation of the syntactic constructs of the latter in a\nhigh-level programming language as its medium of implementation. The\nprogram\u2019s instructions interpret the algorithm's tasks in a\nprogramming language. Also the execution LoA provides a semantic\ninterpretation of the assembly/machine code operations into the medium\ngiven by the structural properties of the physical machine. According\nto the analysis in (Rapaport 1999, 2005), implementation is an\nasymmetric relation: if I is an implementation of A,\nA cannot be an implementation of I. However, the\nauthor argues that any LoA can be both a syntactic and a semantic\nlevel, that is, it can play the role of both the implementation I and\nof a syntactic domain A. Whereas an algorithm is assigned a semantic\ninterpretation by a program expressed in a high-level language, the\nsame algorithm provides a semantic interpretation for the\nspecification. It follows that the abstraction-implementation relation\npairs the functional-structural relation for computational\nsystems.\n\nPrimiero (2020) considers this latter aspect as one main limit of\nRapaport\u2019s (1999, 2005) account of implementation:\nimplementation reduces to a unique relation between a\nsyntactic level and its semantic interpretation and it does not\naccount for the layered ontology of computational systems seen in\n \u00a71.2.\n In order to extend the present definition of implementation to all\nLoAs, each level has to be reinterpreted each time either as syntactic\nor as a semantic level. This, in turn, has a repercussion on the\nsecond difficulty characterizing, according to Primero (2020),\nimplementation as a semantic interpretation: on the one hand, this\napproach does not take into account incorrect\nimplementations; on the other hand, for a given incorrect\nimplementation, the unique relation so defined can relate\nincorrectness only to one syntactic level, excluding all other levels\nas potential error locations.\n\nTurner (2018) aims to show that semantic interpretation not only does\nnot account for incorrect implementation, but not even to correct\nones. One first example is provided by the implementation of one\nlanguage into another: the implementing language here is not providing\na semantic interpretation of the implemented language, unless the\nformer is associated with a semantics providing meaning and\ncorrectness criteria for the latter. Such semantics will remain\nexternal to the implementation relation: whereas correctness is\nassociated with semantic interpretation, implementation does not\nalways come with a semantic interpretation. A second example is given\nby considering an abstract stack implemented by an array; again, the\narray does not provide correctness criteria for the stack. Quite to\nthe contrary, it is the stack that specifies correctness criteria for\nany of its implementation, arrays included.\n5.2 Implementation as the Relation Specification-Artifact\n\nThe fact that correctness criteria for the implementation relation are\nprovided by the abstract level\u00a0induces Turner (2012, 2014, 2018)\nto define implementation as the relation\nspecification-artefact. As examined in\n \u00a72,\n specifications have correctness jurisdiction over artifacts, that is,\nthey prescribe the allowed behaviors of artifacts. Also recall that\nartifacts can be both abstract and concrete entities, and that any LoA\ncan play the role of specification for lower levels. This amounts to\nsaying that the specification-artefact relation is able to define any\nimplementation relation across the layered ontology of computational\nsystems.\n\nDepending on how the specification-artifact relation is defined,\nTurner (2012) distinguishes as many as three different notions of\nimplementation. Consider the case of a physical machine implementing a\ngiven abstract machine. According to an intentional notion of\nimplementation, an abstract machine works as a specification for a\nphysical machine, provided it advances all the functional requirements\nthe latter must fulfill, i.e., it specifies (in principle) all the\nallowed behaviors of the implementing physical machine. According to\nan extensional notion of implementation, a physical machine\nis a correct implementation of an abstract machine if and only if\nisomorphisms can be established mapping states of the latter to states\nof the former, and transitions in the abstract machine correspond to\nactual executions (computational traces) of the artifact. Finally, an\nempirical notion of implementation requires the physical\nmachine to display computations that match those prescribed by the\nabstract machine; that is to say, correct implementation has to be\nevaluated empirically through testing.\n\nPrimiero (2020) underlines how, while this approach addresses the\nissue of correctness and miscomputation as it allows to distinguish a\ncorrect from an incorrect implementation, it still identifies a unique\nimplementation relation between a specification level and an artifact\nlevel. Again, if this account is allowed to involve the layered\nontology of computational systems by reinterpreting each time any LoA\neither as a specification or artifact, Turner\u2019s account prevents\nfrom referring to more than one level at the same time as the cause of\nmiscomputation:\u00a0a\u00a0miscomputation always occurs here as an\nincorrect implementation of a specification by an artifact. By\ndefining implementation as a relation holding accross all the LoAs,\none would be able to identify multiple incorrect implementations which\ndo not directly refer to the abstract specification. A miscomputation\nmay indeed be caused by an incorrect implementation of lower levels\nwhich is then inherited all the way down to the execution level.\n5.3 Implementation for LoAs\n\nPrimiero (2020) proposes a definition of implementation not as a\nrelation between two fixed levels, but one that is allowed to range\nover any LoA. Under this view, an implementation I is a\nrelation of instantiation holding between a LoA and any other\none higher in the abstraction hierarchy. Accordingly, a physical\ncomputing machine is an implementation of assembly/machine code\noperations; by transitivity, it can also be considered as an\ninstantiation of a set of instructions expressed in high-level\nprogramming language instructions. A program expressed in a high-level\nlanguage is an implementation of an algorithm; but it can also be\ntaken to be the instantiation of a set of specifications.\n\nSuch a definition of implementation allows Primiero (2020) to provide\na general definition of correctness: a physical computing system is\ncorrect if and only if it is characterized by correct implementations\nat any LoA. Hence correctness and implementation are coupled and\ndefined at any LoA. Functional correctness is the property of\na computational system that displays the functionalities required by\nthe specifications of that system. Procedural correctness\ncharacterizes computational systems displaying the functionalities\nintended by the implemented algorithms. And executional\ncorrectness is defined as the property of a system that is able\nto correctly execute the program on its architecture. Each of these\nforms of correctness can also be classified quantitatively, depending\non the amount of functionalities being satisfied. A functionally\nefficient computational system displays a minimal subset of\nthe functionalities required by the specifications; a functionally\noptimal system is able to display a maximal subset of those\nfunctionalities. Similarly, the author defines procedurally as well as\nexecutionally efficient and optimal computational systems.\n5.4 Physical Computation\n\nAccording to this definition, implementation shifts from level to\nlevel: a set of algorithms defining a computational system are\nimplemented as procedures in some formal language,\u00a0as\ninstructions in a high-level language,\u00a0or as operations in a\nlow-level programming language. An interesting question is whether\nany system, beyond computational artifacts, implementing\nprocedures of this sort qualifies as a computational system. In other\nwords, asking about the nature of physical implementation amounts to\nasking what is a computational system. If any system implementing an\nalgorithm would qualify as computational, the class of such systems\ncould be extended to biological systems, such as the brain or the\ncell; to physical systems, including the universe or some portion of\nit; and eventually to any system whatsoever, a thesis known as\npancomputationalism (for an exhaustive overview on the topic\nsee Rapaport 2018).\n\nTraditionally, a computational system is intended as a mechanical\nartifact that takes input data, elaborates them\nalgorithmically according to a set of instructions, and\nreturns manipulated data as outputs. For instance, von Neumann (1945,\np.1) states that \u201cAn automatic computing system is a (usually\nhighly composite) device, which can carry out instructions to perform\ncalculations of a considerable order of complexity\u201d. Such an\ninformal and well-accepted definition leaves some questions open,\nincluding whether computational systems have to be machines, whether\nthey have to process data algorithmically and, consequently, whether\ncomputations have to be Turing complete.\n\nRapaport (2018) provides a more explicit characterization of a\ncomputational system defined as any \u201cphysical plausible\nimplementation of anything logically equivalent to a universal Turing\nmachine\u201d. Strictly speaking personal computers are not physical\nTuring machines, but register machines are known to be Turing\nequivalent. To qualify as computational, systems must be\nplausible implementations thereof, in that Turing machines,\ncontrary to physical machines, have access to infinite memory space\nand are, as abstract machines, error free. According to\nRapaport\u2019s (2018) definition, any physical\nimplementation of this sort is thus a computational system, including\nnatural systems. This raises the question about which class of natural\nsystems is able to implement Turing equivalent computations. Searle\nfamously argued that anything can be an implementation of a Turing\nmachine, or of a logical equivalent model (Searle 1990). His argument\nlevers on the fact that being a Turing machine is a syntactic\nproperty, in that it is all about manipulating tokens of 0\u2019s and\n1\u2019s. According to Searle, syntactic properties are not intrinsic\nto physical systems, but they are assigned to them by an observer. In\nother words, a physical state of a system is not intrinsically a\ncomputational state: there must be an observer, or user, who assigns\nto that state a computational role. It follows that any system whose\nbehavior can be described as syntactic manipulation of 0\u2019s and\n1\u2019s is a computational system.\n\nHayes (1997) objects to Searle (1990) that if everything was a\ncomputational system, the property \u201cbeing a computational\nsystem\u201d would become vacuous, as all entities would possess it.\nInstead, there are entities which are computational systems, and\nentities which are not. Computational systems are those in which the\npatterns received as inputs and saved into memory are able to change\nthemselves. In other words, Hayes makes reference to the fact that\nstored inputs can be both data and instructions and that instructions,\nwhen executed, are able to modify the value of some input data.\n\u201cIf it were paper, it would be \u2018magic paper\u2019 on\nwhich writing might spontaneously change, or new writing appear\u201d\n(Hayes 1997, p. 393). Only systems able to act as \u201cmagic\npaper\u201d can be acknowledged as computational.\n\nA yet different approach comes from Piccinini (2007, 2008) in the\ncontext of his mechanistic analysis of physical computations\n(Piccinini 2015; see also the entry on\n computation in physical systems).\n A physical computing system is a system whose behaviors can be\nexplained mechanistically by describing the computing\nmechanism that brings about those behaviors. Mechanisms can be defined\nby \u201centities and activities organized such that they are\nproductive of regular changes from start or set-up to finish or\ntermination condition\u201d (Machamer et al. 2000; see the entry on\n mechanisms in science).\n Computations, as physical processes, can be understood as those\nmechanisms that \u201cgenerate output strings from input strings in\naccordance with general rules that apply to all input strings and\ndepend on the input (and sometimes internal states)\u201d (Piccinini\n2007, p. 108). It is easy to identify set-up and termination\nconditions for computational processes. Any system which can be\nexplained by describing an underlying computing mechanism is to be\nconsidered a computational system. The focus on explanation helps\nPiccinini avoid the Searlean conclusion that any system is a\ncomputational system: even if one may interpret, in principle, any\ngiven set of entities and activities as a computing mechanism, only\nthe need to explain a certain observed phenomenon in terms of a\ncomputing mechanism defines the system under examination as\ncomputational.\n6. Verification\n\nA crucial step in the software development process is verification.\nThis consists in the process of evaluating whether a given\ncomputational system is correct with respect to the specification of\nits design. In the early days of the computer industry, validity and\ncorrectness checking methods included several design and construction\ntechniques, see for example (Arif et al. 2018). Nowadays,\ncorrectness evaluation methods can be roughly sorted into two main\ngroups: formal verification and testing. Formal verification (Monin\nand Hinchey 2003) involves a proof of correctness with mathematical\ntools; software testing (Ammann and Offutt 2008) rather consists in\nrunning the implemented program to observe whether performed\nexecutions comply or not with the advanced specifications. In many\npractical cases, a combination of both methods is used (see for\ninstance Callahan et al. 1996).\n6.1 Models and Theories\n\nFormal verification methods require a representation of the\nsoftware under verification. In theorem proving (see van\nLeeuwen 1990), programs are represented in terms of axiomatic systems\nand a set of rules of inference representing the pre- and\npost-conditions of program transitions. A proof of correctness is then\nobtained by deriving formulas expressing specifications from the\naxioms. In model checking (Baier and Katoen 2008), a program\nis represented in terms of a state transition system, its property\nspecifications are formalised by temporal logic formulas (Kr\u00f6ger\nand Merz 2008), and a proof of correctness is achieved by a\ndepth-first search algorithm that checks whether those formulas hold\nof the state transition system.\n\nAxiomatic systems and state transition systems used for correctness\nevaluation can be understood as theories of the represented\nartifacts, in that they are used to predict and explain their future\nbehaviors. Methodologically state transition systems in model checking\ncan be compared with scientific models in empirical sciences (Angius\nand Tamburrini 2011). For instance, Kripke Structures (see Clarke\net al. 1999 ch. 2) are in compliance with Suppes\u2019\n(1960) definition of scientific models as set-theoretic structures\nestablishing proper mapping relations with models of data collected by\nmeans of experiments on the target empirical system (see also the\nentry on\n models in science).\n Kripke Structures and other state transition systems utilized in\nformal verification methods are often called system specifications.\nThey are distinguished from common specifications, also called\nproperty specifications. The latter specify some required behavioral\nproperties the program to be encoded must instantiate, while the\nformer specify (in principle) all potential executions of an already\nencoded program, thus allowing for algorithmic checks on its traces\n(Clarke et al. 1999). In order to achieve this goal, system\nspecifications are considered as abductive structures,\nhypothesizing the set of potential executions of a target\ncomputational system on the basis of the program\u2019s code and the\nallowed state transitions (Angius 2013b). Indeed, once it has been\nchecked whether some temporal logic formula holds of the modeled\nKripke Structure, the represented program is empirically tested\nagainst the behavioral property corresponding to the checked formula,\nin order to evaluate whether the model-hypothesis is an adequate\nrepresentation of the target computational system. Accordingly,\nproperty specifications and system specifications differ also in their\nintentional stance (Turner 2011): the former are requirements\non the program to be encoded, the latter are (hypothetical)\ndescriptions of the encoded program. The descriptive and abductive\ncharacter of state transition systems in model checking is an\nadditional and essential feature putting state transition systems on a\npar with scientific models.\n6.2 Testing and Experiments\n\nTesting is the more \u2018empirical\u2019 process of launching a\nprogram and observing its executions in order to evaluate whether they\ncomply with the supplied property specifications. Such technique is\nextensively used in the software development process. Philosophers and\nphilosophically-minded computer scientists have considered software\ntesting under the light of traditional methodological approaches in\nscientific discovery (Snelting 1998; Gagliardi 2007; Northover et\nal. 2008; Angius 2014) and questioned whether software tests can\nbe acknowledged as scientific experiments evaluating the\ncorrectness of programs (Schiaffonati and Verdicchio 2014,\nSchiaffonati 2015; Tedre 2015).\n\nDijkstra\u2019s well-known dictum \u201cProgram testing can be used\nto show the presence of bugs, but never to show their absence\u201d\n(Dijkstra 1970, p.7), introduces Popper\u2019s (1959) principle of\nfalsifiability into computer science (Snelting 1998). Testing\na program against an advanced property specification for a given\ninterval of time may exhibit some failures, but if no failure occurs\nwhile observing the running program one cannot conclude that the\nprogram is correct. An incorrect execution might be observed at the\nvery next system\u2019s run. The reason is that testers can only\nlaunch the program with a finite subset of the potential\nprogram\u2019s input set and only for a finite interval of time;\naccordingly, not all potential executions of the program to be tested\ncan be empirically observed. For this reason, the aim of software\ntesting is to detect programs\u2019 faults and not to guarantee their\nabsence (Ammann and Offutt 2008, p. 11). A program is falsifiable in\nthat tests can reveal faults (Northover et al. 2008). Hence,\ngiven a computational system and a property specification, a test is\nakin to a scientific experiment which, by observing the system\u2019s\nbehaviors, tries to falsify the hypothesis that the program is correct\nwith respect to the interested specification.\n\nHowever, other methodological and epistemological traits\ncharacterizing scientific experiments are not shared by software\ntests. A first methodological distinction can be recognized in that a\nfalsifying test leads to the revision of the computational system, not\nof the hypothesis, as in the case of testing scientific hypotheses.\nThis is due to the difference in the intentional stance of\nspecifications and empirical hypotheses in science (Turner 2011).\nSpecifications are requirements whose violation demands for program\nrevisions until the program becomes a correct instantiation of the\nspecifications.\n\nFor this, among other reasons, the traditional notion of scientific\nexperiment needs to be \u2018stretched\u2019 in order to be applied\nto software testing activities (Schiaffonati 2015). Theory-driven\nexperiments, characterizing most of the experimental sciences,\nfind no counterpart in actual computer science practice. If one\nexcludes the cases wherein testing is combined with formal methods,\nmost experiments performed by software engineers are rather\nexplorative, i.e. aimed at \u2018exploring\u2019\n\u201cthe realm of possibilities pertaining to the functioning of an\nartefact and its interaction with the environment in the absence of a\nproper theory or theoretical background\u201d (Schiaffonati 2015:\n662). Software testers often do not have theoretical control on the\nexperiments they perform; exploration on the behaviors of the\ncomputational system interacting with users and environments rather\nallows testers to formulate theoretical generalizations on the\nobserved behaviors. Explorative experiments in computer science are\nalso characterized by the fact that programs are often tested in a\nreal-like environment wherein testers play the role of users. However,\nit is an essential feature of theory-driven experiments that\nexperimenters do not take part in the experiment to be carried\nout.\n\nAs a result, while some software testing activities are closer to the\nexperimental activities one finds in empirical sciences, some others\nrather define a new typology of experiment that turns out to belong to\nthe software development process. Five typologies of experiments can\nbe distinguished in the process of specifying, implementing, and\nevaluating computational systems (Tedre 2015):\n\nfeasibility experiments are performed to evaluate whether\na system performs the functions specified by users and\nstakeholders;\ntrial experiments are carried out to evaluate isolated\ncapabilities of the system given some set of initial conditions;\nfield experiments are performed in real environments and\nnot in simulated ones;\ncomparison experiments test similar systems,\ninstantiating in different ways the same function, to evaluate which\ninstantiation better performs the desired function both in real-like\nand real environments;\nfinally, controlled experiments are used to appraise\nadvanced hypotheses on the behaviors of the testing computational\nsystem and are the only ones on a par with scientific theory-driven\nexperiments, in that they are carried out on the basis of some\ntheoretical hypotheses under evaluation.\n\n6.3 Explanation\n\nA software test is considered successful when miscomputations are\ndetected (assuming that no computational artifact is 100% correct).\nThe successive step is to find out what caused the execution to be\nincorrect, that is, to trace back the fault (more familiarly named\n\u2018bug\u2019), before proceeding to the debugging phase and then\ntesting the system again. In other words, an explanation of\nthe observed miscomputation is to be advanced.\n\nEfforts have been made to consider explanations in computer science\n(Piccinini 2007; Piccinini and Craver 2011; Piccinini 2015; Angius and\nTamburrini 2016) in relation to the different models of explanations\nelaborated in the philosophy of science. In particular, computational\nexplanations can be understood as a specific kind of mechanistic\nexplanation (Glennan 1996; Machamer et al. 2000; Bechtel\nand Abrahamsen 2005), insofar as computing processes can be analyzed\nas mechanisms (Piccinini 2007; 2015; see also the entry on\n computation in physical systems).\n\nConsider a processor executing an instruction. The involved process\ncan be understood as a mechanism whose components are states and\ncombinatory elements in the processor instantiating the functions\nprescribed by the relevant hardware specifications (specifications for\nregisters, for the Arithmetic Logic Unit etc..), organized in such a\nway that they are capable of carrying out the observed execution.\nProviding the description of such a mechanism counts as advancing a\nmechanist explanation of the observed computation, such as the\nexplanation of an operational malfunction.\n\nFor every type of miscomputation (see\n \u00a77.3),\n a corresponding mechanist explanation can be defined at the adequate\nLoA and with respect to the set of specifications characterizing that\nLoA. Indeed, abstract descriptions of mechanisms still supply one with\na mechanist explanation in the form of a mechanism schema,\ndefined as \u201ca truncated abstract description of a mechanism that\ncan be filled with descriptions of known component parts and\nactivities\u201d (Machamer et al. 2000, p. 15). For\ninstance, suppose the very common case in which a machine miscomputes\nby executing a program containing syntax errors, called slips. The\ncomputing machine is unable to correctly implement the functional\nrequirements provided by the program specifications. However, for\nexplanatory purposes, it would be redundant to provide an explanation\nof the occurred slip at the hardware level of abstraction, by\nadvancing the detailed description of the hardware components and\ntheir functional organization. In such cases, a satisfactory\nexplanation may consist in showing that the program\u2019s code is\nnot a correct instantiation of the provided program specifications\n(Angius and Tamburrini 2016). In order to explain mechanistically an\noccurred miscomputation, it may be sufficient to provide the\ndescription of the incorrect program, abstracting from the rest of the\ncomputing mechanism (Piccinini and Craver 2011). Abstraction is a\nvirtue not only in software development and specification, but also in\nthe explanation of computational systems\u2019 behaviors.\n7. Correctness\n\nEach of the different approaches on software verification examined in\nthe previous section assumes a different understanding of correctness\nfor software. Standardly, correctness has been understood as a\nrelation holding between an abstraction and its implementation, such\nthat it holds if the latter fulfills the properties formulated by the\nformer. Once computational systems are described as having a layered\nontology, correctness needs to be reformulated as the relation that\nany structural level entertains with respect to its functional level\n(Primiero, 2020). Hence, correctness can still be considered as a\nmathematical relationship when formulated between abstract and\nfunctional level; while it can be considered as an empirical\nrelationship when formulated between the functional and the\nimplementation levels. One of the earlier debates in the philosophy of\ncomputer science (De Millo et al. 1979; Fetzer 1988) was\nindeed around this distinction.\n7.1 Mathematical Correctness\n\nFormal verification methods grant an a-priori analysis of the\nbehaviors of programs, without requiring the observation of any of\ntheir implementation or considering their execution. In particular,\ntheorem proving allows one to deduce any potential behavior\nof the program under consideration and its behavioral properties from\na suitable axiomatic representation. In the case of model checking,\none knows in advance the behavioural properties displayed by the\nexecution of a program by performing an algorithmic search of the\nformulas valid in a given set-theoretic model. These considerations\nfamously led Hoare (1969) to conclude that program development is an\n\u201cexact science\u201d, which should be characterized by\nmathematical proofs of correctness, epistemologically on a par with\nstandard proofs in mathematical practice.\n\nDe Millo et al. (1979) question Hoare\u2019s thesis: correct\nmathematical proofs are usually elegant and\ngraspable, implying that any (expert) reader can\n\u201csee\u201d that the conclusion follows from the premises (for\nthe notion of elegance in software see also Hill (2018)). What are\noften called Cartesian proofs (Hacking 2014) do not have a\ncounterpart in correctness proofs, typically long and cumbersome,\ndifficult to grasp and not explaining why the conclusion necessarily\nfollows from the premises. Yet, many proofs in mathematics are long\nand complex, but they are in principle surveyable, thanks to\nthe use of lemmas, abstractions and the analytic construction of new\nconcepts leading step by step to the statement to be proved.\nCorrectness proofs, on the contrary, do not involve the creation of\nnew concepts, nor the modularity one typically finds in mathematical\nproofs (Turner, 2018). And yet, proofs that are not surveyable cannot\nbe considered mathematical proofs (Wittgenstein 1956).\n\nA second theoretical difficulty concerning proofs of correctness for\ncomputer programs concerns their complexity and that of the programs\nto be verified. Already Hoare (1981) admitted that while verification\nof correctness is always possible in principle, in practice it is\nhardly achievable. Except for trivial cases, contemporary software is\nmodularly encoded, is required to satisfy a large set of\nspecifications, and it is developed so as to interact with other\nprograms, systems, users. Embedded and reactive software are cases in\npoint. In order to verify such complex software, correctness proofs\nare carried out automatically. Hence, on the one hand, the correctness\nproblem shifts from the program under examination to the program\nperforming the verification, e.g. a theorem prover; on the other hand,\nproofs carried out by a physical process can go wrong, due to\nmechanical mistakes of the machine. Against this infinite regress\nargument, Arkoudas and Bringsjord (2007) argue that one can make use\nof a proof checker which, by being a relatively small program, is\nusually easier to verify.\n\nMost recently, formal methods for checking correctness based on a\ncombination of logical and statistical analysis have given new\nstimulus to this research area: the ability of Separation Logics\n(Reynolds, 2002) to offer a representation of the logical behavior of\nthe physical memory of computational systems, and the possibility of\nconsidering probabilistic distributions of inputs as statistical\nsource of errors, have allowed formal correctness check of large\ninteractive systems like the Facebook platform (see also Pym et\nal. 2019).\n7.2 Physical Correctness\n\nFetzer (1988) objected that deductive reasoning is only able to\nguarantee for the correctness of a program with respect to its\nspecifications, but not for the correctness of a computational system,\nthat is also accounting for the program\u2019s physical\nimplementation. Even if the program were correct with respect to any\nof the related upper LoAs (algorithms, specifications, requirements),\nits implementation could still violate one or more of the intended\nspecifications due to a physical malfunctioning. The former kind of\ncorrectness can in principle be proved mathematically, but the\ncorrectness of the execution LoA requires an empirical assessment. As\nexamined in\n \u00a76.2,\n software testing can show only in principle the correctness of a\ncomputational system. In practice, the number of allowed executions of\nnon-trivial systems are potentially infinite and cannot be\nexhaustively checked in a finite (or reasonable) amount of time\n(Dijkstra 1974). Most successful testing methods rather see both\nformal verification and testing used together to reach a satisfactory\ncorrection level.\n\nAnother objection to the theoretical possibility of mathematical\ncorrectness is that since proofs are carried out by a theorem prover,\ni.e. a physical machine, the knowledge one attains about computational\nsystems is not a-priori but empirical (see Turner 2018 ch.\n25). However, Burge (1988) argues that computer-based proofs of\ncorrectness can still be regarded as a-priori, in that even\nthough their possibility depends on sensory experience, their\njustification does not (as it is for a-posteriori knowledge).\nFor instance, the knowledge that red is a color is a-priori\neven though it requires having sensory experience of red; this is\nbecause \u2018red is a colour\u2019 is true independently of any\nsensory experience. For further discussion on the nature of the use of\ncomputers in mathematical proofs, see (Hales 2008; Harrison 2008;\nTymoczko 1979, 1980).\n\nThe problem of correctness eventually reduces to asking what it means\nfor a physical machine to satisfy an abstract requirement. According\nto the simple mapping account, a computational system\nS is a correct implementation of specification SP\nonly if:\n\nthere can be established a morphism from the states ascribed to\nS to the states defined by SP, and\nfor any state transition \\(s_1 \\rightarrow s_2\\) in S\nthere is a state transition \\(s'_1 \\rightarrow s'_2\\) in SP\nbetween state \\(s'_1\\) mapping to \\(s_1\\) and state \\(s'_2\\) mapping\nto \\(s_2\\).\n\n\nThe simple mapping account only demands for an extensional agreement\nbetween the description of S and SP. The weakness of\nthis account is that it is quite easy to identify an extensional\nagreement between any couple of physical system-specification, leaving\nroom for a pancomputationalist perspective.\n\nThe danger of pancomputationalism has led some authors to attempt an\naccount of correct implementation that somehow restricts the class of\npossible interpretations. In particular,\n\nThe causal account (D. J. Chalmers 1996; Copeland 1996)\nsuggests that the material conditional (if the system is in the\nphysical state \\(s_1\\) \u2026) is replaced by a counterfactual\none.\nThe semantic account argues that a computational system\nmust be associated with a semantic description, specifying what the\nsystem is to achieve (Sprevak 2012). For example, a physical device\ncould be interpreted as an AND gate or an OR gate but without a\ndefinition of the device there is no way of fixing what the artifact\nis.\nThe syntactic account demands that only physical states\nthat can be defined as syntactic can be mapped onto computational\nstates. What remains to be examined is what defines a syntactic state\n(see Piccinini 2015 or the entry on\n computation in physical systems\n for an overview of the syntactic account\nThe normative account (Turner 2012) maintains not only\nthat abstract and physical computational processes must be in\nagreement, but also that the abstract specification has normative\nforce over the system. According to such an account, computations are\nphysical processes whose function is fixed by an abstract\nspecification. This relationship is stronger than both the semantic\naccount, asking for a simple descriptive relationship, and the\nsyntactic account, focusing on a syntactic object and its semantic\ninterpretation.\n\n7.3 Miscomputations\n\nFrom what has been said so far, it follows that correctness of\nimplemented programs does not automatically establish the\nwell-functioning of a computational system. Turing (1950) already\ndistinguished between errors of functioning and errors of\nconclusion. The former are caused by a faulty implementation\nunable to execute the instructions of some high-level language\nprogram; errors of conclusion characterize correct abstract machines\nthat nonetheless fail to carry out the tasks they were supposed to\naccomplish. This may happen in those cases in which a program\ninstantiates correctly some specifications which do not properly\nexpress the users\u2019 requirements on such a program. In both\ncases, machines implementing correct programs can still be said to\nmiscompute.\n\nTuring\u2019s distinction between errors of functioning and errors of\nconclusion has been expanded into a complete taxonomy of\nmiscomputations (Fresco and Primiero 2013). The classification is\nestablished on the basis of the different LoAs defining computational\nsystems. Errors can be:\n\nconceptual: they violate validity conditions requiring\nconsistency for specifications expressed in propositional conjunctive\nnormal form;\nmaterial: they violate the correctness requirements of\nprograms with respect to the set of their specifications;\nperformable: they arise when physical constraints are\nbreached by some faulty implementing hardware.\n\n\nPerformable errors clearly emerge only at the execution level, and\nthey correspond with Turing\u2019s (1950) error of functioning, also\ncalled operational malfunctions. Conceptual and material\nerrors may arise at any level of abstraction from the intention level\ndown to the physical implementation level. Conceptual errors engender\nmistakes, while material errors induce failures. For\ninstance, a mistake at the intention level consists of an inconsistent\nset of requirements, while at the physical implementation level it may\ncorrespond to an invalid hardware design (such as in the choice of the\nlogic gates for the truth-functional connectives). Failures occurring\nat the specification level may be due to a design that is deemed to be\nincomplete with respect to the set of desired functional requirements,\nwhile a failure at the algorithm level occurs in those frequent cases\nin which the algorithm is found not to fulfill the specifications.\nBeyond mistakes, failures, and operational malfunctions,\nslips are a source of miscomputations at the high-level\nprogramming language instructions level: they may be conceptual or\nmaterial errors due to, respectively, a syntactic or a semantic flaw\nin the program. Conceptual slips appear in all those cases in which\nthe syntactical rules of high-level languages are violated; material\nslips involve the violation of semantic rules of programming\nlanguages, such as when a variable is used but not initialized.\n\nA further distinction has to be made between dysfunctions and\nmisfunctions for software-based computational systems\n(Floridi, Fresco and Primiero 2015). Software can only misfunction but\ncannot ever dysfunction. A software token can dysfunction in case its\nphysical implementation fails to satisfy intentions or specifications.\nDysfunctions only apply to single tokens since a token dysfunctions in\nthat it does not behave as the other tokens of the same type do with\nrespect to the implemented functions. For this reason, dysfunctions do\nnot apply to the intention level and the specification level. On the\ncontrary, both software types and tokens can misfunction, since\nmisfunctions do not depend on comparisons with tokens of the same type\nbeing able to perform some implemented function or not. Misfunction of\ntokens usually depends on the dysfunction of some other component,\nwhile misfunction of types is often due to poor design. A software\ntoken cannot dysfunction, because all tokens of a given type implement\nfunctions specified uniformly at the intention and specification\nlevels. Those functions are implemented at the algorithm\nimplementation level before being performed at the execution level; in\ncase of correct implementation, all tokens will behave correctly at\nthe execution level (provided that no operational malfunction occurs).\nFor the very same reason, software tokens cannot misfunction, since\nthey are implementations of the same intentions and specifications.\nOnly software types can misfunction in case of poor design;\nmisfunctioning software types are able to correctly perform their\nfunctions but may also produce some undesired side-effect. For the\napplication of the notion of malfunctioning to the problem of malware\nclassification, see (Primiero et al. 2019).\n8. The Epistemological Status of Computer Science\u00a0\n\nBetween the 1960s and the 1970s, computer science emerged as an\nacademic discipline independent from its older siblings, mathematics\nand physics, and with it the problem of defining its epistemological\nstatus as influenced by mathematical, empirical, and engineering\nmethods (Tedre and Sutien 2008, Tedre 2011, Tedre 2015, Primiero\n2020). A debate is still in place today concerning whether computer\nscience has to be mostly considered as a mathematical\ndiscipline, a branch of engineering, or as a scientific\ndiscipline.\n8.1 Computer Science as a Mathematical Discipline\n\nAny epistemological characterization of computer science is based on\nontological, methodological, and epistemological commitments, namely\non assumptions about the nature of computational systems, the methods\nguiding the software development process, and the kind of reasoning\nthereby involved, whether deductive, inductive, or a combination of\nboth (Eden 2007).\n\nThe origin of the analysis of computation as a mathematical notion\ncame notoriously from logic, with Hilbert's question concerning\nthe decidability of predicate calculus, known as the\nEntschiedungsproblem (Hilbert and Ackermann 1950): could\nthere be a mechanical procedure for deciding of an arbitrary sentence\nof logic whether it is provable? To address this question, a rigorous\nmodel of the informal concept of an effective or mechanical method in\nlogic and mathematics was required. This is first and foremost a\nmathematical endeavor: one has to develop a mathematical analogue of\nthe informal notion. Supporters of the view that computer science is\nmathematical in nature assume that a computer program can be seen as a\nphysical realization of such a mathematical entity and that one can\nreason about programs deductively through the formal methods of\ntheoretical computer science.\u00a0Dijkstra (1974) and Hoare (1986)\nwere very explicit in considering programs\u2019 instructions as\nmathematical sentences, and considering a formal semantics for\nprogramming languages in terms of an axiomatic system (Hoare 1969).\nProvided that program specifications and instructions are advanced in\nthe same formal language, formal semantics provide the means to prove\ncorrectness. Accordingly, knowledge about the behaviors of\ncomputational systems is acquired by the deductive reasoning involved\nin mathematical proofs of correctness. The reason at the basis of such\na rationalist optimism (Eden 2007) about what can be known about\ncomputational systems is that they are artifacts, that is,\nhuman-made systems and, as such, one can predict their\nbehaviors with certainty (Knuth 1974).\n\nAlthough a central concern of theoretical computer science, the topics\nof computability and complexity are covered in existing entries on the\n Church-Turing thesis,\n computational complexity theory, and\n recursive functions.\n8.2 Computer Science as an Engineering Discipline\n\nIn the late 1970s, the increasing number of applications of\ncomputational systems in everyday contexts, and the consequent booming\nof market demands caused a deviation of interests for computer\nscientists in Academia and in Industry: from focusing on methods of\nproving programs\u2019 correctness, they turned to methods for\nmanaging complexity and evaluating the reliability of those system\n(Wegner 1976). Indeed, expressing formally the specifications,\nstructure, and input of highly complex programs embedded in larger\nsystems and interacting with users is practically impossible, and\nhence providing mathematical proofs of their correctness becomes\nmostly unfeasible. Computer science research developed in the\ndirection of testing techniques able to provide a statistical\nevaluation of correctness, often called reliability (Littlewood and\nStrigini 2000), in terms of estimation of error distributions in a\nprogram\u2019s code.\n\nIn line with this engineering account of computer science is the\nthesis that reliability of computational systems is evaluated in the\nsame way that civil engineering does for bridges and aerospace\nengineering for airplanes (DeMillo et al. 1979). In\nparticular, whereas empirical sciences examine what exists, computer\nscience focuses on what can exist, i.e., on how to produce\nartifacts, and it should be therefore acknowledged as an\n\u201cengineering of mathematics\u201d (Hartmanis 1981). Similarly,\nwhereas scientific inquiries are involved in discovering laws\nconcerning the phenomena under observation, one cannot identify proper\nlaws in computer science practice, insofar as the latter is rather\ninvolved in the production of phenomena concerning computational\nartifacts (Brooks 1996).\n8.3\u00a0Computer Science as a Scientific Discipline\n\nAs examined in\n \u00a76,\n because software testing and reliability measuring techniques are\nknown for their incapability of assuring for the absence of code\nfaults (Dijkstra 1970), in many cases, and especially for the\nevaluation of the so-called safety-critical systems (such as\ncontrollers of airplanes, rockets, nuclear plants etc..), a\ncombination of formal methods and empirical testing is used to\nevaluate correctness and dependability. Computer science can\naccordingly be understood as a scientific discipline, in that it makes\nuse of both deductive and inductive probabilistic reasoning to examine\ncomputational systems (Denning et al. 1981, 2005, 2007; Tichy 1998;\nColburn 2000).\n\nThe thesis that computer science is, from a methodological viewpoint,\non a par with empirical sciences traces back to Newell, Perlis, and\nSimon\u2019s 1967 letter to Science (Newell et al. 1967) and\ndominated all the 1980\u2019s (Wegner 1976). In the 1975 Turing Award\nlecture, Newell and Simon argued:\n\nComputer science is an empirical discipline. We would have called it\nan experimental science, but like astronomy, economics, and geology,\nsome of its unique forms of observation and experience do not fit a\nnarrow stereotype of the experimental method. Nonetheless, they are\nexperiments. Each new machine that is built is an experiment. Actually\nconstructing the machine poses a question to nature; and we listen for\nthe answer by observing the machine in operation and analyzing it by\nall analytical and measurement means available (Newell and Simon 1975,\np. 114)\n\n\nSince Newell and Simon\u2019s Turing award lecture, it has been clear\nthat computer science can be understood as an empirical science but of\na special sort, and this is related to the nature of experiments in\ncomputing. Indeed, much current debate on the epistemological status\nof computer science concerns the problem of defining what kind of\nscience it is (Tedre 2011, Tedre 2015) and, in particular, the nature\nof experiments in computer science (Schiaffonati and Verdicchio 2014),\nthe nature, if any, of laws and theorems in computing (Hartmanis 1993;\nRombach and Seelish 2008), and the methodological relation between\ncomputer science and software engineering (Gruner 2011).\n", "bibliography": {"categories": [], "cat_ref_text": {"ref_list": ["Abramsky, Samson &amp; Guy McCusker, 1995, \u201cGames and Full\nAbstraction for the Lazy \\(\\lambda\\)-Calculus\u201d, in D. Kozen\n(ed.), <em>Tenth Annual IEEEE Symposium on Logic in Computer\nScience</em>, IEEE Computer Society Press, pp. 234\u201343.\ndoi:10.1109/LICS.1995.523259", "Abramsky, Samson, Pasquale Malacaria, &amp; Radha Jagadeesan,\n1994, \u201cFull Abstraction for PCF\u201d, in M. Hagiya &amp; J.C.\nMitchell (eds.), <em>Theoretical Aspects of Computer Software:\nInternational Symposium TACS \u201894</em>, Sendai, Japan, April\n19\u201322, 1994, Springer-Verlag, pp. 1\u201315.", "Abrial, Jean-Raymond, 1996, <em>The B-Book: Assigning Programs to\nMeanings</em>, Cambridge: Cambridge University Press.", "Alama, Jesse, 2015, \u201cThe Lambda Calculus\u201d, <em>The\nStanford Encyclopedia of Philosophy</em> (Spring 2015 Edition), Edward\nN. Zalta (ed.), URL =\n &lt;<a href=\"https://plato.stanford.edu/archives/spr2015/entries/lambda-calculus/\">https://plato.stanford.edu/archives/spr2015/entries/lambda-calculus/</a>&gt;.", "Allen, Robert J., 1997, <em>A Formal Approach to Software\nArchitecture</em>, Ph.D. Thesis, Computer Science, Carnegie Mellon\nUniversity. Issued as CMU Technical Report CMU-CS-97-144.\n <a href=\"http://www.cs.cmu.edu/~able/paper_abstracts/rallen_thesis.htm\" target=\"other\">Allen 1997 available on line</a>", "Ammann, Paul &amp; Jeff Offutt, 2008, <em>Introduction to Software\nTesting</em>, Cambridge: Cambridge University Press.", "Angius, Nicola, 2013a, \u201cAbstraction and Idealization in the\nFormal Verification of Software\u201d, <em>Minds and Machines</em>,\n23(2): 211\u2013226. doi:10.1007/s11023-012-9289-8", "\u2013\u2013\u2013, 2013b, \u201cModel-Based Abductive\nReasoning in Automated Software Testing\u201d, <em>Logic Journal of\nIGPL</em>, 21(6): 931\u2013942. doi:10.1093/jigpal/jzt006", "\u2013\u2013\u2013, 2014, \u201cThe Problem of Justification\nof Empirical Hypotheses in Software Testing\u201d, <em>Philosophy\n&amp; Technology</em>, 27(3): 423\u2013439.\ndoi:10.1007/s13347-014-0159-6", "Angius, N., &amp; Primiero, G., 2018, \u201cThe logic of identity\nand copy for computational artefacts\u201d, <em>Journal of Logic and\nComputation</em>, 28(6): 1293\u20131322.", "Angius, Nicola &amp; Guglielmo Tamburrini, 2011, \u201cScientific\nTheories of Computational Systems in Model Checking\u201d, <em>Minds\nand Machines</em>, 21(2): 323\u2013336.\ndoi:10.1007/s11023-011-9231-5", "\u2013\u2013\u2013, 2017, \u201cExplaining engineered\ncomputing systems\u2019 behaviour: the role of abstraction and\nidealization\u201d, <em>Philosophy &amp; Technology</em>, 30(2):\n239\u2013258.", "Anscombe, G. E. M., 1963, <em>Intention</em>, second edition,\nOxford: Blackwell.", "Arkoudas, Konstantine &amp; Selmer Bringsjord, 2007,\n\u201cComputers, Justification, and Mathematical Knowledge\u201d,\n<em>Minds and Machines</em>, 17(2): 185\u2013202.\ndoi:10.1007/s11023-007-9063-5", "Arif, R. Mori, E., and Primiero, G, 2018, \u201cValidity and\nCorrectness before the OS: the case of LEOI and LEOII\u201d, in\nLiesbeth de Mol, Giuseppe Primiero (eds.), <em>Reflections on\nProgrammings Systems - Historical and Philosophical Aspects</em>,\nPhilosophical Studies Series, Cham: Springer, pp. 15\u201347.", "Ashenhurst, Robert L. (ed.), 1989, \u201cLetters in the ACM\nForum\u201d, <em>Communications of the ACM</em>, 32(3): 287.\ndoi:10.1145/62065.315925", "Baier, A., 1970, \u201cAct and Intent\u201d, <em>Journal of\nPhilosophy</em>, 67: 648\u2013658.", "Baier, Christel &amp; Joost-Pieter Katoen, 2008, <em>Principles of\nModel Checking</em>, Cambridge, MA: The MIT Press.", "Bass, Len, Paul C. Clements, &amp; Rick Kazman, 2003 [1997],\n<em>Software Architecture in Practice</em>, second edition, Reading,\nMA: Addison-Wesley; first edition 1997; third edition, 2012.", "Bechtel, William &amp; Adele Abrahamsen, 2005, \u201cExplanation:\nA Mechanist Alternative\u201d, <em>Studies in History and Philosophy\nof Science Part C: Studies in History and Philosophy of Biological and\nBiomedical Sciences</em>, 36(2): 421\u2013441.\ndoi:10.1016/j.shpsc.2005.03.010", "Boghossian, Paul A., 1989, \u201cThe Rule-following\nConsiderations\u201d, <em>Mind</em>, 98(392): 507\u2013549.\ndoi:10.1093/mind/XCVIII.392.507", "Bourbaki, Nicolas, 1968, <em>Theory of Sets</em>, Ettore Majorana\nInternational Science Series, Paris: Hermann.", "Bratman, M. E., 1987, <em>Intention, Plans, and Practical\nReason</em>, Cambridge, MA: Harvard University Press.", "Bridges, Douglas &amp; Palmgren Erik, 2013, \u201cConstructive\nMathematics\u201d, <em>The Stanford Encyclopedia of Philosophy</em>\n(Winter 2013 Edition), Edward N. Zalta (ed.), URL =\n &lt;<a href=\"https://plato.stanford.edu/archives/win2013/entries/mathematics-constructive/\">https://plato.stanford.edu/archives/win2013/entries/mathematics-constructive/</a>&gt;.", "Brooks, Frederick P. Jr., 1995, <em>The Mythical Man Month: Essays\non Software Engineering</em>, Anniversary Edition, Reading, MA:\nAddison-Wesley.", "\u2013\u2013\u2013, 1996, \u201cThe Computer Scientist as\nToolsmith II\u201d, <em>Communications of the ACM</em>, 39(3):\n61\u201368. doi:10.1145/227234.227243", "Burge, Tyler, 1998, \u201cComputer Proof, Apriori Knowledge, and\nOther Minds\u201d, <em>No\u00fbs</em>, 32(S12): 1\u201337.\ndoi:10.1111/0029-4624.32.s12.1", "Bynum, Terrell Ward, 2008, \u201cMilestones in the History of\nInformation and Computer Ethics\u201d, in Himma and Tavani 2008:\n25\u201348. doi:10.1002/9780470281819.ch2", "Callahan, John, Francis Schneider, &amp; Steve Easterbrook, 1996,\n\u201cAutomated Software Testing Using Model-Checking\u201d, in\n<em>Proceeding Spin Workshop</em>, J.C. Gregoire, G.J. Holzmann and D.\nPeled (eds.), New Brunswick, NJ: Rutgers University, pp.\n118\u2013127.", "Cardelli, Luca &amp; Peter Wegner, 1985, \u201cOn Understanding\nTypes, Data Abstraction, and Polymorphism\u201d, 17(4):\n471\u2013522.\n [<a href=\"http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf\" target=\"other\">Cardelli and Wegner 1985 available online</a>]", "Carnap, R., 1966, <em>Philosophical foundations of physics</em>\n(Vol. 966), New York: Basic Books.", "Carrara, M., Gaio, S., and Soavi, M., 2014, \u201cArtifact kinds,\nidentity criteria, and logical adequacy\u201d, in M. Franssen, P.\nKroes, T. Reydon and P. E. Vermaas (eds.), <em>Artefact Kinds:\nOntology and The Human-made World</em>, New York: Springer, pp.\n85\u2013101.", "Chalmers, A. F., 1999, <em>What is this thing called\nScience?</em>, Maidenhead: Open University Press", "Chalmers, David J., 1996, \u201cDoes a Rock Implement Every\nFinite-State Automaton?\u201d <em>Synthese</em>, 108(3):\n309\u201333.\n [<a href=\"http://consc.net/papers/rock.html\" target=\"other\">D.J. Chalmers 1996 available online</a>]\n doi:10.1007/BF00413692", "Clarke, Edmund M. Jr., Orna Grumberg, &amp; Doron A. Peled, 1999,\n<em>Model Checking</em>, Cambridge, MA: The MIT Press.", "Colburn, Timothy R., 1999, \u201cSoftware, Abstraction, and\nOntology\u201d, <em>The Monist</em>, 82(1): 3\u201319.\ndoi:10.5840/monist19998215", "\u2013\u2013\u2013, 2000, <em>Philosophy and Computer\nScience</em>, Armonk, NY: M.E. Sharp.", "Colburn, T. R., Fetzer, J. H. , and Rankin T. L., 1993,\n<em>Program Verification: Fundamental Issues in Computer Science</em>,\nDordrecht: Kluwer Academic Publishers.", "Colburn, Timothy &amp; Gary Shute, 2007, \u201cAbstraction in\nComputer Science\u201d, <em>Minds and Machines</em>, 17(2):\n169\u2013184. doi:10.1007/s11023-007-9061-7", "Copeland, B. Jack, 1993, <em>Artificial Intelligence: A\nPhilosophical Introduction</em>, San Francisco: John Wiley &amp;\nSons.", "\u2013\u2013\u2013, 1996, \u201cWhat is Computation?\u201d\n<em>Synthese</em>, 108(3): 335\u2013359. doi:10.1007/BF00413693", "\u2013\u2013\u2013, 2015, \u201cThe Church-Turing\nThesis\u201d, <em>The Stanford Encyclopedia of Philosophy</em>\n(Summer 2015 Edition), Edward N. Zalta (ed.), URL =\n &lt;<a href=\"https://plato.stanford.edu/archives/sum2015/entries/church-turing/\">https://plato.stanford.edu/archives/sum2015/entries/church-turing/</a>&gt;.", "Copeland, B. Jack &amp; Oron Shagrir, 2007, \u201cPhysical\nComputation: How General are Gandy\u2019s Principles for\nMechanisms?\u201d <em>Minds and Machines</em>, 17(2): 217\u2013231.\ndoi:10.1007/s11023-007-9058-2", "\u2013\u2013\u2013, 2011, \u201cDo Accelerating Turing\nMachines Compute the Uncomputable?\u201d <em>Minds and Machines</em>,\n21(2): 221\u2013239. doi:10.1007/s11023-011-9238-y", "Cummins, Robert, 1975, \u201cFunctional Analysis\u201d, <em>The\nJournal of Philosophy</em>, 72(20): 741\u2013765.\ndoi:10.2307/2024640", "Davidson, D., 1963, \u201cActions, Reasons, and Causes,\u201d\nreprinted in <em>Essays on Actions and Events</em>, Oxford: Oxford\nUniversity Press, 1980, pp. 3\u201320.", "\u2013\u2013\u2013, 1978, \u201cIntending\u201d, reprinted in\n<em>Essays on Actions and Events</em>, Oxford: Oxford University\nPress, 1980, pp. 83\u2013102.", "De Millo, Richard A., Richard J. Lipton, &amp; Alan J. Perlis,\n1979, \u201cSocial Processes and Proofs of Theorems and\nPrograms\u201d, <em>Communications of the ACM</em>, 22(5):\n271\u2013281. doi:10.1145/359104.359106", "Denning, Peter J., 2005, \u201cIs Computer Science\nScience?\u201d, <em>Communications of the ACM</em>, 48(4):\n27\u201331. doi:10.1145/1053291.1053309", "\u2013\u2013\u2013, 2007, \u201cComputing is a Natural\nScience\u201d, <em>Communications of the ACM</em>, 50(7):\n13\u201318. doi:10.1145/1272516.1272529", "Denning, Peter J., Edward A. Feigenbaum, Paul Gilmore, Anthony C.\nHearn, Robert W. Ritchie, &amp; Joseph F. Traub, 1981, \u201cA\nDiscipline in Crisis\u201d, <em>Communications of the ACM</em>,\n24(6): 370\u2013374. doi:10.1145/358669.358682", "Devlin, Keith, 1994, <em>Mathematics: The Science of Patterns: The\nSearch for Order in Life, Mind, and the Universe</em>, New York: Henry\nHolt.", "Dijkstra, Edsger W., 1970, <em>Notes on Structured\nProgramming</em>, T.H.-Report 70-WSK-03, Mathematics Technological\nUniversity Eindhoven, The Netherlands.\n [<a href=\"http://www.cs.utexas.edu/users/EWD/ewd02xx/EWD249.PDF\" target=\"other\">Dijkstra 1970 available online</a>]", "\u2013\u2013\u2013, 1974, \u201cProgramming as a Discipline of\nMathematical Nature\u201d, <em>American Mathematical Monthly</em>,\n81(6): 608\u2013612.\n [<a href=\"http://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD361.html\" target=\"other\">Dijkstra 1974 available online</a>", "Distributed Software Engineering, 1997, <em>The Darwin\nLanguage</em>, Department of Computing, Imperial College of Science,\nTechnology and Medicine, London.\n [<a href=\"http://www.cs.toronto.edu/~chechik/courses00/ece450/darwin-lang.pdf\" target=\"other\">Darwin language 1997 available online</a>]", "Duhem, P., 1954, <em>The Aim and Structure of Physical\nTheory</em>, Princeton: Princeton University Press.", "Duijf, H., Broersen, J., and Meyer, J. J. C., 2019,\n\u201cConflicting intentions: rectifying the consistency\nrequirements\u201d, <em>Philosophical Studies</em>, 176(4):\n1097\u20131118.", "Dummett, Michael A.E., 2006, <em>Thought and Reality</em>, Oxford:\nOxford University Press.", "Duncan, William, 2011, \u201cUsing Ontological Dependence to\nDistinguish between Hardware and Software\u201d, <em>Proceedings of\nthe Society for the Study of Artificial Intelligence and Simulation of\nBehavior Conference: Computing and Philosophy</em>, University of\nYork, York, UK.\n [<a href=\"http://www.aisb.org.uk/publications/proceedings/aisb2011.zip\" target=\"other\">Duncan 2011 available online (zip file)</a>]", "\u2013\u2013\u2013, 2017,\u00a0\u201cOntological Distinctions\nbetween Hardware and Software\u201d,\u00a0<em>Applied Ontology</em>,\n12(1): 5\u201332.", "Eden, Amnon H., 2007, \u201cThree Paradigms of Computer\nScience\u201d, <em>Minds and Machines</em>, 17(2): 135\u2013167.\ndoi:10.1007/s11023-007-9060-8", "Egan, Frances, 1992, \u201cIndividualism, Computation, and\nPerceptual Content\u201d, <em>Mind</em>, 101(403): 443\u201359.\ndoi:10.1093/mind/101.403.443", "Edgar, Stacey L., 2003 [1997], <em>Morality and Machines:\nPerspectives on Computer Ethics</em>, Sudbury, MA: Jones &amp;\nBartlett Learning.", "Ferrero, L., 2017, \u201cIntending, Acting, and Doing,\u201d\n<em>Philosophical Explorations</em>, 20 (Supplement 2):\n13\u201339.", "Fern\u00e1ndez, Maribel, 2004, <em>Programming Languages and\nOperational Semantics: An Introduction</em>, London: King\u2019s\nCollege Publications.", "Fetzer, James H., 1988, \u201cProgram Verification: The Very\nIdea\u201d, <em>Communications of the ACM</em>, 31(9):\n1048\u20131063. doi:10.1145/48529.48530", "\u2013\u2013\u2013, 1990, <em>Artificial Intelligence: Its\nScope and Limits</em>, Dordrecht: Springer Netherlands.", "Feynman, Richard P., 1984\u20131986, <em>Feynman Lectures on\nComputation</em>, Cambridge, MA: Westview Press, 2000.", "Flanagan, Mary, Daniel C. Howe, &amp; Helen Nissenbaum, 2008,\n\u201cEmbodying Values in Technology: Theory and Practice\u201d, in\n<em>Information Technology and Moral Philosophy</em>, Jeroen van den\nHoven and John Weckert (eds.), Cambridge: Cambridge University Press,\npp. 322\u2013353.", "Floridi, Luciano, 2008, \u201cThe Method of Levels of\nAbstraction\u201d, <em>Minds and Machines</em>, 18(3): 303\u2013329.\ndoi:10.1007/s11023-008-9113-7", "Floridi, Luciano, Nir Fresco, &amp; Giuseppe Primiero, 2015,\n\u201cOn Malfunctioning Software\u201d, <em>Synthese</em>, 192(4):\n1199\u20131220. doi:10.1007/s11229-014-0610-3", "Floyd, Robert W., 1979, \u201cThe Paradigms of\nProgramming\u201d, <em>Communications of the ACM</em>, 22(8):\n455\u2013460. doi:10.1145/1283920.1283934", "Fowler, Martin, 2003, <em>UML Distilled: A Brief Guide to the\nStandard Object Modeling Language</em>, 3<sup>rd</sup> edition,\nReading, MA: Addison-Wesley.", "Franssen, Maarten, Gert-Jan Lokhorst, &amp; Ibio van de Poel,\n2013, \u201cPhilosophy of Technology\u201d, <em>The Stanford\nEncyclopedia of Philosophy</em> (Winter 2013 Edition), Edward N. Zalta\n(ed.), URL =\n &lt;<a href=\"https://plato.stanford.edu/archives/win2013/entries/technology/\">https://plato.stanford.edu/archives/win2013/entries/technology/</a>&gt;.", "Frege, Gottlob, 1914, \u201cLetter to Jourdain\u201d, reprinted\nin Frege 1980: 78\u201380.", "\u2013\u2013\u2013, 1980, Gottlob Frege: <em>Philosophical and\nMathematical Correspondence</em>, G. Gabriel, H. Hermes, F. Kambartel,\nC. Thiel, and A. Veraart (eds.), Oxford: Blackwell Publishers.", "Fresco, Nir &amp; Giuseppe Primiero, 2013,\n\u201cMiscomputation\u201d, <em>Philosophy &amp; Technology</em>,\n26(3): 253\u2013272. doi:10.1007/s13347-013-0112-0", "Friedman, Batya &amp; Helen Nissenbaum, 1996, \u201cBias in\nComputer Systems\u201d, <em>ACM Transactions on Information Systems\n(TOIS)</em>, 14(3): 330\u2013347. doi:10.1145/230538.230561", "Frigg, Roman &amp; Stephan Hartmann, 2012, \u201cModels in\nScience\u201d, <em>The Stanford Encyclopedia of Philosophy</em> (Fall\n2012 Edition), Edward N. Zalta (ed.), URL\n =&lt;<a href=\"https://plato.stanford.edu/archives/fall2012/entries/models-science/\">https://plato.stanford.edu/archives/fall2012/entries/models-science/</a>&gt;.", "Gagliardi, Francesco, 2007, \u201cEpistemological Justification\nof Test Driven Development in Agile Processes\u201d, <em>Agile\nProcesses in Software Engineering and Extreme Programming: Proceedings\nof the 8th International Conference, XP 2007</em>, Como, Italy, June\n18\u201322, 2007, Berlin: Springer Berlin Heidelberg, pp.\n253\u2013256. doi:10.1007/978-3-540-73101-6_48", "Gamma, Erich, Richard Helm, Ralph Johnson, &amp; John Vlissides,\n1994, <em>Design Patterns: Elements of Reusable Object-Oriented\nSoftware</em>, Reading, MA: Addison-Wesley.", "Glennan, Stuart S., 1996, \u201cMechanisms and the Nature of\nCausation\u201d, <em>Erkenntnis</em>, 44(1): 49\u201371.\ndoi:10.1007/BF00172853", "Gl\u00fcer, Kathrin &amp; \u00c5sa Wikforss, 2015, \u201cThe\nNormativity of Meaning and Content\u201d, <em>The Stanford\nEncyclopedia of Philosophy</em> (Summer 2015 Edition), Edward N. Zalta\n(ed.), URL =\n &lt;<a href=\"https://plato.stanford.edu/archives/sum2015/entries/meaning-normativity/\">https://plato.stanford.edu/archives/sum2015/entries/meaning-normativity/</a>&gt;.", "Goguen, Joseph A. &amp; Rod M. Burstall, 1985,\n\u201cInstitutions: Abstract Model Theory for Computer\nScience\u201d, <em>Report CSLI-85-30</em>, Center for the Study of\nLanguage and Information at Stanford University.", "\u2013\u2013\u2013, 1992, \u201cInstitutions: Abstract Model\nTheory for Specification and Programming\u201d, <em>Journal of the\nACM (JACM)</em>, 39(1): 95\u2013146. doi:10.1145/147508.147524", "Gordon, Michael J.C., 1979, <em>The Denotational Description of\nProgramming Languages</em>, New York: Springer-Verlag.", "Gotterbarn, Donald, 1991, \u201cComputer Ethics: Responsibility\nRegained\u201d, <em>National Forum: The Phi Beta Kappa Journal</em>,\n71(3): 26\u201331.", "\u2013\u2013\u2013, 2001, \u201cInformatics and Professional\nResponsibility\u201d, <em>Science and Engineering Ethics</em>, 7(2):\n221\u2013230. doi:10.1007/s11948-001-0043-5", "Gotterbarn, Donald, Keith Miller, &amp; Simon Rogerson, 1997,\n\u201cSoftware Engineering Code of Ethics\u201d, <em>Information\nSociety</em>, 40(11): 110\u2013118. doi:10.1145/265684.265699", "Gotterbarn, Donald &amp; Keith W. Miller, 2009, \u201cThe Public\nis the Priority: Making Decisions Using the Software Engineering Code\nof Ethics\u201d, <em>IEEE Computer</em>, 42(6): 66\u201373.\ndoi:10.1109/MC.2009.204", "Gruner, Stefan, 2011, \u201cProblems for a Philosophy of Software\nEngineering\u201d, <em>Minds and Machines</em>, 21(2): 275\u2013299.\ndoi:10.1007/s11023-011-9234-2", "Gunter, Carl A., 1992, <em>Semantics of Programming Languages:\nStructures and Techniques</em>, Cambridge, MA: MIT Press.", "Gupta, Anil, 2014, \u201cDefinitions\u201d, <em>The Stanford\nEncyclopedia of Philosophy</em> (Fall 2014 Edition), Edward N. Zalta\n(ed.), URL =\n &lt;<a href=\"https://plato.stanford.edu/archives/fall2014/entries/definitions/\">https://plato.stanford.edu/archives/fall2014/entries/definitions/</a>&gt;.", "Gurevich, Y., 2000, \u201cSequential Abstract-State Machines\nCapture Sequential Algorithms\u201d, <em>ACM Transactions on\nComputational Logic (TOCL)</em>, 1(1): 77-111.", "\u2013\u2013\u2013, 2012, \u201cWhat is an algorithm?\u201d,\nin <em>International conference on current trends in theory and\npractice of computer science</em>, Heidelberg, Berlin: Springer, pp.\n31\u201342.", "Hacking, I., 2014, <em>Why is there a Philosophy of Mathematics at\nall?</em>, Cambridge: Cambridge University Press.", "Hagar, Amit, 2007, \u201cQuantum Algorithms: Philosophical\nLessons\u201d, <em>Minds and Machines</em>, 17(2): 233\u2013247.\ndoi:10.1007/s11023-007-9057-3", "Hale, Bob, 1987, <em>Abstract Objects</em>, Oxford: Basil\nBlackwell.", "Hales, Thomas C., 2008, \u201cFormal Proof\u201d, <em>Notices of\nthe American Mathematical Society</em>, 55(11): 1370\u20131380.", "Hankin, Chris, 2004, <em>An Introduction to Lambda Calculi for\nComputer Scientists</em>, London: King\u2019s College\nPublications.", "Harrison, John, 2008, \u201cFormal Proof\u2014Theory and\nPractice\u201d, <em>Notices of the American Mathematical\nSociety</em>, 55(11): 1395\u20131406.", "Hartmanis, Juris, 1981, \u201cNature of Computer Science and Its\nParadigms\u201d, pp. 353\u2013354 (in Section 1) of \u201cQuo\nVadimus: Computer Science in a Decade\u201d, J.F. Traub (ed.),\n<em>Communications of the ACM</em>, 24(6): 351\u2013369.\ndoi:10.1145/358669.358677", "\u2013\u2013\u2013, 1993, \u201cSome Observations About the\nNature of Computer Science\u201d, in <em>International Conference on\nFoundations of Software Technology and Theoretical Computer\nScience</em>, Springer Berlin Heidelberg, pp. 1\u201312.\ndoi:10.1007/3-540-57529-4_39", "Hayes, P. J., 1997, \u201cWhat is a Computer?\u201d, <em>The\nMonist</em>, 80(3): 389\u2013404.", "Hempel, C. G., 1970, \u201cOn the \u2018standard\nconception\u2019 of scientific theories\u201d, <em>Minnesota Studies\nin the Philosophy of Science</em>, 4: 142\u2013163.", "Henson, Martin C., 1987, <em>Elements of Functional\nProgramming</em>, Oxford: Blackwell.", "Hilbert, David, 1931, \u201cThe Grounding of Elementary Number\nTheory\u201d, reprinted in P. Mancosu (ed.), 1998, <em>From Brouwer\nto Hilbert: the Debate on the Foundations of Mathematics in the\n1920s</em>, New York: Oxford University Press, pp. 266\u2013273.", "Hilbert, David &amp; Wilhelm Ackermann, 1928, <em>Grundz\u00fcge\nDer Theoretischen Logik</em>, translated as <em>Principles of\nMathematical Logic</em>, Lewis M. Hammond, George G. Leckie, and F.\nSteinhardt (trans.), New York: Chelsea, 1950.", "Hill, R.K., 2016, \u201cWhat an algorithm is\u201d,\n<em>Philosophy &amp; Technology</em>, 29(1): 35\u201359.", "\u2013\u2013\u2013, 2018, \u201cElegance in Software\u201d,\nin Liesbeth de Mol, Giuseppe Primiero (eds.), <em>Reflections on\nProgrammings Systems - Historical and Philosophical Aspects\n(Philosophical Studies Series)</em>, Cham: Springer, pp.\n273\u2013286.", "Hoare, C.A.R., 1969, \u201cAn Axiomatic Basis for Computer\nProgramming\u201d, <em>Communications of the ACM</em>, 12(10):\n576\u2013580. doi:10.1145/363235.363259", "\u2013\u2013\u2013, 1973, \u201cNotes on Data\nStructuring\u201d, in O.J. Dahl, E.W. Dijkstra, and C.A.R. Hoare\n(eds.), <em>Structured Programming</em>, London: Academic Press, pp.\n83\u2013174.", "\u2013\u2013\u2013, 1981, \u201cThe Emperor\u2019s Old\nClothes\u201d, <em>Communications of the ACM</em>, 24(2):\n75\u201383. doi:10.1145/1283920.1283936", "\u2013\u2013\u2013, 1985, <em>Communicating Sequential\nProcesses</em>, Englewood Cliffs, NJ: Prentice Hall.\n [<a href=\"http://www.usingcsp.com/\" target=\"other\">Hoare 1985 available online</a>]", "\u2013\u2013\u2013, 1986, <em>The Mathematics of Programming:\nAn Inaugural Lecture Delivered Before the University of Oxford on Oct.\n17, 1985</em>, Oxford: Oxford University Press.", "Hodges, Andrews, 2011, \u201cAlan Turing\u201d, <em>The Stanford\nEncyclopedia of Philosophy</em> (Summer 2011 Edition), Edward N. Zalta\n(ed.), URL =\n &lt;<a href=\"https://plato.stanford.edu/archives/sum2011/entries/turing/\">https://plato.stanford.edu/archives/sum2011/entries/turing/</a>&gt;.", "Hodges, Wilfrid, 2013, \u201cModel Theory\u201d, <em>The\nStanford Encyclopedia of Philosophy</em> (Fall 2013 Edition), Edward\nN. Zalta (ed.), forthcoming URL =\n &lt;<a href=\"https://plato.stanford.edu/archives/fall2013/entries/model-theory/\">https://plato.stanford.edu/archives/fall2013/entries/model-theory/</a>&gt;.", "Hopcroft, John E. &amp; Jeffrey D. Ullman, 1969, <em>Formal\nLanguages and their Relation to Automata</em>, Reading, MA:\nAddison-Wesley.", "Hughes, Justin, 1988, \u201cThe Philosophy of Intellectual\nProperty\u201d, <em>Georgetown Law Journal</em>, 77: 287.", "Irmak, Nurbay, 2012, \u201cSoftware is an Abstract\nArtifact\u201d, <em>Grazer Philosophische Studien</em>, 86(1):\n55\u201372.", "Johnson, Christopher W., 2006, \u201cWhat are Emergent Properties\nand How Do They Affect the Engineering of Complex Systems\u201d,\n<em>Reliability Engineering and System Safety</em>, 91(12):\n1475\u20131481.\n [<a href=\"http://www.dcs.gla.ac.uk/~johnson/papers/RESS/Complexity_Emergence_Editorial.pdf\" target=\"other\">Johnson 2006 available online</a>]", "Johnson-Laird, P. N., 1988, <em>The Computer and the Mind: An\nIntroduction to Cognitive Science</em>, Cambridge, MA: Harvard\nUniversity Press.", "Jones, Cliff B., 1990 [1986], <em>Systematic Software Development\nUsing VDM</em>, second edition, Englewood Cliffs, NJ: Prentice Hall.\n [<a href=\"http://homepages.cs.ncl.ac.uk/cliff.jones/publications/\" target=\"other\">Jones 1990 available online</a>]", "Kimppa, Kai, 2005, \u201cIntellectual Property Rights in\nSoftware\u2014Justifiable from a Liberalist Position? Free Software\nFoundation\u2019s Position in Comparison to John Locke\u2019s\nConcept of Property\u201d, in R.A. Spinello &amp; H.T. Tavani (eds.),\n<em>Intellectual Property Rights in a Networked World: Theory and\nPractice</em>, Hershey, PA: Idea, pp. 67\u201382.", "Kinsella, N. Stephan, 2001, \u201cAgainst Intellectual\nProperty\u201d, <em>Journal of Libertarian Studies</em>, 15(2):\n1\u201353.", "Kleene, S. C., 1967, <em>Mathematical Logic</em>, New York:\nWiley.", "Knuth, D. E., 1973, <em>The Art of Computer Programming</em>,\nsecond edition, Reading, MA: Addison-Wesley.", "\u2013\u2013\u2013, 1974a, \u201cComputer Programming as an\nArt\u201d, <em>Communications of the ACM</em>, 17(12): 667\u2013673.\ndoi:10.1145/1283920.1283929", "\u2013\u2013\u2013, 1974b, \u201cComputer Science and Its\nRelation to Mathematics\u201d, <em>The American Mathematical\nMonthly</em>, 81(4): 323\u2013343.", "\u2013\u2013\u2013, 1977, \u201cAlgorithms\u201d,\n<em>Scientifc American</em>, 236(4): 63\u201380.", "Kripke, Saul, 1982, <em>Wittgenstein on Rules and Private\nLanguage</em>, Cambridge, MA: Harvard University Press.", "Kroes, Peter, 2010, \u201cEngineering and the Dual Nature of\nTechnical Artefacts\u201d, <em>Cambridge Journal of Economics</em>,\n34(1): 51\u201362. doi:10.1093/cje/bep019", "\u2013\u2013\u2013, 2012, <em>Technical Artefacts: Creations of\nMind and Matter: A Philosophy of Engineering Design</em>, Dordrecht:\nSpringer.", "Kroes, Peter &amp; Anthonie Meijers, 2006, \u201cThe Dual Nature\nof Technical Artefacts\u201d, <em>Studies in History and Philosophy\nof Science</em>, 37(1): 1\u20134.\ndoi:10.1016/j.shpsa.2005.12.001", "Kr\u00f6ger, Fred &amp; Stephan Merz, 2008, <em>Temporal Logics\nand State Systems</em>, Berlin: Springer.", "Ladd, John, 1988, \u201cComputers and Moral Responsibility: a\nFramework for An Ethical Analysis\u201d, in Carol C. Gould, (ed.),\n<em>The Information Web: Ethical &amp; Social Implications of Computer\nNetworking</em>, Boulder, CO: Westview Press, pp. 207\u2013228.", "Landin, P.J., 1964, \u201cThe Mechanical Evaluation of\nExpressions\u201d, <em>The Computer Journal</em>, 6(4):\n308\u2013320. doi:10.1093/comjnl/6.4.308", "Littlewood, Bev &amp; Lorenzo Strigini, 2000, \u201cSoftware\nReliability and Dependability: a Roadmap\u201d, <em>ICSE \u201900\nProceedings of the Conference on the Future of Software\nEngineering</em>, pp. 175\u2013188. doi:10.1145/336512.336551", "Locke, John, 1690, <em>The Second Treatise of Government</em>.\n [<a href=\"https://www.gutenberg.org/files/7370/7370-h/7370-h.htm\" target=\"other\">Locke 1690 available online</a>]", "Loewenheim, Ulrich, 1989, \u201cLegal Protection for Computer\nPrograms in West Germany\u201d, <em>Berkeley Technology Law\nJournal</em>, 4(2): 187\u2013215.\n [<a href=\"http://scholarship.law.berkeley.edu/btlj/vol4/iss2/1/\" target=\"other\">Loewenheim 1989 available online</a>]\n doi:10.15779/Z38Q67F", "Long, Roderick T., 1995, \u201cThe Libertarian Case Against\nIntellectual Property Rights\u201d, <em>Formulations</em>, Autumn,\nFree Nation Foundation.", "Loui, Michael C. &amp; Keith W. Miller, 2008, \u201cEthics and\nProfessional Responsibility in Computing\u201d, <em>Wiley\nEncyclopedia of Computer Science and Engineering</em>, Benjamin Wah\n(ed.), John Wiley &amp; Sons.\n [<a href=\"http://hdl.handle.net/2142/12247\" target=\"other\">Loui and Miller 2008 available online</a>]", "Lowe, E. J., 1998, <em>The Possibility of Metaphysics: Substance,\nIdentity, and Time</em>, Oxford: Clarendon Press.", "Luckham, David C., 1998, \u201cRapide: A Language and Toolset for\nCausal Event Modeling of Distributed System Architectures\u201d, in\nY. Masunaga, T. Katayama, and M. Tsukamoto (eds.), <em>Worldwide\nComputing and its Applications</em>, WWCA\u201998, Berlin: Springer,\npp. 88\u201396. doi:10.1007/3-540-64216-1_42", "Machamer, Peter K., Lindley Darden, &amp; Carl F. Craver, 2000,\n\u201cThinking About Mechanisms\u201d, <em>Philosophy of\nScience</em>, 67(1): 1\u201325. doi:10.1086/392759", "Magee, Jeff, Naranker Dulay, Susan Eisenbach, &amp; Jeff Kramer,\n1995, \u201cSpecifying Distributed Software Architectures\u201d,\n<em>Proceedings of 5th European Software Engineering Conference (ESEC\n95)</em>, Berlin: Springer-Verlag, pp. 137\u2013153.", "Markov, A., 1954, \u201cTheory of algorithms\u201d, Tr. Mat.\nInst. Steklov 42, pp. 1\u201314. trans. by Edwin Hewitt in\n<em>American Mathematical Society Translations</em>, Series 2, Vol. 15\n(1960).", "Martin-L\u00f6f, Per, 1982, \u201cConstructive Mathematics and\nComputer Programming\u201d, in <em>Logic, Methodology and Philosophy\nof Science</em> (Volume VI: 1979), Amsterdam: North-Holland, pp.\n153\u2013175.", "McGettrick, Andrew, 1980, <em>The Definition of Programming\nLanguages</em>, Cambridge: Cambridge University Press.", "McLaughlin, Peter, 2001, <em>What Functions Explain: Functional\nExplanation and Self-Reproducing Systems</em>, Cambridge: Cambridge\nUniversity Press.", "Meijers, A.W.M., 2001, \u201cThe Relational Ontology of Technical\nArtifacts\u201d, in P.A. Kroes and A.W.M. Meijers (eds.), <em>The\nEmpirical Turn in the Philosophy of Technology</em>, Amsterdam:\nElsevier, pp. 81\u201396.", "Mitchelmore, Michael &amp; Paul White, 2004, \u201cAbstraction in\nMathematics and Mathematics Learning\u201d, in M.J. H\u00f8ines and\nA.B. Fuglestad (eds.), <em>Proceedings of the 28th Conference of the\nInternational Group for the Psychology of Mathematics Education\n(Volume 3)</em>, Bergen: Programm Committee, pp. 329\u2013336.\n [<a href=\"http://www.emis.de/proceedings/PME28/RR/RR031_Mitchelmore.pdf\" target=\"other\">Mitchelmore and White 2004 available online</a>]", "Miller, Alexander &amp; Crispin Wright (eds), 2002, <em>Rule\nFollowing and Meaning</em>, Montreal/Ithaca: McGill-Queen's\nUniversity Press.", "Milne, Robert &amp; Christopher Strachey, 1976, <em>A Theory of\nProgramming Language Semantics</em>, London: Chapman and Hall.", "Milner, R., 1971, \u201cAn algebraic definition of simulation\nbetween programs\u201d, Technical Report, <em>CS-205</em>, pp.\n481\u2013489, Department of Computer Science, Stanford\nUniversity.", "Mitchell, John C., 2003, <em>Concepts in Programming\nLanguages</em>, Cambridge: Cambridge University Press.", "Monin, Jean Fran\u00e7ois, 2003, <em>Understanding Formal\nMethods</em>, Michael G. Hinchey (ed.), London: Springer (this is\nMonin's translation of his own Introduction aux M\u00e9thodes\nFormelles, Hermes, 1996, first edition; 2000, second edition),\ndoi:10.1007/978-1-4471-0043-0", "Mooers, Calvin N., 1975, \u201cComputer Software and\nCopyright\u201d, <em>ACM Computing Surveys</em>, 7(1): 45\u201372.\ndoi:10.1145/356643.356647", "Moor, James H., 1978, \u201cThree Myths of Computer\nScience\u201d, <em>The British Journal for the Philosophy of\nScience</em>, 29(3): 213\u2013222.", "Morgan, C., 1994, <em>Programming From Specifications</em>,\nEnglewood Cliffs: Prentice Hall. [Morgan 1994 available online]", "Moschovakis, Y. N., 2001, \u201cWhat is an algorithm?\u201d, in\n<em>Mathematics Unlimited\u20142001 and Beyond</em>, Heidelberg,\nBerlin: Springer, pp. 919\u2013936.", "Naur, P., 1985, \u201cProgramming as theory building\u201d,\n<em>Microprocessing and microprogramming</em>, 15(5):\n253\u2013261.", "Newell, A., and Simon, H. A., 1961, \u201cComputer simulation of\nhuman thinking\u201d <em>Science</em>, 134(3495):\n2011\u20132017.", "\u2013\u2013\u2013 1972, <em>Human Problem Solving</em>,\nEnglewood Cliffs, NJ: Prentice-Hall.", "\u2013\u2013\u2013, 1976, \u201cComputer Science as Empirical\nInquiry: Symbols and Search\u201d, <em>Communications of the\nACM</em>, 19(3): 113\u2013126. doi:10.1145/1283920.1283930", "Newell, Allen, Alan J. Perlis, &amp; Herbert A. Simon, 1967,\n\u201cComputer Science\u201d, <em>Science</em>, 157(3795):\n1373\u20131374. doi:10.1126/science.157.3795.1373-b", "Nissenbaum,Helen, 1998, \u201cValues in the Design of Computer\nSystems\u201d, <em>Computers and Society</em>, 28(1):\n38\u201339.", "Northover, Mandy, Derrick G. Kourie, Andrew Boake, Stefan Gruner,\n&amp; Alan Northover, 2008, \u201cTowards a Philosophy of Software\nDevelopment: 40 Years After the Birth of Software Engineering\u201d,\n<em>Journal for General Philosophy of Science</em>, 39(1):\n85\u2013113. doi:10.1007/s10838-008-9068-7", "Pears, David Francis, 2006, <em>Paradox and Platitude in\nWittgenstein\u2019s Philosophy</em>, Oxford: Oxford University Press.\ndoi:10.1093/acprof:oso/9780199247707.001.0001", "Piccinini, Gualtiero, 2007, \u201cComputing Mechanisms\u201d,\n<em>Philosophy of Science</em>, 74(4): 501\u2013526.\ndoi:10.1086/522851", "\u2013\u2013\u2013, 2008, \u201cComputation without\nRepresentation\u201d, <em>Philosophical Studies</em>, 137(2):\n206\u2013241.\n [<a href=\"http://www.umsl.edu/~piccininig/Computation_without_Representation.pdf\" target=\"other\">Piccinini 2008 available online</a>]\n doi:10.1007/s11098-005-5385-4", "\u2013\u2013\u2013, 2008, \u201cComputers\u201d, <em>Pacific\nPhilosophical Quarterly</em>, 89: 32\u201373.", "\u2013\u2013\u2013, 2015, <em>Physical Computation: A\nMechanistic Account</em>, Oxford: Oxford University Press.\ndoi:10.1093/acprof:oso/9780199658855.001.0001", "Piccinini, Gualtiero &amp; Carl Craver, 2011, \u201cIntegrating\nPsychology and Neuroscience: Functional Analyses as Mechanism\nSketches\u201d, <em>Synthese</em>, 183(3): 283\u2013311.\ndoi:10.1007/s11229-011-9898-4", "Popper, Karl R., 1959, <em>The Logic of Scientific Discovery</em>,\nLondon: Hutchinson.", "Primiero, G., 2016, \u201cInformation in the philosophy of\ncomputer science\u201d, in Floridi L. (ed.), <em>The Routledge\nHandbook of Philosophy of Information</em>, London: Routledge, pp.\n90\u2013106.", "\u2013\u2013\u2013, 2020, <em>On the Foundations of\nComputing</em>. New York: Oxford University Press.", "Primiero, G., D.F. Solheim &amp; J.M. Spring, 2019 \u201cOn\nMalfunction, Mechanisms and Malware Classification\u201d, <em>Philos.\nTechnol</em>. 32: 339\u2013362.\nhttps://doi.org/10.1007/s13347-018-0334-2", "Pylyshyn, Z. W., 1984, <em>Computation and Cognition: Towards a\nFoundation for Cognitive Science</em>, Cambridge, MA: MIT Press.", "Pym, D., J.M. Spring, &amp; P. O\u2019Hearn, 2019, \u201cWhy\nSeparation Logic Works\u201d, <em>Philosophy &amp; Technology</em>,\n32: 483\u2013516.", "Rapaport, William J., 1995, \u201cUnderstanding Understanding:\nSyntactic Semantics and Computational Cognition\u201d, in Tomberlin\n(ed.), <em>Philosophical Perspectives</em>, Vol. 9: AI, Connectionism,\nand Philosophical Psychology, Atascadero, CA: Ridgeview, pp.\n49\u201388.\n [<a href=\"http://www.cse.buffalo.edu/~rapaport/Papers/rapaport95-uu.pdf\" target=\"other\">Rapaport 1995 available online</a>]\n doi:10.2307/2214212", "\u2013\u2013\u2013, 1999, \u201cImplementation Is Semantic\nInterpretation\u201d, <em>The Monist</em>, 82(1): 109\u201330.\n [<a href=\"http://www.cse.buffalo.edu/~rapaport/Papers/monist.pdf\" target=\"other\">Rapaport 1999 available online</a>]", "\u2013\u2013\u2013, 2005, \u201cImplementation as Semantic\nInterpretation: Further Thoughts\u201d, <em>Journal of\nExperimental&amp; Theoretical Artificial Intelligence</em>, 17(4):\n385\u2013417.\n [<a href=\"http://www.cse.buffalo.edu/~rapaport/Papers/jetai05.pdf\" target=\"other\">Rapaport 2005 available online</a>]", "\u2013\u2013\u2013, 2012, \u201cSemiotic systems, computers,\nand the mind: how cognition could be computing\u201d,\n<em>International Journal of Signs and Semiotic Systems</em>, 2(1):\n32\u201371", "\u2013\u2013\u2013, 2018, \u201cWhat is a Computer? A\nSurvey\u201d, <em>Minds and Machines</em>, 28(3): 385\u2013426.", "Reynolds, J.C., 2002, \u201cSeparation Logic: a logic for shared\nmutable data structures\u201d, in <em>Proceedings of the 17th Annual\nIEEE Symposium on Logic in Computer Science</em>, IEEE, pp.\n55\u201374.", "Rombach, Dieter &amp; Frank Seelisch, 2008, \u201cFormalisms in\nSoftware Engineering: Myths Versus Empirical Facts\u201d, in\n<em>Balancing Agility and Formalism in Software Engineering</em>,\nSpringer Berlin Heidelberg, pp. 13\u201325.\ndoi:10.1007/978-3-540-85279-7_2", "Rosenberg, A., 2012, <em>The Philosophy of Science</em>, London:\nRoutledge.", "Ryle G., 1949 [2009], <em>The Concept of Mind</em>, Abingdon:\nRoutledge", "Schiaffonati, Viola, 2015, \u201cStretching the Traditional\nNotion of Experiment in Computing: Explorative Experiments\u201d,\n<em>Science and Engineering Ethics</em>, 22(3): 1\u201319.\ndoi:10.1007/s11948-015-9655-z", "Schiaffonati, Viola &amp; Mario Verdicchio, 2014, \u201cComputing\nand Experiments\u201d, <em>Philosophy &amp; Technology</em>, 27(3):\n359\u2013376. doi:10.1007/s13347-013-0126-7", "Searle, J. R., 1990, \u201cIs the brain a digital\ncomputer?\u201d <em>Proceedings and Addresses of the American\nPhilosophical Association</em>, 64(3): 21\u201337.", "Searle, John R., 1995, <em>The Construction of Social\nReality</em>, New York: Free Press.", "Setiya, K., \u201cIntention\u201d, <em>The Stanford Encyclopedia\nof Philosophy</em> (Fall 2018 Edition), Edward N. Zalta (ed.), URL =\n &lt;<a href=\"https://plato.stanford.edu/archives/fall2018/entries/intention/\">https://plato.stanford.edu/archives/fall2018/entries/intention/</a>&gt;.", "Shanker, S.G., 1987, \u201cWittgenstein versus Turing on the\nNature of Church\u2019s Thesis\u201d, <em>Notre Dame Journal of\nFormal Logic</em>, 28(4): 615\u2013649.\n [<a href=\"http://projecteuclid.org/euclid.ndjfl/1093637650\" target=\"other\">Shanker 1987 available online</a>]\n doi:10.1305/ndjfl/1093637650", "Shavell, Steven &amp; Tanguy van Ypersele, 2001, \u201cRewards\nVersus Intellectual Property Rights\u201d, <em>Journal of Law and\nEconomics</em>, 44: 525\u2013547", "Skemp, Richard R., 1987, <em>The Psychology of Learning\nMathematics</em>, Hillsdale, NJ: Lawrence Erlbaum Associates.", "Smith, Brian Cantwell, 1985, \u201cThe Limits of Correctness in\nComputers\u201d, <em>ACM SIGCAS Computers and Society</em>,\n14\u201315(1\u20134): 18\u201326. doi:10.1145/379486.379512", "Snelting, Gregor, 1998, \u201cPaul Feyerabend and Software\nTechnology\u201d, <em>Software Tools for Technology Transfer</em>,\n2(1): 1\u20135. doi:10.1007/s100090050013", "Sommerville, Ian, 2016 [1982], <em>Software Engineering</em>,\nReading, MA: Addison-Wesley; first edition, 1982.", "Sprevak, M., 2010, \u201cComputation, individuation, and the\nreceived view on representation\u201d, <em>Studies in History and\nPhilosophy of Science</em>, 41(3): 260\u2013270.", "\u2013\u2013\u2013, 2012, \u201cThree Challenges to Chalmers\non Computational Implementation\u201d, <em>Journal of Cognitive\nScience</em>, 13(2): 107\u2013143.", "Stoy, Joseph E., 1977, <em>Denotational Semantics: The\nScott-Strachey Approach to Programming Language Semantics</em>,\nCambridge, MA: MIT Press.", "Strachey, Christopher, 2000, \u201cFundamental Concepts in\nProgramming Languages\u201d, <em>Higher-Order and Symbolic\nComputation</em>, 13(1\u20132): 11\u201349.\ndoi:10.1023/A:1010000313106", "Suber, Peter, 1988, \u201cWhat Is Software?\u201d <em>Journal of\nSpeculative Philosophy</em>, 2(2): 89\u2013119.\n [<a href=\"https://dash.harvard.edu/bitstream/handle/1/3715472/suber_software.html\" target=\"other\">Suber 1988 available online</a>]", "Summerville, I., 2012, <em>Software Engineering</em>, Reading, MA:\nAddison-Wesley; first edition, 1982.", "Suppe, Frederick, 1989, <em>The Semantic Conception of Theories\nand Scientific Realism</em>, Chicago: University of Illinois\nPress.", "Suppes, Patrick, 1960, \u201cA Comparison of the Meaning and Uses\nof Models in Mathematics and the Empirical Sciences\u201d,\n<em>Synthese</em>, 12(2): 287\u2013301. doi:10.1007/BF00485107", "\u2013\u2013\u2013, 1969, \u201cModels of Data\u201d, in\n<em>Studies in the Methodology and Foundations of Science</em>,\nDordrecht: Springer Netherlands, pp. 24\u201335.", "Technical Correspondence, Corporate, 1989, <em>Communications of\nthe ACM</em>, 32(3): 374\u2013381. Letters from James C. Pleasant,\nLawrence Paulson/Avra Cohen/Michael Gordon, William Bevier/Michael\nSmith/William Young, Thomas Clune, Stephen Savitzky, James Fetzer.\ndoi:10.1145/62065.315927", "Tedre, Matti, 2011, \u201cComputing as a Science: A Survey of\nCompeting Viewpoints\u201d, <em>Minds and Machines</em>, 21(3):\n361\u2013387. doi:10.1007/s11023-011-9240-4", "\u2013\u2013\u2013, 2015, <em>The Science of Computing: Shaping\na Discipline</em>, Boca Raton: CRC Press, Taylor and Francis\nGroup.", "Tedre, Matti &amp; Ekki Sutinen, 2008, \u201cThree Traditions of\nComputing: What Educators Should Know\u201d, <em>Computer Science\nEducation</em>, 18(3): 153\u2013170.\ndoi:10.1080/08993400802332332", "Thagard, P., 1984, \u201cComputer programs as psychological\ntheories\u201d, <em>Mind, Language and Society</em>, Vienna:\nConceptus-Studien, pp. 77\u201384.", "Thomasson, Amie, 2007, \u201cArtifacts and Human Concepts\u201d,\nin Eric Margolis and Stephen Laurence (eds.), <em>Creations of the\nMind: Essays on Artifacts and Their Representations</em>, Oxford:\nOxford University Press, pp. 52\u201373.", "Thompson, Simon, 2011, <em>Haskell: The Craft of Functional\nProgramming</em>, third edition, Reading, MA: Addison-Wesley; first\nedition, 1996.", "Tichy, Walter F., 1998, \u201cShould Computer Scientists\nExperiment More?\u201d, <em>IEEE Computer</em>, 31(5): 32\u201340.\ndoi:10.1109/2.675631", "Turing, A.M., 1936, \u201cOn Computable Numbers, with an\nApplication to the Entscheidungsproblem\u201d, <em>Proceedings of the\nLondon Mathematical Society (Series 2)</em>, 42: 230\u201365.\ndoi:10.1112/plms/s2-42.1.230", "\u2013\u2013\u2013, 1950, \u201cComputing Machinery and\nIntelligence\u201d, <em>Mind</em>, 59(236): 433\u2013460.\ndoi:10.1093/mind/LIX.236.433", "Turner, Raymond, 2007, \u201cUnderstanding Programming\nLanguages\u201d, <em>Minds and Machines</em>, 17(2): 203\u2013216.\ndoi:10.1007/s11023-007-9062-6", "\u2013\u2013\u2013, 2009a, <em>Computable Models</em>, Berlin:\nSpringer. doi:10.1007/978-1-84882-052-4", "\u2013\u2013\u2013, 2009b, \u201cThe Meaning of Programming\nLanguages\u201d, <em>APA Newsletters</em>, 9(1): 2\u20137. (This APA\nNewsletter is available online; see the Other Internet\nResources.)", "\u2013\u2013\u2013, 2010, \u201cProgramming Languages as\nMathematical Theories\u201d, in J. Vallverd\u00fa (ed.),\n<em>Thinking Machines and the Philosophy of Computer Science: Concepts\nand Principles</em>, Hershey, PA: IGI Global, pp. 66\u201382.", "\u2013\u2013\u2013, 2011, \u201cSpecification\u201d,\n<em>Minds and Machines</em>, 21(2): 135\u2013152.\ndoi:10.1007/s11023-011-9239-x", "\u2013\u2013\u2013, 2012, \u201cMachines\u201d, in H. Zenil\n(ed.), <em>A Computable Universe: Understanding and Exploring Nature\nas Computation</em>, London: World Scientific Publishing\nCompany/Imperial College Press, pp. 63\u201376.", "\u2013\u2013\u2013, 2014, \u201cProgramming Languages as\nTechnical Artefacts\u201d, <em>Philosophy and Technology</em>, 27(3):\n377\u2013397; first published online 2013.\ndoi:10.1007/s13347\u2013012\u20130098-z", "\u2013\u2013\u2013, 2018, <em>Computational artifacts: Towards\na philosophy of computer science</em>, Berlin Heidelberg:\nSpringer.", "Tymoczko, Thomas, 1979, \u201cThe Four Color Problem and Its\nPhilosophical Significance\u201d, <em>The Journal of Philosophy</em>,\n76(2): 57\u201383. doi:10.2307/2025976", "\u2013\u2013\u2013, 1980, \u201cComputers, Proofs and\nMathematicians: A Philosophical Investigation of the Four-Color\nProof\u201d, <em>Mathematics Magazine</em>, 53(3):\n131\u2013138.", "Van Fraassen, Bas C., 1980, <em>The Scientific Image</em>, Oxford:\nOxford University Press. doi:10.1093/0198244274.001.0001", "\u2013\u2013\u2013, 1989, <em>Laws and Symmetry</em>, Oxford:\nOxford University Press. doi:10.1093/0198248601.001.0001", "Van Leeuwen, Jan (ed.), 1990, <em>Handbook of Theoretical Computer\nScience. Volume B: Formal Models and Semantics</em>, Amsterdam:\nElsevier and Cambridge, MA: MIT Press.", "Vardi, M., 2012, \u201cWhat is an algorithm?\u201d,\n<em>Communications of the ACM</em>, 55(3): 5.\ndoi:10.1145/2093548.2093549", "Vermaas, Pieter E. &amp; Wybo Houkes, 2003, \u201cAscribing\nFunctions to Technical Artifacts: A Challenge to Etiological Accounts\nof Function\u201d, <em>British Journal of the Philosophy of\nScience</em>, 54: 261\u2013289.\n [<a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.5.5058\" target=\"other\">Vermaas and Houkes 2003 available online</a>]", "Vliet, Hans van, 2008, <em>Software Engineering: Principles and\nPractice</em>, 3rd edition, Hoboken, NJ: Wiley. (First edition,\n1993)", "von Neumann, J. (1945). \u201cFirst draft report on the\nEDVAC\u201d, <em>IEEE Annals of the History of Computing</em>, 15(4):\n27\u201375.", "Wang, Hao, 1974, <em>From Mathematics to Philosophy</em>, London:\nRoutledge, Kegan &amp; Paul.", "Wegner, Peter, 1976, \u201cResearch Paradigms in Computer\nScience\u201d, in <em>Proceedings of the 2nd international Conference\non Software Engineering</em>, Los Alamitos, CA: IEEE Computer Society\nPress, pp. 322\u2013330.", "White, Graham, 2003, \u201cThe Philosophy of Computer\nLanguages\u201d, in Luciano Floridi (ed.), <em>The Blackwell Guide to\nthe Philosophy of Computing and Information</em>, Malden:\nWiley-Blackwell, pp. 318\u2013326.\ndoi:10.1111/b.9780631229193.2003.00020.x", "Wiener, Norbert, 1948, <em>Cybernetics: Control and Communication\nin the Animal and the Machine</em>, New York: Wiley &amp; Sons.", "\u2013\u2013\u2013, 1964, <em>God and Golem, Inc.: A Comment on\nCertain Points Where Cybernetics Impinges on Religion</em>, Cambridge,\nMA: MIT press.", "Wittgenstein, Ludwig, 1953 [2001], <em>Philosophical\nInvestigations</em>, translated by G.E.M. Anscombe, 3rd Edition,\nOxford: Blackwell Publishing.", "\u2013\u2013\u2013, 1956 [1978], <em>Remarks of the Foundations\nof Mathematics</em>, G.H. von Wright, R. Rhees, and G.E.M. Anscombe\n(eds.), translated by G.E.M. Anscombe, revised edition, Oxford: Basil\nBlackwell.", "\u2013\u2013\u2013, 1939 [1975], <em>Wittgenstein\u2019s\nLectures on the Foundations of Mathematics, Cambridge 1939</em>, C.\nDiamond (ed.), Cambridge: Cambridge University Press.", "Woodcock, Jim &amp; Jim Davies, 1996, <em>Using Z: Specification,\nRefinement, and Proof</em>, Englewood Cliffs, NJ: Prentice Hall.", "Wright, Crispin 1983, <em>Frege\u2019s Conception of Numbers as\nObjects</em>, Aberdeen: Aberdeen University Press."]}, "raw_text": "<div id=\"bibliography\">\n<h2 id=\"Bib\">Bibliography</h2>\n<ul class=\"hanging\">\n<li>Abramsky, Samson &amp; Guy McCusker, 1995, \u201cGames and Full\nAbstraction for the Lazy \\(\\lambda\\)-Calculus\u201d, in D. Kozen\n(ed.), <em>Tenth Annual IEEEE Symposium on Logic in Computer\nScience</em>, IEEE Computer Society Press, pp. 234\u201343.\ndoi:10.1109/LICS.1995.523259</li>\n<li>Abramsky, Samson, Pasquale Malacaria, &amp; Radha Jagadeesan,\n1994, \u201cFull Abstraction for PCF\u201d, in M. Hagiya &amp; J.C.\nMitchell (eds.), <em>Theoretical Aspects of Computer Software:\nInternational Symposium TACS \u201894</em>, Sendai, Japan, April\n19\u201322, 1994, Springer-Verlag, pp. 1\u201315.</li>\n<li>Abrial, Jean-Raymond, 1996, <em>The B-Book: Assigning Programs to\nMeanings</em>, Cambridge: Cambridge University Press.</li>\n<li>Alama, Jesse, 2015, \u201cThe Lambda Calculus\u201d, <em>The\nStanford Encyclopedia of Philosophy</em> (Spring 2015 Edition), Edward\nN. Zalta (ed.), URL =\n &lt;<a href=\"https://plato.stanford.edu/archives/spr2015/entries/lambda-calculus/\">https://plato.stanford.edu/archives/spr2015/entries/lambda-calculus/</a>&gt;.</li>\n<li>Allen, Robert J., 1997, <em>A Formal Approach to Software\nArchitecture</em>, Ph.D. Thesis, Computer Science, Carnegie Mellon\nUniversity. Issued as CMU Technical Report CMU-CS-97-144.\n <a href=\"http://www.cs.cmu.edu/~able/paper_abstracts/rallen_thesis.htm\" target=\"other\">Allen 1997 available on line</a></li>\n<li>Ammann, Paul &amp; Jeff Offutt, 2008, <em>Introduction to Software\nTesting</em>, Cambridge: Cambridge University Press.</li>\n<li>Angius, Nicola, 2013a, \u201cAbstraction and Idealization in the\nFormal Verification of Software\u201d, <em>Minds and Machines</em>,\n23(2): 211\u2013226. doi:10.1007/s11023-012-9289-8</li>\n<li>\u2013\u2013\u2013, 2013b, \u201cModel-Based Abductive\nReasoning in Automated Software Testing\u201d, <em>Logic Journal of\nIGPL</em>, 21(6): 931\u2013942. doi:10.1093/jigpal/jzt006</li>\n<li>\u2013\u2013\u2013, 2014, \u201cThe Problem of Justification\nof Empirical Hypotheses in Software Testing\u201d, <em>Philosophy\n&amp; Technology</em>, 27(3): 423\u2013439.\ndoi:10.1007/s13347-014-0159-6</li>\n<li>Angius, N., &amp; Primiero, G., 2018, \u201cThe logic of identity\nand copy for computational artefacts\u201d, <em>Journal of Logic and\nComputation</em>, 28(6): 1293\u20131322.</li>\n<li>Angius, Nicola &amp; Guglielmo Tamburrini, 2011, \u201cScientific\nTheories of Computational Systems in Model Checking\u201d, <em>Minds\nand Machines</em>, 21(2): 323\u2013336.\ndoi:10.1007/s11023-011-9231-5</li>\n<li>\u2013\u2013\u2013, 2017, \u201cExplaining engineered\ncomputing systems\u2019 behaviour: the role of abstraction and\nidealization\u201d, <em>Philosophy &amp; Technology</em>, 30(2):\n239\u2013258.</li>\n<li>Anscombe, G. E. M., 1963, <em>Intention</em>, second edition,\nOxford: Blackwell.</li>\n<li>Arkoudas, Konstantine &amp; Selmer Bringsjord, 2007,\n\u201cComputers, Justification, and Mathematical Knowledge\u201d,\n<em>Minds and Machines</em>, 17(2): 185\u2013202.\ndoi:10.1007/s11023-007-9063-5</li>\n<li>Arif, R. Mori, E., and Primiero, G, 2018, \u201cValidity and\nCorrectness before the OS: the case of LEOI and LEOII\u201d, in\nLiesbeth de Mol, Giuseppe Primiero (eds.), <em>Reflections on\nProgrammings Systems - Historical and Philosophical Aspects</em>,\nPhilosophical Studies Series, Cham: Springer, pp. 15\u201347.</li>\n<li>Ashenhurst, Robert L. (ed.), 1989, \u201cLetters in the ACM\nForum\u201d, <em>Communications of the ACM</em>, 32(3): 287.\ndoi:10.1145/62065.315925</li>\n<li>Baier, A., 1970, \u201cAct and Intent\u201d, <em>Journal of\nPhilosophy</em>, 67: 648\u2013658.</li>\n<li>Baier, Christel &amp; Joost-Pieter Katoen, 2008, <em>Principles of\nModel Checking</em>, Cambridge, MA: The MIT Press.</li>\n<li>Bass, Len, Paul C. Clements, &amp; Rick Kazman, 2003 [1997],\n<em>Software Architecture in Practice</em>, second edition, Reading,\nMA: Addison-Wesley; first edition 1997; third edition, 2012.</li>\n<li>Bechtel, William &amp; Adele Abrahamsen, 2005, \u201cExplanation:\nA Mechanist Alternative\u201d, <em>Studies in History and Philosophy\nof Science Part C: Studies in History and Philosophy of Biological and\nBiomedical Sciences</em>, 36(2): 421\u2013441.\ndoi:10.1016/j.shpsc.2005.03.010</li>\n<li>Boghossian, Paul A., 1989, \u201cThe Rule-following\nConsiderations\u201d, <em>Mind</em>, 98(392): 507\u2013549.\ndoi:10.1093/mind/XCVIII.392.507</li>\n<li>Bourbaki, Nicolas, 1968, <em>Theory of Sets</em>, Ettore Majorana\nInternational Science Series, Paris: Hermann.</li>\n<li>Bratman, M. E., 1987, <em>Intention, Plans, and Practical\nReason</em>, Cambridge, MA: Harvard University Press.</li>\n<li>Bridges, Douglas &amp; Palmgren Erik, 2013, \u201cConstructive\nMathematics\u201d, <em>The Stanford Encyclopedia of Philosophy</em>\n(Winter 2013 Edition), Edward N. Zalta (ed.), URL =\n &lt;<a href=\"https://plato.stanford.edu/archives/win2013/entries/mathematics-constructive/\">https://plato.stanford.edu/archives/win2013/entries/mathematics-constructive/</a>&gt;.</li>\n<li>Brooks, Frederick P. Jr., 1995, <em>The Mythical Man Month: Essays\non Software Engineering</em>, Anniversary Edition, Reading, MA:\nAddison-Wesley.</li>\n<li>\u2013\u2013\u2013, 1996, \u201cThe Computer Scientist as\nToolsmith II\u201d, <em>Communications of the ACM</em>, 39(3):\n61\u201368. doi:10.1145/227234.227243</li>\n<li>Burge, Tyler, 1998, \u201cComputer Proof, Apriori Knowledge, and\nOther Minds\u201d, <em>No\u00fbs</em>, 32(S12): 1\u201337.\ndoi:10.1111/0029-4624.32.s12.1</li>\n<li>Bynum, Terrell Ward, 2008, \u201cMilestones in the History of\nInformation and Computer Ethics\u201d, in Himma and Tavani 2008:\n25\u201348. doi:10.1002/9780470281819.ch2</li>\n<li>Callahan, John, Francis Schneider, &amp; Steve Easterbrook, 1996,\n\u201cAutomated Software Testing Using Model-Checking\u201d, in\n<em>Proceeding Spin Workshop</em>, J.C. Gregoire, G.J. Holzmann and D.\nPeled (eds.), New Brunswick, NJ: Rutgers University, pp.\n118\u2013127.</li>\n<li>Cardelli, Luca &amp; Peter Wegner, 1985, \u201cOn Understanding\nTypes, Data Abstraction, and Polymorphism\u201d, 17(4):\n471\u2013522.\n [<a href=\"http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf\" target=\"other\">Cardelli and Wegner 1985 available online</a>]</li>\n<li>Carnap, R., 1966, <em>Philosophical foundations of physics</em>\n(Vol. 966), New York: Basic Books.</li>\n<li>Carrara, M., Gaio, S., and Soavi, M., 2014, \u201cArtifact kinds,\nidentity criteria, and logical adequacy\u201d, in M. Franssen, P.\nKroes, T. Reydon and P. E. Vermaas (eds.), <em>Artefact Kinds:\nOntology and The Human-made World</em>, New York: Springer, pp.\n85\u2013101.</li>\n<li>Chalmers, A. F., 1999, <em>What is this thing called\nScience?</em>, Maidenhead: Open University Press</li>\n<li>Chalmers, David J., 1996, \u201cDoes a Rock Implement Every\nFinite-State Automaton?\u201d <em>Synthese</em>, 108(3):\n309\u201333.\n [<a href=\"http://consc.net/papers/rock.html\" target=\"other\">D.J. Chalmers 1996 available online</a>]\n doi:10.1007/BF00413692</li>\n<li>Clarke, Edmund M. Jr., Orna Grumberg, &amp; Doron A. Peled, 1999,\n<em>Model Checking</em>, Cambridge, MA: The MIT Press.</li>\n<li>Colburn, Timothy R., 1999, \u201cSoftware, Abstraction, and\nOntology\u201d, <em>The Monist</em>, 82(1): 3\u201319.\ndoi:10.5840/monist19998215</li>\n<li>\u2013\u2013\u2013, 2000, <em>Philosophy and Computer\nScience</em>, Armonk, NY: M.E. Sharp.</li>\n<li>Colburn, T. R., Fetzer, J. H. , and Rankin T. L., 1993,\n<em>Program Verification: Fundamental Issues in Computer Science</em>,\nDordrecht: Kluwer Academic Publishers.</li>\n<li>Colburn, Timothy &amp; Gary Shute, 2007, \u201cAbstraction in\nComputer Science\u201d, <em>Minds and Machines</em>, 17(2):\n169\u2013184. doi:10.1007/s11023-007-9061-7</li>\n<li>Copeland, B. Jack, 1993, <em>Artificial Intelligence: A\nPhilosophical Introduction</em>, San Francisco: John Wiley &amp;\nSons.</li>\n<li>\u2013\u2013\u2013, 1996, \u201cWhat is Computation?\u201d\n<em>Synthese</em>, 108(3): 335\u2013359. doi:10.1007/BF00413693</li>\n<li>\u2013\u2013\u2013, 2015, \u201cThe Church-Turing\nThesis\u201d, <em>The Stanford Encyclopedia of Philosophy</em>\n(Summer 2015 Edition), Edward N. Zalta (ed.), URL =\n &lt;<a href=\"https://plato.stanford.edu/archives/sum2015/entries/church-turing/\">https://plato.stanford.edu/archives/sum2015/entries/church-turing/</a>&gt;.</li>\n<li>Copeland, B. Jack &amp; Oron Shagrir, 2007, \u201cPhysical\nComputation: How General are Gandy\u2019s Principles for\nMechanisms?\u201d <em>Minds and Machines</em>, 17(2): 217\u2013231.\ndoi:10.1007/s11023-007-9058-2</li>\n<li>\u2013\u2013\u2013, 2011, \u201cDo Accelerating Turing\nMachines Compute the Uncomputable?\u201d <em>Minds and Machines</em>,\n21(2): 221\u2013239. doi:10.1007/s11023-011-9238-y</li>\n<li>Cummins, Robert, 1975, \u201cFunctional Analysis\u201d, <em>The\nJournal of Philosophy</em>, 72(20): 741\u2013765.\ndoi:10.2307/2024640</li>\n<li>Davidson, D., 1963, \u201cActions, Reasons, and Causes,\u201d\nreprinted in <em>Essays on Actions and Events</em>, Oxford: Oxford\nUniversity Press, 1980, pp. 3\u201320.</li>\n<li>\u2013\u2013\u2013, 1978, \u201cIntending\u201d, reprinted in\n<em>Essays on Actions and Events</em>, Oxford: Oxford University\nPress, 1980, pp. 83\u2013102.</li>\n<li>De Millo, Richard A., Richard J. Lipton, &amp; Alan J. Perlis,\n1979, \u201cSocial Processes and Proofs of Theorems and\nPrograms\u201d, <em>Communications of the ACM</em>, 22(5):\n271\u2013281. doi:10.1145/359104.359106</li>\n<li>Denning, Peter J., 2005, \u201cIs Computer Science\nScience?\u201d, <em>Communications of the ACM</em>, 48(4):\n27\u201331. doi:10.1145/1053291.1053309</li>\n<li>\u2013\u2013\u2013, 2007, \u201cComputing is a Natural\nScience\u201d, <em>Communications of the ACM</em>, 50(7):\n13\u201318. doi:10.1145/1272516.1272529</li>\n<li>Denning, Peter J., Edward A. Feigenbaum, Paul Gilmore, Anthony C.\nHearn, Robert W. Ritchie, &amp; Joseph F. Traub, 1981, \u201cA\nDiscipline in Crisis\u201d, <em>Communications of the ACM</em>,\n24(6): 370\u2013374. doi:10.1145/358669.358682</li>\n<li>Devlin, Keith, 1994, <em>Mathematics: The Science of Patterns: The\nSearch for Order in Life, Mind, and the Universe</em>, New York: Henry\nHolt.</li>\n<li>Dijkstra, Edsger W., 1970, <em>Notes on Structured\nProgramming</em>, T.H.-Report 70-WSK-03, Mathematics Technological\nUniversity Eindhoven, The Netherlands.\n [<a href=\"http://www.cs.utexas.edu/users/EWD/ewd02xx/EWD249.PDF\" target=\"other\">Dijkstra 1970 available online</a>]</li>\n<li>\u2013\u2013\u2013, 1974, \u201cProgramming as a Discipline of\nMathematical Nature\u201d, <em>American Mathematical Monthly</em>,\n81(6): 608\u2013612.\n [<a href=\"http://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD361.html\" target=\"other\">Dijkstra 1974 available online</a></li>\n<li>Distributed Software Engineering, 1997, <em>The Darwin\nLanguage</em>, Department of Computing, Imperial College of Science,\nTechnology and Medicine, London.\n [<a href=\"http://www.cs.toronto.edu/~chechik/courses00/ece450/darwin-lang.pdf\" target=\"other\">Darwin language 1997 available online</a>]</li>\n<li>Duhem, P., 1954, <em>The Aim and Structure of Physical\nTheory</em>, Princeton: Princeton University Press.</li>\n<li>Duijf, H., Broersen, J., and Meyer, J. J. C., 2019,\n\u201cConflicting intentions: rectifying the consistency\nrequirements\u201d, <em>Philosophical Studies</em>, 176(4):\n1097\u20131118.</li>\n<li>Dummett, Michael A.E., 2006, <em>Thought and Reality</em>, Oxford:\nOxford University Press.</li>\n<li>Duncan, William, 2011, \u201cUsing Ontological Dependence to\nDistinguish between Hardware and Software\u201d, <em>Proceedings of\nthe Society for the Study of Artificial Intelligence and Simulation of\nBehavior Conference: Computing and Philosophy</em>, University of\nYork, York, UK.\n [<a href=\"http://www.aisb.org.uk/publications/proceedings/aisb2011.zip\" target=\"other\">Duncan 2011 available online (zip file)</a>]</li>\n<li>\u2013\u2013\u2013, 2017,\u00a0\u201cOntological Distinctions\nbetween Hardware and Software\u201d,\u00a0<em>Applied Ontology</em>,\n12(1): 5\u201332.</li>\n<li>Eden, Amnon H., 2007, \u201cThree Paradigms of Computer\nScience\u201d, <em>Minds and Machines</em>, 17(2): 135\u2013167.\ndoi:10.1007/s11023-007-9060-8</li>\n<li>Egan, Frances, 1992, \u201cIndividualism, Computation, and\nPerceptual Content\u201d, <em>Mind</em>, 101(403): 443\u201359.\ndoi:10.1093/mind/101.403.443</li>\n<li>Edgar, Stacey L., 2003 [1997], <em>Morality and Machines:\nPerspectives on Computer Ethics</em>, Sudbury, MA: Jones &amp;\nBartlett Learning.</li>\n<li>Ferrero, L., 2017, \u201cIntending, Acting, and Doing,\u201d\n<em>Philosophical Explorations</em>, 20 (Supplement 2):\n13\u201339.</li>\n<li>Fern\u00e1ndez, Maribel, 2004, <em>Programming Languages and\nOperational Semantics: An Introduction</em>, London: King\u2019s\nCollege Publications.</li>\n<li>Fetzer, James H., 1988, \u201cProgram Verification: The Very\nIdea\u201d, <em>Communications of the ACM</em>, 31(9):\n1048\u20131063. doi:10.1145/48529.48530</li>\n<li>\u2013\u2013\u2013, 1990, <em>Artificial Intelligence: Its\nScope and Limits</em>, Dordrecht: Springer Netherlands.</li>\n<li>Feynman, Richard P., 1984\u20131986, <em>Feynman Lectures on\nComputation</em>, Cambridge, MA: Westview Press, 2000.</li>\n<li>Flanagan, Mary, Daniel C. Howe, &amp; Helen Nissenbaum, 2008,\n\u201cEmbodying Values in Technology: Theory and Practice\u201d, in\n<em>Information Technology and Moral Philosophy</em>, Jeroen van den\nHoven and John Weckert (eds.), Cambridge: Cambridge University Press,\npp. 322\u2013353.</li>\n<li>Floridi, Luciano, 2008, \u201cThe Method of Levels of\nAbstraction\u201d, <em>Minds and Machines</em>, 18(3): 303\u2013329.\ndoi:10.1007/s11023-008-9113-7</li>\n<li>Floridi, Luciano, Nir Fresco, &amp; Giuseppe Primiero, 2015,\n\u201cOn Malfunctioning Software\u201d, <em>Synthese</em>, 192(4):\n1199\u20131220. doi:10.1007/s11229-014-0610-3</li>\n<li>Floyd, Robert W., 1979, \u201cThe Paradigms of\nProgramming\u201d, <em>Communications of the ACM</em>, 22(8):\n455\u2013460. doi:10.1145/1283920.1283934</li>\n<li>Fowler, Martin, 2003, <em>UML Distilled: A Brief Guide to the\nStandard Object Modeling Language</em>, 3<sup>rd</sup> edition,\nReading, MA: Addison-Wesley.</li>\n<li>Franssen, Maarten, Gert-Jan Lokhorst, &amp; Ibio van de Poel,\n2013, \u201cPhilosophy of Technology\u201d, <em>The Stanford\nEncyclopedia of Philosophy</em> (Winter 2013 Edition), Edward N. Zalta\n(ed.), URL =\n &lt;<a href=\"https://plato.stanford.edu/archives/win2013/entries/technology/\">https://plato.stanford.edu/archives/win2013/entries/technology/</a>&gt;.</li>\n<li>Frege, Gottlob, 1914, \u201cLetter to Jourdain\u201d, reprinted\nin Frege 1980: 78\u201380.</li>\n<li>\u2013\u2013\u2013, 1980, Gottlob Frege: <em>Philosophical and\nMathematical Correspondence</em>, G. Gabriel, H. Hermes, F. Kambartel,\nC. Thiel, and A. Veraart (eds.), Oxford: Blackwell Publishers.</li>\n<li>Fresco, Nir &amp; Giuseppe Primiero, 2013,\n\u201cMiscomputation\u201d, <em>Philosophy &amp; Technology</em>,\n26(3): 253\u2013272. doi:10.1007/s13347-013-0112-0</li>\n<li>Friedman, Batya &amp; Helen Nissenbaum, 1996, \u201cBias in\nComputer Systems\u201d, <em>ACM Transactions on Information Systems\n(TOIS)</em>, 14(3): 330\u2013347. doi:10.1145/230538.230561</li>\n<li>Frigg, Roman &amp; Stephan Hartmann, 2012, \u201cModels in\nScience\u201d, <em>The Stanford Encyclopedia of Philosophy</em> (Fall\n2012 Edition), Edward N. Zalta (ed.), URL\n =&lt;<a href=\"https://plato.stanford.edu/archives/fall2012/entries/models-science/\">https://plato.stanford.edu/archives/fall2012/entries/models-science/</a>&gt;.</li>\n<li>Gagliardi, Francesco, 2007, \u201cEpistemological Justification\nof Test Driven Development in Agile Processes\u201d, <em>Agile\nProcesses in Software Engineering and Extreme Programming: Proceedings\nof the 8th International Conference, XP 2007</em>, Como, Italy, June\n18\u201322, 2007, Berlin: Springer Berlin Heidelberg, pp.\n253\u2013256. doi:10.1007/978-3-540-73101-6_48</li>\n<li>Gamma, Erich, Richard Helm, Ralph Johnson, &amp; John Vlissides,\n1994, <em>Design Patterns: Elements of Reusable Object-Oriented\nSoftware</em>, Reading, MA: Addison-Wesley.</li>\n<li>Glennan, Stuart S., 1996, \u201cMechanisms and the Nature of\nCausation\u201d, <em>Erkenntnis</em>, 44(1): 49\u201371.\ndoi:10.1007/BF00172853</li>\n<li>Gl\u00fcer, Kathrin &amp; \u00c5sa Wikforss, 2015, \u201cThe\nNormativity of Meaning and Content\u201d, <em>The Stanford\nEncyclopedia of Philosophy</em> (Summer 2015 Edition), Edward N. Zalta\n(ed.), URL =\n &lt;<a href=\"https://plato.stanford.edu/archives/sum2015/entries/meaning-normativity/\">https://plato.stanford.edu/archives/sum2015/entries/meaning-normativity/</a>&gt;.</li>\n<li>Goguen, Joseph A. &amp; Rod M. Burstall, 1985,\n\u201cInstitutions: Abstract Model Theory for Computer\nScience\u201d, <em>Report CSLI-85-30</em>, Center for the Study of\nLanguage and Information at Stanford University.</li>\n<li>\u2013\u2013\u2013, 1992, \u201cInstitutions: Abstract Model\nTheory for Specification and Programming\u201d, <em>Journal of the\nACM (JACM)</em>, 39(1): 95\u2013146. doi:10.1145/147508.147524</li>\n<li>Gordon, Michael J.C., 1979, <em>The Denotational Description of\nProgramming Languages</em>, New York: Springer-Verlag.</li>\n<li>Gotterbarn, Donald, 1991, \u201cComputer Ethics: Responsibility\nRegained\u201d, <em>National Forum: The Phi Beta Kappa Journal</em>,\n71(3): 26\u201331.</li>\n<li>\u2013\u2013\u2013, 2001, \u201cInformatics and Professional\nResponsibility\u201d, <em>Science and Engineering Ethics</em>, 7(2):\n221\u2013230. doi:10.1007/s11948-001-0043-5</li>\n<li>Gotterbarn, Donald, Keith Miller, &amp; Simon Rogerson, 1997,\n\u201cSoftware Engineering Code of Ethics\u201d, <em>Information\nSociety</em>, 40(11): 110\u2013118. doi:10.1145/265684.265699</li>\n<li>Gotterbarn, Donald &amp; Keith W. Miller, 2009, \u201cThe Public\nis the Priority: Making Decisions Using the Software Engineering Code\nof Ethics\u201d, <em>IEEE Computer</em>, 42(6): 66\u201373.\ndoi:10.1109/MC.2009.204</li>\n<li>Gruner, Stefan, 2011, \u201cProblems for a Philosophy of Software\nEngineering\u201d, <em>Minds and Machines</em>, 21(2): 275\u2013299.\ndoi:10.1007/s11023-011-9234-2</li>\n<li>Gunter, Carl A., 1992, <em>Semantics of Programming Languages:\nStructures and Techniques</em>, Cambridge, MA: MIT Press.</li>\n<li>Gupta, Anil, 2014, \u201cDefinitions\u201d, <em>The Stanford\nEncyclopedia of Philosophy</em> (Fall 2014 Edition), Edward N. Zalta\n(ed.), URL =\n &lt;<a href=\"https://plato.stanford.edu/archives/fall2014/entries/definitions/\">https://plato.stanford.edu/archives/fall2014/entries/definitions/</a>&gt;.</li>\n<li>Gurevich, Y., 2000, \u201cSequential Abstract-State Machines\nCapture Sequential Algorithms\u201d, <em>ACM Transactions on\nComputational Logic (TOCL)</em>, 1(1): 77-111.</li>\n<li>\u2013\u2013\u2013, 2012, \u201cWhat is an algorithm?\u201d,\nin <em>International conference on current trends in theory and\npractice of computer science</em>, Heidelberg, Berlin: Springer, pp.\n31\u201342.</li>\n<li>Hacking, I., 2014, <em>Why is there a Philosophy of Mathematics at\nall?</em>, Cambridge: Cambridge University Press.</li>\n<li>Hagar, Amit, 2007, \u201cQuantum Algorithms: Philosophical\nLessons\u201d, <em>Minds and Machines</em>, 17(2): 233\u2013247.\ndoi:10.1007/s11023-007-9057-3</li>\n<li>Hale, Bob, 1987, <em>Abstract Objects</em>, Oxford: Basil\nBlackwell.</li>\n<li>Hales, Thomas C., 2008, \u201cFormal Proof\u201d, <em>Notices of\nthe American Mathematical Society</em>, 55(11): 1370\u20131380.</li>\n<li>Hankin, Chris, 2004, <em>An Introduction to Lambda Calculi for\nComputer Scientists</em>, London: King\u2019s College\nPublications.</li>\n<li>Harrison, John, 2008, \u201cFormal Proof\u2014Theory and\nPractice\u201d, <em>Notices of the American Mathematical\nSociety</em>, 55(11): 1395\u20131406.</li>\n<li>Hartmanis, Juris, 1981, \u201cNature of Computer Science and Its\nParadigms\u201d, pp. 353\u2013354 (in Section 1) of \u201cQuo\nVadimus: Computer Science in a Decade\u201d, J.F. Traub (ed.),\n<em>Communications of the ACM</em>, 24(6): 351\u2013369.\ndoi:10.1145/358669.358677</li>\n<li>\u2013\u2013\u2013, 1993, \u201cSome Observations About the\nNature of Computer Science\u201d, in <em>International Conference on\nFoundations of Software Technology and Theoretical Computer\nScience</em>, Springer Berlin Heidelberg, pp. 1\u201312.\ndoi:10.1007/3-540-57529-4_39</li>\n<li>Hayes, P. J., 1997, \u201cWhat is a Computer?\u201d, <em>The\nMonist</em>, 80(3): 389\u2013404.</li>\n<li>Hempel, C. G., 1970, \u201cOn the \u2018standard\nconception\u2019 of scientific theories\u201d, <em>Minnesota Studies\nin the Philosophy of Science</em>, 4: 142\u2013163.</li>\n<li>Henson, Martin C., 1987, <em>Elements of Functional\nProgramming</em>, Oxford: Blackwell.</li>\n<li>Hilbert, David, 1931, \u201cThe Grounding of Elementary Number\nTheory\u201d, reprinted in P. Mancosu (ed.), 1998, <em>From Brouwer\nto Hilbert: the Debate on the Foundations of Mathematics in the\n1920s</em>, New York: Oxford University Press, pp. 266\u2013273.</li>\n<li>Hilbert, David &amp; Wilhelm Ackermann, 1928, <em>Grundz\u00fcge\nDer Theoretischen Logik</em>, translated as <em>Principles of\nMathematical Logic</em>, Lewis M. Hammond, George G. Leckie, and F.\nSteinhardt (trans.), New York: Chelsea, 1950.</li>\n<li>Hill, R.K., 2016, \u201cWhat an algorithm is\u201d,\n<em>Philosophy &amp; Technology</em>, 29(1): 35\u201359.</li>\n<li>\u2013\u2013\u2013, 2018, \u201cElegance in Software\u201d,\nin Liesbeth de Mol, Giuseppe Primiero (eds.), <em>Reflections on\nProgrammings Systems - Historical and Philosophical Aspects\n(Philosophical Studies Series)</em>, Cham: Springer, pp.\n273\u2013286.</li>\n<li>Hoare, C.A.R., 1969, \u201cAn Axiomatic Basis for Computer\nProgramming\u201d, <em>Communications of the ACM</em>, 12(10):\n576\u2013580. doi:10.1145/363235.363259</li>\n<li>\u2013\u2013\u2013, 1973, \u201cNotes on Data\nStructuring\u201d, in O.J. Dahl, E.W. Dijkstra, and C.A.R. Hoare\n(eds.), <em>Structured Programming</em>, London: Academic Press, pp.\n83\u2013174.</li>\n<li>\u2013\u2013\u2013, 1981, \u201cThe Emperor\u2019s Old\nClothes\u201d, <em>Communications of the ACM</em>, 24(2):\n75\u201383. doi:10.1145/1283920.1283936</li>\n<li>\u2013\u2013\u2013, 1985, <em>Communicating Sequential\nProcesses</em>, Englewood Cliffs, NJ: Prentice Hall.\n [<a href=\"http://www.usingcsp.com/\" target=\"other\">Hoare 1985 available online</a>]</li>\n<li>\u2013\u2013\u2013, 1986, <em>The Mathematics of Programming:\nAn Inaugural Lecture Delivered Before the University of Oxford on Oct.\n17, 1985</em>, Oxford: Oxford University Press.</li>\n<li>Hodges, Andrews, 2011, \u201cAlan Turing\u201d, <em>The Stanford\nEncyclopedia of Philosophy</em> (Summer 2011 Edition), Edward N. Zalta\n(ed.), URL =\n &lt;<a href=\"https://plato.stanford.edu/archives/sum2011/entries/turing/\">https://plato.stanford.edu/archives/sum2011/entries/turing/</a>&gt;.</li>\n<li>Hodges, Wilfrid, 2013, \u201cModel Theory\u201d, <em>The\nStanford Encyclopedia of Philosophy</em> (Fall 2013 Edition), Edward\nN. Zalta (ed.), forthcoming URL =\n &lt;<a href=\"https://plato.stanford.edu/archives/fall2013/entries/model-theory/\">https://plato.stanford.edu/archives/fall2013/entries/model-theory/</a>&gt;.</li>\n<li>Hopcroft, John E. &amp; Jeffrey D. Ullman, 1969, <em>Formal\nLanguages and their Relation to Automata</em>, Reading, MA:\nAddison-Wesley.</li>\n<li>Hughes, Justin, 1988, \u201cThe Philosophy of Intellectual\nProperty\u201d, <em>Georgetown Law Journal</em>, 77: 287.</li>\n<li>Irmak, Nurbay, 2012, \u201cSoftware is an Abstract\nArtifact\u201d, <em>Grazer Philosophische Studien</em>, 86(1):\n55\u201372.</li>\n<li>Johnson, Christopher W., 2006, \u201cWhat are Emergent Properties\nand How Do They Affect the Engineering of Complex Systems\u201d,\n<em>Reliability Engineering and System Safety</em>, 91(12):\n1475\u20131481.\n [<a href=\"http://www.dcs.gla.ac.uk/~johnson/papers/RESS/Complexity_Emergence_Editorial.pdf\" target=\"other\">Johnson 2006 available online</a>]</li>\n<li>Johnson-Laird, P. N., 1988, <em>The Computer and the Mind: An\nIntroduction to Cognitive Science</em>, Cambridge, MA: Harvard\nUniversity Press.</li>\n<li>Jones, Cliff B., 1990 [1986], <em>Systematic Software Development\nUsing VDM</em>, second edition, Englewood Cliffs, NJ: Prentice Hall.\n [<a href=\"http://homepages.cs.ncl.ac.uk/cliff.jones/publications/\" target=\"other\">Jones 1990 available online</a>]</li>\n<li>Kimppa, Kai, 2005, \u201cIntellectual Property Rights in\nSoftware\u2014Justifiable from a Liberalist Position? Free Software\nFoundation\u2019s Position in Comparison to John Locke\u2019s\nConcept of Property\u201d, in R.A. Spinello &amp; H.T. Tavani (eds.),\n<em>Intellectual Property Rights in a Networked World: Theory and\nPractice</em>, Hershey, PA: Idea, pp. 67\u201382.</li>\n<li>Kinsella, N. Stephan, 2001, \u201cAgainst Intellectual\nProperty\u201d, <em>Journal of Libertarian Studies</em>, 15(2):\n1\u201353.</li>\n<li>Kleene, S. C., 1967, <em>Mathematical Logic</em>, New York:\nWiley.</li>\n<li>Knuth, D. E., 1973, <em>The Art of Computer Programming</em>,\nsecond edition, Reading, MA: Addison-Wesley.</li>\n<li>\u2013\u2013\u2013, 1974a, \u201cComputer Programming as an\nArt\u201d, <em>Communications of the ACM</em>, 17(12): 667\u2013673.\ndoi:10.1145/1283920.1283929</li>\n<li>\u2013\u2013\u2013, 1974b, \u201cComputer Science and Its\nRelation to Mathematics\u201d, <em>The American Mathematical\nMonthly</em>, 81(4): 323\u2013343.</li>\n<li>\u2013\u2013\u2013, 1977, \u201cAlgorithms\u201d,\n<em>Scientifc American</em>, 236(4): 63\u201380.</li>\n<li>Kripke, Saul, 1982, <em>Wittgenstein on Rules and Private\nLanguage</em>, Cambridge, MA: Harvard University Press.</li>\n<li>Kroes, Peter, 2010, \u201cEngineering and the Dual Nature of\nTechnical Artefacts\u201d, <em>Cambridge Journal of Economics</em>,\n34(1): 51\u201362. doi:10.1093/cje/bep019</li>\n<li>\u2013\u2013\u2013, 2012, <em>Technical Artefacts: Creations of\nMind and Matter: A Philosophy of Engineering Design</em>, Dordrecht:\nSpringer.</li>\n<li>Kroes, Peter &amp; Anthonie Meijers, 2006, \u201cThe Dual Nature\nof Technical Artefacts\u201d, <em>Studies in History and Philosophy\nof Science</em>, 37(1): 1\u20134.\ndoi:10.1016/j.shpsa.2005.12.001</li>\n<li>Kr\u00f6ger, Fred &amp; Stephan Merz, 2008, <em>Temporal Logics\nand State Systems</em>, Berlin: Springer.</li>\n<li>Ladd, John, 1988, \u201cComputers and Moral Responsibility: a\nFramework for An Ethical Analysis\u201d, in Carol C. Gould, (ed.),\n<em>The Information Web: Ethical &amp; Social Implications of Computer\nNetworking</em>, Boulder, CO: Westview Press, pp. 207\u2013228.</li>\n<li>Landin, P.J., 1964, \u201cThe Mechanical Evaluation of\nExpressions\u201d, <em>The Computer Journal</em>, 6(4):\n308\u2013320. doi:10.1093/comjnl/6.4.308</li>\n<li>Littlewood, Bev &amp; Lorenzo Strigini, 2000, \u201cSoftware\nReliability and Dependability: a Roadmap\u201d, <em>ICSE \u201900\nProceedings of the Conference on the Future of Software\nEngineering</em>, pp. 175\u2013188. doi:10.1145/336512.336551</li>\n<li>Locke, John, 1690, <em>The Second Treatise of Government</em>.\n [<a href=\"https://www.gutenberg.org/files/7370/7370-h/7370-h.htm\" target=\"other\">Locke 1690 available online</a>]</li>\n<li>Loewenheim, Ulrich, 1989, \u201cLegal Protection for Computer\nPrograms in West Germany\u201d, <em>Berkeley Technology Law\nJournal</em>, 4(2): 187\u2013215.\n [<a href=\"http://scholarship.law.berkeley.edu/btlj/vol4/iss2/1/\" target=\"other\">Loewenheim 1989 available online</a>]\n doi:10.15779/Z38Q67F</li>\n<li>Long, Roderick T., 1995, \u201cThe Libertarian Case Against\nIntellectual Property Rights\u201d, <em>Formulations</em>, Autumn,\nFree Nation Foundation.</li>\n<li>Loui, Michael C. &amp; Keith W. Miller, 2008, \u201cEthics and\nProfessional Responsibility in Computing\u201d, <em>Wiley\nEncyclopedia of Computer Science and Engineering</em>, Benjamin Wah\n(ed.), John Wiley &amp; Sons.\n [<a href=\"http://hdl.handle.net/2142/12247\" target=\"other\">Loui and Miller 2008 available online</a>]</li>\n<li>Lowe, E. J., 1998, <em>The Possibility of Metaphysics: Substance,\nIdentity, and Time</em>, Oxford: Clarendon Press.</li>\n<li>Luckham, David C., 1998, \u201cRapide: A Language and Toolset for\nCausal Event Modeling of Distributed System Architectures\u201d, in\nY. Masunaga, T. Katayama, and M. Tsukamoto (eds.), <em>Worldwide\nComputing and its Applications</em>, WWCA\u201998, Berlin: Springer,\npp. 88\u201396. doi:10.1007/3-540-64216-1_42</li>\n<li>Machamer, Peter K., Lindley Darden, &amp; Carl F. Craver, 2000,\n\u201cThinking About Mechanisms\u201d, <em>Philosophy of\nScience</em>, 67(1): 1\u201325. doi:10.1086/392759</li>\n<li>Magee, Jeff, Naranker Dulay, Susan Eisenbach, &amp; Jeff Kramer,\n1995, \u201cSpecifying Distributed Software Architectures\u201d,\n<em>Proceedings of 5th European Software Engineering Conference (ESEC\n95)</em>, Berlin: Springer-Verlag, pp. 137\u2013153.</li>\n<li>Markov, A., 1954, \u201cTheory of algorithms\u201d, Tr. Mat.\nInst. Steklov 42, pp. 1\u201314. trans. by Edwin Hewitt in\n<em>American Mathematical Society Translations</em>, Series 2, Vol. 15\n(1960).</li>\n<li>Martin-L\u00f6f, Per, 1982, \u201cConstructive Mathematics and\nComputer Programming\u201d, in <em>Logic, Methodology and Philosophy\nof Science</em> (Volume VI: 1979), Amsterdam: North-Holland, pp.\n153\u2013175.</li>\n<li>McGettrick, Andrew, 1980, <em>The Definition of Programming\nLanguages</em>, Cambridge: Cambridge University Press.</li>\n<li>McLaughlin, Peter, 2001, <em>What Functions Explain: Functional\nExplanation and Self-Reproducing Systems</em>, Cambridge: Cambridge\nUniversity Press.</li>\n<li>Meijers, A.W.M., 2001, \u201cThe Relational Ontology of Technical\nArtifacts\u201d, in P.A. Kroes and A.W.M. Meijers (eds.), <em>The\nEmpirical Turn in the Philosophy of Technology</em>, Amsterdam:\nElsevier, pp. 81\u201396.</li>\n<li>Mitchelmore, Michael &amp; Paul White, 2004, \u201cAbstraction in\nMathematics and Mathematics Learning\u201d, in M.J. H\u00f8ines and\nA.B. Fuglestad (eds.), <em>Proceedings of the 28th Conference of the\nInternational Group for the Psychology of Mathematics Education\n(Volume 3)</em>, Bergen: Programm Committee, pp. 329\u2013336.\n [<a href=\"http://www.emis.de/proceedings/PME28/RR/RR031_Mitchelmore.pdf\" target=\"other\">Mitchelmore and White 2004 available online</a>]</li>\n<li>Miller, Alexander &amp; Crispin Wright (eds), 2002, <em>Rule\nFollowing and Meaning</em>, Montreal/Ithaca: McGill-Queen's\nUniversity Press.</li>\n<li>Milne, Robert &amp; Christopher Strachey, 1976, <em>A Theory of\nProgramming Language Semantics</em>, London: Chapman and Hall.</li>\n<li>Milner, R., 1971, \u201cAn algebraic definition of simulation\nbetween programs\u201d, Technical Report, <em>CS-205</em>, pp.\n481\u2013489, Department of Computer Science, Stanford\nUniversity.</li>\n<li>Mitchell, John C., 2003, <em>Concepts in Programming\nLanguages</em>, Cambridge: Cambridge University Press.</li>\n<li>Monin, Jean Fran\u00e7ois, 2003, <em>Understanding Formal\nMethods</em>, Michael G. Hinchey (ed.), London: Springer (this is\nMonin's translation of his own Introduction aux M\u00e9thodes\nFormelles, Hermes, 1996, first edition; 2000, second edition),\ndoi:10.1007/978-1-4471-0043-0</li>\n<li>Mooers, Calvin N., 1975, \u201cComputer Software and\nCopyright\u201d, <em>ACM Computing Surveys</em>, 7(1): 45\u201372.\ndoi:10.1145/356643.356647</li>\n<li>Moor, James H., 1978, \u201cThree Myths of Computer\nScience\u201d, <em>The British Journal for the Philosophy of\nScience</em>, 29(3): 213\u2013222.</li>\n<li>Morgan, C., 1994, <em>Programming From Specifications</em>,\nEnglewood Cliffs: Prentice Hall. [Morgan 1994 available online]</li>\n<li>Moschovakis, Y. N., 2001, \u201cWhat is an algorithm?\u201d, in\n<em>Mathematics Unlimited\u20142001 and Beyond</em>, Heidelberg,\nBerlin: Springer, pp. 919\u2013936.</li>\n<li>Naur, P., 1985, \u201cProgramming as theory building\u201d,\n<em>Microprocessing and microprogramming</em>, 15(5):\n253\u2013261.</li>\n<li>Newell, A., and Simon, H. A., 1961, \u201cComputer simulation of\nhuman thinking\u201d <em>Science</em>, 134(3495):\n2011\u20132017.</li>\n<li>\u2013\u2013\u2013 1972, <em>Human Problem Solving</em>,\nEnglewood Cliffs, NJ: Prentice-Hall.</li>\n<li>\u2013\u2013\u2013, 1976, \u201cComputer Science as Empirical\nInquiry: Symbols and Search\u201d, <em>Communications of the\nACM</em>, 19(3): 113\u2013126. doi:10.1145/1283920.1283930</li>\n<li>Newell, Allen, Alan J. Perlis, &amp; Herbert A. Simon, 1967,\n\u201cComputer Science\u201d, <em>Science</em>, 157(3795):\n1373\u20131374. doi:10.1126/science.157.3795.1373-b</li>\n<li>Nissenbaum,Helen, 1998, \u201cValues in the Design of Computer\nSystems\u201d, <em>Computers and Society</em>, 28(1):\n38\u201339.</li>\n<li>Northover, Mandy, Derrick G. Kourie, Andrew Boake, Stefan Gruner,\n&amp; Alan Northover, 2008, \u201cTowards a Philosophy of Software\nDevelopment: 40 Years After the Birth of Software Engineering\u201d,\n<em>Journal for General Philosophy of Science</em>, 39(1):\n85\u2013113. doi:10.1007/s10838-008-9068-7</li>\n<li>Pears, David Francis, 2006, <em>Paradox and Platitude in\nWittgenstein\u2019s Philosophy</em>, Oxford: Oxford University Press.\ndoi:10.1093/acprof:oso/9780199247707.001.0001</li>\n<li>Piccinini, Gualtiero, 2007, \u201cComputing Mechanisms\u201d,\n<em>Philosophy of Science</em>, 74(4): 501\u2013526.\ndoi:10.1086/522851</li>\n<li>\u2013\u2013\u2013, 2008, \u201cComputation without\nRepresentation\u201d, <em>Philosophical Studies</em>, 137(2):\n206\u2013241.\n [<a href=\"http://www.umsl.edu/~piccininig/Computation_without_Representation.pdf\" target=\"other\">Piccinini 2008 available online</a>]\n doi:10.1007/s11098-005-5385-4</li>\n<li>\u2013\u2013\u2013, 2008, \u201cComputers\u201d, <em>Pacific\nPhilosophical Quarterly</em>, 89: 32\u201373.</li>\n<li>\u2013\u2013\u2013, 2015, <em>Physical Computation: A\nMechanistic Account</em>, Oxford: Oxford University Press.\ndoi:10.1093/acprof:oso/9780199658855.001.0001</li>\n<li>Piccinini, Gualtiero &amp; Carl Craver, 2011, \u201cIntegrating\nPsychology and Neuroscience: Functional Analyses as Mechanism\nSketches\u201d, <em>Synthese</em>, 183(3): 283\u2013311.\ndoi:10.1007/s11229-011-9898-4</li>\n<li>Popper, Karl R., 1959, <em>The Logic of Scientific Discovery</em>,\nLondon: Hutchinson.</li>\n<li>Primiero, G., 2016, \u201cInformation in the philosophy of\ncomputer science\u201d, in Floridi L. (ed.), <em>The Routledge\nHandbook of Philosophy of Information</em>, London: Routledge, pp.\n90\u2013106.</li>\n<li>\u2013\u2013\u2013, 2020, <em>On the Foundations of\nComputing</em>. New York: Oxford University Press.</li>\n<li>Primiero, G., D.F. Solheim &amp; J.M. Spring, 2019 \u201cOn\nMalfunction, Mechanisms and Malware Classification\u201d, <em>Philos.\nTechnol</em>. 32: 339\u2013362.\nhttps://doi.org/10.1007/s13347-018-0334-2</li>\n<li>Pylyshyn, Z. W., 1984, <em>Computation and Cognition: Towards a\nFoundation for Cognitive Science</em>, Cambridge, MA: MIT Press.</li>\n<li>Pym, D., J.M. Spring, &amp; P. O\u2019Hearn, 2019, \u201cWhy\nSeparation Logic Works\u201d, <em>Philosophy &amp; Technology</em>,\n32: 483\u2013516.</li>\n<li>Rapaport, William J., 1995, \u201cUnderstanding Understanding:\nSyntactic Semantics and Computational Cognition\u201d, in Tomberlin\n(ed.), <em>Philosophical Perspectives</em>, Vol. 9: AI, Connectionism,\nand Philosophical Psychology, Atascadero, CA: Ridgeview, pp.\n49\u201388.\n [<a href=\"http://www.cse.buffalo.edu/~rapaport/Papers/rapaport95-uu.pdf\" target=\"other\">Rapaport 1995 available online</a>]\n doi:10.2307/2214212</li>\n<li>\u2013\u2013\u2013, 1999, \u201cImplementation Is Semantic\nInterpretation\u201d, <em>The Monist</em>, 82(1): 109\u201330.\n [<a href=\"http://www.cse.buffalo.edu/~rapaport/Papers/monist.pdf\" target=\"other\">Rapaport 1999 available online</a>]</li>\n<li>\u2013\u2013\u2013, 2005, \u201cImplementation as Semantic\nInterpretation: Further Thoughts\u201d, <em>Journal of\nExperimental&amp; Theoretical Artificial Intelligence</em>, 17(4):\n385\u2013417.\n [<a href=\"http://www.cse.buffalo.edu/~rapaport/Papers/jetai05.pdf\" target=\"other\">Rapaport 2005 available online</a>]</li>\n<li>\u2013\u2013\u2013, 2012, \u201cSemiotic systems, computers,\nand the mind: how cognition could be computing\u201d,\n<em>International Journal of Signs and Semiotic Systems</em>, 2(1):\n32\u201371</li>\n<li>\u2013\u2013\u2013, 2018, \u201cWhat is a Computer? A\nSurvey\u201d, <em>Minds and Machines</em>, 28(3): 385\u2013426.</li>\n<li>Reynolds, J.C., 2002, \u201cSeparation Logic: a logic for shared\nmutable data structures\u201d, in <em>Proceedings of the 17th Annual\nIEEE Symposium on Logic in Computer Science</em>, IEEE, pp.\n55\u201374.</li>\n<li>Rombach, Dieter &amp; Frank Seelisch, 2008, \u201cFormalisms in\nSoftware Engineering: Myths Versus Empirical Facts\u201d, in\n<em>Balancing Agility and Formalism in Software Engineering</em>,\nSpringer Berlin Heidelberg, pp. 13\u201325.\ndoi:10.1007/978-3-540-85279-7_2</li>\n<li>Rosenberg, A., 2012, <em>The Philosophy of Science</em>, London:\nRoutledge.</li>\n<li>Ryle G., 1949 [2009], <em>The Concept of Mind</em>, Abingdon:\nRoutledge</li>\n<li>Schiaffonati, Viola, 2015, \u201cStretching the Traditional\nNotion of Experiment in Computing: Explorative Experiments\u201d,\n<em>Science and Engineering Ethics</em>, 22(3): 1\u201319.\ndoi:10.1007/s11948-015-9655-z</li>\n<li>Schiaffonati, Viola &amp; Mario Verdicchio, 2014, \u201cComputing\nand Experiments\u201d, <em>Philosophy &amp; Technology</em>, 27(3):\n359\u2013376. doi:10.1007/s13347-013-0126-7</li>\n<li>Searle, J. R., 1990, \u201cIs the brain a digital\ncomputer?\u201d <em>Proceedings and Addresses of the American\nPhilosophical Association</em>, 64(3): 21\u201337.</li>\n<li>Searle, John R., 1995, <em>The Construction of Social\nReality</em>, New York: Free Press.</li>\n<li>Setiya, K., \u201cIntention\u201d, <em>The Stanford Encyclopedia\nof Philosophy</em> (Fall 2018 Edition), Edward N. Zalta (ed.), URL =\n &lt;<a href=\"https://plato.stanford.edu/archives/fall2018/entries/intention/\">https://plato.stanford.edu/archives/fall2018/entries/intention/</a>&gt;.</li>\n<li>Shanker, S.G., 1987, \u201cWittgenstein versus Turing on the\nNature of Church\u2019s Thesis\u201d, <em>Notre Dame Journal of\nFormal Logic</em>, 28(4): 615\u2013649.\n [<a href=\"http://projecteuclid.org/euclid.ndjfl/1093637650\" target=\"other\">Shanker 1987 available online</a>]\n doi:10.1305/ndjfl/1093637650</li>\n<li>Shavell, Steven &amp; Tanguy van Ypersele, 2001, \u201cRewards\nVersus Intellectual Property Rights\u201d, <em>Journal of Law and\nEconomics</em>, 44: 525\u2013547</li>\n<li>Skemp, Richard R., 1987, <em>The Psychology of Learning\nMathematics</em>, Hillsdale, NJ: Lawrence Erlbaum Associates.</li>\n<li>Smith, Brian Cantwell, 1985, \u201cThe Limits of Correctness in\nComputers\u201d, <em>ACM SIGCAS Computers and Society</em>,\n14\u201315(1\u20134): 18\u201326. doi:10.1145/379486.379512</li>\n<li>Snelting, Gregor, 1998, \u201cPaul Feyerabend and Software\nTechnology\u201d, <em>Software Tools for Technology Transfer</em>,\n2(1): 1\u20135. doi:10.1007/s100090050013</li>\n<li>Sommerville, Ian, 2016 [1982], <em>Software Engineering</em>,\nReading, MA: Addison-Wesley; first edition, 1982.</li>\n<li>Sprevak, M., 2010, \u201cComputation, individuation, and the\nreceived view on representation\u201d, <em>Studies in History and\nPhilosophy of Science</em>, 41(3): 260\u2013270.</li>\n<li>\u2013\u2013\u2013, 2012, \u201cThree Challenges to Chalmers\non Computational Implementation\u201d, <em>Journal of Cognitive\nScience</em>, 13(2): 107\u2013143.</li>\n<li>Stoy, Joseph E., 1977, <em>Denotational Semantics: The\nScott-Strachey Approach to Programming Language Semantics</em>,\nCambridge, MA: MIT Press.</li>\n<li>Strachey, Christopher, 2000, \u201cFundamental Concepts in\nProgramming Languages\u201d, <em>Higher-Order and Symbolic\nComputation</em>, 13(1\u20132): 11\u201349.\ndoi:10.1023/A:1010000313106</li>\n<li>Suber, Peter, 1988, \u201cWhat Is Software?\u201d <em>Journal of\nSpeculative Philosophy</em>, 2(2): 89\u2013119.\n [<a href=\"https://dash.harvard.edu/bitstream/handle/1/3715472/suber_software.html\" target=\"other\">Suber 1988 available online</a>]</li>\n<li>Summerville, I., 2012, <em>Software Engineering</em>, Reading, MA:\nAddison-Wesley; first edition, 1982.</li>\n<li>Suppe, Frederick, 1989, <em>The Semantic Conception of Theories\nand Scientific Realism</em>, Chicago: University of Illinois\nPress.</li>\n<li>Suppes, Patrick, 1960, \u201cA Comparison of the Meaning and Uses\nof Models in Mathematics and the Empirical Sciences\u201d,\n<em>Synthese</em>, 12(2): 287\u2013301. doi:10.1007/BF00485107</li>\n<li>\u2013\u2013\u2013, 1969, \u201cModels of Data\u201d, in\n<em>Studies in the Methodology and Foundations of Science</em>,\nDordrecht: Springer Netherlands, pp. 24\u201335.</li>\n<li>Technical Correspondence, Corporate, 1989, <em>Communications of\nthe ACM</em>, 32(3): 374\u2013381. Letters from James C. Pleasant,\nLawrence Paulson/Avra Cohen/Michael Gordon, William Bevier/Michael\nSmith/William Young, Thomas Clune, Stephen Savitzky, James Fetzer.\ndoi:10.1145/62065.315927</li>\n<li>Tedre, Matti, 2011, \u201cComputing as a Science: A Survey of\nCompeting Viewpoints\u201d, <em>Minds and Machines</em>, 21(3):\n361\u2013387. doi:10.1007/s11023-011-9240-4</li>\n<li>\u2013\u2013\u2013, 2015, <em>The Science of Computing: Shaping\na Discipline</em>, Boca Raton: CRC Press, Taylor and Francis\nGroup.</li>\n<li>Tedre, Matti &amp; Ekki Sutinen, 2008, \u201cThree Traditions of\nComputing: What Educators Should Know\u201d, <em>Computer Science\nEducation</em>, 18(3): 153\u2013170.\ndoi:10.1080/08993400802332332</li>\n<li>Thagard, P., 1984, \u201cComputer programs as psychological\ntheories\u201d, <em>Mind, Language and Society</em>, Vienna:\nConceptus-Studien, pp. 77\u201384.</li>\n<li>Thomasson, Amie, 2007, \u201cArtifacts and Human Concepts\u201d,\nin Eric Margolis and Stephen Laurence (eds.), <em>Creations of the\nMind: Essays on Artifacts and Their Representations</em>, Oxford:\nOxford University Press, pp. 52\u201373.</li>\n<li>Thompson, Simon, 2011, <em>Haskell: The Craft of Functional\nProgramming</em>, third edition, Reading, MA: Addison-Wesley; first\nedition, 1996.</li>\n<li>Tichy, Walter F., 1998, \u201cShould Computer Scientists\nExperiment More?\u201d, <em>IEEE Computer</em>, 31(5): 32\u201340.\ndoi:10.1109/2.675631</li>\n<li>Turing, A.M., 1936, \u201cOn Computable Numbers, with an\nApplication to the Entscheidungsproblem\u201d, <em>Proceedings of the\nLondon Mathematical Society (Series 2)</em>, 42: 230\u201365.\ndoi:10.1112/plms/s2-42.1.230</li>\n<li>\u2013\u2013\u2013, 1950, \u201cComputing Machinery and\nIntelligence\u201d, <em>Mind</em>, 59(236): 433\u2013460.\ndoi:10.1093/mind/LIX.236.433</li>\n<li>Turner, Raymond, 2007, \u201cUnderstanding Programming\nLanguages\u201d, <em>Minds and Machines</em>, 17(2): 203\u2013216.\ndoi:10.1007/s11023-007-9062-6</li>\n<li>\u2013\u2013\u2013, 2009a, <em>Computable Models</em>, Berlin:\nSpringer. doi:10.1007/978-1-84882-052-4</li>\n<li>\u2013\u2013\u2013, 2009b, \u201cThe Meaning of Programming\nLanguages\u201d, <em>APA Newsletters</em>, 9(1): 2\u20137. (This APA\nNewsletter is available online; see the Other Internet\nResources.)</li>\n<li>\u2013\u2013\u2013, 2010, \u201cProgramming Languages as\nMathematical Theories\u201d, in J. Vallverd\u00fa (ed.),\n<em>Thinking Machines and the Philosophy of Computer Science: Concepts\nand Principles</em>, Hershey, PA: IGI Global, pp. 66\u201382.</li>\n<li>\u2013\u2013\u2013, 2011, \u201cSpecification\u201d,\n<em>Minds and Machines</em>, 21(2): 135\u2013152.\ndoi:10.1007/s11023-011-9239-x</li>\n<li>\u2013\u2013\u2013, 2012, \u201cMachines\u201d, in H. Zenil\n(ed.), <em>A Computable Universe: Understanding and Exploring Nature\nas Computation</em>, London: World Scientific Publishing\nCompany/Imperial College Press, pp. 63\u201376.</li>\n<li>\u2013\u2013\u2013, 2014, \u201cProgramming Languages as\nTechnical Artefacts\u201d, <em>Philosophy and Technology</em>, 27(3):\n377\u2013397; first published online 2013.\ndoi:10.1007/s13347\u2013012\u20130098-z</li>\n<li>\u2013\u2013\u2013, 2018, <em>Computational artifacts: Towards\na philosophy of computer science</em>, Berlin Heidelberg:\nSpringer.</li>\n<li>Tymoczko, Thomas, 1979, \u201cThe Four Color Problem and Its\nPhilosophical Significance\u201d, <em>The Journal of Philosophy</em>,\n76(2): 57\u201383. doi:10.2307/2025976</li>\n<li>\u2013\u2013\u2013, 1980, \u201cComputers, Proofs and\nMathematicians: A Philosophical Investigation of the Four-Color\nProof\u201d, <em>Mathematics Magazine</em>, 53(3):\n131\u2013138.</li>\n<li>Van Fraassen, Bas C., 1980, <em>The Scientific Image</em>, Oxford:\nOxford University Press. doi:10.1093/0198244274.001.0001</li>\n<li>\u2013\u2013\u2013, 1989, <em>Laws and Symmetry</em>, Oxford:\nOxford University Press. doi:10.1093/0198248601.001.0001</li>\n<li>Van Leeuwen, Jan (ed.), 1990, <em>Handbook of Theoretical Computer\nScience. Volume B: Formal Models and Semantics</em>, Amsterdam:\nElsevier and Cambridge, MA: MIT Press.</li>\n<li>Vardi, M., 2012, \u201cWhat is an algorithm?\u201d,\n<em>Communications of the ACM</em>, 55(3): 5.\ndoi:10.1145/2093548.2093549</li>\n<li>Vermaas, Pieter E. &amp; Wybo Houkes, 2003, \u201cAscribing\nFunctions to Technical Artifacts: A Challenge to Etiological Accounts\nof Function\u201d, <em>British Journal of the Philosophy of\nScience</em>, 54: 261\u2013289.\n [<a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.5.5058\" target=\"other\">Vermaas and Houkes 2003 available online</a>]</li>\n<li>Vliet, Hans van, 2008, <em>Software Engineering: Principles and\nPractice</em>, 3rd edition, Hoboken, NJ: Wiley. (First edition,\n1993)</li>\n<li>von Neumann, J. (1945). \u201cFirst draft report on the\nEDVAC\u201d, <em>IEEE Annals of the History of Computing</em>, 15(4):\n27\u201375.</li>\n<li>Wang, Hao, 1974, <em>From Mathematics to Philosophy</em>, London:\nRoutledge, Kegan &amp; Paul.</li>\n<li>Wegner, Peter, 1976, \u201cResearch Paradigms in Computer\nScience\u201d, in <em>Proceedings of the 2nd international Conference\non Software Engineering</em>, Los Alamitos, CA: IEEE Computer Society\nPress, pp. 322\u2013330.</li>\n<li>White, Graham, 2003, \u201cThe Philosophy of Computer\nLanguages\u201d, in Luciano Floridi (ed.), <em>The Blackwell Guide to\nthe Philosophy of Computing and Information</em>, Malden:\nWiley-Blackwell, pp. 318\u2013326.\ndoi:10.1111/b.9780631229193.2003.00020.x</li>\n<li>Wiener, Norbert, 1948, <em>Cybernetics: Control and Communication\nin the Animal and the Machine</em>, New York: Wiley &amp; Sons.</li>\n<li>\u2013\u2013\u2013, 1964, <em>God and Golem, Inc.: A Comment on\nCertain Points Where Cybernetics Impinges on Religion</em>, Cambridge,\nMA: MIT press.</li>\n<li>Wittgenstein, Ludwig, 1953 [2001], <em>Philosophical\nInvestigations</em>, translated by G.E.M. Anscombe, 3rd Edition,\nOxford: Blackwell Publishing.</li>\n<li>\u2013\u2013\u2013, 1956 [1978], <em>Remarks of the Foundations\nof Mathematics</em>, G.H. von Wright, R. Rhees, and G.E.M. Anscombe\n(eds.), translated by G.E.M. Anscombe, revised edition, Oxford: Basil\nBlackwell.</li>\n<li>\u2013\u2013\u2013, 1939 [1975], <em>Wittgenstein\u2019s\nLectures on the Foundations of Mathematics, Cambridge 1939</em>, C.\nDiamond (ed.), Cambridge: Cambridge University Press.</li>\n<li>Woodcock, Jim &amp; Jim Davies, 1996, <em>Using Z: Specification,\nRefinement, and Proof</em>, Englewood Cliffs, NJ: Prentice Hall.</li>\n<li>Wright, Crispin 1983, <em>Frege\u2019s Conception of Numbers as\nObjects</em>, Aberdeen: Aberdeen University Press.</li>\n</ul>\n</div>"}, "related_entries": {"entry_list": ["artificial intelligence: logic and", "Church-Turing Thesis", "computability and complexity", "computation: in physical systems", "computational complexity theory", "information", "information: semantic conceptions of", "intention", "mathematics, philosophy of", "recursive functions", "technology, philosophy of", "Turing machines"], "entry_link": [{"../logic-ai/": "artificial intelligence: logic and"}, {"../church-turing/": "Church-Turing Thesis"}, {"../computability/": "computability and complexity"}, {"../computation-physicalsystems/": "computation: in physical systems"}, {"../computational-complexity/": "computational complexity theory"}, {"../information/": "information"}, {"../information-semantic/": "information: semantic conceptions of"}, {"../intention/": "intention"}, {"../philosophy-mathematics/": "mathematics, philosophy of"}, {"../recursive-functions/": "recursive functions"}, {"../technology/": "technology, philosophy of"}, {"../turing-machine/": "Turing machines"}]}, "academic_tools": {"listed_text": ["<img alt=\"sep man icon\" src=\"../../symbols/sepman-icon.jpg\"/>", "<a href=\"https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=computer-science\" target=\"other\">How to cite this entry</a>.", "<img alt=\"sep man icon\" src=\"../../symbols/sepman-icon.jpg\"/>", "<a href=\"https://leibniz.stanford.edu/friends/preview/computer-science/\" target=\"other\">Preview the PDF version of this entry</a> at the\n <a href=\"https://leibniz.stanford.edu/friends/\" target=\"other\">Friends of the SEP Society</a>.", "<img alt=\"inpho icon\" src=\"../../symbols/inpho.png\"/>", "<a href=\"https://www.inphoproject.org/entity?sep=computer-science&amp;redirect=True\" target=\"other\">Look up topics and thinkers related to this entry</a>\n at the Internet Philosophy Ontology Project (InPhO).", "<img alt=\"phil papers icon\" src=\"../../symbols/pp.gif\"/>", "<a href=\"https://philpapers.org/sep/computer-science/\" target=\"other\">Enhanced bibliography for this entry</a>\nat <a href=\"https://philpapers.org/\" target=\"other\">PhilPapers</a>, with links to its database."], "listed_links": [{"https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=computer-science": "How to cite this entry"}, {"https://leibniz.stanford.edu/friends/preview/computer-science/": "Preview the PDF version of this entry"}, {"https://leibniz.stanford.edu/friends/": "Friends of the SEP Society"}, {"https://www.inphoproject.org/entity?sep=computer-science&redirect=True": "Look up topics and thinkers related to this entry"}, {"https://philpapers.org/sep/computer-science/": "Enhanced bibliography for this entry"}, {"https://philpapers.org/": "PhilPapers"}]}, "other_internet_resources": {"listed_text": ["ACM (ed.), 2013,\n <a href=\"http://amturing.acm.org/byyear.cfm\" target=\"other\">ACM Turing Award Lectures</a>.", "<a href=\"https://cdn.ymaws.com/www.apaonline.org/resource/collection/EADE8D52-8D02-4136-9A2A-729368501E43/v09n1Computers.pdf\">APA Newsletter on Philosophy and Computers</a>,\n 9(1): Fall 2009.", "Groklaw, 2012a,\n <a href=\"http://www.groklaw.net/article.php?story=20121013192858600\" target=\"other\">\u201cWhat Does \u2018Software is Mathematics\u2019 Mean?\u201d Part 1, by PoIR.</a>", "Groklaw, 2012b,\n <a href=\"http://www.groklaw.net/articlebasic.php?story=20121129053154687\" target=\"other\">\u201cWhat Does \u2018Software is Mathematics\u2019 Mean?\u201d Part 2, by PoIR.</a>", "Huss, Eric, 1997,\n <a href=\"http://www.fortran-2000.com/ArnaudRecipes/Cstd/\" target=\"other\">The C Library Reference Guide</a>,\n at Fortran 90+ (www.fortran-2000.com).", "Rapaport, William J., 2020, \u201cPhilosophy of Computer\nScience\u201d. DRAFT \u00a9 2004\u20132020\u00a0by William J.\nRapaport. Available at\n <a href=\"http://www.cse.buffalo.edu/~rapaport/Papers/phics.pdf\" target=\"other\">Philosophy of Computer Science</a>,\n manuscript.", "Smith, Barry, 2012,\n <a href=\"http://ontology.buffalo.edu/smith/articles/lfo.pdf\" target=\"other\">\u201cLogic and Formal Ontology\u201d</a>.\n A revised version of the paper which appeared in J. N. Mohanty and W.\nMcKenna (eds), 1989, <em>Husserl\u2019s Phenomenology: A\nTextbook</em>, Lanham: University Press of America.", "Turner, Ray and Amon Eden, 2011, \u201cThe Philosophy of Computer\nScience\u201d, <em>Stanford Encyclopedia of Philosophy</em> (Winter\n2011 Edition), Edward N. Zalta (ed.), URL =\n &lt;<a href=\"https://plato.stanford.edu/archives/win2011/entries/computer-science/\" target=\"other\">https://plato.stanford.edu/archives/win2011/entries/computer-science/</a>&gt;.\n [This was the previous entry on the philosophy of computer science in\nthe <em>Stanford Encyclopedia of Philosophy</em>\u2014see the\n <a href=\"https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=computer-science\" target=\"other\">version history</a>.]", "<a href=\"http://www.cs.uu.nl/groups/AD/index-phil.html\" target=\"other\">Center for Philosophy of Computer Science</a>"], "listed_links": [{"http://amturing.acm.org/byyear.cfm": "ACM Turing Award Lectures"}, {"https://cdn.ymaws.com/www.apaonline.org/resource/collection/EADE8D52-8D02-4136-9A2A-729368501E43/v09n1Computers.pdf": "APA Newsletter on Philosophy and Computers"}, {"http://www.groklaw.net/article.php?story=20121013192858600": "\u201cWhat Does \u2018Software is Mathematics\u2019 Mean?\u201d Part 1, by PoIR."}, {"http://www.groklaw.net/articlebasic.php?story=20121129053154687": "\u201cWhat Does \u2018Software is Mathematics\u2019 Mean?\u201d Part 2, by PoIR."}, {"http://www.fortran-2000.com/ArnaudRecipes/Cstd/": "The C Library Reference Guide"}, {"http://www.cse.buffalo.edu/~rapaport/Papers/phics.pdf": "Philosophy of Computer Science"}, {"http://ontology.buffalo.edu/smith/articles/lfo.pdf": "\u201cLogic and Formal Ontology\u201d"}, {"https://plato.stanford.edu/archives/win2011/entries/computer-science/": "https://plato.stanford.edu/archives/win2011/entries/computer-science/"}, {"https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=computer-science": "version history"}, {"http://www.cs.uu.nl/groups/AD/index-phil.html": "Center for Philosophy of Computer Science"}]}, "tokenized_text": ["1", "computational", "system", "computational", "system", "widespread", "everyday", "life", "design", "development", "analysis", "proper", "object", "study", "discipline", "computer", "science", "philosophy", "computer", "science", "treat", "instead", "object", "theoretical", "analysis", "first", "aim", "define", "system", "ie", "develop", "ontology", "computational", "system", "literature", "offer", "two", "main", "approach", "topic", "first", "one", "understands", "computational", "system", "defined", "distinct", "ontology", "software", "hardware", "usually", "taken", "elementary", "component", "different", "approach", "see", "computational", "system", "comprising", "several", "element", "around", "softwarehardware", "dichotomy", "second", "view", "computational", "system", "defined", "basis", "hierarchy", "level", "abstraction", "arranging", "hardware", "level", "bottom", "hierarchy", "extending", "upwards", "element", "design", "downwards", "include", "user", "following", "present", "two", "approach", "11", "software", "hardware", "usually", "computational", "system", "seen", "composed", "two", "ontologically", "distinct", "entity", "software", "hardware", "algorithm", "source", "code", "program", "fall", "first", "category", "abstract", "entity", "microprocessor", "hard", "drive", "computing", "machine", "concrete", "physical", "entity", "moore", "1978", "argues", "duality", "one", "three", "myth", "computer", "science", "dichotomy", "softwarehardware", "pragmatic", "ontological", "significance", "computer", "program", "set", "instruction", "computer", "may", "execute", "examined", "symbolic", "level", "encoded", "instruction", "physical", "level", "set", "instruction", "stored", "physical", "medium", "moore", "stress", "program", "exists", "pure", "abstract", "entity", "without", "physical", "realization", "flash", "drive", "hard", "disk", "server", "even", "piece", "paper", "early", "program", "even", "hardwired", "directly", "beginning", "computer", "era", "program", "consisted", "pattern", "physical", "lever", "softwarehardware", "opposition", "one", "usually", "identifies", "software", "symbolic", "level", "program", "hardware", "corresponding", "physical", "level", "distinction", "however", "pragmatically", "justified", "delimits", "different", "task", "developer", "software", "may", "given", "algorithm", "source", "code", "implementing", "hardware", "given", "machine", "code", "microprocessor", "able", "execute", "contrast", "engineer", "realizing", "circuit", "implementing", "hardwired", "program", "may", "inclined", "call", "software", "many", "physical", "part", "computing", "machine", "word", "count", "software", "one", "professional", "may", "count", "hardware", "another", "one", "suber", "1988", "go", "even", "maintaining", "hardware", "kind", "software", "software", "defined", "pattern", "amenable", "read", "executed", "one", "realizes", "physical", "object", "display", "pattern", "one", "forced", "accept", "conclusion", "hardware", "physical", "object", "also", "software", "suber", "defines", "pattern", "definite", "structure", "narrow", "sense", "requires", "recurrence", "regularity", "symmetry", "1988", "90", "argues", "structure", "indeed", "read", "executed", "definite", "pattern", "meaning", "associated", "always", "possible", "conceive", "syntax", "semantics", "giving", "meaning", "thereby", "making", "pattern", "executable", "program", "colburn", "1999", "2000", "keeping", "software", "hardware", "apart", "stress", "former", "dual", "nature", "concrete", "abstraction", "abstract", "concrete", "define", "software", "one", "need", "make", "reference", "medium", "description", "ie", "language", "used", "express", "algorithm", "medium", "execution", "namely", "circuit", "composing", "hardware", "software", "always", "concrete", "software", "without", "concretization", "physical", "medium", "nonetheless", "abstract", "programmer", "consider", "implementing", "machine", "activity", "would", "rather", "develop", "program", "executable", "machine", "aspect", "called", "colburn", "1999", "enlargement", "content", "defines", "abstraction", "computer", "science", "abstraction", "content", "content", "enlarged", "rather", "deleted", "happens", "mathematical", "abstraction", "irmak", "2012", "criticizes", "dual", "nature", "software", "proposed", "colburn", "1999", "2000", "understands", "abstract", "entity", "one", "lacking", "spatiotemporal", "property", "concrete", "mean", "property", "defining", "software", "concrete", "abstraction", "would", "therefore", "imply", "software", "contradictory", "property", "software", "temporal", "property", "object", "human", "creation", "start", "exist", "time", "conceived", "implemented", "cease", "exist", "certain", "subsequent", "time", "software", "cease", "exist", "copy", "destroyed", "author", "die", "nobody", "else", "remembers", "respective", "algorithm", "object", "human", "creation", "software", "artifact", "however", "software", "lack", "spatial", "property", "identified", "concrete", "realization", "destroying", "physical", "copy", "given", "software", "would", "imply", "particular", "software", "cease", "exist", "stated", "reason", "would", "deleting", "text", "implementing", "software", "algorithm", "highlevel", "language", "software", "thus", "abstract", "entity", "endowed", "temporal", "property", "reason", "irmak", "2010", "definies", "software", "abstract", "artifact", "duncan", "2011", "point", "distinguishing", "software", "hardware", "requires", "finer", "ontology", "one", "involving", "simple", "abstractconcrete", "dichotomy", "duncan", "2017", "aim", "providing", "ontology", "focusing", "turner", "2011", "notion", "specification", "expression", "give", "correctness", "condition", "program", "see", "2", "duncan", "2017", "stress", "program", "act", "also", "specification", "implementing", "machine", "meaning", "program", "specifies", "correct", "behavior", "machine", "required", "perform", "machine", "act", "consistently", "program", "machine", "said", "malfunction", "way", "program", "correct", "respect", "specification", "said", "flawed", "containing", "bug", "another", "ontological", "category", "necessary", "define", "distinction", "softwarehardware", "artifact", "duncan", "2017", "defines", "physical", "spatiotemporal", "entity", "constructed", "fulfill", "function", "community", "recognizing", "artifact", "serving", "purpose", "said", "software", "defined", "set", "instruction", "encoded", "programming", "language", "act", "specification", "artifact", "able", "read", "instruction", "hardware", "defined", "artifact", "whose", "function", "carry", "specified", "computation", "12", "method", "level", "abstraction", "shown", "distinction", "software", "hardware", "sharp", "one", "different", "ontological", "approach", "computational", "system", "relies", "role", "abstraction", "abstraction", "crucial", "element", "computer", "science", "take", "many", "different", "form", "goguen", "burstall", "1985", "describe", "variety", "following", "example", "instance", "code", "repeated", "programming", "naming", "text", "parameter", "practice", "known", "procedural", "abstraction", "operation", "formal", "basis", "abstraction", "operation", "lambda", "calculus", "see", "entry", "lambda", "calculus", "allows", "formal", "mechanism", "known", "polymorphism", "hankin", "2004", "another", "example", "typing", "typical", "functional", "programming", "provides", "expressive", "system", "representation", "syntactic", "constructor", "language", "else", "objectoriented", "design", "pattern", "gamma", "et", "al", "1994", "abstracted", "common", "structure", "found", "software", "system", "used", "interface", "implementation", "object", "specification", "example", "share", "underlying", "methodology", "level", "abstraction", "henceforth", "loa", "used", "also", "mathematics", "mitchelmore", "white", "2004", "philosophy", "floridi", "2008", "abstraction", "mathematics", "piled", "upon", "neverending", "search", "abstract", "concept", "account", "abstraction", "selfcontained", "abstract", "mathematical", "object", "take", "meaning", "system", "within", "defined", "constraint", "new", "object", "related", "consistent", "system", "operated", "without", "reference", "previous", "external", "meaning", "argue", "respect", "least", "abstraction", "computer", "science", "fundamentally", "different", "abstraction", "mathematics", "computational", "abstraction", "must", "leave", "behind", "implementation", "trace", "mean", "information", "hidden", "destroyed", "colburn", "shute", "2007", "detail", "ignored", "one", "loa", "must", "ignored", "one", "lower", "loas", "example", "programmer", "need", "worry", "precise", "location", "memory", "associated", "particular", "variable", "virtual", "machine", "required", "handle", "memory", "allocation", "reliance", "abstraction", "different", "level", "reflected", "property", "computational", "system", "depend", "upon", "existence", "implementation", "example", "even", "though", "class", "hide", "detail", "method", "must", "implementation", "hence", "computational", "abstraction", "preserve", "abstract", "guise", "implementation", "full", "formulation", "loas", "ontology", "digital", "computational", "system", "devised", "primiero", "2016", "including", "intention", "specification", "algorithm", "highlevel", "programming", "language", "instruction", "assemblymachine", "code", "operation", "execution", "intention", "cognitive", "act", "defines", "computational", "problem", "solved", "formulates", "request", "create", "computational", "process", "perform", "certain", "task", "request", "sort", "usually", "provided", "customer", "user", "stakeholder", "involved", "given", "software", "development", "project", "specification", "formulation", "set", "requirement", "necessary", "solving", "computational", "problem", "hand", "concern", "possibly", "formal", "determination", "operation", "software", "must", "perform", "process", "known", "requirement", "elicitation", "algorithm", "express", "procedure", "providing", "solution", "proposed", "computational", "problem", "one", "must", "meet", "requirement", "specification", "highlevel", "programming", "language", "c", "java", "python", "instruction", "constitute", "linguistic", "implementation", "proposed", "algorithm", "often", "called", "source", "code", "understood", "trained", "programmer", "directly", "executed", "machine", "instruction", "coded", "highlevel", "language", "compiled", "ie", "translated", "compiler", "assembly", "code", "assembled", "machine", "code", "operation", "executable", "processor", "finally", "execution", "loa", "physical", "level", "running", "software", "ie", "computer", "architecture", "executing", "instruction", "according", "view", "loa", "taken", "isolation", "able", "define", "computational", "system", "determine", "distinguish", "software", "hardware", "computational", "system", "rather", "defined", "whole", "abstraction", "hierarchy", "loa", "express", "semantic", "level", "associated", "realization", "either", "linguistic", "physical", "2", "intention", "specification", "intention", "refers", "cognitive", "state", "outside", "computational", "system", "express", "formulation", "computational", "problem", "solved", "specification", "describe", "function", "computational", "system", "developed", "must", "fulfil", "whereas", "intention", "per", "se", "pose", "specific", "philosophical", "controversy", "inside", "philosophy", "computer", "science", "issue", "arise", "connection", "definition", "specification", "relation", "intention", "21", "intention", "intention", "articulate", "criterion", "determine", "whether", "computational", "system", "appropriate", "ie", "correct", "see", "7", "therefore", "considered", "first", "loa", "computational", "system", "appropriate", "problem", "instance", "customer", "user", "may", "require", "smartphone", "app", "able", "filter", "annoying", "call", "call", "center", "request", "constitutes", "intention", "loa", "development", "computational", "system", "able", "perform", "task", "software", "development", "process", "nonnaive", "system", "intention", "usually", "gathered", "technique", "brainstorming", "survey", "prototyping", "even", "focus", "group", "clarke", "moreira", "1999", "aimed", "defining", "structured", "set", "various", "stakeholder", "intention", "loa", "reference", "made", "solve", "computational", "problem", "description", "problem", "must", "solved", "provided", "contemporary", "literature", "intention", "object", "philosophical", "inquiry", "least", "since", "anscombe", "1963", "philosopher", "investigated", "intention", "action", "performed", "davidson", "1963", "intention", "something", "future", "davidson", "1978", "intentional", "action", "anscombe", "1963", "baier", "1970", "ferrero", "2017", "issue", "arise", "concerning", "three", "kind", "intention", "primary", "connected", "relation", "intention", "belief", "whether", "intention", "presuppose", "specific", "mental", "state", "whether", "intention", "act", "cause", "action", "see", "entry", "intention", "formal", "problem", "concern", "opportunity", "agent", "inconsistent", "intention", "yet", "considered", "rational", "bratman", "1987", "duijf", "et", "al", "2019", "role", "first", "loa", "ontology", "computational", "system", "intention", "certainly", "acknowledged", "intention", "future", "express", "objective", "constructing", "system", "able", "perform", "desired", "computational", "task", "since", "intention", "stated", "confine", "definition", "computational", "problem", "solved", "without", "specifying", "computational", "solution", "ontological", "epistemological", "analysis", "differ", "referred", "philosophical", "literature", "word", "nothing", "specifically", "computational", "intention", "defining", "computational", "system", "deserves", "separate", "treatment", "philosophy", "computer", "science", "matter", "relation", "intention", "specification", "intention", "provide", "correctness", "criterion", "specification", "specification", "asked", "express", "computational", "problem", "put", "forward", "intention", "solved", "22", "definition", "specification", "consider", "example", "call", "filtering", "app", "specification", "may", "require", "create", "blacklist", "phone", "number", "associated", "call", "center", "update", "list", "every", "n", "day", "check", "upon", "incoming", "call", "whether", "number", "blacklist", "communicate", "call", "management", "system", "allow", "incoming", "call", "case", "affirmative", "answer", "allow", "call", "case", "negative", "answer", "latter", "fullfledged", "specification", "though", "expressed", "natural", "language", "specification", "often", "advanced", "natural", "language", "closer", "stakeaholder", "intention", "subsequently", "formalized", "proper", "formal", "language", "specification", "may", "expressed", "mean", "graphical", "language", "uml", "fowler", "2003", "formal", "language", "tpl", "turner", "2009a", "vdm", "jones", "1990", "using", "predicate", "logic", "z", "woodcock", "davy", "1996", "focusing", "set", "theory", "instance", "type", "predicate", "logic", "tpl", "express", "requirement", "computational", "system", "using", "predicate", "logic", "formula", "wherein", "type", "quantified", "variable", "specified", "choice", "variable", "type", "allows", "one", "define", "specification", "appropriate", "abstraction", "level", "whether", "specification", "expressed", "informal", "formal", "guise", "often", "depends", "development", "method", "followed", "formal", "specification", "usually", "preferred", "context", "formal", "development", "method", "moreover", "formal", "specification", "facilitate", "verification", "correctness", "computational", "system", "see", "6", "turner", "2018", "asks", "difference", "model", "specification", "extensively", "used", "computer", "science", "difference", "located", "turner", "2011", "call", "intentional", "stance", "model", "describe", "intended", "system", "developed", "case", "mismatch", "two", "model", "refined", "specification", "prescribe", "system", "built", "comply", "intended", "function", "case", "mismatch", "system", "need", "refined", "matching", "model", "system", "reflects", "correspondence", "intention", "describing", "system", "constructed", "term", "computational", "problem", "system", "must", "able", "solve", "specification", "determining", "system", "constructed", "term", "set", "requirement", "necessary", "solving", "computational", "problem", "exemplified", "call", "filtering", "app", "turner", "2011", "word", "something", "specification", "given", "correctness", "jurisdiction", "artefact", "specification", "provide", "correctness", "criterion", "computational", "system", "computational", "system", "thus", "correct", "comply", "specification", "behave", "according", "conversely", "provide", "criterion", "malfunctioning", "73", "computational", "system", "malfunction", "behave", "consistently", "specification", "turner", "2011", "careful", "notice", "definition", "specification", "idealization", "specification", "revised", "case", "specified", "computational", "system", "realized", "physical", "law", "constraint", "cost", "limitation", "turn", "advanced", "specification", "correct", "formalization", "intention", "client", "user", "generally", "correctness", "problem", "deal", "specification", "two", "loas", "defining", "computational", "system", "next", "subsection", "examine", "23", "specification", "function", "fully", "implemented", "constructed", "computational", "system", "technical", "artifact", "ie", "humanmade", "system", "designed", "implemented", "explicit", "aim", "fulfilling", "specific", "function", "kroes", "2012", "technical", "artifact", "defined", "include", "table", "screwdriver", "car", "bridge", "television", "distinct", "natural", "object", "eg", "rock", "cat", "dihydrogen", "monoxide", "molecule", "humanmade", "artwork", "fulfill", "function", "ontology", "computational", "system", "fall", "technical", "artifact", "meijers", "2000", "characterized", "duality", "defined", "functional", "structural", "property", "kroes", "2009", "see", "also", "entry", "philosophy", "technology", "functional", "property", "specify", "function", "artifact", "required", "perform", "structural", "property", "express", "physical", "property", "artifact", "perform", "consider", "screwdriver", "functional", "property", "may", "include", "function", "screwing", "unscrewing", "structural", "property", "refer", "piece", "metal", "capable", "inserted", "head", "screw", "plastic", "handle", "allows", "clockwise", "anticlockwise", "motion", "function", "realized", "multiple", "way", "structural", "counterpart", "instance", "function", "screwdriver", "could", "well", "realized", "full", "metal", "screwdriver", "electric", "screwdriver", "defined", "different", "structural", "property", "layered", "ontology", "computational", "system", "characterized", "many", "different", "loas", "seems", "extend", "dual", "ontology", "defining", "technical", "artifact", "floridi", "et", "al", "2015", "turner", "2018", "argues", "computational", "system", "still", "artifact", "sense", "kroes", "2009", "2012", "loa", "functional", "level", "lower", "loas", "structural", "level", "upper", "loas", "intention", "express", "function", "system", "must", "achieve", "implemented", "specification", "specification", "play", "functional", "role", "explaining", "detail", "concrete", "function", "software", "must", "implement", "realized", "algorithm", "structural", "level", "algorithm", "express", "procedure", "highlevel", "language", "program", "structural", "level", "must", "implement", "instruction", "high", "level", "language", "define", "functional", "property", "machine", "language", "code", "realizes", "machine", "code", "finally", "express", "functional", "property", "implemented", "execution", "level", "express", "physical", "structural", "property", "follows", "according", "turner", "2018", "structural", "level", "need", "necessarily", "physical", "level", "notion", "abstract", "artifact", "hold", "computer", "science", "reason", "turner", "2011", "come", "define", "highlevel", "language", "program", "technical", "artifact", "constitute", "structural", "level", "implementing", "specification", "functional", "level", "see", "42", "first", "consequence", "loa", "expressing", "function", "accomplish", "realized", "multiplicity", "potential", "structural", "level", "expressing", "function", "accomplished", "intended", "functionality", "realized", "specification", "multiple", "way", "computational", "problem", "expressed", "specification", "solution", "multiplicity", "different", "algorithm", "differ", "important", "property", "equally", "valid", "see", "3", "algorithm", "may", "implemented", "different", "program", "written", "different", "highlevel", "programming", "language", "expressing", "program", "implement", "algorithm", "angius", "primiero", "2019", "source", "code", "compiled", "multiplicity", "machine", "language", "adopting", "different", "isas", "instruction", "set", "architecture", "executable", "code", "installed", "run", "multiplicity", "machine", "provided", "share", "isa", "second", "consequence", "loa", "functional", "level", "provides", "correctness", "criterion", "lower", "level", "primiero", "2020", "implementation", "level", "correctness", "required", "loa", "specification", "execution", "cause", "malfunction", "may", "located", "loa", "correctly", "implementing", "proper", "functional", "level", "see", "73", "fresco", "primiero", "2013", "according", "turner", "2018", "specification", "level", "said", "correct", "incorrect", "respect", "intention", "despite", "difficulty", "verifying", "correctness", "correctness", "nonphysical", "layer", "verified", "mathematically", "formal", "verification", "execution", "physical", "level", "verified", "empirically", "testing", "6", "verifying", "correctness", "specification", "respect", "client", "intention", "would", "require", "instead", "access", "mental", "state", "involved", "agent", "latter", "problem", "relates", "general", "one", "establishing", "artifact", "posse", "function", "mean", "structural", "property", "related", "intention", "agent", "problem", "wellknown", "also", "philosophy", "biology", "cognitive", "science", "two", "main", "theory", "put", "forward", "solution", "according", "causal", "theory", "function", "cummins", "1975", "function", "determined", "physical", "capacity", "artifact", "example", "physical", "ability", "heart", "contracting", "expanding", "determines", "function", "pumping", "blood", "circulatory", "system", "however", "theory", "face", "serious", "problem", "applied", "technical", "artifact", "first", "prevents", "defining", "correctness", "malfunctioning", "kroes", "2010", "suppose", "call", "filtering", "app", "installed", "smartphone", "start", "banning", "call", "contact", "mobile", "phonebook", "according", "causal", "theory", "function", "would", "new", "function", "app", "second", "theory", "distinguish", "intended", "function", "side", "effect", "turner", "2011", "case", "longlasting", "call", "smartphone", "would", "certainly", "start", "heating", "however", "function", "intended", "client", "developer", "according", "intentional", "theory", "function", "mclaughlin", "2001", "searle", "1995", "function", "fixed", "designer", "user", "intended", "one", "artifact", "structural", "property", "artifact", "selected", "able", "fulfill", "theory", "able", "explain", "correctness", "malfunction", "well", "distinguish", "side", "effect", "intended", "function", "however", "say", "function", "actually", "resides", "whether", "artifact", "mind", "agent", "former", "case", "one", "back", "question", "artifact", "posse", "function", "latter", "case", "explanation", "needed", "mental", "state", "related", "physical", "property", "artifact", "kroes", "2010", "turner", "2018", "hold", "intuition", "behind", "causal", "intentional", "theory", "function", "useful", "understand", "relation", "function", "structure", "computational", "system", "suggests", "two", "theory", "combined", "single", "one", "one", "hand", "function", "without", "implementation", "hand", "intention", "without", "client", "developer", "user", "3", "algorithm", "even", "though", "known", "widely", "used", "since", "antiquity", "problem", "defining", "algorithm", "still", "open", "vardi", "2012", "word", "algorithm", "originates", "name", "ninthcentury", "persian", "mathematician", "ab\u016b", "ja\u02bffar", "mu\u1e25ammad", "ibn", "m\u016bs\u0101", "alkhw\u0101rizm\u012b", "provided", "rule", "arithmetic", "operation", "using", "arabic", "numeral", "indeed", "rule", "one", "follows", "compute", "basic", "arithmetic", "operation", "multiplication", "division", "everyday", "example", "algorithm", "wellknown", "example", "include", "rule", "bisect", "angle", "using", "compass", "straightedge", "euclid", "algorithm", "calculating", "greatest", "common", "divisor", "intuitively", "algorithm", "set", "instruction", "allowing", "fulfillment", "given", "task", "despite", "ancient", "tradition", "mathematics", "modern", "logical", "philosophical", "reflection", "put", "forward", "task", "providing", "definition", "algorithm", "connection", "foundational", "crisis", "mathematics", "early", "twentieth", "century", "see", "entry", "philosophy", "mathematics", "notion", "effective", "calculability", "arose", "logical", "research", "providing", "formal", "counterpart", "intuitive", "notion", "algorithm", "giving", "birth", "theory", "computation", "since", "different", "definition", "algorithm", "proposed", "ranging", "formal", "nonformal", "approach", "sketched", "next", "section", "31", "classical", "approach", "markov", "1954", "provides", "first", "precise", "definition", "algorithm", "computational", "process", "determined", "applicable", "effective", "computational", "process", "determined", "instruction", "involved", "precise", "enough", "allow", "arbitrary", "choice", "execution", "human", "artificial", "computer", "must", "never", "unsure", "step", "carry", "next", "algorithm", "applicable", "markov", "hold", "class", "input", "natural", "number", "basic", "arithmetic", "operation", "rather", "single", "input", "specific", "natural", "number", "markov", "19541", "defines", "effectiveness", "tendency", "algorithm", "obtain", "certain", "result", "word", "algorithm", "effective", "eventually", "produce", "answer", "computational", "problem", "kleene", "1967", "specifies", "finiteness", "important", "property", "algorithm", "procedure", "described", "mean", "finite", "set", "instruction", "need", "finite", "number", "step", "provide", "answer", "computational", "problem", "counterexample", "consider", "loop", "defined", "finite", "number", "step", "run", "forever", "since", "condition", "loop", "always", "satisfied", "instruction", "also", "amenable", "mechanical", "execution", "insight", "required", "machine", "follow", "following", "markov", "determinability", "strengthening", "effectiveness", "kleene", "1967", "additionally", "specifies", "instruction", "able", "recognize", "solution", "computational", "problem", "achieved", "halt", "computation", "knuth", "1973", "recall", "deepens", "analysis", "markov", "1954", "kleene", "1967", "stating", "besides", "merely", "finite", "set", "rule", "give", "sequence", "operation", "solving", "specific", "type", "problem", "algorithm", "five", "important", "feature", "finiteness", "algorithm", "must", "always", "terminate", "finite", "number", "step", "definiteness", "step", "algorithm", "must", "precisely", "defined", "action", "carried", "must", "rigorously", "unambiguously", "specified", "case", "input", "algorithm", "zero", "input", "output", "algorithm", "zero", "output", "effectiveness", "algorithm", "also", "generally", "expected", "effective", "sense", "operation", "must", "sufficiently", "basic", "principle", "done", "exactly", "finite", "length", "time", "someone", "using", "pencil", "paper", "knuth", "1973", "46", "kleene", "1967", "finiteness", "affect", "number", "instruction", "number", "implemented", "computational", "step", "markov", "determinacy", "knuth", "definiteness", "principle", "requires", "successive", "computational", "step", "unambiguously", "specified", "furthermore", "knuth", "1973", "explicitly", "requires", "algorithm", "potentially", "empty", "set", "input", "output", "algorithm", "input", "output", "knuth", "probably", "refers", "algorithm", "using", "internally", "stored", "data", "input", "algorithm", "returning", "data", "external", "user", "rapaport", "2019", "ch", "7", "internet", "resource", "effectiveness", "besides", "markov", "tendency", "obtain", "certain", "result", "knuth", "requires", "result", "obtained", "finite", "amount", "time", "instruction", "atomic", "simple", "enough", "understandable", "executable", "human", "artificial", "computer", "32", "formal", "approach", "gurevich", "2011", "maintains", "one", "hand", "possible", "provide", "formal", "definition", "algorithm", "notion", "continues", "evolve", "time", "consider", "sequential", "algorithm", "used", "ancient", "mathematics", "flanked", "parallel", "analog", "quantum", "algorithm", "current", "computer", "science", "practice", "new", "kind", "algorithm", "likely", "envisioned", "near", "future", "hand", "formal", "analysis", "advanced", "concerned", "classical", "sequential", "algorithm", "particular", "gurevich", "2000", "provides", "axiomatic", "definition", "class", "algorithm", "sequential", "algorithm", "simulated", "sequential", "abstract", "state", "machine", "satisfying", "three", "axiom", "sequentialtime", "postulate", "associate", "algorithm", "set", "state", "set", "initial", "state", "subset", "map", "onestep", "transformation", "a", "state", "snapshot", "description", "running", "algorithm", "run", "potentially", "infinite", "sequence", "state", "starting", "initial", "state", "onestep", "transformation", "one", "state", "successor", "sequence", "termination", "presupposed", "gurevich", "definition", "onestep", "transformation", "need", "atomic", "may", "composed", "bounded", "set", "atomic", "operation", "according", "abstractstate", "postulate", "state", "firstorder", "structure", "commonly", "defined", "mathematical", "logic", "word", "state", "provide", "semantics", "firstorder", "statement", "finally", "boundedexploration", "postulate", "state", "given", "two", "state", "x", "always", "set", "term", "x", "coincide", "set", "update", "x", "corresponds", "set", "update", "y", "x", "coincide", "every", "term", "evaluation", "x", "evaluation", "y", "allows", "algorithm", "explore", "part", "state", "relative", "term", "t", "moschovakis", "2001", "object", "intuitive", "notion", "algorithm", "captured", "full", "abstract", "machine", "given", "general", "recursive", "function", "f", "\u2115", "\u2115", "defined", "natural", "number", "usually", "many", "different", "algorithm", "computing", "essential", "implementationindependent", "property", "captured", "abstract", "machine", "rather", "system", "recursive", "equation", "consider", "algorithm", "mergesort", "sorting", "list", "many", "different", "abstract", "machine", "mergesort", "question", "arises", "one", "chosen", "mergesort", "algorithm", "mergesort", "algorithm", "instead", "system", "recursive", "equation", "specifying", "involved", "function", "whereas", "abstract", "machine", "mergesort", "procedure", "different", "implementation", "algorithm", "two", "question", "put", "forward", "moschovakis", "formal", "analysis", "different", "implementation", "algorithm", "equivalent", "implementation", "yet", "equivalence", "relation", "among", "algorithm", "implementation", "formally", "defined", "furthermore", "remains", "clarified", "intuitive", "notion", "algorithm", "formalized", "system", "recursive", "equation", "amount", "primiero", "2020", "proposes", "reading", "nature", "algorithm", "three", "different", "level", "abstraction", "high", "loa", "algorithm", "defined", "abstracting", "procedure", "describe", "allowing", "many", "different", "set", "state", "transition", "loa", "algorithm", "understood", "informal", "specification", "informal", "description", "procedure", "p", "lower", "loa", "algorithm", "specify", "instruction", "needed", "solve", "given", "computational", "problem", "word", "specify", "procedure", "algorithm", "thus", "defined", "procedure", "description", "given", "formal", "language", "l", "execute", "procedure", "p", "many", "important", "property", "algorithm", "including", "related", "complexity", "class", "data", "structure", "determined", "procedural", "loa", "instead", "make", "reference", "abstract", "machine", "implementing", "procedure", "needed", "bottom", "loa", "algorithm", "defined", "implementable", "abstract", "machine", "viz", "specification", "formal", "language", "l", "execution", "program", "p", "given", "abstract", "machine", "m", "threefold", "definition", "algorithm", "allows", "primiero", "2020", "supply", "formal", "definition", "equivalence", "relation", "algorithm", "term", "algebraic", "notion", "simulation", "bisimulation", "milner", "1973", "see", "also", "angius", "primero", "2018", "machine", "mi", "executing", "program", "pi", "implement", "algorithm", "machine", "mj", "executing", "program", "pj", "abstract", "machine", "interpreting", "mi", "mj", "bisimulation", "relation", "33", "informal", "approach", "vardi", "2012", "underline", "despite", "many", "formal", "informal", "definition", "available", "general", "consensus", "algorithm", "approach", "gurevich", "2000", "moschovakis", "2001", "even", "proved", "logically", "equivalent", "provide", "logical", "construct", "algorithm", "leaving", "unanswered", "main", "question", "hill", "2013", "suggests", "informal", "definition", "algorithm", "taking", "account", "intuitive", "understanding", "one", "algorithm", "may", "useful", "especially", "public", "discourse", "communication", "practitioner", "user", "rapaport", "2012", "appendix", "provides", "attempt", "summarize", "three", "classical", "definition", "algorithm", "sketched", "stating", "algorithm", "executor", "e", "accomplish", "goal", "g", "procedure", "finite", "set", "sequence", "statement", "rule", "instruction", "statement", "composed", "finite", "number", "symbol", "mark", "finite", "alphabet", "unambiguous", "ethat", "e", "know", "e", "done", "finite", "amount", "time", "e", "know", "next", "procedure", "take", "finite", "amount", "time", "halt", "end", "g", "accomplished", "rapaport", "stress", "algorithm", "procedure", "ie", "finite", "sequence", "statement", "taking", "form", "rule", "instruction", "finiteness", "expressed", "requiring", "instruction", "contain", "finite", "number", "symbol", "finite", "alphabet", "hill", "2016", "aim", "providing", "informal", "definition", "algorithm", "starting", "rapaport", "2012", "algorithm", "finite", "abstract", "effective", "compound", "control", "structure", "imperatively", "given", "accomplishing", "given", "purpose", "given", "provision", "hill", "2016", "48", "first", "algorithm", "compound", "structure", "rather", "atomic", "object", "ie", "composed", "smaller", "unit", "namely", "computational", "step", "structure", "finite", "effective", "explicitly", "mentioned", "markov", "kleene", "knuth", "author", "explicitly", "mention", "abstractness", "hill", "2016", "maintains", "implicit", "analysis", "algorithm", "abstract", "simply", "lack", "spatiotemporal", "property", "independent", "instance", "provide", "control", "content", "brings", "kind", "change", "one", "state", "another", "expressed", "value", "variable", "consequent", "action", "p", "45", "algorithm", "imperatively", "given", "command", "state", "transition", "carry", "specified", "operation", "finally", "algorithm", "operate", "achieve", "certain", "purpose", "usually", "wellspecified", "provision", "precondition", "viewpoint", "author", "argues", "algorithm", "par", "specification", "specifying", "goal", "certain", "resource", "definition", "allows", "distinguish", "algorithm", "compound", "control", "structure", "instance", "recipe", "algorithm", "effective", "game", "imperatively", "given", "4", "program", "ontology", "computer", "program", "strictly", "related", "subsumed", "nature", "computational", "system", "see", "1", "computational", "system", "defined", "basis", "softwarehardware", "dichotomy", "program", "abstract", "entity", "interpreting", "former", "opposed", "concrete", "nature", "hardware", "example", "interpretation", "provided", "11", "include", "concrete", "abstraction", "definition", "colburn", "2000", "abstract", "artifact", "characterization", "irmak", "2012", "program", "specification", "machine", "proposed", "duncan", "2011", "contrast", "interpretation", "computational", "system", "hierarchy", "loas", "program", "implementation", "algorithm", "refer", "5", "implementation", "analysis", "ontology", "program", "sense", "section", "focus", "definition", "program", "significant", "relevance", "literature", "namely", "view", "consider", "program", "theory", "artifact", "focus", "problem", "relation", "program", "world", "41", "program", "theory", "view", "program", "theory", "go", "back", "approach", "cognitive", "science", "context", "socalled", "information", "processing", "psychology", "ipp", "simulative", "investigation", "human", "cognitive", "process", "newell", "simon", "1972", "advanced", "thesis", "simulative", "program", "empirical", "theory", "simulated", "system", "newell", "simon", "assigned", "computer", "program", "role", "theory", "simulated", "system", "well", "simulative", "system", "namely", "machine", "running", "program", "formulate", "prediction", "simulated", "system", "particular", "execution", "trace", "simulative", "program", "given", "specific", "problem", "solve", "used", "predict", "mental", "operation", "strategy", "performed", "human", "subject", "asked", "accomplish", "task", "case", "mismatch", "execution", "trace", "verbal", "report", "operation", "strategy", "human", "subject", "empirical", "theory", "provided", "simulative", "program", "revised", "predictive", "use", "computer", "program", "comparable", "according", "newell", "simon", "predictive", "use", "evolution", "law", "system", "expressed", "differential", "difference", "equation", "newell", "simon", "idea", "program", "theory", "shared", "cognitive", "scientist", "pylyshyn", "1984", "johnsonlaird", "1988", "agree", "program", "contrast", "typical", "theory", "better", "facing", "complexity", "simulative", "process", "modelled", "forcing", "one", "fillin", "detail", "necessary", "program", "executed", "whereas", "incomplete", "incoherent", "theory", "may", "advanced", "stage", "scientific", "inquiry", "case", "program", "hand", "moore", "1978", "considers", "programsastheories", "thesis", "another", "myth", "computer", "science", "program", "simulate", "set", "empirical", "phenomenon", "play", "role", "computational", "model", "phenomenon", "moore", "notice", "program", "acknowledged", "model", "semantic", "function", "nevertheless", "needed", "interpret", "empirical", "system", "simulated", "however", "view", "program", "model", "mistaken", "definition", "program", "theory", "theory", "explain", "predict", "empirical", "phenomenon", "simulated", "model", "simulation", "program", "offer", "according", "computer", "scientist", "paul", "thagard", "1984", "understanding", "program", "theory", "would", "require", "syntactic", "semantic", "view", "theory", "see", "entry", "structure", "scientific", "theory", "program", "comply", "either", "two", "view", "according", "syntactic", "view", "carnap", "1966", "hempel", "1970", "theory", "set", "sentence", "expressed", "defined", "language", "able", "describe", "target", "empirical", "system", "sentence", "define", "axiom", "theory", "lawlike", "statement", "expressing", "regularity", "system", "program", "set", "instruction", "written", "defined", "programming", "language", "however", "describe", "system", "insofar", "procedural", "linguistic", "entity", "declarative", "one", "rapaport", "2020", "see", "internet", "resource", "object", "procedural", "programming", "language", "often", "translated", "declarative", "language", "language", "prolog", "interpreted", "procedurally", "declaratively", "according", "semantic", "view", "suppe", "1989", "van", "fraassen", "1980", "theory", "introduced", "collection", "model", "defined", "settheoretic", "structure", "satisfying", "theory", "sentence", "however", "contrast", "moore", "1978", "thagard", "1984", "denies", "program", "epistemological", "status", "model", "program", "simulate", "physical", "system", "without", "satisfying", "theory", "law", "axiom", "rather", "program", "include", "simulation", "purpose", "implementation", "detail", "programming", "language", "used", "target", "system", "simulated", "yet", "different", "approach", "problem", "whether", "program", "theory", "come", "computer", "scientist", "peter", "naur", "1985", "according", "naur", "programming", "theory", "building", "process", "sense", "program", "theory", "successful", "program", "development", "lifecycle", "require", "programmer", "developer", "theory", "program", "available", "theory", "understood", "following", "ryle", "2009", "corpus", "knowledge", "shared", "scientific", "community", "set", "empirical", "phenomenon", "necessarily", "expressed", "axiomatically", "formally", "theory", "program", "necessary", "program", "lifecycle", "able", "manage", "request", "program", "modification", "pursuant", "observed", "miscomputations", "unsatisfactory", "solution", "computational", "problem", "program", "asked", "solve", "particular", "theory", "program", "allow", "developer", "modify", "program", "new", "solution", "problem", "stake", "provided", "reason", "naur", "1985", "deems", "theory", "fundamental", "software", "development", "documentation", "specification", "turner", "2010", "2018", "ch", "10", "programming", "language", "mathematical", "object", "defined", "formal", "grammar", "formal", "semantics", "particular", "syntactic", "construct", "assignment", "conditional", "loop", "defined", "grammatical", "rule", "determining", "syntax", "semantic", "rule", "associating", "meaning", "depending", "whether", "operational", "denotational", "semantics", "preferred", "meaning", "given", "term", "respectively", "operation", "abstract", "machine", "mathematical", "partial", "function", "set", "state", "set", "state", "instance", "simple", "assignment", "statement", "x", "e", "associated", "operational", "semantics", "machine", "operation", "update", "x", "v", "assigns", "variable", "v", "interpreted", "e", "variable", "x", "state", "s", "case", "operational", "denotational", "semantics", "program", "understood", "mathematical", "theory", "expressing", "operation", "implementing", "machine", "consider", "operational", "semantics", "syntactic", "rule", "form", "langle", "p", "rangle", "downarrow", "s", "state", "semantically", "program", "p", "executed", "state", "s", "result", "s", "according", "turner", "2010", "2018", "programming", "language", "operational", "semantics", "akin", "axiomatic", "theory", "operation", "rule", "provide", "axiom", "relation", "downarrow", "42", "program", "technical", "artifact", "program", "understood", "technical", "artifact", "programming", "language", "defined", "artifact", "basis", "functional", "structural", "property", "turner", "2014", "2018", "ch", "5", "functional", "property", "high", "level", "programming", "language", "provided", "semantics", "associated", "syntactic", "construct", "language", "turner", "2014", "point", "programming", "language", "indeed", "understood", "axiomatic", "theory", "functional", "level", "isolated", "structural", "property", "hand", "specified", "term", "implementation", "language", "identified", "physical", "component", "computing", "machine", "given", "syntactic", "construct", "language", "associated", "functional", "description", "structural", "property", "determined", "physical", "operation", "machine", "performs", "implement", "instruction", "construct", "hand", "instance", "assignment", "construct", "x", "e", "linked", "physical", "computation", "value", "expression", "e", "placement", "value", "e", "physical", "location", "x", "another", "requirement", "programming", "language", "considered", "technical", "artifact", "endowed", "semantics", "providing", "correctness", "criterion", "language", "implementation", "programmer", "attests", "functional", "structural", "property", "program", "taking", "semantics", "correctness", "jurisdiction", "program", "43", "program", "relation", "world", "problem", "whether", "computer", "program", "theory", "tied", "relation", "program", "entertain", "outside", "world", "program", "theory", "would", "represent", "empirical", "system", "semantic", "relation", "would", "directly", "established", "program", "world", "contrast", "argued", "relation", "program", "natural", "system", "mediated", "model", "outside", "world", "colburn", "et", "al", "1993", "smith", "1985", "particular", "smith", "1985", "argues", "model", "abstract", "description", "empirical", "system", "computational", "system", "operating", "program", "act", "model", "model", "ie", "represent", "abstract", "model", "reality", "account", "ontology", "program", "come", "handy", "describing", "correctness", "problem", "computer", "science", "see", "7", "specification", "considered", "model", "requiring", "certain", "behavior", "computational", "system", "program", "seen", "model", "satisfying", "specification", "two", "view", "program", "given", "depending", "whether", "one", "admits", "relation", "world", "rapaport", "2020", "ch", "17", "see", "internet", "resource", "according", "first", "view", "program", "wide", "external", "semantic", "grant", "direct", "reference", "object", "empirical", "system", "operation", "object", "according", "second", "view", "program", "narrow", "internal", "syntactic", "make", "reference", "atomic", "operation", "implementing", "machine", "carrying", "computation", "rapaport", "2020", "see", "internet", "resource", "argues", "program", "need", "external", "semantic", "first", "computation", "need", "external", "turing", "machine", "executes", "instruction", "contained", "finite", "table", "using", "data", "written", "tape", "halting", "data", "resulting", "computation", "written", "tape", "data", "strictly", "speaking", "inputfrom", "outputto", "external", "user", "furthemore", "knuth", "1973", "required", "algorithm", "zero", "input", "output", "see", "31", "computer", "program", "requiring", "input", "may", "program", "say", "outputting", "prime", "number", "1", "program", "output", "program", "computes", "value", "given", "variable", "x", "without", "returning", "value", "stored", "x", "output", "second", "program", "need", "external", "teleological", "ie", "goal", "oriented", "view", "opposes", "known", "position", "literature", "suber", "1988", "argues", "without", "considering", "goal", "purpose", "would", "possible", "ass", "whether", "computer", "program", "correct", "behaves", "intended", "recalled", "33", "hill", "2016", "specifies", "informal", "definition", "algorithm", "accomplish", "given", "purpose", "given", "provisions", "hill", "2016", "48", "view", "rapaport", "2020", "ch", "17", "see", "internet", "resource", "reply", "whereas", "goal", "purpose", "programmer", "intention", "may", "useful", "human", "computor", "understand", "program", "necessary", "artificial", "computer", "carry", "computation", "instructed", "program", "code", "indeed", "principle", "effectiveness", "classical", "approach", "require", "algorithm", "see", "31", "demand", "among", "property", "algorithm", "executed", "without", "recourse", "intuition", "word", "machine", "executing", "program", "adding", "natural", "number", "understand", "adding", "time", "knowing", "given", "program", "performs", "addition", "may", "help", "human", "agent", "understand", "program", "code", "according", "view", "computing", "involves", "symbol", "meaning", "turing", "machine", "become", "symbol", "manipulator", "single", "multiple", "meaning", "associated", "operation", "one", "identify", "two", "program", "program", "meaning", "considering", "function", "perform", "one", "answer", "come", "piccini", "analysis", "computation", "internal", "semantics", "piccini", "2008", "2015", "ch", "3", "two", "program", "identified", "identical", "analysing", "syntax", "operation", "program", "carry", "symbol", "effect", "string", "manipulation", "operation", "considered", "internal", "semantics", "program", "latter", "easily", "determined", "isolating", "subroutine", "method", "program", "code", "afterwards", "used", "identify", "program", "establish", "whether", "two", "program", "namely", "defined", "subroutine", "however", "argued", "case", "possible", "determine", "whether", "two", "program", "without", "making", "reference", "external", "semantics", "sprevak", "2010", "proposes", "consider", "two", "program", "addition", "differ", "fact", "one", "operates", "arabic", "one", "roman", "numeral", "two", "program", "compute", "function", "namely", "addition", "always", "established", "inspecting", "code", "subroutine", "must", "determined", "assigning", "content", "inputoutput", "string", "interpreting", "arabic", "roman", "numeral", "number", "regard", "angius", "primiero", "2018", "underline", "problem", "identity", "computer", "program", "differ", "problem", "identity", "natural", "kind", "lowe", "1998", "technical", "artifact", "carrara", "et", "al", "2014", "problem", "tackled", "fixing", "identity", "criterion", "namely", "formal", "relation", "two", "program", "entertain", "order", "defined", "identical", "angius", "primiero", "2018", "show", "use", "process", "algebra", "relation", "bisimulation", "two", "automaton", "implemented", "two", "program", "examination", "identity", "criterion", "bisimulation", "allows", "establish", "matching", "structural", "property", "program", "implementing", "function", "well", "providing", "weaker", "criterion", "copy", "term", "simulation", "brings", "discussion", "back", "notion", "program", "implementation", "turn", "analyze", "latter", "concept", "5", "implementation", "word", "implementation", "often", "associated", "physical", "realization", "computing", "system", "ie", "machine", "executing", "computer", "program", "particular", "according", "dual", "ontology", "computing", "system", "examined", "11", "implementation", "sense", "reduces", "structural", "hardware", "opposed", "functional", "software", "contrast", "following", "method", "level", "abstraction", "12", "implementation", "becomes", "wider", "relation", "holding", "loa", "defining", "computational", "system", "level", "higher", "hierarchy", "accordingly", "algorithm", "implementation", "set", "specification", "program", "expressed", "high", "level", "programming", "language", "defined", "implementation", "algorithm", "see", "4", "assembly", "machine", "code", "instruction", "seen", "implementation", "set", "highlevel", "programming", "language", "instruction", "respect", "given", "isa", "finally", "execution", "physical", "observable", "implementation", "machine", "code", "instruction", "token", "program", "formulated", "highlevel", "language", "also", "implementation", "specification", "similarly", "argued", "dualontology", "paradigm", "execution", "implementation", "highlevel", "programming", "language", "instruction", "according", "turner", "2018", "even", "specification", "understood", "implementation", "called", "intention", "remains", "examined", "nature", "implementation", "relation", "thus", "defined", "analyzing", "relation", "essential", "define", "notion", "correctness", "7", "indeed", "correct", "program", "amount", "correct", "implementation", "algorithm", "correct", "computing", "system", "correct", "implementation", "set", "specification", "word", "view", "notion", "correctness", "paired", "implementation", "loa", "level", "said", "correct", "respect", "upper", "level", "correct", "implementation", "thereof", "following", "three", "subsection", "examine", "three", "main", "definition", "implementation", "relation", "advanced", "philosophy", "computer", "science", "literature", "51", "implementation", "semantic", "interpretation", "first", "philosophical", "analysis", "notion", "implementation", "computer", "science", "advanced", "rapaport", "1999", "2005", "defines", "implementation", "semantic", "interpretation", "syntactic", "abstract", "domain", "medium", "implementation", "m", "implementation", "understood", "relation", "holding", "given", "loa", "upper", "level", "hierarchical", "ontology", "computational", "system", "follows", "rapaport", "definition", "extends", "accordingly", "loa", "provides", "semantic", "interpretation", "given", "medium", "implementation", "upper", "level", "view", "specification", "provide", "semantic", "interpretation", "intention", "expressed", "stakeholder", "specification", "formal", "language", "algorithm", "provide", "semantic", "interpretation", "specification", "using", "one", "many", "language", "algorithm", "formulated", "natural", "language", "pseudocode", "logic", "language", "functional", "language", "etc", "medium", "implementation", "either", "abstract", "concrete", "computer", "program", "implementation", "algorithm", "former", "provides", "semantic", "interpretation", "syntactic", "construct", "latter", "highlevel", "programming", "language", "medium", "implementation", "program", "instruction", "interpret", "algorithm", "s", "task", "programming", "language", "also", "execution", "loa", "provides", "semantic", "interpretation", "assemblymachine", "code", "operation", "medium", "given", "structural", "property", "physical", "machine", "according", "analysis", "rapaport", "1999", "2005", "implementation", "asymmetric", "relation", "implementation", "implementation", "i", "however", "author", "argues", "loa", "syntactic", "semantic", "level", "play", "role", "implementation", "syntactic", "domain", "a", "whereas", "algorithm", "assigned", "semantic", "interpretation", "program", "expressed", "highlevel", "language", "algorithm", "provides", "semantic", "interpretation", "specification", "follows", "abstractionimplementation", "relation", "pair", "functionalstructural", "relation", "computational", "system", "primiero", "2020", "considers", "latter", "aspect", "one", "main", "limit", "rapaport", "1999", "2005", "account", "implementation", "implementation", "reduces", "unique", "relation", "syntactic", "level", "semantic", "interpretation", "account", "layered", "ontology", "computational", "system", "seen", "12", "order", "extend", "present", "definition", "implementation", "loas", "level", "reinterpreted", "time", "either", "syntactic", "semantic", "level", "turn", "repercussion", "second", "difficulty", "characterizing", "according", "primero", "2020", "implementation", "semantic", "interpretation", "one", "hand", "approach", "take", "account", "incorrect", "implementation", "hand", "given", "incorrect", "implementation", "unique", "relation", "defined", "relate", "incorrectness", "one", "syntactic", "level", "excluding", "level", "potential", "error", "location", "turner", "2018", "aim", "show", "semantic", "interpretation", "account", "incorrect", "implementation", "even", "correct", "one", "one", "first", "example", "provided", "implementation", "one", "language", "another", "implementing", "language", "providing", "semantic", "interpretation", "implemented", "language", "unless", "former", "associated", "semantics", "providing", "meaning", "correctness", "criterion", "latter", "semantics", "remain", "external", "implementation", "relation", "whereas", "correctness", "associated", "semantic", "interpretation", "implementation", "always", "come", "semantic", "interpretation", "second", "example", "given", "considering", "abstract", "stack", "implemented", "array", "array", "provide", "correctness", "criterion", "stack", "quite", "contrary", "stack", "specifies", "correctness", "criterion", "implementation", "array", "included", "52", "implementation", "relation", "specificationartifact", "fact", "correctness", "criterion", "implementation", "relation", "provided", "abstract", "level", "induces", "turner", "2012", "2014", "2018", "define", "implementation", "relation", "specificationartefact", "examined", "2", "specification", "correctness", "jurisdiction", "artifact", "prescribe", "allowed", "behavior", "artifact", "also", "recall", "artifact", "abstract", "concrete", "entity", "loa", "play", "role", "specification", "lower", "level", "amount", "saying", "specificationartefact", "relation", "able", "define", "implementation", "relation", "across", "layered", "ontology", "computational", "system", "depending", "specificationartifact", "relation", "defined", "turner", "2012", "distinguishes", "many", "three", "different", "notion", "implementation", "consider", "case", "physical", "machine", "implementing", "given", "abstract", "machine", "according", "intentional", "notion", "implementation", "abstract", "machine", "work", "specification", "physical", "machine", "provided", "advance", "functional", "requirement", "latter", "must", "fulfill", "ie", "specifies", "principle", "allowed", "behavior", "implementing", "physical", "machine", "according", "extensional", "notion", "implementation", "physical", "machine", "correct", "implementation", "abstract", "machine", "isomorphism", "established", "mapping", "state", "latter", "state", "former", "transition", "abstract", "machine", "correspond", "actual", "execution", "computational", "trace", "artifact", "finally", "empirical", "notion", "implementation", "requires", "physical", "machine", "display", "computation", "match", "prescribed", "abstract", "machine", "say", "correct", "implementation", "evaluated", "empirically", "testing", "primiero", "2020", "underline", "approach", "address", "issue", "correctness", "miscomputation", "allows", "distinguish", "correct", "incorrect", "implementation", "still", "identifies", "unique", "implementation", "relation", "specification", "level", "artifact", "level", "account", "allowed", "involve", "layered", "ontology", "computational", "system", "reinterpreting", "time", "loa", "either", "specification", "artifact", "turner", "account", "prevents", "referring", "one", "level", "time", "cause", "miscomputation", "miscomputation", "always", "occurs", "incorrect", "implementation", "specification", "artifact", "defining", "implementation", "relation", "holding", "accross", "loas", "one", "would", "able", "identify", "multiple", "incorrect", "implementation", "directly", "refer", "abstract", "specification", "miscomputation", "may", "indeed", "caused", "incorrect", "implementation", "lower", "level", "inherited", "way", "execution", "level", "53", "implementation", "loas", "primiero", "2020", "proposes", "definition", "implementation", "relation", "two", "fixed", "level", "one", "allowed", "range", "loa", "view", "implementation", "relation", "instantiation", "holding", "loa", "one", "higher", "abstraction", "hierarchy", "accordingly", "physical", "computing", "machine", "implementation", "assemblymachine", "code", "operation", "transitivity", "also", "considered", "instantiation", "set", "instruction", "expressed", "highlevel", "programming", "language", "instruction", "program", "expressed", "highlevel", "language", "implementation", "algorithm", "also", "taken", "instantiation", "set", "specification", "definition", "implementation", "allows", "primiero", "2020", "provide", "general", "definition", "correctness", "physical", "computing", "system", "correct", "characterized", "correct", "implementation", "loa", "hence", "correctness", "implementation", "coupled", "defined", "loa", "functional", "correctness", "property", "computational", "system", "display", "functionality", "required", "specification", "system", "procedural", "correctness", "characterizes", "computational", "system", "displaying", "functionality", "intended", "implemented", "algorithm", "executional", "correctness", "defined", "property", "system", "able", "correctly", "execute", "program", "architecture", "form", "correctness", "also", "classified", "quantitatively", "depending", "amount", "functionality", "satisfied", "functionally", "efficient", "computational", "system", "display", "minimal", "subset", "functionality", "required", "specification", "functionally", "optimal", "system", "able", "display", "maximal", "subset", "functionality", "similarly", "author", "defines", "procedurally", "well", "executionally", "efficient", "optimal", "computational", "system", "54", "physical", "computation", "according", "definition", "implementation", "shift", "level", "level", "set", "algorithm", "defining", "computational", "system", "implemented", "procedure", "formal", "language", "instruction", "highlevel", "language", "operation", "lowlevel", "programming", "language", "interesting", "question", "whether", "system", "beyond", "computational", "artifact", "implementing", "procedure", "sort", "qualifies", "computational", "system", "word", "asking", "nature", "physical", "implementation", "amount", "asking", "computational", "system", "system", "implementing", "algorithm", "would", "qualify", "computational", "class", "system", "could", "extended", "biological", "system", "brain", "cell", "physical", "system", "including", "universe", "portion", "eventually", "system", "whatsoever", "thesis", "known", "pancomputationalism", "exhaustive", "overview", "topic", "see", "rapaport", "2018", "traditionally", "computational", "system", "intended", "mechanical", "artifact", "take", "input", "data", "elaborates", "algorithmically", "according", "set", "instruction", "return", "manipulated", "data", "output", "instance", "von", "neumann", "1945", "p1", "state", "automatic", "computing", "system", "usually", "highly", "composite", "device", "carry", "instruction", "perform", "calculation", "considerable", "order", "complexity", "informal", "wellaccepted", "definition", "leaf", "question", "open", "including", "whether", "computational", "system", "machine", "whether", "process", "data", "algorithmically", "consequently", "whether", "computation", "turing", "complete", "rapaport", "2018", "provides", "explicit", "characterization", "computational", "system", "defined", "physical", "plausible", "implementation", "anything", "logically", "equivalent", "universal", "turing", "machine", "strictly", "speaking", "personal", "computer", "physical", "turing", "machine", "register", "machine", "known", "turing", "equivalent", "qualify", "computational", "system", "must", "plausible", "implementation", "thereof", "turing", "machine", "contrary", "physical", "machine", "access", "infinite", "memory", "space", "abstract", "machine", "error", "free", "according", "rapaport", "2018", "definition", "physical", "implementation", "sort", "thus", "computational", "system", "including", "natural", "system", "raise", "question", "class", "natural", "system", "able", "implement", "turing", "equivalent", "computation", "searle", "famously", "argued", "anything", "implementation", "turing", "machine", "logical", "equivalent", "model", "searle", "1990", "argument", "lever", "fact", "turing", "machine", "syntactic", "property", "manipulating", "token", "0", "1", "according", "searle", "syntactic", "property", "intrinsic", "physical", "system", "assigned", "observer", "word", "physical", "state", "system", "intrinsically", "computational", "state", "must", "observer", "user", "assigns", "state", "computational", "role", "follows", "system", "whose", "behavior", "described", "syntactic", "manipulation", "0", "1", "computational", "system", "hayes", "1997", "object", "searle", "1990", "everything", "computational", "system", "property", "computational", "system", "would", "become", "vacuous", "entity", "would", "posse", "instead", "entity", "computational", "system", "entity", "computational", "system", "pattern", "received", "input", "saved", "memory", "able", "change", "word", "hayes", "make", "reference", "fact", "stored", "input", "data", "instruction", "instruction", "executed", "able", "modify", "value", "input", "data", "paper", "would", "magic", "paper", "writing", "might", "spontaneously", "change", "new", "writing", "appear", "hayes", "1997", "p", "393", "system", "able", "act", "magic", "paper", "acknowledged", "computational", "yet", "different", "approach", "come", "piccinini", "2007", "2008", "context", "mechanistic", "analysis", "physical", "computation", "piccinini", "2015", "see", "also", "entry", "computation", "physical", "system", "physical", "computing", "system", "system", "whose", "behavior", "explained", "mechanistically", "describing", "computing", "mechanism", "brings", "behavior", "mechanism", "defined", "entity", "activity", "organized", "productive", "regular", "change", "start", "setup", "finish", "termination", "condition", "machamer", "et", "al", "2000", "see", "entry", "mechanism", "science", "computation", "physical", "process", "understood", "mechanism", "generate", "output", "string", "input", "string", "accordance", "general", "rule", "apply", "input", "string", "depend", "input", "sometimes", "internal", "state", "piccinini", "2007", "p", "108", "easy", "identify", "setup", "termination", "condition", "computational", "process", "system", "explained", "describing", "underlying", "computing", "mechanism", "considered", "computational", "system", "focus", "explanation", "help", "piccinini", "avoid", "searlean", "conclusion", "system", "computational", "system", "even", "one", "may", "interpret", "principle", "given", "set", "entity", "activity", "computing", "mechanism", "need", "explain", "certain", "observed", "phenomenon", "term", "computing", "mechanism", "defines", "system", "examination", "computational", "6", "verification", "crucial", "step", "software", "development", "process", "verification", "consists", "process", "evaluating", "whether", "given", "computational", "system", "correct", "respect", "specification", "design", "early", "day", "computer", "industry", "validity", "correctness", "checking", "method", "included", "several", "design", "construction", "technique", "see", "example", "arif", "et", "al", "2018", "nowadays", "correctness", "evaluation", "method", "roughly", "sorted", "two", "main", "group", "formal", "verification", "testing", "formal", "verification", "monin", "hinchey", "2003", "involves", "proof", "correctness", "mathematical", "tool", "software", "testing", "ammann", "offutt", "2008", "rather", "consists", "running", "implemented", "program", "observe", "whether", "performed", "execution", "comply", "advanced", "specification", "many", "practical", "case", "combination", "method", "used", "see", "instance", "callahan", "et", "al", "1996", "61", "model", "theory", "formal", "verification", "method", "require", "representation", "software", "verification", "theorem", "proving", "see", "van", "leeuwen", "1990", "program", "represented", "term", "axiomatic", "system", "set", "rule", "inference", "representing", "pre", "postconditions", "program", "transition", "proof", "correctness", "obtained", "deriving", "formula", "expressing", "specification", "axiom", "model", "checking", "baier", "katoen", "2008", "program", "represented", "term", "state", "transition", "system", "property", "specification", "formalised", "temporal", "logic", "formula", "kr\u00f6ger", "merz", "2008", "proof", "correctness", "achieved", "depthfirst", "search", "algorithm", "check", "whether", "formula", "hold", "state", "transition", "system", "axiomatic", "system", "state", "transition", "system", "used", "correctness", "evaluation", "understood", "theory", "represented", "artifact", "used", "predict", "explain", "future", "behavior", "methodologically", "state", "transition", "system", "model", "checking", "compared", "scientific", "model", "empirical", "science", "angius", "tamburrini", "2011", "instance", "kripke", "structure", "see", "clarke", "et", "al", "1999", "ch", "2", "compliance", "suppes", "1960", "definition", "scientific", "model", "settheoretic", "structure", "establishing", "proper", "mapping", "relation", "model", "data", "collected", "mean", "experiment", "target", "empirical", "system", "see", "also", "entry", "model", "science", "kripke", "structure", "state", "transition", "system", "utilized", "formal", "verification", "method", "often", "called", "system", "specification", "distinguished", "common", "specification", "also", "called", "property", "specification", "latter", "specify", "required", "behavioral", "property", "program", "encoded", "must", "instantiate", "former", "specify", "principle", "potential", "execution", "already", "encoded", "program", "thus", "allowing", "algorithmic", "check", "trace", "clarke", "et", "al", "1999", "order", "achieve", "goal", "system", "specification", "considered", "abductive", "structure", "hypothesizing", "set", "potential", "execution", "target", "computational", "system", "basis", "program", "code", "allowed", "state", "transition", "angius", "2013b", "indeed", "checked", "whether", "temporal", "logic", "formula", "hold", "modeled", "kripke", "structure", "represented", "program", "empirically", "tested", "behavioral", "property", "corresponding", "checked", "formula", "order", "evaluate", "whether", "modelhypothesis", "adequate", "representation", "target", "computational", "system", "accordingly", "property", "specification", "system", "specification", "differ", "also", "intentional", "stance", "turner", "2011", "former", "requirement", "program", "encoded", "latter", "hypothetical", "description", "encoded", "program", "descriptive", "abductive", "character", "state", "transition", "system", "model", "checking", "additional", "essential", "feature", "putting", "state", "transition", "system", "par", "scientific", "model", "62", "testing", "experiment", "testing", "empirical", "process", "launching", "program", "observing", "execution", "order", "evaluate", "whether", "comply", "supplied", "property", "specification", "technique", "extensively", "used", "software", "development", "process", "philosopher", "philosophicallyminded", "computer", "scientist", "considered", "software", "testing", "light", "traditional", "methodological", "approach", "scientific", "discovery", "snelting", "1998", "gagliardi", "2007", "northover", "et", "al", "2008", "angius", "2014", "questioned", "whether", "software", "test", "acknowledged", "scientific", "experiment", "evaluating", "correctness", "program", "schiaffonati", "verdicchio", "2014", "schiaffonati", "2015", "tedre", "2015", "dijkstra", "wellknown", "dictum", "program", "testing", "used", "show", "presence", "bug", "never", "show", "absence", "dijkstra", "1970", "p7", "introduces", "popper", "1959", "principle", "falsifiability", "computer", "science", "snelting", "1998", "testing", "program", "advanced", "property", "specification", "given", "interval", "time", "may", "exhibit", "failure", "failure", "occurs", "observing", "running", "program", "one", "conclude", "program", "correct", "incorrect", "execution", "might", "observed", "next", "system", "run", "reason", "tester", "launch", "program", "finite", "subset", "potential", "program", "input", "set", "finite", "interval", "time", "accordingly", "potential", "execution", "program", "tested", "empirically", "observed", "reason", "aim", "software", "testing", "detect", "program", "fault", "guarantee", "absence", "ammann", "offutt", "2008", "p", "11", "program", "falsifiable", "test", "reveal", "fault", "northover", "et", "al", "2008", "hence", "given", "computational", "system", "property", "specification", "test", "akin", "scientific", "experiment", "observing", "system", "behavior", "try", "falsify", "hypothesis", "program", "correct", "respect", "interested", "specification", "however", "methodological", "epistemological", "trait", "characterizing", "scientific", "experiment", "shared", "software", "test", "first", "methodological", "distinction", "recognized", "falsifying", "test", "lead", "revision", "computational", "system", "hypothesis", "case", "testing", "scientific", "hypothesis", "due", "difference", "intentional", "stance", "specification", "empirical", "hypothesis", "science", "turner", "2011", "specification", "requirement", "whose", "violation", "demand", "program", "revision", "program", "becomes", "correct", "instantiation", "specification", "among", "reason", "traditional", "notion", "scientific", "experiment", "need", "stretched", "order", "applied", "software", "testing", "activity", "schiaffonati", "2015", "theorydriven", "experiment", "characterizing", "experimental", "science", "find", "counterpart", "actual", "computer", "science", "practice", "one", "excludes", "case", "wherein", "testing", "combined", "formal", "method", "experiment", "performed", "software", "engineer", "rather", "explorative", "ie", "aimed", "exploring", "realm", "possibility", "pertaining", "functioning", "artefact", "interaction", "environment", "absence", "proper", "theory", "theoretical", "background", "schiaffonati", "2015", "662", "software", "tester", "often", "theoretical", "control", "experiment", "perform", "exploration", "behavior", "computational", "system", "interacting", "user", "environment", "rather", "allows", "tester", "formulate", "theoretical", "generalization", "observed", "behavior", "explorative", "experiment", "computer", "science", "also", "characterized", "fact", "program", "often", "tested", "reallike", "environment", "wherein", "tester", "play", "role", "user", "however", "essential", "feature", "theorydriven", "experiment", "experimenter", "take", "part", "experiment", "carried", "result", "software", "testing", "activity", "closer", "experimental", "activity", "one", "find", "empirical", "science", "others", "rather", "define", "new", "typology", "experiment", "turn", "belong", "software", "development", "process", "five", "typology", "experiment", "distinguished", "process", "specifying", "implementing", "evaluating", "computational", "system", "tedre", "2015", "feasibility", "experiment", "performed", "evaluate", "whether", "system", "performs", "function", "specified", "user", "stakeholder", "trial", "experiment", "carried", "evaluate", "isolated", "capability", "system", "given", "set", "initial", "condition", "field", "experiment", "performed", "real", "environment", "simulated", "one", "comparison", "experiment", "test", "similar", "system", "instantiating", "different", "way", "function", "evaluate", "instantiation", "better", "performs", "desired", "function", "reallike", "real", "environment", "finally", "controlled", "experiment", "used", "appraise", "advanced", "hypothesis", "behavior", "testing", "computational", "system", "one", "par", "scientific", "theorydriven", "experiment", "carried", "basis", "theoretical", "hypothesis", "evaluation", "63", "explanation", "software", "test", "considered", "successful", "miscomputations", "detected", "assuming", "computational", "artifact", "100", "correct", "successive", "step", "find", "caused", "execution", "incorrect", "trace", "back", "fault", "familiarly", "named", "bug", "proceeding", "debugging", "phase", "testing", "system", "word", "explanation", "observed", "miscomputation", "advanced", "effort", "made", "consider", "explanation", "computer", "science", "piccinini", "2007", "piccinini", "craver", "2011", "piccinini", "2015", "angius", "tamburrini", "2016", "relation", "different", "model", "explanation", "elaborated", "philosophy", "science", "particular", "computational", "explanation", "understood", "specific", "kind", "mechanistic", "explanation", "glennan", "1996", "machamer", "et", "al", "2000", "bechtel", "abrahamsen", "2005", "insofar", "computing", "process", "analyzed", "mechanism", "piccinini", "2007", "2015", "see", "also", "entry", "computation", "physical", "system", "consider", "processor", "executing", "instruction", "involved", "process", "understood", "mechanism", "whose", "component", "state", "combinatory", "element", "processor", "instantiating", "function", "prescribed", "relevant", "hardware", "specification", "specification", "register", "arithmetic", "logic", "unit", "etc", "organized", "way", "capable", "carrying", "observed", "execution", "providing", "description", "mechanism", "count", "advancing", "mechanist", "explanation", "observed", "computation", "explanation", "operational", "malfunction", "every", "type", "miscomputation", "see", "73", "corresponding", "mechanist", "explanation", "defined", "adequate", "loa", "respect", "set", "specification", "characterizing", "loa", "indeed", "abstract", "description", "mechanism", "still", "supply", "one", "mechanist", "explanation", "form", "mechanism", "schema", "defined", "truncated", "abstract", "description", "mechanism", "filled", "description", "known", "component", "part", "activity", "machamer", "et", "al", "2000", "p", "15", "instance", "suppose", "common", "case", "machine", "miscomputes", "executing", "program", "containing", "syntax", "error", "called", "slip", "computing", "machine", "unable", "correctly", "implement", "functional", "requirement", "provided", "program", "specification", "however", "explanatory", "purpose", "would", "redundant", "provide", "explanation", "occurred", "slip", "hardware", "level", "abstraction", "advancing", "detailed", "description", "hardware", "component", "functional", "organization", "case", "satisfactory", "explanation", "may", "consist", "showing", "program", "code", "correct", "instantiation", "provided", "program", "specification", "angius", "tamburrini", "2016", "order", "explain", "mechanistically", "occurred", "miscomputation", "may", "sufficient", "provide", "description", "incorrect", "program", "abstracting", "rest", "computing", "mechanism", "piccinini", "craver", "2011", "abstraction", "virtue", "software", "development", "specification", "also", "explanation", "computational", "system", "behavior", "7", "correctness", "different", "approach", "software", "verification", "examined", "previous", "section", "assumes", "different", "understanding", "correctness", "software", "standardly", "correctness", "understood", "relation", "holding", "abstraction", "implementation", "hold", "latter", "fulfills", "property", "formulated", "former", "computational", "system", "described", "layered", "ontology", "correctness", "need", "reformulated", "relation", "structural", "level", "entertains", "respect", "functional", "level", "primiero", "2020", "hence", "correctness", "still", "considered", "mathematical", "relationship", "formulated", "abstract", "functional", "level", "considered", "empirical", "relationship", "formulated", "functional", "implementation", "level", "one", "earlier", "debate", "philosophy", "computer", "science", "de", "millo", "et", "al", "1979", "fetzer", "1988", "indeed", "around", "distinction", "71", "mathematical", "correctness", "formal", "verification", "method", "grant", "apriori", "analysis", "behavior", "program", "without", "requiring", "observation", "implementation", "considering", "execution", "particular", "theorem", "proving", "allows", "one", "deduce", "potential", "behavior", "program", "consideration", "behavioral", "property", "suitable", "axiomatic", "representation", "case", "model", "checking", "one", "know", "advance", "behavioural", "property", "displayed", "execution", "program", "performing", "algorithmic", "search", "formula", "valid", "given", "settheoretic", "model", "consideration", "famously", "led", "hoare", "1969", "conclude", "program", "development", "exact", "science", "characterized", "mathematical", "proof", "correctness", "epistemologically", "par", "standard", "proof", "mathematical", "practice", "de", "millo", "et", "al", "1979", "question", "hoare", "thesis", "correct", "mathematical", "proof", "usually", "elegant", "graspable", "implying", "expert", "reader", "see", "conclusion", "follows", "premise", "notion", "elegance", "software", "see", "also", "hill", "2018", "often", "called", "cartesian", "proof", "hacking", "2014", "counterpart", "correctness", "proof", "typically", "long", "cumbersome", "difficult", "grasp", "explaining", "conclusion", "necessarily", "follows", "premise", "yet", "many", "proof", "mathematics", "long", "complex", "principle", "surveyable", "thanks", "use", "lemma", "abstraction", "analytic", "construction", "new", "concept", "leading", "step", "step", "statement", "proved", "correctness", "proof", "contrary", "involve", "creation", "new", "concept", "modularity", "one", "typically", "find", "mathematical", "proof", "turner", "2018", "yet", "proof", "surveyable", "considered", "mathematical", "proof", "wittgenstein", "1956", "second", "theoretical", "difficulty", "concerning", "proof", "correctness", "computer", "program", "concern", "complexity", "program", "verified", "already", "hoare", "1981", "admitted", "verification", "correctness", "always", "possible", "principle", "practice", "hardly", "achievable", "except", "trivial", "case", "contemporary", "software", "modularly", "encoded", "required", "satisfy", "large", "set", "specification", "developed", "interact", "program", "system", "user", "embedded", "reactive", "software", "case", "point", "order", "verify", "complex", "software", "correctness", "proof", "carried", "automatically", "hence", "one", "hand", "correctness", "problem", "shift", "program", "examination", "program", "performing", "verification", "eg", "theorem", "prover", "hand", "proof", "carried", "physical", "process", "go", "wrong", "due", "mechanical", "mistake", "machine", "infinite", "regress", "argument", "arkoudas", "bringsjord", "2007", "argue", "one", "make", "use", "proof", "checker", "relatively", "small", "program", "usually", "easier", "verify", "recently", "formal", "method", "checking", "correctness", "based", "combination", "logical", "statistical", "analysis", "given", "new", "stimulus", "research", "area", "ability", "separation", "logic", "reynolds", "2002", "offer", "representation", "logical", "behavior", "physical", "memory", "computational", "system", "possibility", "considering", "probabilistic", "distribution", "input", "statistical", "source", "error", "allowed", "formal", "correctness", "check", "large", "interactive", "system", "like", "facebook", "platform", "see", "also", "pym", "et", "al", "2019", "72", "physical", "correctness", "fetzer", "1988", "objected", "deductive", "reasoning", "able", "guarantee", "correctness", "program", "respect", "specification", "correctness", "computational", "system", "also", "accounting", "program", "physical", "implementation", "even", "program", "correct", "respect", "related", "upper", "loas", "algorithm", "specification", "requirement", "implementation", "could", "still", "violate", "one", "intended", "specification", "due", "physical", "malfunctioning", "former", "kind", "correctness", "principle", "proved", "mathematically", "correctness", "execution", "loa", "requires", "empirical", "assessment", "examined", "62", "software", "testing", "show", "principle", "correctness", "computational", "system", "practice", "number", "allowed", "execution", "nontrivial", "system", "potentially", "infinite", "exhaustively", "checked", "finite", "reasonable", "amount", "time", "dijkstra", "1974", "successful", "testing", "method", "rather", "see", "formal", "verification", "testing", "used", "together", "reach", "satisfactory", "correction", "level", "another", "objection", "theoretical", "possibility", "mathematical", "correctness", "since", "proof", "carried", "theorem", "prover", "ie", "physical", "machine", "knowledge", "one", "attains", "computational", "system", "apriori", "empirical", "see", "turner", "2018", "ch", "25", "however", "burge", "1988", "argues", "computerbased", "proof", "correctness", "still", "regarded", "apriori", "even", "though", "possibility", "depends", "sensory", "experience", "justification", "aposteriori", "knowledge", "instance", "knowledge", "red", "color", "apriori", "even", "though", "requires", "sensory", "experience", "red", "red", "colour", "true", "independently", "sensory", "experience", "discussion", "nature", "use", "computer", "mathematical", "proof", "see", "hale", "2008", "harrison", "2008", "tymoczko", "1979", "1980", "problem", "correctness", "eventually", "reduces", "asking", "mean", "physical", "machine", "satisfy", "abstract", "requirement", "according", "simple", "mapping", "account", "computational", "system", "correct", "implementation", "specification", "sp", "established", "morphism", "state", "ascribed", "state", "defined", "sp", "state", "transition", "s_1", "rightarrow", "s_2", "state", "transition", "s_1", "rightarrow", "s_2", "sp", "state", "s_1", "mapping", "s_1", "state", "s_2", "mapping", "s_2", "simple", "mapping", "account", "demand", "extensional", "agreement", "description", "sp", "weakness", "account", "quite", "easy", "identify", "extensional", "agreement", "couple", "physical", "systemspecification", "leaving", "room", "pancomputationalist", "perspective", "danger", "pancomputationalism", "led", "author", "attempt", "account", "correct", "implementation", "somehow", "restricts", "class", "possible", "interpretation", "particular", "causal", "account", "d", "j", "chalmers", "1996", "copeland", "1996", "suggests", "material", "conditional", "system", "physical", "state", "s_1", "replaced", "counterfactual", "one", "semantic", "account", "argues", "computational", "system", "must", "associated", "semantic", "description", "specifying", "system", "achieve", "sprevak", "2012", "example", "physical", "device", "could", "interpreted", "gate", "gate", "without", "definition", "device", "way", "fixing", "artifact", "syntactic", "account", "demand", "physical", "state", "defined", "syntactic", "mapped", "onto", "computational", "state", "remains", "examined", "defines", "syntactic", "state", "see", "piccinini", "2015", "entry", "computation", "physical", "system", "overview", "syntactic", "account", "normative", "account", "turner", "2012", "maintains", "abstract", "physical", "computational", "process", "must", "agreement", "also", "abstract", "specification", "normative", "force", "system", "according", "account", "computation", "physical", "process", "whose", "function", "fixed", "abstract", "specification", "relationship", "stronger", "semantic", "account", "asking", "simple", "descriptive", "relationship", "syntactic", "account", "focusing", "syntactic", "object", "semantic", "interpretation", "73", "miscomputations", "said", "far", "follows", "correctness", "implemented", "program", "automatically", "establish", "wellfunctioning", "computational", "system", "turing", "1950", "already", "distinguished", "error", "functioning", "error", "conclusion", "former", "caused", "faulty", "implementation", "unable", "execute", "instruction", "highlevel", "language", "program", "error", "conclusion", "characterize", "correct", "abstract", "machine", "nonetheless", "fail", "carry", "task", "supposed", "accomplish", "may", "happen", "case", "program", "instantiates", "correctly", "specification", "properly", "express", "user", "requirement", "program", "case", "machine", "implementing", "correct", "program", "still", "said", "miscompute", "turing", "distinction", "error", "functioning", "error", "conclusion", "expanded", "complete", "taxonomy", "miscomputations", "fresco", "primiero", "2013", "classification", "established", "basis", "different", "loas", "defining", "computational", "system", "error", "conceptual", "violate", "validity", "condition", "requiring", "consistency", "specification", "expressed", "propositional", "conjunctive", "normal", "form", "material", "violate", "correctness", "requirement", "program", "respect", "set", "specification", "performable", "arise", "physical", "constraint", "breached", "faulty", "implementing", "hardware", "performable", "error", "clearly", "emerge", "execution", "level", "correspond", "turing", "1950", "error", "functioning", "also", "called", "operational", "malfunction", "conceptual", "material", "error", "may", "arise", "level", "abstraction", "intention", "level", "physical", "implementation", "level", "conceptual", "error", "engender", "mistake", "material", "error", "induce", "failure", "instance", "mistake", "intention", "level", "consists", "inconsistent", "set", "requirement", "physical", "implementation", "level", "may", "correspond", "invalid", "hardware", "design", "choice", "logic", "gate", "truthfunctional", "connective", "failure", "occurring", "specification", "level", "may", "due", "design", "deemed", "incomplete", "respect", "set", "desired", "functional", "requirement", "failure", "algorithm", "level", "occurs", "frequent", "case", "algorithm", "found", "fulfill", "specification", "beyond", "mistake", "failure", "operational", "malfunction", "slip", "source", "miscomputations", "highlevel", "programming", "language", "instruction", "level", "may", "conceptual", "material", "error", "due", "respectively", "syntactic", "semantic", "flaw", "program", "conceptual", "slip", "appear", "case", "syntactical", "rule", "highlevel", "language", "violated", "material", "slip", "involve", "violation", "semantic", "rule", "programming", "language", "variable", "used", "initialized", "distinction", "made", "dysfunction", "misfunctions", "softwarebased", "computational", "system", "floridi", "fresco", "primiero", "2015", "software", "misfunction", "ever", "dysfunction", "software", "token", "dysfunction", "case", "physical", "implementation", "fails", "satisfy", "intention", "specification", "dysfunction", "apply", "single", "token", "since", "token", "dysfunction", "behave", "token", "type", "respect", "implemented", "function", "reason", "dysfunction", "apply", "intention", "level", "specification", "level", "contrary", "software", "type", "token", "misfunction", "since", "misfunctions", "depend", "comparison", "token", "type", "able", "perform", "implemented", "function", "misfunction", "token", "usually", "depends", "dysfunction", "component", "misfunction", "type", "often", "due", "poor", "design", "software", "token", "dysfunction", "token", "given", "type", "implement", "function", "specified", "uniformly", "intention", "specification", "level", "function", "implemented", "algorithm", "implementation", "level", "performed", "execution", "level", "case", "correct", "implementation", "token", "behave", "correctly", "execution", "level", "provided", "operational", "malfunction", "occurs", "reason", "software", "token", "misfunction", "since", "implementation", "intention", "specification", "software", "type", "misfunction", "case", "poor", "design", "misfunctioning", "software", "type", "able", "correctly", "perform", "function", "may", "also", "produce", "undesired", "sideeffect", "application", "notion", "malfunctioning", "problem", "malware", "classification", "see", "primiero", "et", "al", "2019", "8", "epistemological", "status", "computer", "science", "1960s", "1970s", "computer", "science", "emerged", "academic", "discipline", "independent", "older", "sibling", "mathematics", "physic", "problem", "defining", "epistemological", "status", "influenced", "mathematical", "empirical", "engineering", "method", "tedre", "sutien", "2008", "tedre", "2011", "tedre", "2015", "primiero", "2020", "debate", "still", "place", "today", "concerning", "whether", "computer", "science", "mostly", "considered", "mathematical", "discipline", "branch", "engineering", "scientific", "discipline", "81", "computer", "science", "mathematical", "discipline", "epistemological", "characterization", "computer", "science", "based", "ontological", "methodological", "epistemological", "commitment", "namely", "assumption", "nature", "computational", "system", "method", "guiding", "software", "development", "process", "kind", "reasoning", "thereby", "involved", "whether", "deductive", "inductive", "combination", "eden", "2007", "origin", "analysis", "computation", "mathematical", "notion", "came", "notoriously", "logic", "hilbert", "s", "question", "concerning", "decidability", "predicate", "calculus", "known", "entschiedungsproblem", "hilbert", "ackermann", "1950", "could", "mechanical", "procedure", "deciding", "arbitrary", "sentence", "logic", "whether", "provable", "address", "question", "rigorous", "model", "informal", "concept", "effective", "mechanical", "method", "logic", "mathematics", "required", "first", "foremost", "mathematical", "endeavor", "one", "develop", "mathematical", "analogue", "informal", "notion", "supporter", "view", "computer", "science", "mathematical", "nature", "assume", "computer", "program", "seen", "physical", "realization", "mathematical", "entity", "one", "reason", "program", "deductively", "formal", "method", "theoretical", "computer", "science", "dijkstra", "1974", "hoare", "1986", "explicit", "considering", "program", "instruction", "mathematical", "sentence", "considering", "formal", "semantics", "programming", "language", "term", "axiomatic", "system", "hoare", "1969", "provided", "program", "specification", "instruction", "advanced", "formal", "language", "formal", "semantics", "provide", "mean", "prove", "correctness", "accordingly", "knowledge", "behavior", "computational", "system", "acquired", "deductive", "reasoning", "involved", "mathematical", "proof", "correctness", "reason", "basis", "rationalist", "optimism", "eden", "2007", "known", "computational", "system", "artifact", "humanmade", "system", "one", "predict", "behavior", "certainty", "knuth", "1974", "although", "central", "concern", "theoretical", "computer", "science", "topic", "computability", "complexity", "covered", "existing", "entry", "churchturing", "thesis", "computational", "complexity", "theory", "recursive", "function", "82", "computer", "science", "engineering", "discipline", "late", "1970s", "increasing", "number", "application", "computational", "system", "everyday", "context", "consequent", "booming", "market", "demand", "caused", "deviation", "interest", "computer", "scientist", "academia", "industry", "focusing", "method", "proving", "program", "correctness", "turned", "method", "managing", "complexity", "evaluating", "reliability", "system", "wegner", "1976", "indeed", "expressing", "formally", "specification", "structure", "input", "highly", "complex", "program", "embedded", "larger", "system", "interacting", "user", "practically", "impossible", "hence", "providing", "mathematical", "proof", "correctness", "becomes", "mostly", "unfeasible", "computer", "science", "research", "developed", "direction", "testing", "technique", "able", "provide", "statistical", "evaluation", "correctness", "often", "called", "reliability", "littlewood", "strigini", "2000", "term", "estimation", "error", "distribution", "program", "code", "line", "engineering", "account", "computer", "science", "thesis", "reliability", "computational", "system", "evaluated", "way", "civil", "engineering", "bridge", "aerospace", "engineering", "airplane", "demillo", "et", "al", "1979", "particular", "whereas", "empirical", "science", "examine", "exists", "computer", "science", "focus", "exist", "ie", "produce", "artifact", "therefore", "acknowledged", "engineering", "mathematics", "hartmanis", "1981", "similarly", "whereas", "scientific", "inquiry", "involved", "discovering", "law", "concerning", "phenomenon", "observation", "one", "identify", "proper", "law", "computer", "science", "practice", "insofar", "latter", "rather", "involved", "production", "phenomenon", "concerning", "computational", "artifact", "brook", "1996", "83", "computer", "science", "scientific", "discipline", "examined", "6", "software", "testing", "reliability", "measuring", "technique", "known", "incapability", "assuring", "absence", "code", "fault", "dijkstra", "1970", "many", "case", "especially", "evaluation", "socalled", "safetycritical", "system", "controller", "airplane", "rocket", "nuclear", "plant", "etc", "combination", "formal", "method", "empirical", "testing", "used", "evaluate", "correctness", "dependability", "computer", "science", "accordingly", "understood", "scientific", "discipline", "make", "use", "deductive", "inductive", "probabilistic", "reasoning", "examine", "computational", "system", "denning", "et", "al", "1981", "2005", "2007", "tichy", "1998", "colburn", "2000", "thesis", "computer", "science", "methodological", "viewpoint", "par", "empirical", "science", "trace", "back", "newell", "perlis", "simon", "1967", "letter", "science", "newell", "et", "al", "1967", "dominated", "1980", "wegner", "1976", "1975", "turing", "award", "lecture", "newell", "simon", "argued", "computer", "science", "empirical", "discipline", "would", "called", "experimental", "science", "like", "astronomy", "economics", "geology", "unique", "form", "observation", "experience", "fit", "narrow", "stereotype", "experimental", "method", "nonetheless", "experiment", "new", "machine", "built", "experiment", "actually", "constructing", "machine", "pose", "question", "nature", "listen", "answer", "observing", "machine", "operation", "analyzing", "analytical", "measurement", "mean", "available", "newell", "simon", "1975", "p", "114", "since", "newell", "simon", "turing", "award", "lecture", "clear", "computer", "science", "understood", "empirical", "science", "special", "sort", "related", "nature", "experiment", "computing", "indeed", "much", "current", "debate", "epistemological", "status", "computer", "science", "concern", "problem", "defining", "kind", "science", "tedre", "2011", "tedre", "2015", "particular", "nature", "experiment", "computer", "science", "schiaffonati", "verdicchio", "2014", "nature", "law", "theorem", "computing", "hartmanis", "1993", "rombach", "seelish", "2008", "methodological", "relation", "computer", "science", "software", "engineering", "gruner", "2011"]}