{"url": "computability", "title": "Computability and Complexity", "authorship": {"year": "Copyright \u00a9 2021", "author_text": "Neil Immerman\n<immerman@cs.umass.edu>", "author_links": [{"http://www.cs.umass.edu/~immerman/": "Neil Immerman"}, {"mailto:immerman%40cs%2eumass%2eedu": "immerman@cs.umass.edu"}], "raw_html": "<div id=\"article-copyright\">\n<p>\n<a href=\"../../info.html#c\">Copyright \u00a9 2021</a> by\n\n<br/>\n<a href=\"http://www.cs.umass.edu/~immerman/\" target=\"other\">Neil Immerman</a>\n&lt;<a href=\"mailto:immerman%40cs%2eumass%2eedu\"><em>immerman<abbr title=\" at \">@</abbr>cs<abbr title=\" dot \">.</abbr>umass<abbr title=\" dot \">.</abbr>edu</em></a>&gt;\n    </p>\n</div>"}, "pubinfo": ["First published Thu Jun 24, 2004", "substantive revision Mon Oct 18, 2021"], "preamble": "\n\n\nA mathematical problem is computable if it can be solved in\nprinciple by a computing device. Some common synonyms for\n\u201ccomputable\u201d are \u201csolvable\u201d,\n\u201cdecidable\u201d, and \u201crecursive\u201d. Hilbert believed\nthat all mathematical problems were solvable, but in the 1930\u2019s\nG\u00f6del, Turing, and Church showed that this is not the case. There\nis an extensive study and classification of which mathematical\nproblems are computable and which are not. In addition, there is an\nextensive classification of computable problems into computational\ncomplexity classes according to how much computation\u2014as a\nfunction of the size of the problem instance\u2014is needed to\nanswer that instance. It is striking how clearly, elegantly, and\nprecisely these classifications have been drawn. \n", "toc": [{"#WhaComPriIntHis": "1. What can be computed in principle? Introduction and History"}, {"#TurMac": "2. Turing Machines"}, {"#UniMac": "2.1 Universal Machines"}, {"#HalPro": "2.2 The Halting Problem"}, {"#ComFunEnu": "2.3 Computable Functions and Enumerability"}, {"#UnsHalPro": "2.4 The Unsolvability of the Halting Problem"}, {"#PriRecFun": "3. Primitive Recursive Functions"}, {"#RecFun": "3.1 Recursive Functions"}, {"#ComComFunComPra": "4. Computational Complexity: Functions Computable in Practice"}, {"#RedCom": "4.1 Reductions and Completeness"}, {"#SigCom": "4.2 Significance of Complexity"}, {"#Bib": "Bibliography"}, {"#Aca": "Academic Tools"}, {"#Oth": "Other Internet Resources"}, {"#Rel": "Related Entries"}], "main_text": "\n1. What can be computed in principle? Introduction and History\n\n\nIn the 1930\u2019s, well before there were computers, various\nmathematicians from around the world invented precise, independent\ndefinitions of what it means to be computable. Alonzo Church defined\nthe Lambda calculus, Kurt G\u00f6del defined Recursive functions,\nStephen Kleene defined Formal systems, Markov defined what became known\nas Markov algorithms, Emil Post and Alan Turing defined abstract\nmachines now known as Post machines and Turing machines.\n\n\nSurprisingly, all of these models are exactly equivalent: anything\ncomputable in the lambda calculus is computable by a Turing machine and\nsimilarly for any other pairs of the above computational systems. After\nthis was proved, Church expressed the belief that the intuitive notion\nof \u201ccomputable in principle\u201d is identical to the above precise notions.\nThis belief, now called the \u201cChurch-Turing Thesis\u201d, is uniformly\naccepted by mathematicians.\n\n\nPart of the impetus for the drive to codify what is computable came\nfrom the mathematician David Hilbert. Hilbert believed that all of\nmathematics could be precisely axiomatized. Once this was\ndone, there would be an \u201ceffective procedure\u201d, i.e., an algorithm that\nwould take as input any precise mathematical statement, and, after a\nfinite number of steps, decide whether the statement was true or false.\nHilbert was asking for what would now be called a decision\nprocedure for all of mathematics.\n\n\nAs a special case of this decision problem, Hilbert considered the\nvalidity problem for first-order logic. First-order logic is a\nmathematical language in which most mathematical statements can be\nformulated. Every statement in first-order logic has a precise meaning\nin every appropriate logical structure, i.e., it is true or false in\neach such structure. Those statements that are true in every\nappropriate structure are called valid. Those statements that\nare true in some structure are called satisfiable. Notice that\na formula, \\(\\varphi\\), is valid iff its negation, \\(\\neg \\varphi\\), is not\nsatisfiable.\n\n\nHilbert called the validity problem for first-order logic, the\nentscheidungsproblem. In a textbook, Principles of\nMathematical Logic by Hilbert and Ackermann, the authors wrote,\n\u201cThe Entscheidungsproblem is solved when we know a procedure that\nallows for any given logical expression to decide by finitely many\noperations its validity or satisfiability.\u2026 The\nentscheidungsproblem must be considered the main problem of\nmathematical logic.\u201d (B\u00f6erger, Gr\u00e4del, & Gurevich\n1997).\n\n\nIn his 1930 Ph.D. thesis, G\u00f6del presented a complete\naxiomatization of first-order logic, based on the Principia\nMathematica by Whitehead and Russell (G\u00f6del 1930). G\u00f6del proved his\nCompleteness Theorem, namely that a formula is provable from the axioms\nif and only if it is valid. G\u00f6del\u2019s Completeness theorem was a\nstep towards the resolution of Hilbert\u2019s\nentscheidungsproblem.\n\n\nIn particular, since the axioms are easily recognizable, and rules\nof inference very simple, there is a mechanical procedure that can list\nout all proofs. Note that each line in a proof is either an axiom, or\nfollows from previous lines by one of the simple rules. For any given\nstring of characters, we can tell if it is a proof. Thus we can\nsystematically list all strings of characters of length 1, 2, 3, and so\non, and check whether each of these is a proof. If so, then we can add\nthe proof\u2019s last line to our list of theorems. In this way, we can list\nout all theorems, i.e., exactly all the valid formulas of first-order\nlogic, can be listed out by a simple mechanical procedure. More\nprecisely, the set of valid formulas is the range of a computable\nfunction. In modern terminology we say that the set of valid formulas\nof first-order logic is recursively enumerable (r.e.).\n\n\nG\u00f6del\u2019s Completeness theorem was not sufficient, however, to\ngive a positive solution to the entscheidungsproblem. Given a\nformula, \\(\\varphi\\), if \\(\\varphi\\) is valid then the above procedure would\neventually list it out and thus could answer, \u201cYes, \\(\\varphi\\) is valid.\u201d\nHowever, if \\(\\varphi\\) were not valid then we might never find this fact\nout. What was missing was a procedure to list out all the non-valid\nformulas, or equivalently to list out all satisfiable formulas.\n\n\nA year later, in 1931, G\u00f6del shocked the mathematical world by\nproving his Incompleteness Theorem: there is no complete and computable\naxiomatization of the first-order theory of the natural numbers. That\nis, there is no reasonable list of axioms from which we can prove\nexactly all true statements of number theory (G\u00f6del 1931).\n\n\nA few years later, Church and Turing independently proved that the\nentscheidungsproblem is unsolvable. Church did this by using\nthe methods of G\u00f6del\u2019s Incompleteness Theorem to show that the set\nof satisfiable formulas of first-order logic is not r.e., i.e., they\ncannot be systematically listed out by a function computable by the\nlambda calculus. Turing introduced his machines and proved many\ninteresting theorems some of which we will discuss in the next section.\nIn particular, he proved the unsolvability of the halting\nproblem. He obtained the unsolvability of the\nentscheidungsproblem as a corollary.\n\n\nHilbert was very disappointed because his program towards a decision\nprocedure for all of mathematics was proved impossible. However, as we\nwill see in more detail in the rest of this article, a vast amount was\nlearned about the fundamental nature of computation.\n2. Turing Machines\n\n\nIn his 1936 paper, \u201cOn Computable Numbers, with an Application to\nthe Entscheidungsproblem\u201d, Alan Turing introduced his machines and\nestablished their basic properties.\n\n\nHe thought clearly and abstractly about what it would mean for a\nmachine to perform a computational task. Turing defined his machines to\nconsist of the following:\n\na finite set, \\(Q\\), of possible states, because any device\nmust be in one of finitely many possible states;\na potentially infinite tape, consisting of consecutive cells,\n\\(\\sigma_{1}, \\sigma_{2}, \\sigma_{3}\\), from\nsome finite alphabet, \\(\\Sigma\\);\n\n \\((\\Sigma\\) may be any finite set containing at least two symbols. It is\nconvenient to fix \\(\\Sigma = \\{0, 1, b\\}\\) consisting of the binary\nalphabet plus the blank cell symbol. We usually assume that a finite\ninitial segment of the tape contains binary symbols, and the rest is\nblank.)\na read/write tape head, \\(h \\ge 1\\), scanning tape cell\n\\(\\sigma_{h}\\); and finally,\na transition function, \\(\\delta : Q \\times \\Sigma \\rightarrow Q\n\\times \\Sigma \\times \\{-1,0,1\\}\\).   (The meaning of the\ntransition function is that from any given state, \\(q\\), looking at\nany given symbol, \\(\\sigma_{h}, \\delta\\) tells us the new state the\nmachine should enter, the new symbol that should be written in the\ncurrent square, and the new head position, \\(h' = h + d\\), where \\(d\n\\in \\{-1,0,1\\}\\) is the displacement given by \\(\\delta\\).)\n\n\n\nThe linear nature of its memory tape, as opposed to random access\nmemory, is a limitation on computation speed but not power: a Turing\nmachine can find any memory location, i.e., tape cell, but this may be\ntime consuming because it has to move its head step by step along its\ntape.\n\n\nThe beauty of Turing machines is that the model is extremely simple,\nyet nonetheless, extremely powerful. A Turing machine has potentially\ninfinite work space so that it can process arbitrarily large inputs,\ne.g., multiply two huge numbers, but it can only read or write a\nbounded amount of information, i.e., one symbol, per step. Even before\nTuring machines and all the other mathematical models of computation\nwere proved equivalent, and before any statement of the Church-Turing\nthesis, Turing argued convincingly that his machines were as powerful\nas any possible computing device.\n2.1 Universal Machines\n\n\nEach Turing machine can be uniquely described by its transition\ntable: for each state, \\(q\\), and each symbol, \\(\\sigma ,\n\\delta(q,\\sigma)\\) is the new state, the new symbol, and the\nhead displacement. These transition tables, can be written as a finite\nstring of symbols, giving the complete set of instructions of each\nTuring machine. Furthermore, these strings of symbols can be listed in\nlexicographic order as follows: \\(M_{1},\nM_{2}, M_{3},\\ldots\\), where\n\\(M_{i}\\) is the transition table, i.e., the complete set\nof instructions, for Turing machine number \\(i\\). The transition\ntable for \\(M_{i}\\) is the program for Turing machine\n\\(i\\), or more simply, the \\(i\\)th program.\n\n\nTuring showed that he could build a Turing machine, \\(U\\), that\nwas universal, in the sense that it could run the program of\nany other Turing machine. More explicitly, for any \\(i\\), and any\ninput \\(w, U\\) on inputs \\(i\\) and \\(w\\) would\ndo exactly what \\(M_{i}\\) would do on input \\(w\\), in\nsymbols,\n\n\\[\nU(i,w) = M_{i}(w)\n\\]\n\n\n\nTuring\u2019s construction of a universal machine gives the most\nfundamental insight into computation: one machine can run any program\nwhatsoever. No matter what computational tasks we may need to perform\nin the future, a single machine can perform them all. This is the\ninsight that makes it feasible to build and sell computers. One\ncomputer can run any program. We don\u2019t need to buy a new computer every\ntime we have a new problem to solve. Of course, in the age of personal\ncomputers, this fact is such a basic assumption that it may be\ndifficult to step back and appreciate it.\n2.2 The Halting Problem\n\n\nBecause they were designed to embody all possible computations,\nTuring machines have an inescapable flaw: some Turing machines on\ncertain inputs never halt. Some Turing machines do not halt for silly\nreasons, for example, we can mis-program a Turing machine so that it\ngets into a tight loop, for example, in state 17 looking at a 1 it\nmight go to state 17, write a 1 and displace its head by 0. Slightly\nless silly, we can reach a blank symbol, having only blank symbols to\nthe right, and yet keep staying in the same state, moving one step to\nthe right, and looking for a \u201c1\u201d. Both of those cases of non-halting\ncould be easily detected and repaired by a decent compiler. However,\nconsider the Turing machine \\(M_{F}\\), which on\ninput \u201c0\u201d, systematically searches for the first counter-example to\nFermat\u2019s last theorem, and upon finding it outputs the counter-example\nand halts. Until Andrew Wiles relatively recently proved Fermat\u2019s Last\nTheorem, all the mathematicians in the world, working for over three\ncenturies, were unable to decide whether or not\n\\(M_{F}\\) on input \u201c0\u201d eventually halts. Now we\nknow that it never does.\n2.3 Computable Functions and Enumerability\n\n\nSince a Turing machine might not halt on certain inputs, we have to\nbe careful in how we define functions computable by Turing machines.\nLet the natural numbers, \\(\\mathbf{N}\\), be the set\n\\(\\{0,1,2,\\ldots \\}\\) and let us consider Turing machines as partial\nfunctions from \\(\\mathbf{N}\\) to \\(\\mathbf{N}\\).\n\n\nLet \\(M\\) be a Turing machine and \\(n\\) a natural number.\nWe say that \\(M\\)\u2019s tape contains the number\n\\(n\\), if \\(M\\)\u2019s tape begins with a binary\nrepresentation of the number \\(n\\) (with no unnecessary leading\n0\u2019s) followed by just blank symbols from there on.\n\n\nIf we start the Turing machine \\(M\\) on a tape containing\n\\(n\\) and it eventually halts with its tape containing \\(m\\),\nthen we say that \\(M\\) on input \\(n\\), computes \\(m:\nM(n) = m\\). If, when we start \\(M\\) on\ninput \\(n\\), it either never halts, or when it halts, its tape\ndoes not contain a natural number, e.g., because it has leading 0\u2019s, or\ndigits interspersed with blank symbols, then we say that\n\\(M(n)\\) is undefined, in symbols: \\(M(n)\n=\\nearrow\\).\n We can thus\nassociate with each Turing machine, \\(M\\), a partial\nfunction, \\(M: \\mathbf{N} \\rightarrow \\mathbf{N} \\cup \\{\\nearrow\\}\\). We say that\nthe function \\(M\\) is total if for all\n\\(n\\in \\mathbf{N}\\), \\(M(n) \\in \\mathbf{N}\\), i.e., M\\((n)\\) is always defined.\n\n\nNow we can formally define what it means for a set to be\nrecursively enumerable (r.e.) which we earlier described\ninformally. Let \\(S \\subseteq \\mathbf{N}\\). Then \\(S\\)\nis r.e. if and only if there is some Turing machine, \\(M\\), such\nthat \\(S\\) is the image of the function computed by \\(M\\), in\nsymbols,\n\n\\[\nS = \\{M(n) \\mid n \\in \\mathbf{N}; M(n) \\ne\\nearrow\\}.\n\\]\n\n\n\nThus, \\(S\\) is r.e. just if it can be listed out by some Turing\nmachine. Suppose that \\(S\\) is r.e. and its elements are\nenumerated by Turing machine \\(M\\) as above. We can then describe\nanother Turing machine, \\(P\\), which, on input \\(n\\), runs\n\\(M\\) in a round-robin fashion on all its possible inputs until\neventually \\(M\\) outputs \\(n\\). If this happens then\n\\(P\\) halts and outputs \u201c1\u201d, i.e., \\(P(n)=1\\). If\n\\(n \\not\\in S\\), then\n\\(M\\) will never output \\(n\\), so \\(P(n)\\) will\nnever halt, i.e., \\(P(n)=\\nearrow\\).\n\n\n\nLet the notation \\(P(n)\\downarrow\\) mean that Turing\nmachine \\(P\\) on input \\(n\\) eventually halts. For a Turing\nmachine, \\(P\\), define \\(L(P)\\), the set\naccepted by \\(P\\), to be those numbers \\(n\\) such that\n\\(P\\) on input \\(n\\) eventually halts,\n\n\\[\nL(P) = \\{n \\mid P(n)\\downarrow \\}.\n\\]\n\n\n\nThe above argument shows that if a set \\(S\\) is r.e. then it is\naccepted by some Turing machine, \\(P\\), i.e., \\(S = L(P)\\). The\nconverse of this statement holds as well.  That is, \\(S\\) is r.e. if\nand only if it is accepted by some Turing machine, \\(P\\).\n\n\nWe say that a set, \\(S\\), is decidable if and only if there\nis a total Turing machine, \\(M\\), that decides for all \\(n \\in\n\\mathbf{N}\\) whether or not \\(n \\in S\\). Think of \u201c1\u201d as\n\u201cyes\u201d and \u201c0\u201d as \u201cno\u201d. For all\n\\(n\\in \\mathbf{N}\\), if \\(n \\in S\\), then \\(M(n) = 1\\), i.e., \\(M\\) on\ninput \\(n\\) eventually halts and outputs \u201cyes\u201d, whereas if\n\\(n \\not\\in S\\), then \\(M(n) = 0\\), i.e., \\(M\\) on input \\(n\\)\neventually halts and outputs \u201cno\u201d. Synonyms for decidable\nare:\ncomputable, solvable, and recursive.\n\n\nFor \\(S \\subseteq \\mathbf{N}\\), the complement of\n\\(S\\) is \\(\\mathbf{N} - S\\), i.e., the set of all\nnatural numbers not in \\(S\\). We say that the set \\(S\\) is\nco-r.e. if and only if its complement is r.e. If a set,\n\\(S\\), is r.e. and co-r.e. then we can list out all of its\nelements in one column and we can list out all of its non-elements in a\nsecond column. In this way we can decide whether or not a given\nelement, \\(n\\), is in \\(S\\): just scan the two columns and\nwait for \\(n\\) to show up. If it shows up in the first column then\n\\(n \\in S\\). Otherwise it will show up in the second\ncolumn and \\(n \\not\\in S\\).\nIn fact, a set is recursive iff it is r.e. and co-r.e.\n2.4 The Unsolvability of the Halting Problem\n\n\nTuring asked whether every set of natural numbers is decidable. It\nis easy to see that the answer is, \u201cno\u201d, by the following counting\nargument. There are uncountably many subsets of \\(\\mathbf{N}\\), but\nsince there are only countably many Turing machines, there can be only\ncountably many decidable sets. Thus almost all sets are\nundecidable.\n\n\nTuring actually constructed a non-decidable set. As we will see, he\ndid this using a diagonal argument. The diagonal argument goes back to\nGeorg Cantor who used it to show that the real numbers are uncountable.\nG\u00f6del used a similar diagonal argument in his proof of the\nIncompleteness Theorem in which he constructed a sentence, \\(J\\),\nin number theory whose meaning could be understood to be, \u201c\\(J\\)\nis not a theorem.\u201d\n\n\nTuring constructed a diagonal halting set, \\(K\\), as\nfollows:\n\n\\[\nK = \\{n \\mid M_{n}(n)\\downarrow \\}.\n\\]\n\n\n\nThat is, \\(K\\) consists of those Turing machines that\neventually halt when input their own programs.\n\n\nIt is not hard to see that \\(K\\) is r.e. Suppose for the sake\nof a contradiction that \\(K\\) is also co-r.e., and let \\(d\\)\nbe the number of a Turing machine that accepts the complement of\n\\(K\\). That is, for any \\(n\\),\n\n\\[\nn \\not\\in K \\Leftrightarrow M_{d}(n)\\downarrow\n\\]\n\n\n\nBut consider what happens when we substitute \\(d\\) for\n\\(n\\) in the above equation:\n\n\\[\nd \\not\\in K \\Leftrightarrow M_{d}(d)\\downarrow.\n\\]\n\n\n\nHowever, the definition of \\(K\\) tells us that:\n\n\\[\nd \\in K \\Leftrightarrow M_{d}(d)\\downarrow .\n\\]\n\n\n\nThus we have that\n\n\\[\nd \\in K \\Leftrightarrow d \\not\\in K,\n\\]\n\n\n\nwhich is a contradiction. Thus our assumption that \\(K\\) is\nco-r.e. is false. Thus \\(K\\) is not recursive. It follows that it\nis not a computable problem to be given a Turing machine and its input\nand to decide whether or not the Turing machine will eventually halt on\nthat input, i.e., the halting problem is unsolvable.\n3. Primitive Recursive Functions\n\n\nWe next define the class of Primitive Recursive Functions.\nThis is a very interesting class of functions \ndescribed a in paper by Skolem (1923) and used by\nG\u00f6del in\nhis proof of the Incompleteness Theorem. We are interested in\nfunctions \\(f\\) from \\(\\mathbf{N}^{r}\\) to\n\\(\\mathbf{N}\\), for \\(r = 0, 1, 2,\\ldots\\) . Here\n\\(r\\) is called the arity of the function \\(f\\), i.e., the\nnumber of arguments that it takes. G\u00f6del started with three very\nsimple functions, the initial functions, and two natural closure\noperations, composition and primitive recursion, each of which take\nsome already defined functions and use them to define a new one. We\nnext explain his definitions in detail. This section is technical and\ncan be safely skipped. The important idea is that the primitive\nrecursive functions comprise a very large and powerful class of\ncomputable functions, all generated in an extremely simple way.\n\n\nWe begin with the three initial primitive recursive\nfunctions:\n\n\\(\\zeta\\), the zero function of arity \\(0, \\zeta\\)(\u00a0) \\(= 0\\);\n\\(\\eta\\), the identity function of arity \\(1, \\eta(n) = n\\); and,\n\\(\\sigma\\), the successor function of arity \\(1, \\sigma(n) = n +1\\).\n\n\n\nNow consider the following two operations:\n\nComposition: if \\(f\\) is a primitive recursive\nfunction of arity \\(a\\), and \\(g_{1}, \\ldots ,g_{a}\\) are primitive\nrecursive functions of arities \\(r_{1}, \\ldots ,r_{a}\\), and \\(k\\in\n\\mathbf{N}\\), then the following is a primitive recursive function of\narity \\(k\\):\n\n\\[\nh(x_{1}, \\ldots ,x_{k}) = f(g_{1}(w_{1}), \\ldots ,g_{a}(w_{a})),\n\\]\n\n\n\nwhere each \\(w_{i}\\) is a list of \\(r_{i}\\) arguments, perhaps with\nrepetition, from \\(x_{1}, \\ldots ,x_{k}\\); and,\nPrimitive recursion: if \\(f\\) and \\(g\\)\nare primitive recursive functions of arity \\(k\\) and \\(k+2\\),\nrespectively, then there is a primitive recursive function, \\(h\\),\nof arity \\(k+1\\) satisfying the following conditions: \n\n\\[\\begin{align}\n\n h(0,x_{1},\\ldots ,x_{k}) &= f(x_{1},\\ldots ,x_{k}); \\text{ and,} \\\\\n\n h(n+1,x_{1},\\ldots ,x_{k}) &= g(h(n,x_{1},\\ldots ,x_{k}), n,x_{1},\\ldots ,x_{k}).\n\n\\end{align}\\]\n\n\n\nHere composition is the natural way to combine functions, and\nprimitive recursion is a restricted kind of recursion in which\n\\(h\\) with first argument \\(n+1\\) is defined in terms of\n\\(h\\) with first argument \\(n\\), and all the other arguments\nunchanged. \n\n\nDefine the primitive recursive functions to be the smallest\nclass of functions that contains the Initial functions and is closed\nunder Composition and Primitive Recursion. The set of primitive\nrecursive functions is equal to the set of functions computed using\nbounded iteration (Meyer & Ritchie 1967), i.e. the set of\nfunctions definable in the language Bloop from (Hofstadter 1979).\n\n\nThe primitive recursive functions have a very simple definition and\nyet they are extremely powerful. G\u00f6del proved inductively that\nevery primitive recursive function can be simply represented in\nfirst-order number theory. He then used the primitive recursive\nfunctions to encode formulas and even sequences of formulas by numbers.\nHe finally used the primitive recursive functions to compute properties\nof the represented formulas including that a formula is well formed and that a\nsequence of formulas is a proof.\n\n\nIt takes a long series of lemmas to show how powerful the primitive\nrecursive functions are. The following are a few examples showing that\naddition, multiplication, and exponentiation are primitive\nrecursive.\n\n\nDefine the addition function, \\(P(x,y)\\), as\nfollows:\n\n\\[\\begin{align}\n   P(0,y)  &= \\eta(y) \\\\\n  P(n+1,y) &= \\sigma(P(n,y))\n\\end{align}\\]\n\n\n\n(Note that this fits into the definition of primitive recursion\nbecause the function \\(g(x_{1},x_{2},x_{3}) = \\eta(\\sigma(x_{1}))\\) is\ndefinable from the initial functions \\(\\eta\\) and \\(\\sigma\\) by\ncomposition.)\n\n\nNext, define the multiplication function,\n\\(T(x,y)\\), as follows:\n\n\\[\\begin{align}\n   T(0,y) &= \\zeta(\\ ) \\\\\n T(n+1,y) &= P(T(n,y),y).\n\\end{align}\\]\n\n\n\nNext, we define the exponential function,\n\\(E(x,y)\\). (Usually \\(0^{0}\\) is\nconsidered undefined, but since primitive recursive functions must be\ntotal, we define \\(E\\)(0,0) to be 1.) Since\nprimitive recursion only allows us to recurse on the first argument,\nwe use two steps to define the exponential function:\n\n\\[\\begin{align}\n  R(0,y) &= \\sigma(\\zeta(\\ )) \\\\\nR(n+1,y) &= T(R(n,y),y).\n\\end{align}\\]\n\n\n\nFinally we can define \\(E(x,y) = R(\\eta(y),\\eta(x))\\) by\ncomposition. (Recall that \\(\\eta\\) is the identity function so this\ncould be more simply written as \\(E(x,y) = R(y,x)\\).)\n\n\nThe exponential function, \\(E\\), grows very rapidly, for\nexample, \\(E\\)(10,10) is ten billion, and \\(E\\)(50,50) is\nover \\(10^{84}\\) (and thus significantly more than the estimated\nnumber of atoms in the universe). However, there are much faster\ngrowing primitive recursive functions. As we saw, \\(E\\) was\ndefined from the slowly growing function, \\(\\sigma\\), using three\napplications of primitive recursion: one for addition, one for\nmultiplication, and then one more for exponentiation. We can continue\nto apply primitive recursion to build a series of unimaginably fast\ngrowing functions. Let\u2019s do just one more step in the series defining\nthe hyper-exponential function, \\(H(n,m)\\) as 2\nto the 2 to the 2 to the \u2026 to the \\(m\\), with a tower of\n\\(n\\) 2s. \\(H\\) is primitive recursive because it can be\ndefined from \\(E\\) using one more application of primitive\nrecursion:\n\n\\[\\begin{align}\n  H(0,y) &= y \\\\\nH(n+1,y) &= E(2,H(n,y))\n\\end{align}\\]\n\n\n\nThus \\(H(2,2) = 2^{4} = 16, H(3,3) = 2^{256}\\) is more than\n\\(10^{77}\\) and comparable to the number of atoms in the universe. If\nthat\u2019s not big enough for you then consider \\(H(4,4)\\). To write\nthis number in decimal notation we would need a one, followed by more\nzero\u2019s than the number of particles in the universe.\n3.1 Recursive Functions\n\n\nThe set of primitive recursive functions is a huge class of\ncomputable functions. In fact, they can be characterized as the set of\nfunctions computable in time that is some primitive recursive function\nof \\(n\\), where \\(n\\) is the length of the input. For\nexample, since \\(H(n,n)\\) is a primitive\nrecursive function, the primitive recursive functions include all of\nTIME[\\(H(n,n)\\)]. (See the next section for a\ndiscussion of computational complexity, including TIME.) Thus, the\nprimitive recursive functions include all functions that are feasibly\ncomputable by any conceivable measure of feasible, and much beyond\nthat.\n\n\nHowever, the primitive recursive functions do not include all\nfunctions computable in principle. To see this, we can again use\ndiagonalization. We can systematically encode all definitions of\nprimitive recursive functions of arity 1, calling them\n\\(p_{1}, p_{2}, p_{3}\\),\nand so on.\n\n\nWe can then build a Turing machine to compute the value of the\nfollowing diagonal function, \\(D(n) = p_{n}(n) + 1\\).\n\n\nNotice that \\(D\\) is a total, computable function from\n\\(\\mathbf{N}\\) to \\(\\mathbf{N}\\), but it is not primitive\nrecursive. Why? Suppose for the sake of a contradiction that \\(D\\)\nwere primitive recursive. Then \\(D\\) would be equal to\n\\(p_{d}\\) for some \\(d\\in \\mathbf{N}\\). But it would then follow that\n\n\\[\np_{d}(d) = p_{d}(d) +1,\n\\]\n\n\n\nwhich is a contradiction. Therefore, \\(D\\) is not primitive\nrecursive.\n\n\nAlas, the above diagonal argument works on any class of total\nfunctions that could be considered a candidate for the class of all\ncomputable functions. The only way around this, if we want all\nfunctions computable in principle, not just in practice, is to add some\nkind of unbounded search operation. This is what G\u00f6del did to\nextend the primitive recursive functions to the recursive\nfunctions.\n\n\nDefine the unbounded minimization operator, \\(\\mu\\), as follows. Let\n\\(f\\) be a perhaps partial function of arity \\(k+1\\). Then\n\\(\\mu[f\\)] is defined as the following function of arity k. On\ninput \\(x_{1}, \\ldots ,x_{k}\\) do the\nfollowing:\n\nFor \\(i = 0\\) to \\(\\infty\\) do \\(\\{\\)\nif \\(f(i,x_{1},\\ldots ,x_{k}) = 1\\), then output \\(i\\)\n\n\\(\\}\\)\n\n\n\nThus if \\(f(i,x_{1},\\ldots ,x_{k}) = 1\\), and for all \\(j \\lt i,\nf(j,x_{1},\\ldots ,x_{k})\\) is defined, but not equal to 1, then \\(\\mu\n[f](x_{1}, \\ldots ,x_{k}) = i\\). Otherwise \\(\\mu[f](x_{1}, \\ldots\n,x_{k})\\) is undefined.\n\n\nG\u00f6del defined the set of Recursive functions to be the\nclosure of the initial primitive recursive functions under composition,\nprimitive recursion, and \\(\\mu\\) . With this definition, the Recursive\nfunctions are exactly the same as the set of partial functions\ncomputable by the Lambda calculus, by Kleene Formal systems, by Markov\nalgorithms, by Post machines, and by Turing machines.\n4. Computational Complexity: Functions Computable in Practice\n\n\nDuring World War II, Turing helped design and build a specialized\ncomputing device called the Bombe at Bletchley Park. He used the Bombe\nto crack the German \u201cEnigma\u201d code, greatly aiding the\nAllied cause [Hodges, 1992]. By the 1960\u2019s computers were widely\navailable in industry and at universities. As algorithms were\ndeveloped to solve myriad problems, some mathematicians and scientists\nbegan to classify algorithms according to their efficiency and to\nsearch for best algorithms for certain problems. This was the\nbeginning of the modern theory of computation.\n\n\nIn this section we are dealing with complexity instead of\ncomputability, and all the Turing machines that we consider will halt\non all their inputs. Rather than accepting by halting, we will assume\nthat a Turing machine accepts by outputting \u201c1\u201d and rejects by\noutputting \u201c0\u201d, thus we redefine the set accepted by a total machine,\n\\(M\\),\n\n\\[\nL(M) = \\{n \\mid M(n) = 1\\}.\n\\]\n\n\n\nThe time that an algorithm takes depends on the input and the\nmachine on which it is run. The first important insight in complexity\ntheory is that a good measure of the complexity of an algorithm is its\nasymptotic worst-case complexity as a function of the size of the\ninput, \\(n\\).\n\n\nFor an input, \\(w\\), let \\(n = \\lvert w\\rvert\\) be the length of\n\\(w\\). Following [Hartmanis, 1989] we say that a Turing machine\n\\(M\\) runs in time \\(T(n)\\) if for all \\(w\\) of length \\(n,\nM(w)\\) takes at most \\(T(n)\\) steps and then halts. This is called\nworst-case complexity because \\(T(n)\\) must be as large as the time\ntaken by any input of length \\(n\\).\n\n\nFor any function \\(T : \\mathbf{N} \\rightarrow \\mathbf{N}\\), let\n\n\\[\n\\TIME[T(n)] = \\{ A \\mid A = L(M) \\text{ for some }\n  M \\text{ that runs in time } T(n)\\}.\n\\]\n\n\n\nAlan Cobham and Jack Edmonds identified the complexity class, \\(\\P\\), of\nproblems recognizable in some polynomial amount of time, as being an\nexcellent mathematical wrapper of the class of feasible \nproblems\u2014those problems all of whose moderately-sized instances can be\nfeasibly recognized,\n\n\\[\n \\P = \\bigcup_{i=1,2,\\ldots} \\TIME[n^{i}]\n\\]\n\n\n\nAny problem not in \\(\\P\\) is certainly not feasible. On the other hand,\nnatural problems that have algorithms in \\(\\P\\), tend to eventually have\nalgorithms discovered for them that are actually feasible.\n\n\nMany important complexity classes besides P have been defined and\nstudied; a few of these are \\(\\NP\\), \\(\\PSPACE\\), and \\(\\EXPTIME\\).\n\\(\\PSPACE\\) consists of those problems solvable using some polynomial\namount of memory space. \\(\\EXPTIME\\) is the set of problems solvable in\ntime \\(2^{p(n)}\\) for some polynomial, \\(p\\).\n\n\nPerhaps the most interesting of the above classes is NP:\nnondeterministic polynomial time. The definition comes not from a real\nmachine, but rather a mathematical abstraction. A nondeterministic\nTuring machine, \\(N\\), makes a choice (guess) of one of two\npossible actions at each step. If, on input \\(w\\), some sequence\nof these choices leads to acceptance, then we say that\n\\(\\mathbf{N}\\) accepts \\(w\\), and we say the\nnondeterministic time taken by \\(\\mathbf{N}\\) on input\n\\(w\\), is just the number of steps taken in the sequence that\nleads to acceptance. A nondeterministic machine is not charged for all\nthe other possible choices it might have made, just the single sequence\nof correct choices.\n\n\nNP is sometimes described as the set of problems, \\(S\\), that\nhave short proofs of membership. For example, suppose we are given a\nlist of \\(m\\) large natural numbers: \\(a_{1},\n\\ldots ,a_{m}\\), and a target number,\n\\(t\\). This is an instance of the Subset Sum problem: is there a\nsubset of the \\(m\\) numbers whose sum is exactly \\(t\\)? This\nproblem is easy to solve in nondeterministic linear time: for each\n\\(i\\), we guess whether or not to take \\(a_{i}\\).\nNext we add up all the numbers we decided to take and if the sum is\nequal to \\(t\\) then accept. Thus the nondeterministic time is\nlinear, i.e., some constant times the length of the input, \\(n\\).\nHowever there is no known (deterministic) way to solve this problem in\ntime less than exponential in \\(n\\).\n4.1 Reductions and Completeness\n\n\nThere has been a large study of algorithms and the complexity of\nmany important problems is well understood. In particular reductions\nbetween problems have been defined and used to compare the relative\ndifficulty of two problems. Intuitively, we say that \\(A\\) is\nreducible to \\(B\\)  \\((A \\le B)\\) if there\nis an easy-to-compute transformation, \\(\\tau\\), that maps instances of \\(A\\) to\ninstances of \\(B\\) in a way that preserves membership, i.e.,\n\\(\\tau\\)(w) \\(\\in B \\Leftrightarrow\\) w \\(\\in A\\).\n\n\nRemarkably, a high percentage of naturally occurring computational\nproblems turn out to be complete for one of the above classes. (A\nproblem, \\(A\\), is complete for a complexity class \\(C\\) if\n\\(A\\) is a member of \\(C\\) and all other problems \\(B\\)\nin \\(C\\) are no harder than \\(A\\), i.e., \\(B \\le A\\). Two complete problems for the same class have equivalent\ncomplexity.)\n\n\nThe reason for this completeness phenomenon has not been adequately\nexplained. One plausible explanation is that natural computational\nproblems tend to be universal in the sense of Turing\u2019s universal\nmachine. A universal problem in a certain complexity class can simulate\nany other problem in that class.\n\n\nIn 1971, Cook proved SAT is NP complete [Cook, 1971].  Shortly later, \nKarp showed that many important combinatorial problems were also\nNP complete, thus establishing the importance of the class NP [Karp, 1972].\n\n\n\nOur definition of reduction above lacked precision, just saying that the mapping \\(\\tau\\) must by\neasy-to-compute.  The reductions that Karp used were polynomial-time reductions, i.e., \\(\\tau\\) is\ncomputable in polynomial time.  \nSince then, many researchers have observed that natural problems\nremain complete for natural complexity classes under surprisingly weak\nreductions including logspace reductions [Jones, 1973], first-order reductions [Immerman, 1999],\nprojections [Valiant, 1982], and first-order projections [Immerman, 1999].\n\n\n\nWith a very few exceptions, when a natural problem is in NP, it turns out to be either NP complete,\nor in P.  People wondered whether this was always the case.  Ladner proved that if P \\(\\ne\\)  NP, then\nthere is an intermediate problem \\(I\\) that is in NP but not in P and not NP complete [Ladner, 1975].\n\n\n\nLadner\u2019s proof method is called delayed diagonalization.  He generalized his result to show that for\nany two well-behaved complexity classes, C, E such that C is strictly contained in E, there is an\nintermediate class, D such that C is strictly contained in D and D is strictly contained in E.  Thus\nthe ordering of complexity classes is dense.\n\n\n\nHowever, these intermediate problems don\u2019t tend to show up.   This phenomenon has received a great deal of\nattention recently via the dichotomy conjecture of Feder and Vardi [Feder and Vardi, 1999].\nSchaefer introduced this work with an insightful paper in which he studied all\nvariants of the boolean satisfiability problem [Schaefer, 1978].   He proved that each such problem\n    was either NP \ncomplete or in P, thus Ladner\u2019s intermediate problems\ncannot occur among such satisfiability problems.  Since there were just these two possibilities,\nSchaefer called this a dichotomy. \n\n\n\nIn fact, if one looks closer, all of Schaefer\u2019s satisfiability problems are either NP complete, P\ncomplete, \\(\\oplus\\)L complete, NL complete, L complete, or trivial [Allender et al., 2009].  That is the\nnon-trivial problems \nin P may be P complete, or complete for one of these three complexity classes within P.  In other\nwords, if we look closer, the NP/P dichotomy phenomenon problem is really a \u201cmulti-chotomoy\u201d\nphenomenon, namely all non-trivial satisfiability problems are complete for one of five well-known\ncomplexity classes.\n\n\n\nFeder and Vardi studied Schaefer\u2019s dichotomy and conjectured that it holds for all finite-domain\nConstraint Satisfaction Problems (CSP) [Feder and Vardi, 1999].\nA finite-domain CSP, C, consists of a finite domain, D, and a finite set of relations \\(R_1,\n\\ldots , R_k\\) over D.  An instance of C consists of a set of variables, \\(v_1, \\ldots v_n\\)\nand a conjunction of atoms \\(\\varphi  \\equiv \\bigwedge R_i(v_{j_1}, \\ldots)\\).\nThe answer to the instance, \\(\\varphi\\), is \u201cyes\u201d, i.e., \\(\\varphi \\in C\\) iff there is an assignment of the\nvariables to elements of the domain, D, so that \\(\\varphi\\) is satisfied.\n\n\n\nWith domains of size 2, a CSP problem is just a satisfiability problem, so Schaefer\u2019s theorem\nalready established the Feder and Vardi conjecture for this case.\nA simple instance of a CSP with domain size 3 is the 3COLOR problem for undirected graphs.  Given such a\ngraph, G, can the vertices of G be colored one of three colors so that no two adjacent vertices have\nthe same color?  To write this as a CSP, let \\(D = \\{R,Y,B\\}\\) be a set of three distinct colors and\nlet the relation \\(N\\) be the not-equal relation  on \\(D\\).  Then from \\(G=(V,E)\\) the instance of 3COLOR\nis\n\\[ \\varphi_G \\quad = \\quad \\bigwedge_{(u,v)\\in E} N(u,v)\\; .\\]\nNote that \\(\\varphi_G\\) says that whenever there is an edge in \\(G\\) between vertices \\(u\\) and \\(v\\), then \\(u\\)\nand \\(v\\) are assigned different colors.\n\n\n\nFeder and Vardi\u2019s conjecture led to an extremely productive research program.  \nIn particular, a rich algebraic theory of CSPs was developed in a number of papers starting with\n[Jeavons et al. 1997]; see [Bulatov, 2018] for a survey.\nEventually, by applying and advancing this algebraic theory, Bulatov and Zhuk independently proved\nthe Feder and\nVardi conjecture [Bulatov, 2017; Zhuk, 2017]. \n\n4.2 Significance of Complexity\n\n\nThe reason that the class NP is so\nwell studied is that a large number of important practical problems are\nNP complete, including Subset Sum. None of these problems is known to\nhave an algorithm that is faster than exponential time, although some\nNP-complete problems admit feasible approximations to their\nsolutions.\n\n\nA great deal remains open about computational complexity. We know that\nstrictly more of a particular computational resource lets us solve\nstrictly harder problems, e.g. \\(\\TIME[n]\\) is strictly contained in\n\\(\\TIME[n^{1.01}]\\) and similarly for \\(\\SPACE\\) and other\nmeasures. However, the trade-offs between different computational\nresources is still quite poorly understood. It is obvious that \\(\\P\\)\nis contained in \\(\\NP\\). Furthermore, \\(\\NP\\) is contained in\n\\(\\PSPACE\\) because in \\(\\PSPACE\\) we can systematically try every\nsingle branch of an \\(\\NP\\) computation, reusing space for the\nsuccessive branches, and accepting if any of these branches lead to\nacceptance. \\(\\PSPACE\\) is contained in \\(\\EXPTIME\\) because if a\n\\(\\PSPACE\\) machine takes more than exponential time, then it has\nexactly repeated some configuration so it must be in an infinite\nloop. The following are the known relationships between the above\nclasses:\n\n\\[\n\\P \\subseteq \\NP \\subseteq \\PSPACE \\subseteq \\EXPTIME\n\\]\n\n\n\nHowever, while it seems clear that \\(\\P\\) is strictly contained in\n\\(\\NP\\), that \\(\\NP\\) is strictly contained in \\(\\PSPACE\\), and that\n\\(\\PSPACE\\) is strictly contained in \\(\\EXPTIME\\), none of these\ninequalities has been proved. In fact, it is not even known that\n\\(\\P\\) is different from \\(\\PSPACE\\), nor that \\(\\NP\\) is different\nfrom \\(\\EXPTIME\\). The only known proper inclusion from the above is\nthat \\(\\P\\) is strictly contained in \\(\\EXPTIME\\). The remaining\nquestions concerning the relative power of different computational\nresources are fundamental unsolved problems in the theory of\ncomputation.\n\n\nThe following diagram  maps out all the\ncomplexity classes we have discussed and a few more as well.  The diagram comes from work in\nDescriptive Complexity [Immerman, 1999] which \nshows that all important complexity \nclasses have descriptive characterizations.  Fagin began this field by proving that NP = \nSO\\(\\exists\\), i.e., a property is in NP iff it is expressible in second-order existential logic\n[Fagin, 1974].\n\n\nVardi and the author of this entry later independently proved that P =\nFO(LFP): a property is in P iff it is expressible in first-order logic\nplus a least fixed-point operator (LFP) which formalizes the power to\ndefine new relations by induction.  A captivating corollary of this is\nthat P = NP iff SO = FO(LFP).  That is, P is equal to NP iff every\nproperty expressible in second order logic is already expressible in\nfirst-order logic plus inductive definitions. (The languages in\nquestion are over finite ordered input structures.  See [Immerman,\n1999] for details.)\n\n\nThe World of Computability and Complexity\n\n\n\nThe top right of the diagram shows the recursively enumerable (r.e.)\nproblems; this includes r.e.-complete problems such as the halting\nproblem (Halt). On the left is the set of co-r.e. problems including\nthe co-r.e.-complete problem \\(\\overline{{\\rm Halt}}\\) -- the set of\nTuring Machines that never halt on a given input.  We mentioned at the\nend of Section 2.3 that the intersection of the set of r.e problems\nand the set of co-r.e problems is equal to the set of Recursive\nproblems.  The set of Primitive Recursive problems is a strict subset\nof the Recursive problems.\n\n\nMoving toward the bottom of the diagram, there is a region marked with\na green dotted line labelled \u201ctruly feasible\u201d.  Note that\nthis is not a mathematically defined class, but rather an intuitive\nnotion of those problems that can be solved exactly, for all the\ninstances of reasonable size, within a reasonable amount of time,\nusing a computer that we can afford. (Interestingly, as the speed of\ncomputers has dramatically increased over the years, our expectation\nof how large an instance we should be able to handle has increased\naccordingly.  Thus, the boundary of what is \u201ctruly\nfeasible\u201d changes more slowly than the increase of computer\nspeed might suggest.)\n\n\nAs mentioned before, P is a good mathematical wrapper for the set of\nfeasible problems.  There are problems in P requiring \\(n^{1,000}\\)\ntime for problems of size \\(n\\) and thus not feasible.  Nature appears\nto be our friend here, which is to say naturally occurring problems in\nP favor relatively simple algorithms, and \u201cnatural\u201d\nproblems tend to be feasible. The number of steps required for\nproblems of size \\(n\\) tends to be less than \\(c n^k\\) with small\nmultiplicative constants \\(c\\), and very small exponents, \\(k\\), i.e.,\n\\(k\\leq 2\\).\n\n\nIn practice the asymptotic complexity of naturally occurring problems\ntends to be the key issue determining whether or not they are\nfeasible.  A problem with complexity \\(17n\\) can be handled in under a\nminute on modern computers, for every instance of size a\nbillion.  On the other hand, a problem with worst-case complexity\n\\(2^n\\) cannot be handled in our lifetimes for some instance of\nsize a hundred.\n\n\nAs discussed, natural problems tend to be complete for important\ncomplexity classes, namely the ones in the diagram and only a very few\nothers.  This fascinating phenomenon means that algorithms and\ncomplexity are more than abstract concepts; they are important at a\npractical level.  We have had remarkable success in proving that our\nproblem of interest is complete for a well-known complexity class.  If\nthe class is contained in P, then we can usually just look up a known\nefficient algorithm.  Otherwise, we must look at simplifications or\napproximations of our problem which may be feasible.\n\n\nThere is a rich theory of the approximability of NP optimization\nproblems (See [Arora & Barak, 2009]).  For example, the Subset Sum\nproblem mentioned above is an NP-complete problem.  Most likely it\nrequires exponential time to tell whether a given Subset Sum problem\nhas an exact solution.  However, if we only want to see if we can\nreach the target up to a fixed number of digits of accuracy, then the\nproblem is quite easy, i.e., Subset Sum is hard, but very easy to\napproximate.\n\n\nEven the r.e.-complete Halting problem has many important feasible\nsubproblems.  Given a program, it is in general not possible to figure\nout what it does and whether or not it eventually halts.  However,\nmost programs written by programmers or students can be automatically\nanalyzed, optimized and even corrected by modern compilers and model\ncheckers.\n\n\nThe class NP is very important practically and philosophically.  It is\nthe class of problems, \\(S\\), such that any input \\(w\\) is in \\(S\\)\niff there is a proof, \\(p(w)\\), that \\(w\\in S\\) and \\(p(w)\\) is not\nmuch larger than \\(w\\).  Thus, very informally, we can think of NP has\nthe set of intellectual endeavors that may be in reach: if we find the\nanswer to whether \\(w \\in S\\), we can convince others that we have\ndone so.\n\n\nThe boolean satisfiability problem, SAT, was the first problem proved\nNP complete [Cook, 1971], i.e., it is a hardest NP problem.  The fact\nthat SAT is NP complete means that all problems in NP are reducible to\nSAT.  Over the years, researchers have built very efficient SAT\nsolvers which can quickly solve many SAT instances \u2013 i.e., find a\nsatisfying assignment or prove that there is none\n-- even for instances with millions of variables.  Thus, SAT solvers are being used as general purpose\nproblem solvers.  On the other hand, there are known classes of small instances for which current\nSAT solvers fail.  Thus part of the P versus NP question concerns the practical and theoretical\ncomplexity of SAT [Nordstr\u00f6m, 2015].\n\n\nThere is an extensive theory of computational complexity.  This entry\nbriefly describes the area, putting it into the context of the\nquestion of what is computable in principle versus in practice.  For\nreaders interested in learning more about complexity, there are\nexcellent books, for example, [Papadimitriou, 1994] and [Arora and\nBarak, 2009]. There is also the entry on\n Computational Complexity Theory.\n", "bibliography": {"categories": [], "cat_ref_text": {"ref_list": ["Allender, E., M. Bauland, N. Immerman, H. Schnoor and H. Vollmer, 2009, \n\u201cThe Complexity of Satisfiability Problems: Refining Schaefer\u2019s\nTheorem\u201d,  <em>Journal of Computer and System Science</em> 75(4): 245\u2013254.", "Arora, Sanjeev and Boaz Barak, 2009, <em>Computational Complexity:\nA Modern Approach</em>, New York: Cambridge University Press.", "B\u00f6erger, Egon, Erich Gr\u00e4del, and Yuri Gurevich, 1997,\n<em>The Classical Decision Problem</em>, Heidelberg: Springer.", "Bulatov, Andrei, 2017, \u201cA Dichotomy Theorem for Nonuniform\nCSPs\u201d, <em>IEEE 58th Annual Symposium on\nFoundations of Computer Science</em>, 319\u2013330.", "\u2013\u2013\u2013, 2018, \u201cConstraint Satisfaction\nProblems: Complexity and Algorithms\u201d, <em>SIGLOG News</em> 4(5):\n3\u201324.", "Church, Alonzo, 1933, \u201cA Set of Postulates for the\nFoundation of Logic (Second Paper)\u201d, <em>Annals of\nMathematics</em> (Second Series), 33: 839\u2013864.", "\u2013\u2013\u2013, 1936a, \u201cAn Unsolvable Problem of\nElementary Number Theory,\u201d <em>American Journal of\nMathematics</em>, 58: 345\u2013363.", "\u2013\u2013\u2013, 1936b, \u201cA Note on the\nEntscheidungsproblem,\u201d <em>Journal of Symbolic Logic</em>, 1:\n40\u201341; correction 1, 101\u2013102.", "Cobham, Alan, 1964, \u201cThe Intrinsic Computational Difficulty of\nFunctions,\u201d <em>Proceedings of the 1964 Congress for Logic,\nMathematics, and Philosophy of Science</em>, Amsterdam: North-Holland, pp. 24\u201330.", "Cook, Stephen, 1971, \u201cThe Complexity of Theorem Proving\nProcedures,\u201d <em>Proceedings of the Third Annual ACM STOC\nSymposium</em>, Shaker Heights, Ohio, pp. 151\u2013158.", "Davis, Martin, 2000, <em>The Universal Computer: the Road from\nLeibniz to Turing</em>, New York: W. W. Norton &amp; Company.", "Edmonds, Jack, 1965, \u201cPaths, Trees and Flowers,\u201d <em>Canadian\nJournal of Mathematics</em>, 17: 449\u2013467.", "Enderton, Herbert B., 1972, <em>A Mathematical Introduction to\nLogic</em>, New York: Academic Press.", "Fagin, Ronald, 1974, \u201cGeneralized First-Order Spectra and\nPolynomial-Time Recognizable Sets,\u201d in <em>Complexity of\nComputation</em>, R. Karp (ed.), <em>SIAM-AMS Proc</em>, 7:\n27\u201341.", "Feder, Tomas and Moshe Vardi, 1999, \u201cThe Computational\nStructure of Monotone Monadic SNP and Constraint Satisfaction: A Study\nThrough Datalog and Group Theory\u201d, <em>SIAM Journal of\nComputing</em> 28: 57\u2013104.", "Garey, Michael and David S. Johnson, 1979, <em>Computers and\nIntractability</em>, New York: Freeman.", "G\u00f6del, Kurt, 1930, \u201cThe Completeness of the Axioms of the\nFunctional Calculus,\u201d in van Heijenoort 1967: 582\u2013591.", "\u2013\u2013\u2013, 1931, \u201cOn Formally Undecidable Propositions\nof Principia Mathematica and Related Systems I,\u201d in van Heijenoort,\n1967: 592\u2013617.", "Hartmanis, Juris, 1989, \u201cOverview of computational Complexity\nTheory\u201d in J. Hartmanis (ed.), <em>Computational Complexity Theory</em>,\nProvidence: American Mathematical Society, pp. 1\u201317.", "Hilbert and Ackermann, 1928/1938, <em>Grundz\u00fcge der\ntheoretischen Logik</em>, Springer. English translation of the 2nd\nedition: <em>Principles of Mathematical Logic</em>, New York: Chelsea\nPublishing Company, 1950.", "Hodges, Andrew, 1992, <em>Alan Turing: the Enigma</em>, London: Random\nHouse.", "Hofstadter, Douglas, 1979, <em>G\u00f6del, Escher, Bach: an Eternal\nGolden Braid</em>, New York: Basic Books.", "Hopcroft, John E., 1984, \u201cTuring Machines\u201d, <em>Scientific\nAmerican</em>, 250(5): 70\u201380.", "Immerman, Neil, 1999, <em>Descriptive Complexity</em>, New York: Springer.", "Jeavons, P.G., D.A. Cohen and M. Gyssens, 1997, \u201cClosure Properties of\nConstraints\u201d, <em>Journal of the ACM</em>, 44: 527\u2013548.", "Jones, Neil, 1973, \u201cReducibility Among Combinatorial\n    Problems in Log <em>n</em> Space\u201d, <em>Proc. Seventh Annual Princeton Conf. Info. Sci. and Systems</em>, 547\u2013551.", "Karp, Richard, 1972, \u201cReducibility Among Combinatorial\nProblems,\u201d, in <em>Complexity of Computations</em>, R.E. Miller\nand J.W. Thatcher (eds.), New York: Plenum Press, pp. 85\u2013104.", "Kleene, Stephen C., 1935, \u201cA Theory of Positive Integers in\nFormal Logic,\u201d <em>American Journal of Mathematics</em>, 57:\n153\u2013173, 219\u2013244.", "\u2013\u2013\u2013, 1950, <em>Introduction to Metamathematics</em>,\nPrinceton: Van Nostrand.", "Ladner, Richard, 1975, \u201cOn the structure of polynomial time reducibility\u201d, <em>Journal of the ACM</em>, 155\u2013171.", "Levin, Leonid, 1973, \u201cUniversal search\nproblems,\u201d <em>Problemy Peredachi Informatsii</em>, 9(3):\n265\u2013266; partial English translation in B.A.Trakhtenbrot, 1984,\n\u201cA Survey of Russian Approaches to Perebor (Brute-force Search)\nAlgorithms,\u201d <em>IEEE Annals of the History of Computing</em>,\n6(4): 384\u2013400.", "Markov, A.A., 1960, \u201cThe Theory of\nAlgorithms,\u201d <em>American Mathematical Society Translations</em>\n(Series 2), 15: 1\u201314.", "Meyer, Albert and Dennis Ritchie, 1967, \u201cThe Complexity of\nLoop Programs,\u201d <em>Proceedings of the 22nd National ACM\nConference</em>, Washington, D.C., 465\u2013470.", "Nordstr\u00f6m, Jakob, 2015, \u201cOn the Interplay Between Proof\nComplexity and SAT Solving,\u201d SIGLOG News, 2(3): 18\u201344.", "Papadimitriou, Christos H., 1994, <em>Computational\nComplexity</em>, Reading, MA: Addison-Wesley.", "P\u00e9ter, R\u00f3zsa. 1967, <em>Recursive Functions</em>,\ntranslated by Istv\u00e1n F\u00f6ldes, New York: Academic\nPress.", "Post, Emil, 1936, \u201cFinite Combinatory Processes \u2013\nFormulation I,\u201d\n<em>Journal of Symbolic Logic</em>, 1: 103\u2013105.", "Rogers, Hartley Jr., 1967, <em>Theory of Recursive Functions and\nEffective Computability</em>, New York: McGraw-Hill.", "Schaefer, Thomas, 1978, \u201cThe Complexity of Satisfiability\nProblems\u201d, <em>Proceedings of the Tenth Annual ACM STOC\nSymposium</em>, 216\u2013226.", "Skolem, Thoralf, 1923, \u201cThe foundations of elementary\narithmetic established by means of the recursive mode of\nthought,\u201d in van Heijenoort 1967: 302\u201333.", "Turing, A. M., 1936\u20137, \u201cOn Computable Numbers, with an\nApplication to the Entscheidungsproblem\u201d, <em>Proceedings of the\nLondon Mathematical Society</em>, 2(42): 230\u2013265\n[<a href=\"http://www.abelard.org/turpap2/tp2-ie.asp\" target=\"other\">Preprint available online</a>].", " Valiant, Leslie, 1982, \u201cReducibility By Algebraic Projections\u201d, <em>L\u2019Enseignement mathematique</em>, 28(3\u20134): 253\u2013268.", "van Heijenoort, Jean, (ed.), 1967, <em>From Frege To G\u00f6del: A\nSource Book in Mathematical Logic, 1879\u20131931</em>, Cambridge, Massachusetts:\nHarvard University Press.", "Whitehead, Alfred North and Bertrand Russell, 1910\u20131913,\n<em>Principia Mathematica</em>, first edition, Cambridge: Cambridge\nUniversity Press.", " Zhuk, Dmitriy, 2020, \u201cA Proof of CSP Dichotomy Conjecture\u201d,<em> Journal of the ASM</em>, 30: 1\u201378."]}, "raw_text": "<div id=\"bibliography\">\n<h2><a id=\"Bib\">Bibliography</a></h2>\n<ul class=\"hanging\">\n<li>Allender, E., M. Bauland, N. Immerman, H. Schnoor and H. Vollmer, 2009, \n\u201cThe Complexity of Satisfiability Problems: Refining Schaefer\u2019s\nTheorem\u201d,  <em>Journal of Computer and System Science</em> 75(4): 245\u2013254.</li>\n<li>Arora, Sanjeev and Boaz Barak, 2009, <em>Computational Complexity:\nA Modern Approach</em>, New York: Cambridge University Press.</li>\n<li>B\u00f6erger, Egon, Erich Gr\u00e4del, and Yuri Gurevich, 1997,\n<em>The Classical Decision Problem</em>, Heidelberg: Springer.</li>\n<li>Bulatov, Andrei, 2017, \u201cA Dichotomy Theorem for Nonuniform\nCSPs\u201d, <em>IEEE 58th Annual Symposium on\nFoundations of Computer Science</em>, 319\u2013330.</li>\n<li>\u2013\u2013\u2013, 2018, \u201cConstraint Satisfaction\nProblems: Complexity and Algorithms\u201d, <em>SIGLOG News</em> 4(5):\n3\u201324.</li>\n<li>Church, Alonzo, 1933, \u201cA Set of Postulates for the\nFoundation of Logic (Second Paper)\u201d, <em>Annals of\nMathematics</em> (Second Series), 33: 839\u2013864.</li>\n<li>\u2013\u2013\u2013, 1936a, \u201cAn Unsolvable Problem of\nElementary Number Theory,\u201d <em>American Journal of\nMathematics</em>, 58: 345\u2013363.</li>\n<li>\u2013\u2013\u2013, 1936b, \u201cA Note on the\nEntscheidungsproblem,\u201d <em>Journal of Symbolic Logic</em>, 1:\n40\u201341; correction 1, 101\u2013102.</li>\n<li>Cobham, Alan, 1964, \u201cThe Intrinsic Computational Difficulty of\nFunctions,\u201d <em>Proceedings of the 1964 Congress for Logic,\nMathematics, and Philosophy of Science</em>, Amsterdam: North-Holland, pp. 24\u201330.</li>\n<li>Cook, Stephen, 1971, \u201cThe Complexity of Theorem Proving\nProcedures,\u201d <em>Proceedings of the Third Annual ACM STOC\nSymposium</em>, Shaker Heights, Ohio, pp. 151\u2013158.</li>\n<li>Davis, Martin, 2000, <em>The Universal Computer: the Road from\nLeibniz to Turing</em>, New York: W. W. Norton &amp; Company.</li>\n<li>Edmonds, Jack, 1965, \u201cPaths, Trees and Flowers,\u201d <em>Canadian\nJournal of Mathematics</em>, 17: 449\u2013467.</li>\n<li>Enderton, Herbert B., 1972, <em>A Mathematical Introduction to\nLogic</em>, New York: Academic Press.</li>\n<li>Fagin, Ronald, 1974, \u201cGeneralized First-Order Spectra and\nPolynomial-Time Recognizable Sets,\u201d in <em>Complexity of\nComputation</em>, R. Karp (ed.), <em>SIAM-AMS Proc</em>, 7:\n27\u201341.</li>\n<li>Feder, Tomas and Moshe Vardi, 1999, \u201cThe Computational\nStructure of Monotone Monadic SNP and Constraint Satisfaction: A Study\nThrough Datalog and Group Theory\u201d, <em>SIAM Journal of\nComputing</em> 28: 57\u2013104.</li>\n<li>Garey, Michael and David S. Johnson, 1979, <em>Computers and\nIntractability</em>, New York: Freeman.</li>\n<li>G\u00f6del, Kurt, 1930, \u201cThe Completeness of the Axioms of the\nFunctional Calculus,\u201d in van Heijenoort 1967: 582\u2013591.</li>\n<li>\u2013\u2013\u2013, 1931, \u201cOn Formally Undecidable Propositions\nof Principia Mathematica and Related Systems I,\u201d in van Heijenoort,\n1967: 592\u2013617.</li>\n<li>Hartmanis, Juris, 1989, \u201cOverview of computational Complexity\nTheory\u201d in J. Hartmanis (ed.), <em>Computational Complexity Theory</em>,\nProvidence: American Mathematical Society, pp. 1\u201317.</li>\n<li>Hilbert and Ackermann, 1928/1938, <em>Grundz\u00fcge der\ntheoretischen Logik</em>, Springer. English translation of the 2nd\nedition: <em>Principles of Mathematical Logic</em>, New York: Chelsea\nPublishing Company, 1950.</li>\n<li>Hodges, Andrew, 1992, <em>Alan Turing: the Enigma</em>, London: Random\nHouse.</li>\n<li>Hofstadter, Douglas, 1979, <em>G\u00f6del, Escher, Bach: an Eternal\nGolden Braid</em>, New York: Basic Books.</li>\n<li>Hopcroft, John E., 1984, \u201cTuring Machines\u201d, <em>Scientific\nAmerican</em>, 250(5): 70\u201380.</li>\n<li>Immerman, Neil, 1999, <em>Descriptive Complexity</em>, New York: Springer.</li>\n<li>Jeavons, P.G., D.A. Cohen and M. Gyssens, 1997, \u201cClosure Properties of\nConstraints\u201d, <em>Journal of the ACM</em>, 44: 527\u2013548.</li>\n<li>Jones, Neil, 1973, \u201cReducibility Among Combinatorial\n    Problems in Log <em>n</em> Space\u201d, <em>Proc. Seventh Annual Princeton Conf. Info. Sci. and Systems</em>, 547\u2013551.</li>\n<li>Karp, Richard, 1972, \u201cReducibility Among Combinatorial\nProblems,\u201d, in <em>Complexity of Computations</em>, R.E. Miller\nand J.W. Thatcher (eds.), New York: Plenum Press, pp. 85\u2013104.</li>\n<li>Kleene, Stephen C., 1935, \u201cA Theory of Positive Integers in\nFormal Logic,\u201d <em>American Journal of Mathematics</em>, 57:\n153\u2013173, 219\u2013244.</li>\n<li>\u2013\u2013\u2013, 1950, <em>Introduction to Metamathematics</em>,\nPrinceton: Van Nostrand.</li>\n<li>Ladner, Richard, 1975, \u201cOn the structure of polynomial time reducibility\u201d, <em>Journal of the ACM</em>, 155\u2013171.</li>\n<li>Levin, Leonid, 1973, \u201cUniversal search\nproblems,\u201d <em>Problemy Peredachi Informatsii</em>, 9(3):\n265\u2013266; partial English translation in B.A.Trakhtenbrot, 1984,\n\u201cA Survey of Russian Approaches to Perebor (Brute-force Search)\nAlgorithms,\u201d <em>IEEE Annals of the History of Computing</em>,\n6(4): 384\u2013400.</li>\n<li>Markov, A.A., 1960, \u201cThe Theory of\nAlgorithms,\u201d <em>American Mathematical Society Translations</em>\n(Series 2), 15: 1\u201314.</li>\n<li>Meyer, Albert and Dennis Ritchie, 1967, \u201cThe Complexity of\nLoop Programs,\u201d <em>Proceedings of the 22nd National ACM\nConference</em>, Washington, D.C., 465\u2013470.</li>\n<li>Nordstr\u00f6m, Jakob, 2015, \u201cOn the Interplay Between Proof\nComplexity and SAT Solving,\u201d SIGLOG News, 2(3): 18\u201344.</li>\n<li>Papadimitriou, Christos H., 1994, <em>Computational\nComplexity</em>, Reading, MA: Addison-Wesley.</li>\n<li>P\u00e9ter, R\u00f3zsa. 1967, <em>Recursive Functions</em>,\ntranslated by Istv\u00e1n F\u00f6ldes, New York: Academic\nPress.</li>\n<li>Post, Emil, 1936, \u201cFinite Combinatory Processes \u2013\nFormulation I,\u201d\n<em>Journal of Symbolic Logic</em>, 1: 103\u2013105.</li>\n<li>Rogers, Hartley Jr., 1967, <em>Theory of Recursive Functions and\nEffective Computability</em>, New York: McGraw-Hill.</li>\n<li>Schaefer, Thomas, 1978, \u201cThe Complexity of Satisfiability\nProblems\u201d, <em>Proceedings of the Tenth Annual ACM STOC\nSymposium</em>, 216\u2013226.</li>\n<li>Skolem, Thoralf, 1923, \u201cThe foundations of elementary\narithmetic established by means of the recursive mode of\nthought,\u201d in van Heijenoort 1967: 302\u201333.</li>\n<li>Turing, A. M., 1936\u20137, \u201cOn Computable Numbers, with an\nApplication to the Entscheidungsproblem\u201d, <em>Proceedings of the\nLondon Mathematical Society</em>, 2(42): 230\u2013265\n[<a href=\"http://www.abelard.org/turpap2/tp2-ie.asp\" target=\"other\">Preprint available online</a>].</li>\n<li> Valiant, Leslie, 1982, \u201cReducibility By Algebraic Projections\u201d, <em>L\u2019Enseignement mathematique</em>, 28(3\u20134): 253\u2013268.</li>\n<li>van Heijenoort, Jean, (ed.), 1967, <em>From Frege To G\u00f6del: A\nSource Book in Mathematical Logic, 1879\u20131931</em>, Cambridge, Massachusetts:\nHarvard University Press.</li>\n<li>Whitehead, Alfred North and Bertrand Russell, 1910\u20131913,\n<em>Principia Mathematica</em>, first edition, Cambridge: Cambridge\nUniversity Press.</li>\n<li> Zhuk, Dmitriy, 2020, \u201cA Proof of CSP Dichotomy Conjecture\u201d,<em> Journal of the ASM</em>, 30: 1\u201378.</li>\n</ul>\n</div>"}, "related_entries": {"entry_list": ["Church, Alonzo: logic, contributions to", "Church-Turing Thesis", "computational complexity theory", "G\u00f6del, Kurt", "quantum theory: quantum computing", "recursive functions", "set theory", "Turing, Alan", "Turing machines"], "entry_link": [{"../church-turing/": "Church-Turing Thesis"}, {"../computational-complexity/": "computational complexity theory"}, {"../goedel/": "G\u00f6del, Kurt"}, {"../qt-quantcomp/": "quantum theory: quantum computing"}, {"../recursive-functions/": "recursive functions"}, {"../set-theory/": "set theory"}, {"../turing/": "Turing, Alan"}, {"../turing-machine/": "Turing machines"}]}, "academic_tools": {"listed_text": ["<img alt=\"sep man icon\" src=\"../../symbols/sepman-icon.jpg\"/>", "<a href=\"https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=computability\" target=\"other\">How to cite this entry</a>.", "<img alt=\"sep man icon\" src=\"../../symbols/sepman-icon.jpg\"/>", "<a href=\"https://leibniz.stanford.edu/friends/preview/computability/\" target=\"other\">Preview the PDF version of this entry</a> at the\n <a href=\"https://leibniz.stanford.edu/friends/\" target=\"other\">Friends of the SEP Society</a>.", "<img alt=\"inpho icon\" src=\"../../symbols/inpho.png\"/>", "<a href=\"https://www.inphoproject.org/entity?sep=computability&amp;redirect=True\" target=\"other\">Look up topics and thinkers related to this entry</a>\n at the Internet Philosophy Ontology Project (InPhO).", "<img alt=\"phil papers icon\" src=\"../../symbols/pp.gif\"/>", "<a href=\"https://philpapers.org/sep/computability/\" target=\"other\">Enhanced bibliography for this entry</a>\nat <a href=\"https://philpapers.org/\" target=\"other\">PhilPapers</a>, with links to its database."], "listed_links": [{"https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=computability": "How to cite this entry"}, {"https://leibniz.stanford.edu/friends/preview/computability/": "Preview the PDF version of this entry"}, {"https://leibniz.stanford.edu/friends/": "Friends of the SEP Society"}, {"https://www.inphoproject.org/entity?sep=computability&redirect=True": "Look up topics and thinkers related to this entry"}, {"https://philpapers.org/sep/computability/": "Enhanced bibliography for this entry"}, {"https://philpapers.org/": "PhilPapers"}]}, "other_internet_resources": {"listed_text": ["<a href=\"http://people.cs.umass.edu/~immerman/descriptive_complexity.html\" target=\"other\">Descriptive Complexity</a>:\n a webpage describing research in Descriptive Complexity which is\nComputational Complexity from a Logical Point of View (with a diagram\nshowing the World of Computability and Complexity). Maintained by Neil\nImmerman, University of Massachusetts, Amherst.", "<a href=\"http://www.cs.umass.edu/~immerman/stanford/universe.html\" target=\"other\">Mass, Size, and Density of the Universe</a>,\n from the National Solar Observatory/Sacramento Peak."], "listed_links": [{"http://people.cs.umass.edu/~immerman/descriptive_complexity.html": "Descriptive Complexity"}, {"http://www.cs.umass.edu/~immerman/stanford/universe.html": "Mass, Size, and Density of the Universe"}]}, "tokenized_text": ["1", "computed", "principle", "introduction", "history", "1930", "well", "computer", "various", "mathematician", "around", "world", "invented", "precise", "independent", "definition", "mean", "computable", "alonzo", "church", "defined", "lambda", "calculus", "kurt", "g\u00f6del", "defined", "recursive", "function", "stephen", "kleene", "defined", "formal", "system", "markov", "defined", "became", "known", "markov", "algorithm", "emil", "post", "alan", "turing", "defined", "abstract", "machine", "known", "post", "machine", "turing", "machine", "surprisingly", "model", "exactly", "equivalent", "anything", "computable", "lambda", "calculus", "computable", "turing", "machine", "similarly", "pair", "computational", "system", "proved", "church", "expressed", "belief", "intuitive", "notion", "computable", "principle", "identical", "precise", "notion", "belief", "called", "churchturing", "thesis", "uniformly", "accepted", "mathematician", "part", "impetus", "drive", "codify", "computable", "came", "mathematician", "david", "hilbert", "hilbert", "believed", "mathematics", "could", "precisely", "axiomatized", "done", "would", "effective", "procedure", "ie", "algorithm", "would", "take", "input", "precise", "mathematical", "statement", "finite", "number", "step", "decide", "whether", "statement", "true", "false", "hilbert", "asking", "would", "called", "decision", "procedure", "mathematics", "special", "case", "decision", "problem", "hilbert", "considered", "validity", "problem", "firstorder", "logic", "firstorder", "logic", "mathematical", "language", "mathematical", "statement", "formulated", "every", "statement", "firstorder", "logic", "precise", "meaning", "every", "appropriate", "logical", "structure", "ie", "true", "false", "structure", "statement", "true", "every", "appropriate", "structure", "called", "valid", "statement", "true", "structure", "called", "satisfiable", "notice", "formula", "varphi", "valid", "iff", "negation", "neg", "varphi", "satisfiable", "hilbert", "called", "validity", "problem", "firstorder", "logic", "entscheidungsproblem", "textbook", "principle", "mathematical", "logic", "hilbert", "ackermann", "author", "wrote", "entscheidungsproblem", "solved", "know", "procedure", "allows", "given", "logical", "expression", "decide", "finitely", "many", "operation", "validity", "satisfiability", "entscheidungsproblem", "must", "considered", "main", "problem", "mathematical", "logic", "b\u00f6erger", "gr\u00e4del", "gurevich", "1997", "1930", "phd", "thesis", "g\u00f6del", "presented", "complete", "axiomatization", "firstorder", "logic", "based", "principia", "mathematica", "whitehead", "russell", "g\u00f6del", "1930", "g\u00f6del", "proved", "completeness", "theorem", "namely", "formula", "provable", "axiom", "valid", "g\u00f6del", "completeness", "theorem", "step", "towards", "resolution", "hilbert", "entscheidungsproblem", "particular", "since", "axiom", "easily", "recognizable", "rule", "inference", "simple", "mechanical", "procedure", "list", "proof", "note", "line", "proof", "either", "axiom", "follows", "previous", "line", "one", "simple", "rule", "given", "string", "character", "tell", "proof", "thus", "systematically", "list", "string", "character", "length", "1", "2", "3", "check", "whether", "proof", "add", "proof", "last", "line", "list", "theorem", "way", "list", "theorem", "ie", "exactly", "valid", "formula", "firstorder", "logic", "listed", "simple", "mechanical", "procedure", "precisely", "set", "valid", "formula", "range", "computable", "function", "modern", "terminology", "say", "set", "valid", "formula", "firstorder", "logic", "recursively", "enumerable", "re", "g\u00f6del", "completeness", "theorem", "sufficient", "however", "give", "positive", "solution", "entscheidungsproblem", "given", "formula", "varphi", "varphi", "valid", "procedure", "would", "eventually", "list", "thus", "could", "answer", "yes", "varphi", "valid", "however", "varphi", "valid", "might", "never", "find", "fact", "missing", "procedure", "list", "nonvalid", "formula", "equivalently", "list", "satisfiable", "formula", "year", "later", "1931", "g\u00f6del", "shocked", "mathematical", "world", "proving", "incompleteness", "theorem", "complete", "computable", "axiomatization", "firstorder", "theory", "natural", "number", "reasonable", "list", "axiom", "prove", "exactly", "true", "statement", "number", "theory", "g\u00f6del", "1931", "year", "later", "church", "turing", "independently", "proved", "entscheidungsproblem", "unsolvable", "church", "using", "method", "g\u00f6del", "incompleteness", "theorem", "show", "set", "satisfiable", "formula", "firstorder", "logic", "re", "ie", "systematically", "listed", "function", "computable", "lambda", "calculus", "turing", "introduced", "machine", "proved", "many", "interesting", "theorem", "discus", "next", "section", "particular", "proved", "unsolvability", "halting", "problem", "obtained", "unsolvability", "entscheidungsproblem", "corollary", "hilbert", "disappointed", "program", "towards", "decision", "procedure", "mathematics", "proved", "impossible", "however", "see", "detail", "rest", "article", "vast", "amount", "learned", "fundamental", "nature", "computation", "2", "turing", "machine", "1936", "paper", "computable", "number", "application", "entscheidungsproblem", "alan", "turing", "introduced", "machine", "established", "basic", "property", "thought", "clearly", "abstractly", "would", "mean", "machine", "perform", "computational", "task", "turing", "defined", "machine", "consist", "following", "finite", "set", "q", "possible", "state", "device", "must", "one", "finitely", "many", "possible", "state", "potentially", "infinite", "tape", "consisting", "consecutive", "cell", "sigma_", "1", "sigma_", "2", "sigma_", "3", "finite", "alphabet", "sigma", "sigma", "may", "finite", "set", "containing", "least", "two", "symbol", "convenient", "fix", "sigma", "0", "1", "b", "consisting", "binary", "alphabet", "plus", "blank", "cell", "symbol", "usually", "assume", "finite", "initial", "segment", "tape", "contains", "binary", "symbol", "rest", "blank", "readwrite", "tape", "head", "h", "ge", "1", "scanning", "tape", "cell", "sigma_", "h", "finally", "transition", "function", "delta", "q", "times", "sigma", "rightarrow", "q", "times", "sigma", "times", "101", "meaning", "transition", "function", "given", "state", "q", "looking", "given", "symbol", "sigma_", "h", "delta", "tell", "u", "new", "state", "machine", "enter", "new", "symbol", "written", "current", "square", "new", "head", "position", "h", "h", "d", "in", "101", "displacement", "given", "delta", "linear", "nature", "memory", "tape", "opposed", "random", "access", "memory", "limitation", "computation", "speed", "power", "turing", "machine", "find", "memory", "location", "ie", "tape", "cell", "may", "time", "consuming", "move", "head", "step", "step", "along", "tape", "beauty", "turing", "machine", "model", "extremely", "simple", "yet", "nonetheless", "extremely", "powerful", "turing", "machine", "potentially", "infinite", "work", "space", "process", "arbitrarily", "large", "input", "eg", "multiply", "two", "huge", "number", "read", "write", "bounded", "amount", "information", "ie", "one", "symbol", "per", "step", "even", "turing", "machine", "mathematical", "model", "computation", "proved", "equivalent", "statement", "churchturing", "thesis", "turing", "argued", "convincingly", "machine", "powerful", "possible", "computing", "device", "21", "universal", "machine", "turing", "machine", "uniquely", "described", "transition", "table", "state", "q", "symbol", "sigma", "delta", "q", "sigma", "new", "state", "new", "symbol", "head", "displacement", "transition", "table", "written", "finite", "string", "symbol", "giving", "complete", "set", "instruction", "turing", "machine", "furthermore", "string", "symbol", "listed", "lexicographic", "order", "follows", "m_", "1", "m_", "2", "m_", "3", "ldots", "m_", "transition", "table", "ie", "complete", "set", "instruction", "turing", "machine", "number", "i", "transition", "table", "m_", "program", "turing", "machine", "i", "simply", "i", "th", "program", "turing", "showed", "could", "build", "turing", "machine", "u", "universal", "sense", "could", "run", "program", "turing", "machine", "explicitly", "i", "input", "w", "u", "input", "i", "w", "would", "exactly", "m_", "would", "input", "w", "symbol", "u", "w", "m_", "w", "turing", "construction", "universal", "machine", "give", "fundamental", "insight", "computation", "one", "machine", "run", "program", "whatsoever", "matter", "computational", "task", "may", "need", "perform", "future", "single", "machine", "perform", "insight", "make", "feasible", "build", "sell", "computer", "one", "computer", "run", "program", "need", "buy", "new", "computer", "every", "time", "new", "problem", "solve", "course", "age", "personal", "computer", "fact", "basic", "assumption", "may", "difficult", "step", "back", "appreciate", "22", "halting", "problem", "designed", "embody", "possible", "computation", "turing", "machine", "inescapable", "flaw", "turing", "machine", "certain", "input", "never", "halt", "turing", "machine", "halt", "silly", "reason", "example", "misprogram", "turing", "machine", "get", "tight", "loop", "example", "state", "17", "looking", "1", "might", "go", "state", "17", "write", "1", "displace", "head", "0", "slightly", "le", "silly", "reach", "blank", "symbol", "blank", "symbol", "right", "yet", "keep", "staying", "state", "moving", "one", "step", "right", "looking", "1", "case", "nonhalting", "could", "easily", "detected", "repaired", "decent", "compiler", "however", "consider", "turing", "machine", "m_", "f", "input", "0", "systematically", "search", "first", "counterexample", "fermat", "last", "theorem", "upon", "finding", "output", "counterexample", "halt", "andrew", "wile", "relatively", "recently", "proved", "fermat", "last", "theorem", "mathematician", "world", "working", "three", "century", "unable", "decide", "whether", "m_", "f", "input", "0", "eventually", "halt", "know", "never", "23", "computable", "function", "enumerability", "since", "turing", "machine", "might", "halt", "certain", "input", "careful", "define", "function", "computable", "turing", "machine", "let", "natural", "number", "mathbf", "n", "set", "012", "ldots", "let", "u", "consider", "turing", "machine", "partial", "function", "mathbf", "n", "mathbf", "n", "let", "m", "turing", "machine", "n", "natural", "number", "say", "m", "tape", "contains", "number", "n", "m", "tape", "begin", "binary", "representation", "number", "n", "unnecessary", "leading", "0", "followed", "blank", "symbol", "start", "turing", "machine", "m", "tape", "containing", "n", "eventually", "halt", "tape", "containing", "m", "say", "m", "input", "n", "computes", "n", "m", "start", "m", "input", "n", "either", "never", "halt", "halt", "tape", "contain", "natural", "number", "eg", "leading", "0", "digit", "interspersed", "blank", "symbol", "say", "n", "undefined", "symbol", "n", "nearrow", "thus", "associate", "turing", "machine", "m", "partial", "function", "mathbf", "n", "rightarrow", "mathbf", "n", "cup", "nearrow", "say", "function", "m", "total", "nin", "mathbf", "n", "n", "in", "mathbf", "n", "ie", "m", "n", "always", "defined", "formally", "define", "mean", "set", "recursively", "enumerable", "re", "earlier", "described", "informally", "let", "subseteq", "mathbf", "n", "s", "re", "turing", "machine", "m", "s", "image", "function", "computed", "m", "symbol", "n", "mid", "n", "in", "mathbf", "n", "n", "nenearrow", "thus", "s", "re", "listed", "turing", "machine", "suppose", "s", "re", "element", "enumerated", "turing", "machine", "m", "describe", "another", "turing", "machine", "p", "input", "n", "run", "m", "roundrobin", "fashion", "possible", "input", "eventually", "m", "output", "n", "happens", "p", "halt", "output", "1", "ie", "p", "n", "1", "n", "notin", "s", "m", "never", "output", "n", "p", "n", "never", "halt", "ie", "p", "n", "nearrow", "let", "notation", "p", "n", "downarrow", "mean", "turing", "machine", "p", "input", "n", "eventually", "halt", "turing", "machine", "p", "define", "l", "p", "set", "accepted", "p", "number", "n", "p", "input", "n", "eventually", "halt", "l", "p", "n", "mid", "p", "n", "downarrow", "argument", "show", "set", "s", "re", "accepted", "turing", "machine", "p", "ie", "l", "p", "converse", "statement", "hold", "well", "s", "re", "accepted", "turing", "machine", "p", "say", "set", "s", "decidable", "total", "turing", "machine", "m", "decides", "n", "in", "mathbf", "n", "whether", "n", "in", "s", "think", "1", "yes", "0", "nin", "mathbf", "n", "n", "in", "s", "n", "1", "ie", "m", "input", "n", "eventually", "halt", "output", "yes", "whereas", "n", "notin", "s", "n", "0", "ie", "m", "input", "n", "eventually", "halt", "output", "synonym", "decidable", "computable", "solvable", "recursive", "subseteq", "mathbf", "n", "complement", "s", "mathbf", "n", "s", "ie", "set", "natural", "number", "s", "say", "set", "s", "core", "complement", "re", "set", "s", "re", "core", "list", "element", "one", "column", "list", "nonelements", "second", "column", "way", "decide", "whether", "given", "element", "n", "s", "scan", "two", "column", "wait", "n", "show", "show", "first", "column", "n", "in", "s", "otherwise", "show", "second", "column", "n", "notin", "s", "fact", "set", "recursive", "iff", "re", "core", "24", "unsolvability", "halting", "problem", "turing", "asked", "whether", "every", "set", "natural", "number", "decidable", "easy", "see", "answer", "following", "counting", "argument", "uncountably", "many", "subset", "mathbf", "n", "since", "countably", "many", "turing", "machine", "countably", "many", "decidable", "set", "thus", "almost", "set", "undecidable", "turing", "actually", "constructed", "nondecidable", "set", "see", "using", "diagonal", "argument", "diagonal", "argument", "go", "back", "georg", "cantor", "used", "show", "real", "number", "uncountable", "g\u00f6del", "used", "similar", "diagonal", "argument", "proof", "incompleteness", "theorem", "constructed", "sentence", "j", "number", "theory", "whose", "meaning", "could", "understood", "j", "theorem", "turing", "constructed", "diagonal", "halting", "set", "k", "follows", "k", "n", "mid", "m_", "n", "n", "downarrow", "k", "consists", "turing", "machine", "eventually", "halt", "input", "program", "hard", "see", "k", "re", "suppose", "sake", "contradiction", "k", "also", "core", "let", "d", "number", "turing", "machine", "accepts", "complement", "k", "n", "n", "notin", "k", "leftrightarrow", "m_", "n", "downarrow", "consider", "happens", "substitute", "d", "n", "equation", "notin", "k", "leftrightarrow", "m_", "downarrow", "however", "definition", "k", "tell", "u", "in", "k", "leftrightarrow", "m_", "downarrow", "thus", "in", "k", "leftrightarrow", "notin", "k", "contradiction", "thus", "assumption", "k", "core", "false", "thus", "k", "recursive", "follows", "computable", "problem", "given", "turing", "machine", "input", "decide", "whether", "turing", "machine", "eventually", "halt", "input", "ie", "halting", "problem", "unsolvable", "3", "primitive", "recursive", "function", "next", "define", "class", "primitive", "recursive", "function", "interesting", "class", "function", "described", "paper", "skolem", "1923", "used", "g\u00f6del", "proof", "incompleteness", "theorem", "interested", "function", "f", "mathbf", "n", "r", "mathbf", "n", "r", "0", "1", "2", "ldots", "r", "called", "arity", "function", "f", "ie", "number", "argument", "take", "g\u00f6del", "started", "three", "simple", "function", "initial", "function", "two", "natural", "closure", "operation", "composition", "primitive", "recursion", "take", "already", "defined", "function", "use", "define", "new", "one", "next", "explain", "definition", "detail", "section", "technical", "safely", "skipped", "important", "idea", "primitive", "recursive", "function", "comprise", "large", "powerful", "class", "computable", "function", "generated", "extremely", "simple", "way", "begin", "three", "initial", "primitive", "recursive", "function", "zeta", "zero", "function", "arity", "0", "zeta", "0", "eta", "identity", "function", "arity", "1", "eta", "n", "n", "sigma", "successor", "function", "arity", "1", "sigma", "n", "n", "1", "consider", "following", "two", "operation", "composition", "f", "primitive", "recursive", "function", "arity", "a", "g_", "1", "ldots", "g_", "primitive", "recursive", "function", "arity", "r_", "1", "ldots", "r_", "kin", "mathbf", "n", "following", "primitive", "recursive", "function", "arity", "k", "h", "x_", "1", "ldots", "x_", "k", "f", "g_", "1", "w_", "1", "ldots", "g_", "w_", "w_", "list", "r_", "argument", "perhaps", "repetition", "x_", "1", "ldots", "x_", "k", "primitive", "recursion", "f", "g", "primitive", "recursive", "function", "arity", "k", "k2", "respectively", "primitive", "recursive", "function", "h", "arity", "k1", "satisfying", "following", "condition", "begin", "align", "h", "0", "x_", "1", "ldots", "x_", "k", "f", "x_", "1", "ldots", "x_", "k", "text", "h", "n1", "x_", "1", "ldots", "x_", "k", "g", "h", "n", "x_", "1", "ldots", "x_", "k", "n", "x_", "1", "ldots", "x_", "k", "end", "align", "composition", "natural", "way", "combine", "function", "primitive", "recursion", "restricted", "kind", "recursion", "h", "first", "argument", "n1", "defined", "term", "h", "first", "argument", "n", "argument", "unchanged", "define", "primitive", "recursive", "function", "smallest", "class", "function", "contains", "initial", "function", "closed", "composition", "primitive", "recursion", "set", "primitive", "recursive", "function", "equal", "set", "function", "computed", "using", "bounded", "iteration", "meyer", "ritchie", "1967", "ie", "set", "function", "definable", "language", "bloop", "hofstadter", "1979", "primitive", "recursive", "function", "simple", "definition", "yet", "extremely", "powerful", "g\u00f6del", "proved", "inductively", "every", "primitive", "recursive", "function", "simply", "represented", "firstorder", "number", "theory", "used", "primitive", "recursive", "function", "encode", "formula", "even", "sequence", "formula", "number", "finally", "used", "primitive", "recursive", "function", "compute", "property", "represented", "formula", "including", "formula", "well", "formed", "sequence", "formula", "proof", "take", "long", "series", "lemma", "show", "powerful", "primitive", "recursive", "function", "following", "example", "showing", "addition", "multiplication", "exponentiation", "primitive", "recursive", "define", "addition", "function", "p", "x", "follows", "begin", "align", "p", "0", "eta", "p", "n1", "sigma", "p", "n", "end", "align", "note", "fit", "definition", "primitive", "recursion", "function", "g", "x_", "1", "x_", "2", "x_", "3", "eta", "sigma", "x_", "1", "definable", "initial", "function", "eta", "sigma", "composition", "next", "define", "multiplication", "function", "x", "follows", "begin", "align", "0", "zeta", "n1", "p", "n", "end", "align", "next", "define", "exponential", "function", "e", "x", "usually", "0", "0", "considered", "undefined", "since", "primitive", "recursive", "function", "must", "total", "define", "e", "00", "1", "since", "primitive", "recursion", "allows", "u", "recurse", "first", "argument", "use", "two", "step", "define", "exponential", "function", "begin", "align", "r", "0", "sigma", "zeta", "r", "n1", "r", "n", "end", "align", "finally", "define", "e", "x", "r", "eta", "eta", "x", "composition", "recall", "eta", "identity", "function", "could", "simply", "written", "e", "x", "r", "x", "exponential", "function", "e", "grows", "rapidly", "example", "e", "1010", "ten", "billion", "e", "5050", "10", "84", "thus", "significantly", "estimated", "number", "atom", "universe", "however", "much", "faster", "growing", "primitive", "recursive", "function", "saw", "e", "defined", "slowly", "growing", "function", "sigma", "using", "three", "application", "primitive", "recursion", "one", "addition", "one", "multiplication", "one", "exponentiation", "continue", "apply", "primitive", "recursion", "build", "series", "unimaginably", "fast", "growing", "function", "let", "one", "step", "series", "defining", "hyperexponential", "function", "h", "n", "2", "2", "2", "m", "tower", "n", "2", "h", "primitive", "recursive", "defined", "e", "using", "one", "application", "primitive", "recursion", "begin", "align", "h", "0", "h", "n1", "e", "2", "h", "n", "end", "align", "thus", "h", "22", "2", "4", "16", "h", "33", "2", "256", "10", "77", "comparable", "number", "atom", "universe", "big", "enough", "consider", "h", "44", "write", "number", "decimal", "notation", "would", "need", "one", "followed", "zero", "number", "particle", "universe", "31", "recursive", "function", "set", "primitive", "recursive", "function", "huge", "class", "computable", "function", "fact", "characterized", "set", "function", "computable", "time", "primitive", "recursive", "function", "n", "n", "length", "input", "example", "since", "h", "n", "n", "primitive", "recursive", "function", "primitive", "recursive", "function", "include", "time", "h", "n", "n", "see", "next", "section", "discussion", "computational", "complexity", "including", "time", "thus", "primitive", "recursive", "function", "include", "function", "feasibly", "computable", "conceivable", "measure", "feasible", "much", "beyond", "however", "primitive", "recursive", "function", "include", "function", "computable", "principle", "see", "use", "diagonalization", "systematically", "encode", "definition", "primitive", "recursive", "function", "arity", "1", "calling", "p_", "1", "p_", "2", "p_", "3", "build", "turing", "machine", "compute", "value", "following", "diagonal", "function", "n", "p_", "n", "n", "1", "notice", "d", "total", "computable", "function", "mathbf", "n", "mathbf", "n", "primitive", "recursive", "suppose", "sake", "contradiction", "d", "primitive", "recursive", "d", "would", "equal", "p_", "din", "mathbf", "n", "would", "follow", "p_", "p_", "1", "contradiction", "therefore", "d", "primitive", "recursive", "ala", "diagonal", "argument", "work", "class", "total", "function", "could", "considered", "candidate", "class", "computable", "function", "way", "around", "want", "function", "computable", "principle", "practice", "add", "kind", "unbounded", "search", "operation", "g\u00f6del", "extend", "primitive", "recursive", "function", "recursive", "function", "define", "unbounded", "minimization", "operator", "mu", "follows", "let", "f", "perhaps", "partial", "function", "arity", "k1", "mu", "f", "defined", "following", "function", "arity", "k", "input", "x_", "1", "ldots", "x_", "k", "following", "0", "infty", "f", "x_", "1", "ldots", "x_", "k", "1", "output", "i", "thus", "f", "x_", "1", "ldots", "x_", "k", "1", "j", "lt", "f", "j", "x_", "1", "ldots", "x_", "k", "defined", "equal", "1", "mu", "f", "x_", "1", "ldots", "x_", "k", "i", "otherwise", "mu", "f", "x_", "1", "ldots", "x_", "k", "undefined", "g\u00f6del", "defined", "set", "recursive", "function", "closure", "initial", "primitive", "recursive", "function", "composition", "primitive", "recursion", "mu", "definition", "recursive", "function", "exactly", "set", "partial", "function", "computable", "lambda", "calculus", "kleene", "formal", "system", "markov", "algorithm", "post", "machine", "turing", "machine", "4", "computational", "complexity", "function", "computable", "practice", "world", "war", "ii", "turing", "helped", "design", "build", "specialized", "computing", "device", "called", "bombe", "bletchley", "park", "used", "bombe", "crack", "german", "enigma", "code", "greatly", "aiding", "allied", "cause", "hodges", "1992", "1960", "computer", "widely", "available", "industry", "university", "algorithm", "developed", "solve", "myriad", "problem", "mathematician", "scientist", "began", "classify", "algorithm", "according", "efficiency", "search", "best", "algorithm", "certain", "problem", "beginning", "modern", "theory", "computation", "section", "dealing", "complexity", "instead", "computability", "turing", "machine", "consider", "halt", "input", "rather", "accepting", "halting", "assume", "turing", "machine", "accepts", "outputting", "1", "reject", "outputting", "0", "thus", "redefine", "set", "accepted", "total", "machine", "m", "l", "n", "mid", "n", "1", "time", "algorithm", "take", "depends", "input", "machine", "run", "first", "important", "insight", "complexity", "theory", "good", "measure", "complexity", "algorithm", "asymptotic", "worstcase", "complexity", "function", "size", "input", "n", "input", "w", "let", "n", "lvert", "wrvert", "length", "w", "following", "hartmanis", "1989", "say", "turing", "machine", "m", "run", "time", "n", "w", "length", "n", "w", "take", "n", "step", "halt", "called", "worstcase", "complexity", "n", "must", "large", "time", "taken", "input", "length", "n", "function", "mathbf", "n", "rightarrow", "mathbf", "n", "let", "time", "n", "mid", "l", "text", "text", "run", "time", "n", "alan", "cobham", "jack", "edmonds", "identified", "complexity", "class", "p", "problem", "recognizable", "polynomial", "amount", "time", "excellent", "mathematical", "wrapper", "class", "feasible", "problemsthose", "problem", "whose", "moderatelysized", "instance", "feasibly", "recognized", "p", "bigcup_", "i12", "ldots", "time", "n", "problem", "p", "certainly", "feasible", "hand", "natural", "problem", "algorithm", "p", "tend", "eventually", "algorithm", "discovered", "actually", "feasible", "many", "important", "complexity", "class", "besides", "p", "defined", "studied", "np", "pspace", "exptime", "pspace", "consists", "problem", "solvable", "using", "polynomial", "amount", "memory", "space", "exptime", "set", "problem", "solvable", "time", "2", "p", "n", "polynomial", "p", "perhaps", "interesting", "class", "np", "nondeterministic", "polynomial", "time", "definition", "come", "real", "machine", "rather", "mathematical", "abstraction", "nondeterministic", "turing", "machine", "n", "make", "choice", "guess", "one", "two", "possible", "action", "step", "input", "w", "sequence", "choice", "lead", "acceptance", "say", "mathbf", "n", "accepts", "w", "say", "nondeterministic", "time", "taken", "mathbf", "n", "input", "w", "number", "step", "taken", "sequence", "lead", "acceptance", "nondeterministic", "machine", "charged", "possible", "choice", "might", "made", "single", "sequence", "correct", "choice", "np", "sometimes", "described", "set", "problem", "s", "short", "proof", "membership", "example", "suppose", "given", "list", "m", "large", "natural", "number", "a_", "1", "ldots", "a_", "target", "number", "t", "instance", "subset", "sum", "problem", "subset", "m", "number", "whose", "sum", "exactly", "t", "problem", "easy", "solve", "nondeterministic", "linear", "time", "i", "guess", "whether", "take", "a_", "next", "add", "number", "decided", "take", "sum", "equal", "t", "accept", "thus", "nondeterministic", "time", "linear", "ie", "constant", "time", "length", "input", "n", "however", "known", "deterministic", "way", "solve", "problem", "time", "le", "exponential", "n", "41", "reduction", "completeness", "large", "study", "algorithm", "complexity", "many", "important", "problem", "well", "understood", "particular", "reduction", "problem", "defined", "used", "compare", "relative", "difficulty", "two", "problem", "intuitively", "say", "a", "reducible", "b", "le", "b", "easytocompute", "transformation", "tau", "map", "instance", "a", "instance", "b", "way", "preserve", "membership", "ie", "tau", "w", "in", "b", "leftrightarrow", "w", "in", "a", "remarkably", "high", "percentage", "naturally", "occurring", "computational", "problem", "turn", "complete", "one", "class", "problem", "a", "complete", "complexity", "class", "c", "a", "member", "c", "problem", "b", "c", "harder", "a", "ie", "b", "le", "a", "two", "complete", "problem", "class", "equivalent", "complexity", "reason", "completeness", "phenomenon", "adequately", "explained", "one", "plausible", "explanation", "natural", "computational", "problem", "tend", "universal", "sense", "turing", "universal", "machine", "universal", "problem", "certain", "complexity", "class", "simulate", "problem", "class", "1971", "cook", "proved", "sat", "np", "complete", "cook", "1971", "shortly", "later", "karp", "showed", "many", "important", "combinatorial", "problem", "also", "np", "complete", "thus", "establishing", "importance", "class", "np", "karp", "1972", "definition", "reduction", "lacked", "precision", "saying", "mapping", "tau", "must", "easytocompute", "reduction", "karp", "used", "polynomialtime", "reduction", "ie", "tau", "computable", "polynomial", "time", "since", "many", "researcher", "observed", "natural", "problem", "remain", "complete", "natural", "complexity", "class", "surprisingly", "weak", "reduction", "including", "logspace", "reduction", "jones", "1973", "firstorder", "reduction", "immerman", "1999", "projection", "valiant", "1982", "firstorder", "projection", "immerman", "1999", "exception", "natural", "problem", "np", "turn", "either", "np", "complete", "p", "people", "wondered", "whether", "always", "case", "ladner", "proved", "p", "ne", "np", "intermediate", "problem", "i", "np", "p", "np", "complete", "ladner", "1975", "ladner", "proof", "method", "called", "delayed", "diagonalization", "generalized", "result", "show", "two", "wellbehaved", "complexity", "class", "c", "e", "c", "strictly", "contained", "e", "intermediate", "class", "c", "strictly", "contained", "strictly", "contained", "e", "thus", "ordering", "complexity", "class", "dense", "however", "intermediate", "problem", "tend", "show", "phenomenon", "received", "great", "deal", "attention", "recently", "via", "dichotomy", "conjecture", "feder", "vardi", "feder", "vardi", "1999", "schaefer", "introduced", "work", "insightful", "paper", "studied", "variant", "boolean", "satisfiability", "problem", "schaefer", "1978", "proved", "problem", "either", "np", "complete", "p", "thus", "ladner", "intermediate", "problem", "occur", "among", "satisfiability", "problem", "since", "two", "possibility", "schaefer", "called", "dichotomy", "fact", "one", "look", "closer", "schaefer", "satisfiability", "problem", "either", "np", "complete", "p", "complete", "oplus", "l", "complete", "nl", "complete", "l", "complete", "trivial", "allender", "et", "al", "2009", "nontrivial", "problem", "p", "may", "p", "complete", "complete", "one", "three", "complexity", "class", "within", "p", "word", "look", "closer", "npp", "dichotomy", "phenomenon", "problem", "really", "multichotomoy", "phenomenon", "namely", "nontrivial", "satisfiability", "problem", "complete", "one", "five", "wellknown", "complexity", "class", "feder", "vardi", "studied", "schaefer", "dichotomy", "conjectured", "hold", "finitedomain", "constraint", "satisfaction", "problem", "csp", "feder", "vardi", "1999", "finitedomain", "csp", "c", "consists", "finite", "domain", "finite", "set", "relation", "r_1", "ldots", "r_k", "d", "instance", "c", "consists", "set", "variable", "v_1", "ldots", "v_n", "conjunction", "atom", "varphi", "equiv", "bigwedge", "r_i", "v_", "j_1", "ldots", "answer", "instance", "varphi", "yes", "ie", "varphi", "in", "c", "iff", "assignment", "variable", "element", "domain", "varphi", "satisfied", "domain", "size", "2", "csp", "problem", "satisfiability", "problem", "schaefer", "theorem", "already", "established", "feder", "vardi", "conjecture", "case", "simple", "instance", "csp", "domain", "size", "3", "3color", "problem", "undirected", "graph", "given", "graph", "g", "vertex", "g", "colored", "one", "three", "color", "two", "adjacent", "vertex", "color", "write", "csp", "let", "r", "b", "set", "three", "distinct", "color", "let", "relation", "n", "notequal", "relation", "d", "g", "v", "e", "instance", "3color", "varphi_g", "quad", "quad", "bigwedge_", "u", "v", "in", "e", "n", "u", "v", "note", "varphi_g", "say", "whenever", "edge", "g", "vertex", "u", "v", "u", "v", "assigned", "different", "color", "feder", "vardi", "conjecture", "led", "extremely", "productive", "research", "program", "particular", "rich", "algebraic", "theory", "csps", "developed", "number", "paper", "starting", "jeavons", "et", "al", "1997", "see", "bulatov", "2018", "survey", "eventually", "applying", "advancing", "algebraic", "theory", "bulatov", "zhuk", "independently", "proved", "feder", "vardi", "conjecture", "bulatov", "2017", "zhuk", "2017", "42", "significance", "complexity", "reason", "class", "np", "well", "studied", "large", "number", "important", "practical", "problem", "np", "complete", "including", "subset", "sum", "none", "problem", "known", "algorithm", "faster", "exponential", "time", "although", "npcomplete", "problem", "admit", "feasible", "approximation", "solution", "great", "deal", "remains", "open", "computational", "complexity", "know", "strictly", "particular", "computational", "resource", "let", "u", "solve", "strictly", "harder", "problem", "eg", "time", "n", "strictly", "contained", "time", "n", "101", "similarly", "space", "measure", "however", "tradeoff", "different", "computational", "resource", "still", "quite", "poorly", "understood", "obvious", "p", "contained", "np", "furthermore", "np", "contained", "pspace", "pspace", "systematically", "try", "every", "single", "branch", "np", "computation", "reusing", "space", "successive", "branch", "accepting", "branch", "lead", "acceptance", "pspace", "contained", "exptime", "pspace", "machine", "take", "exponential", "time", "exactly", "repeated", "configuration", "must", "infinite", "loop", "following", "known", "relationship", "class", "p", "subseteq", "np", "subseteq", "pspace", "subseteq", "exptime", "however", "seems", "clear", "p", "strictly", "contained", "np", "np", "strictly", "contained", "pspace", "pspace", "strictly", "contained", "exptime", "none", "inequality", "proved", "fact", "even", "known", "p", "different", "pspace", "np", "different", "exptime", "known", "proper", "inclusion", "p", "strictly", "contained", "exptime", "remaining", "question", "concerning", "relative", "power", "different", "computational", "resource", "fundamental", "unsolved", "problem", "theory", "computation", "following", "diagram", "map", "complexity", "class", "discussed", "well", "diagram", "come", "work", "descriptive", "complexity", "immerman", "1999", "show", "important", "complexity", "class", "descriptive", "characterization", "fagin", "began", "field", "proving", "np", "so", "exists", "ie", "property", "np", "iff", "expressible", "secondorder", "existential", "logic", "fagin", "1974", "vardi", "author", "entry", "later", "independently", "proved", "p", "fo", "lfp", "property", "p", "iff", "expressible", "firstorder", "logic", "plus", "least", "fixedpoint", "operator", "lfp", "formalizes", "power", "define", "new", "relation", "induction", "captivating", "corollary", "p", "np", "iff", "fo", "lfp", "p", "equal", "np", "iff", "every", "property", "expressible", "second", "order", "logic", "already", "expressible", "firstorder", "logic", "plus", "inductive", "definition", "language", "question", "finite", "ordered", "input", "structure", "see", "immerman", "1999", "detail", "world", "computability", "complexity", "top", "right", "diagram", "show", "recursively", "enumerable", "re", "problem", "includes", "recomplete", "problem", "halting", "problem", "halt", "left", "set", "core", "problem", "including", "corecomplete", "problem", "overline", "rm", "halt", "set", "turing", "machine", "never", "halt", "given", "input", "mentioned", "end", "section", "23", "intersection", "set", "re", "problem", "set", "core", "problem", "equal", "set", "recursive", "problem", "set", "primitive", "recursive", "problem", "strict", "subset", "recursive", "problem", "moving", "toward", "bottom", "diagram", "region", "marked", "green", "dotted", "line", "labelled", "truly", "feasible", "note", "mathematically", "defined", "class", "rather", "intuitive", "notion", "problem", "solved", "exactly", "instance", "reasonable", "size", "within", "reasonable", "amount", "time", "using", "computer", "afford", "interestingly", "speed", "computer", "dramatically", "increased", "year", "expectation", "large", "instance", "able", "handle", "increased", "accordingly", "thus", "boundary", "truly", "feasible", "change", "slowly", "increase", "computer", "speed", "might", "suggest", "mentioned", "p", "good", "mathematical", "wrapper", "set", "feasible", "problem", "problem", "p", "requiring", "n", "1000", "time", "problem", "size", "n", "thus", "feasible", "nature", "appears", "friend", "say", "naturally", "occurring", "problem", "p", "favor", "relatively", "simple", "algorithm", "natural", "problem", "tend", "feasible", "number", "step", "required", "problem", "size", "n", "tends", "le", "c", "nk", "small", "multiplicative", "constant", "c", "small", "exponent", "k", "ie", "kleq", "2", "practice", "asymptotic", "complexity", "naturally", "occurring", "problem", "tends", "key", "issue", "determining", "whether", "feasible", "problem", "complexity", "17n", "handled", "minute", "modern", "computer", "every", "instance", "size", "billion", "hand", "problem", "worstcase", "complexity", "2n", "handled", "lifetime", "instance", "size", "hundred", "discussed", "natural", "problem", "tend", "complete", "important", "complexity", "class", "namely", "one", "diagram", "others", "fascinating", "phenomenon", "mean", "algorithm", "complexity", "abstract", "concept", "important", "practical", "level", "remarkable", "success", "proving", "problem", "interest", "complete", "wellknown", "complexity", "class", "class", "contained", "p", "usually", "look", "known", "efficient", "algorithm", "otherwise", "must", "look", "simplification", "approximation", "problem", "may", "feasible", "rich", "theory", "approximability", "np", "optimization", "problem", "see", "arora", "barak", "2009", "example", "subset", "sum", "problem", "mentioned", "npcomplete", "problem", "likely", "requires", "exponential", "time", "tell", "whether", "given", "subset", "sum", "problem", "exact", "solution", "however", "want", "see", "reach", "target", "fixed", "number", "digit", "accuracy", "problem", "quite", "easy", "ie", "subset", "sum", "hard", "easy", "approximate", "even", "recomplete", "halting", "problem", "many", "important", "feasible", "subproblems", "given", "program", "general", "possible", "figure", "whether", "eventually", "halt", "however", "program", "written", "programmer", "student", "automatically", "analyzed", "optimized", "even", "corrected", "modern", "compiler", "model", "checker", "class", "np", "important", "practically", "philosophically", "class", "problem", "s", "input", "w", "s", "iff", "proof", "p", "w", "win", "s", "p", "w", "much", "larger", "w", "thus", "informally", "think", "np", "set", "intellectual", "endeavor", "may", "reach", "find", "answer", "whether", "w", "in", "s", "convince", "others", "done", "boolean", "satisfiability", "problem", "sat", "first", "problem", "proved", "np", "complete", "cook", "1971", "ie", "hardest", "np", "problem", "fact", "sat", "np", "complete", "mean", "problem", "np", "reducible", "sat", "year", "researcher", "built", "efficient", "sat", "solver", "quickly", "solve", "many", "sat", "instance", "ie", "find", "satisfying", "assignment", "prove", "none", "even", "instance", "million", "variable", "thus", "sat", "solver", "used", "general", "purpose", "problem", "solver", "hand", "known", "class", "small", "instance", "current", "sat", "solver", "fail", "thus", "part", "p", "versus", "np", "question", "concern", "practical", "theoretical", "complexity", "sat", "nordstr\u00f6m", "2015", "extensive", "theory", "computational", "complexity", "entry", "briefly", "describes", "area", "putting", "context", "question", "computable", "principle", "versus", "practice", "reader", "interested", "learning", "complexity", "excellent", "book", "example", "papadimitriou", "1994", "arora", "barak", "2009", "also", "entry", "computational", "complexity", "theory"]}