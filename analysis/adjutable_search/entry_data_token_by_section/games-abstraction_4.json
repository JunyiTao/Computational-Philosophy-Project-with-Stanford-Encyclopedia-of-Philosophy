{
    "main_text": "Sequential higher-order computation: the full abstraction problem for PCF || Syntax of PCF\n2.1 Syntax of PCF\n\nPCF is a language based on simply typed \\(\\lambda\\)-calculus extended\nwith arithmetic and boolean primitives, and its type system is defined\naccordingly:\n\n\nDefinition 2.1 (PCF types). The set Types\nof types of PCF is defined inductively\nas follows\n\nthe ground types num (for\nterms representing natural numbers), bool\n(for terms representing boolean values)\nare types,\nif \\(\\sigma, \\tau\\) are types, also \\((\\sigma \\to \\tau)\\) is a\ntype.\n\n\nParentheses will be omitted whenever possible, with the convention\nthat they associate to the right, so that a type \\(\\sigma_1 \\to \\cdots\n\\sigma_n \\to \\tau\\) is equivalent to \\((\\sigma_1 \\to (\\sigma_2 \\to\n(\\cdots (\\sigma_n \\to \\tau)\\cdots)))\\)\n\n\nPCF terms are the terms of simply typed \\(\\lambda\\)-calculus extended\nwith the following arithmetic constants, of the indicated type:\n\na constant \\({0}\\) of type \\(\\texttt{num}\\), representing the\nnatural number 0;\na constant \\(\\texttt{succ}\\) of type \\(\\texttt{num}\\to\n\\texttt{num}\\) representing the successor function over natural\nnumbers;\na constant \\(\\texttt{pred}\\) of type \\(\\texttt{num}\\to\n\\texttt{num}\\) representing the predecessor function over natural\nnumbers;\nconstants \\(\\texttt{tt}\\) and \\(\\texttt{ff}\\) of type\n\\(\\texttt{bool}\\);\nconstants of type \\(\\texttt{bool}\\to \\texttt{num}\\to\n\\texttt{num}\\to \\texttt{num}\\) and \\(\\texttt{bool}\\to \\texttt{bool}\\to\n\\texttt{bool}\\to \\texttt{bool}\\) for conditionals of type num\nand of type bool,\nrespectively: these are both written as\n\\({\\texttt{if }\\cdot\\texttt{ then }\\cdot\\texttt{ else }\\cdot}\\), and\nwe let context make clear what is the intended type of the\nresult;\na constant \\(\\texttt{zero?}\\) for the test for zero of type\n\\(\\texttt{num}\\to \\texttt{bool}\\);\na unary function symbol \\({\\mathtt{Y}(\\cdot)}\\) for the fixed\npoint combinator, where \\({\\mathtt{Y}(e)}:\\sigma\\) for any \\(e:\\sigma\n\\to \\sigma\\).\n\n\nTerms are built inductively according to rules that allow to infer\njudgements of the form \\(B \\vdash e : \\sigma\\), stating that\nterm \\(e\\) is of type \\(\\sigma\\) under the assumption that the\nvariables occurring free in \\(e\\) are given unique types in a\nbasis \\(B\\) of the form \n\n\\[{\\{ x_1:\\sigma_1,\\ldots,x_k:\\sigma_k \\}}.\\]\n\n The rule for building\nPCF-terms are therefore inference rules for such judgements. In\nparticular there are rules for typed constants, for example in any\nbasis \\(B\\) there is a judgement \\(B \\vdash \\texttt{zero?} :\n\\texttt{num}\\to \\texttt{bool}\\), and we have rules for typed\n\\(\\lambda\\)-abstractions \n\n\\[\\frac{B,x:\\sigma \\vdash e:\\tau}{B \\vdash {\\lambda x:\\sigma{\\, . \\,}e}:\\sigma \\to \\tau}\\]\n\n and applications \n\n\\[\\frac{B \\vdash e_1 : \\sigma \\to \\tau \\qquad B \\vdash e_2 : \\sigma}{B \\vdash e_1 e_2 : \\tau}\\]\n\n and\na rule for the fixed-point operator: \n\n\\[\\frac{B \\vdash e:\\sigma \\to \\sigma} {B \\vdash {\\mathtt{Y}(e)}:\\sigma}.\\]\n\n \n",
    "section_title": "2.1 Syntax of PCF",
    "entry_title": "Games, Full Abstraction and Full Completeness",
    "hierarchy_title": "Games, Full Abstraction and Full Completeness || Sequential higher-order computation: the full abstraction problem for PCF || Syntax of PCF",
    "tokenized_text": [
        "sequential",
        "higherorder",
        "computation",
        "full",
        "abstraction",
        "problem",
        "pcf",
        "syntax",
        "pcf",
        "syntax",
        "pcf",
        "pcf",
        "language",
        "based",
        "simply",
        "typed",
        "lambda",
        "calculus",
        "extended",
        "arithmetic",
        "boolean",
        "primitive",
        "type",
        "system",
        "defined",
        "accordingly",
        "definition",
        "pcf",
        "type",
        "set",
        "type",
        "type",
        "pcf",
        "defined",
        "inductively",
        "follows",
        "ground",
        "type",
        "num",
        "term",
        "representing",
        "natural",
        "number",
        "bool",
        "term",
        "representing",
        "boolean",
        "value",
        "type",
        "sigma",
        "tau",
        "type",
        "also",
        "sigma",
        "to",
        "tau",
        "type",
        "parenthesis",
        "omitted",
        "whenever",
        "possible",
        "convention",
        "associate",
        "right",
        "type",
        "sigma_",
        "to",
        "cdots",
        "sigma_n",
        "to",
        "tau",
        "equivalent",
        "sigma_",
        "to",
        "sigma_",
        "to",
        "cdots",
        "sigma_n",
        "to",
        "tau",
        "cdots",
        "pcf",
        "term",
        "term",
        "simply",
        "typed",
        "lambda",
        "calculus",
        "extended",
        "following",
        "arithmetic",
        "constant",
        "indicated",
        "type",
        "constant",
        "type",
        "texttt",
        "num",
        "representing",
        "natural",
        "number",
        "constant",
        "texttt",
        "succ",
        "type",
        "texttt",
        "num",
        "to",
        "texttt",
        "num",
        "representing",
        "successor",
        "function",
        "natural",
        "number",
        "constant",
        "texttt",
        "pred",
        "type",
        "texttt",
        "num",
        "to",
        "texttt",
        "num",
        "representing",
        "predecessor",
        "function",
        "natural",
        "number",
        "constant",
        "texttt",
        "tt",
        "texttt",
        "ff",
        "type",
        "texttt",
        "bool",
        "constant",
        "type",
        "texttt",
        "bool",
        "to",
        "texttt",
        "num",
        "to",
        "texttt",
        "num",
        "to",
        "texttt",
        "num",
        "texttt",
        "bool",
        "to",
        "texttt",
        "bool",
        "to",
        "texttt",
        "bool",
        "to",
        "texttt",
        "bool",
        "conditionals",
        "type",
        "num",
        "type",
        "bool",
        "respectively",
        "written",
        "texttt",
        "cdottexttt",
        "cdottexttt",
        "else",
        "cdot",
        "let",
        "context",
        "make",
        "clear",
        "intended",
        "type",
        "result",
        "constant",
        "texttt",
        "zero",
        "test",
        "zero",
        "type",
        "texttt",
        "num",
        "to",
        "texttt",
        "bool",
        "unary",
        "function",
        "symbol",
        "mathtt",
        "cdot",
        "fixed",
        "point",
        "combinator",
        "mathtt",
        "e",
        "sigma",
        "e",
        "sigma",
        "to",
        "sigma",
        "term",
        "built",
        "inductively",
        "according",
        "rule",
        "allow",
        "infer",
        "judgement",
        "form",
        "b",
        "vdash",
        "e",
        "sigma",
        "stating",
        "term",
        "e",
        "type",
        "sigma",
        "assumption",
        "variable",
        "occurring",
        "free",
        "e",
        "given",
        "unique",
        "type",
        "basis",
        "b",
        "form",
        "x_",
        "sigma_",
        "ldots",
        "x_k",
        "sigma_k",
        "rule",
        "building",
        "pcfterms",
        "therefore",
        "inference",
        "rule",
        "judgement",
        "particular",
        "rule",
        "typed",
        "constant",
        "example",
        "basis",
        "b",
        "judgement",
        "b",
        "vdash",
        "texttt",
        "zero",
        "texttt",
        "num",
        "to",
        "texttt",
        "bool",
        "rule",
        "typed",
        "lambda",
        "abstractions",
        "frac",
        "b",
        "x",
        "sigma",
        "vdash",
        "e",
        "tau",
        "b",
        "vdash",
        "lambda",
        "x",
        "sigma",
        "e",
        "sigma",
        "to",
        "tau",
        "application",
        "frac",
        "b",
        "vdash",
        "e_",
        "sigma",
        "to",
        "tau",
        "qquad",
        "b",
        "vdash",
        "e_",
        "sigma",
        "b",
        "vdash",
        "e_",
        "e_",
        "tau",
        "rule",
        "fixedpoint",
        "operator",
        "frac",
        "b",
        "vdash",
        "e",
        "sigma",
        "to",
        "sigma",
        "b",
        "vdash",
        "mathtt",
        "e",
        "sigma"
    ]
}